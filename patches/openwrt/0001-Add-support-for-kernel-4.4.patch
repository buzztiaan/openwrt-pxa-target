From 85c2e51d94eeb7ee747037e538c34099b75ee584 Mon Sep 17 00:00:00 2001
From: mozzwald <mozzwald@thegridserv.cloud.mozzwald.com>
Date: Sun, 13 Jan 2019 10:29:17 -0600
Subject: [PATCH 1/1] Add support for kernel 4.4

---
 include/kernel-version.mk                          |    2 +
 target/linux/generic/config-4.4                    | 4857 ++++++++++++++++++
 .../pending-4.4/001-mtdsplit_backport.patch        |  153 +
 .../pending-4.4/002-phy_drivers_backport.patch     |  640 +++
 .../pending-4.4/003-myloader_backport.patch        |   11 +
 ...t-hardcode-path-to-awk-in-scripts-ld-vers.patch |   24 +
 .../generic/pending-4.4/020-bcma-from-4.5.patch    |   49 +
 .../generic/pending-4.4/021-bcma-from-4.6.patch    |  761 +++
 .../generic/pending-4.4/022-bcma-from-4.8.patch    |   52 +
 .../generic/pending-4.4/023-bcma-from-4.9.patch    |  108 +
 .../generic/pending-4.4/025-bcma-from-4.11.patch   |   85 +
 .../generic/pending-4.4/026-bcma-from-4.12.patch   |   47 +
 ...Use-skb_cow_head-to-deal-with-cloned-skbs.patch |   40 +
 ...use-skb_cow_head-to-deal-with-cloned-skbs.patch |   38 +
 ...use-skb_cow_head-to-deal-with-cloned-skbs.patch |   43 +
 ..._codel-add-batch-ability-to-fq_codel_drop.patch |  189 +
 ...-fq_codel-add-memory-limitation-per-queue.patch |  182 +
 .../034-fq_codel-fix-memory-limitation-drift.patch |   40 +
 .../035-fq_codel-fix-NET_XMIT_CN-behavior.patch    |   70 +
 ...-include-mtd.h-header-for-struct-mtd_info.patch |   39 +
 ...sflash-use-ioremap_cache-instead-of-KSEG0.patch |  138 +
 ...h-dependency-for-MTD_BCM47XXSFLASH-symbol.patch |   41 +
 ...sflash-use-uncached-MMIO-access-for-BCM53.patch |   59 +
 ...47xxsflash-use-platform_-set-get-_drvdata.patch |   63 +
 ...sflash-support-reading-flash-out-of-mappi.patch |   81 +
 ...part-move-TRX-parsing-code-to-separated-f.patch |  180 +
 ...part-support-layouts-with-multiple-TRX-pa.patch |  112 +
 ...-nor-mx25l3205d-mx25l6405d-append-SECT_4K.patch |   27 +
 ...-m25p80-add-support-for-mmap-read-request.patch |   46 +
 ...-silence-error-output-if-MS_SILENT-is-set.patch |   32 +
 ...s-silence-early-error-if-MS_SILENT-is-set.patch |   54 +
 ...td-spi-nor-backport-SPI_NOR_HAS_LOCK-flag.patch |   47 +
 .../050-backport_netfilter_rtcache.patch           |  531 ++
 ...051-0001-ovl-rename-is_merge-to-is_lowest.patch |   72 +
 ...e-creds-with-the-ones-from-the-superblock.patch |  336 ++
 .../051-0005-ovl-proper-cleanup-of-workdir.patch   |  131 +
 .../052-01-ubifs-Implement-O_TMPFILE.patch         |   99 +
 .../052-02-ubifs-Implement-RENAME_WHITEOUT.patch   |  343 ++
 .../052-03-ubifs-Implement-RENAME_EXCHANGE.patch   |  267 +
 ...4-ubifs-Use-move-variable-in-ubifs_rename.patch |   30 +
 ...softlimit-and-delta-fields-from-struct-ub.patch |   82 +
 ...irty_writeback_interval-value-for-wbuf-ti.patch |   66 +
 .../060-mips_decompressor_memmove.patch            |   22 +
 .../061-softirq-let-ksoftirqd-do-its-job.patch     |   83 +
 ...4.11-mtd-nand-Add-Winbond-manufacturer-id.patch |   34 +
 ...-net-bgmac-clarify-CONFIG_BCMA-dependency.patch |   46 +
 ...elper-checking-for-BCM4707-BCM53018-chip-.patch |  106 +
 ...c-support-Ethernet-device-on-BCM47094-SoC.patch |   39 +
 ...gmac-fix-MAC-soft-reset-bit-for-corerev-4.patch |   34 +
 ...-net_device-with-backing-device-structure.patch |   25 +
 ...-bgmac-Add-support-for-ethtool-statistics.patch |  175 +
 ...003-bgmac-Maintain-some-netdev-statistics.patch |   68 +
 ...t-bgmac-use-phydev-from-struct-net_device.patch |  105 +
 ...t-bgmac-change-bgmac_-prints-to-dev_-prin.patch |  407 ++
 ...02-net-ethernet-bgmac-add-dma_dev-pointer.patch |  112 +
 ...t-bgmac-move-BCMA-MDIO-Phy-code-into-a-se.patch |  676 +++
 ...t-ethernet-bgmac-convert-to-feature-flags.patch |  384 ++
 ...thernet-bgmac-Add-platform-device-support.patch | 1260 +++++
 ...t-bgmac-Fix-return-value-check-in-bgmac_p.patch |   26 +
 ...t-bgmac-Remove-redundant-dev_err-call-in-.patch |   42 +
 ...ix-reversed-check-for-MII-registration-er.patch |   28 +
 ...ac-support-Ethernet-core-on-BCM53573-SoCs.patch |  161 +
 ...ake-it-clear-when-setting-interface-type-.patch |   31 +
 ...3-net-bgmac-Fix-errant-feature-flag-check.patch |   33 +
 ...fix-spelling-mistake-connecton-connection.patch |   25 +
 ...ix-reversed-checks-for-clock-control-flag.patch |   35 +
 ...vm-version-of-alloc_etherdev_mqs-function.patch |   70 +
 ...llocate-struct-bgmac-just-once-don-t-copy.patch |  139 +
 ...rop-struct-bcma_mdio-we-don-t-need-anymor.patch |  274 ++
 ...ac-use-PHY-subsystem-for-initializing-PHY.patch |   53 +
 ...nable-master-mode-for-BCM54210E-and-B5021.patch |   50 +
 ...074-NET-PHY-adds-driver-for-lantiq-PHY11G.patch |  537 ++
 ...1-net-phy-update-Broadcom-drivers-to-v4.5.patch |  125 +
 ...2-net-phy-update-Broadcom-drivers-to-v4.6.patch |  123 +
 ...rry-pick-Broadcom-drivers-updates-from-v4.patch |  315 ++
 ...rry-pick-Broadcom-drivers-updates-from-v4.patch |  283 ++
 ...rry-pick-Broadcom-drivers-updates-from-v4.patch |   37 +
 ...ce-accelerated-read-support-for-spi-flash.patch |  179 +
 ...-add-spi_flash_read-callback-for-MMIO-bas.patch |  157 +
 ...-USB-core-let-USB-device-know-device-node.patch |  179 +
 ...core-usb_alloc_dev-fix-setting-of-portnum.patch |  108 +
 ...dd-devm_-clk_hw_-register-unregister-APIs.patch |  182 +
 .../083-0002-clk-Add-clk_hw-OF-clk-providers.patch |  234 +
 ...usb-core-Introduce-a-USB-port-LED-trigger.patch |  465 ++
 ...bport-Use-proper-LED-API-to-fix-potential.patch |   70 +
 ...ad-USB-ports-from-DT-in-the-usbport-LED-t.patch |  106 +
 ...-gpio-Set-of_node-for-created-LED-devices.patch |   53 +
 ...0002-leds-gpio-introduce-gpio_blink_set_t.patch |   61 +
 ...witch-to-managed-version-of-led_classdev_.patch |   75 +
 ...dd-OF-variants-of-LED-registering-functio.patch |  120 +
 ...se-OF-variant-of-LED-registering-function.patch |   60 +
 ...thermal-Add-devm-version-of-thermal_zone_.patch |  143 +
 ...-core-export-apis-to-get-slope-and-offset.patch |  101 +
 ...cm2835-add-thermal-driver-for-bcm2835-SoC.patch |  365 ++
 ...mal-broadcom-add-Northstar-thermal-driver.patch |  173 +
 ...adcom-fix-compilation-of-Northstar-driver.patch |   19 +
 .../087-regmap-make-LZO-cache-optional.patch       |   69 +
 ...4k-Use-IPI-calls-for-CM-indexed-cache-ops.patch |  317 ++
 ...S-c-r4k-Exclude-sibling-CPUs-in-SMP-calls.patch |   37 +
 ...copy-appended-dtb-to-the-end-of-the-kerne.patch |  132 +
 ...re-the-appended-dtb-address-in-a-variable.patch |  132 +
 ...Fix-size-calc-when-avoiding-IPIs-for-smal.patch |   38 +
 .../096-arc-add-model-property-in-dts.patch        |  163 +
 .../097-MIPS-io.h-Define-ioremap_cache.patch       |   29 +
 .../098-usb-dwc2-Remove-unnecessary-kfree.patch    |   24 +
 ...MIPS-fix-cache-flushing-for-highmem-pages.patch |   31 +
 .../pending-4.4/102-ehci_hcd_ignore_oc.patch       |   82 +
 ...c_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch |   86 +
 .../105-add-linux-spidev-compatible.patch          |   15 +
 ...o_set_value_cansleep-for-setting-chipsele.patch |   21 +
 ...-.rename2-and-add-RENAME_WHITEOUT-support.patch |   86 +
 .../111-jffs2-add-RENAME_EXCHANGE-support.patch    |   81 +
 ...-bridge_allow_receiption_on_disabled_port.patch |   54 +
 .../pending-4.4/132-mips_inline_dma_ops.patch      |  778 +++
 ...t-add-generic-parsing-of-linux-part-probe.patch |  183 +
 ...-add-support-for-ESMT_f25l32qa-and-ESMT_f.patch |   21 +
 ...sb-gadget-udc-net2280-add-usb2380-support.patch |  253 +
 ...-init-serial-console-directly-from-ChipCo.patch |   92 +
 .../generic/pending-4.4/200-fix_localversion.patch |   11 +
 .../pending-4.4/201-extra_optimization.patch       |   18 +
 .../pending-4.4/202-reduce_module_size.patch       |   11 +
 .../pending-4.4/203-kallsyms_uncompressed.patch    |  108 +
 .../generic/pending-4.4/204-module_strip.patch     |  193 +
 .../pending-4.4/205-backtrace_module_info.patch    |   36 +
 .../pending-4.4/206-mips-disable-vdso.patch        |   21 +
 .../207-mips-vdso-dbg-rebuild-after-genvdso.patch  |   29 +
 .../generic/pending-4.4/208-disable-modorder.patch |   34 +
 .../pending-4.4/210-darwin_scripts_include.patch   | 3088 ++++++++++++
 .../pending-4.4/211-sign-file-libressl.patch       |   16 +
 .../pending-4.4/212-byteshift_portability.patch    |   51 +
 .../pending-4.4/214-spidev_h_portability.patch     |   11 +
 .../generic/pending-4.4/220-gc_sections.patch      |  536 ++
 .../generic/pending-4.4/221-module_exports.patch   |   88 +
 .../generic/pending-4.4/222-arm_zimage_none.patch  |  133 +
 .../pending-4.4/230-openwrt_lzma_options.patch     |   58 +
 .../pending-4.4/250-netfilter_depends.patch        |   18 +
 .../generic/pending-4.4/251-sound_kconfig.patch    |   18 +
 .../generic/pending-4.4/252-mv_cesa_depends.patch  |   10 +
 .../pending-4.4/253-ssb_b43_default_on.patch       |   29 +
 .../pending-4.4/254-textsearch_kconfig_hacks.patch |   23 +
 .../pending-4.4/255-lib80211_kconfig_hacks.patch   |   31 +
 .../256-crypto_add_kconfig_prompts.patch           |   47 +
 .../257-wireless_ext_kconfig_hack.patch            |   22 +
 .../258-netfilter_netlink_kconfig_hack.patch       |   11 +
 .../generic/pending-4.4/259-regmap_dynamic.patch   |   90 +
 .../pending-4.4/260-crypto_test_dependencies.patch |   48 +
 ...compat-add-fallback-for-unsupported-libcs.patch |  130 +
 ...er.h-prevent-redefinition-of-struct-ethhd.patch |   55 +
 .../generic/pending-4.4/280-rfkill-stubs.patch     |   79 +
 .../pending-4.4/300-mips_expose_boot_raw.patch     |   39 +
 .../pending-4.4/301-mips_image_cmdline_hack.patch  |   28 +
 .../pending-4.4/302-mips_no_branch_likely.patch    |   11 +
 .../generic/pending-4.4/304-mips_disable_fpu.patch |  106 +
 .../pending-4.4/305-mips_module_reloc.patch        |  355 ++
 .../306-mips_mem_functions_performance.patch       |   83 +
 .../pending-4.4/307-mips_highmem_offset.patch      |   17 +
 .../generic/pending-4.4/308-mips32r2_tune.patch    |   17 +
 .../310-arm_module_unresolved_weak_sym.patch       |   13 +
 .../pending-4.4/320-ppc4xx_optimization.patch      |   31 +
 .../pending-4.4/321-powerpc_crtsavres_prereq.patch |   10 +
 ...Accept-command-line-parameters-from-users.patch |  298 ++
 .../331-arc-remove-dependency-on-DEVTMPFS.patch    |   31 +
 .../pending-4.4/332-arc-add-OWRTDTB-section.patch  |   82 +
 ...rc-enable-unaligned-access-in-kernel-mode.patch |   26 +
 .../400-mtd-add-rootfs-split-support.patch         |  113 +
 ...port-for-different-partition-parser-types.patch |  113 +
 ...mtd-parsers-for-rootfs-and-firmware-split.patch |   71 +
 .../403-mtd-hook-mtdsplit-to-Kbuild.patch          |   22 +
 .../404-mtd-add-more-helper-functions.patch        |  101 +
 ...ve-forward-declaration-of-struct-mtd_info.patch |   18 +
 .../411-mtd-partial_eraseblock_write.patch         |  142 +
 .../412-mtd-partial_eraseblock_unlock.patch        |   18 +
 .../pending-4.4/420-mtd-redboot_space.patch        |   30 +
 .../430-mtd-add-myloader-partition-parser.patch    |   35 +
 ...part-check-for-bad-blocks-when-calculatin.patch |   91 +
 ...-mtd-bcm47xxpart-detect-T_Meter-partition.patch |   42 +
 .../generic/pending-4.4/440-block2mtd_init.patch   |  108 +
 .../generic/pending-4.4/441-block2mtd_probe.patch  |   39 +
 ...allow-to-use-platform-specific-chip-fixup.patch |   37 +
 ...return-code-of-nand_correct_data-function.patch |   11 +
 .../460-mtd-cfi_cmdset_0002-no-erase_suspend.patch |   11 +
 ..._cmdset_0002-add-buffer-write-cmd-timeout.patch |   18 +
 ...465-m25p80-mx-disable-software-protection.patch |   14 +
 .../475-mtd-spi-nor-add-macronix-mx25u25635f.patch |   10 +
 .../476-mtd-spi-nor-add-eon-en25q128.patch         |   10 +
 .../477-mtd-add-spi-nor-add-mx25u3235f.patch       |   10 +
 .../479-enable_mtd_has_lock_for_f25l32pa.patch     |   22 +
 .../480-mtd-set-rootfs-to-be-root-dev.patch        |   26 +
 ...tach-mtd-device-named-ubi-or-data-on-boot.patch |   76 +
 ...bi-auto-create-ubiblock-device-for-rootfs.patch |   69 +
 ...-mounting-ubi0-rootfs-in-init-do_mounts.c.patch |   54 +
 ...-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch |   37 +
 .../494-mtd-ubi-add-EOF-marker-support.patch       |   51 +
 .../530-jffs2_make_lzma_available.patch            | 5142 ++++++++++++++++++++
 .../generic/pending-4.4/531-debloat_lzma.patch     | 1024 ++++
 .../generic/pending-4.4/532-jffs2_eofdetect.patch  |   56 +
 ...1-ubifs-fix-default-compression-selection.patch |   29 +
 .../600-netfilter_conntrack_flush.patch            |   86 +
 ...610-netfilter_match_bypass_default_checks.patch |  101 +
 .../611-netfilter_match_bypass_default_table.patch |  111 +
 .../612-netfilter_match_reduce_memory_access.patch |   16 +
 .../613-netfilter_optional_tcp_window_check.patch  |   36 +
 .../pending-4.4/616-net_optimize_xfrm_calls.patch  |   12 +
 ...ed-codel-do-not-defer-queue-length-update.patch |   86 +
 .../pending-4.4/630-packet_socket_type.patch       |  134 +
 .../pending-4.4/640-bridge_no_eap_forward.patch    |   23 +
 .../pending-4.4/641-bridge_always_accept_eap.patch |   17 +
 .../pending-4.4/642-bridge_port_isolate.patch      |  107 +
 .../645-bridge_multicast_to_unicast.patch          |  420 ++
 .../pending-4.4/651-wireless_mesh_header.patch     |   11 +
 .../pending-4.4/653-disable_netlink_trim.patch     |   27 +
 .../generic/pending-4.4/655-increase_skb_pad.patch |   11 +
 .../pending-4.4/660-fq_codel_defaults.patch        |   11 +
 .../661-fq_codel_keep_dropped_stats.patch          |   10 +
 .../pending-4.4/662-use_fq_codel_by_default.patch  |   95 +
 .../pending-4.4/663-remove_pfifo_fast.patch        |  142 +
 .../666-Add-support-for-MAP-E-FMRs-mesh-mode.patch |  496 ++
 ...jecting-with-source-address-failed-policy.patch |  249 +
 ...-defines-for-_POLICY_FAILED-until-all-cod.patch |   53 +
 ...80-NET-skip-GRO-for-foreign-MAC-addresses.patch |  160 +
 .../681-NET-add-of_get_mac_address_mtd.patch       |  128 +
 .../linux/generic/pending-4.4/700-swconfig.patch   |   39 +
 .../generic/pending-4.4/701-phy_extension.patch    |   63 +
 .../702-phy_add_aneg_done_function.patch           |   27 +
 ...-add-detach-callback-to-struct-phy_driver.patch |   27 +
 .../710-phy-add-mdio_register_board_info.patch     |  193 +
 .../generic/pending-4.4/720-phy_adm6996.patch      |   26 +
 .../generic/pending-4.4/721-phy_packets.patch      |  161 +
 .../generic/pending-4.4/722-phy_mvswitch.patch     |   23 +
 .../linux/generic/pending-4.4/723-phy_ip175c.patch |   23 +
 .../linux/generic/pending-4.4/724-phy_ar8216.patch |   24 +
 .../generic/pending-4.4/725-phy_rtl8306.patch      |   23 +
 .../generic/pending-4.4/726-phy_rtl8366.patch      |   45 +
 .../generic/pending-4.4/727-phy-rtl8367.patch      |   23 +
 .../generic/pending-4.4/728-phy-rtl8367b.patch     |   23 +
 .../linux/generic/pending-4.4/729-phy-tantos.patch |   21 +
 target/linux/generic/pending-4.4/730-phy_b53.patch |   21 +
 .../pending-4.4/732-phy-ar8216-led-support.patch   |   13 +
 .../generic/pending-4.4/733-phy_mvsw61xx.patch     |   23 +
 ...t-phy-at803x-allow-to-configure-via-pdata.patch |  180 +
 .../735-net-phy-at803x-fix-at8033-sgmii-mode.patch |   96 +
 .../736-at803x-fix-reset-handling.patch            |   43 +
 ...03x-Request-reset-GPIO-only-for-AT8030-PH.patch |   42 +
 ...03x-only-the-AT8030-needs-a-hardware-rese.patch |   81 +
 ...739-net-phy-at803x-add-support-for-AT8032.patch |   65 +
 .../pending-4.4/773-bgmac-add-srab-switch.patch    |   88 +
 .../810-pci_disable_common_quirks.patch            |   51 +
 .../811-pci_disable_usb_common_quirks.patch        |  101 +
 ...b-Remove-annoying-warning-about-bogus-URB.patch |   78 +
 .../generic/pending-4.4/831-ledtrig_netdev.patch   |   21 +
 .../generic/pending-4.4/834-ledtrig-libata.patch   |  153 +
 .../generic/pending-4.4/835-misc-owl_loader.patch  |   31 +
 target/linux/generic/pending-4.4/840-rtc7301.patch |  250 +
 .../generic/pending-4.4/841-rtc_pt7c4338.patch     |  247 +
 .../861-04_spi_gpio_implement_spi_delay.patch      |   58 +
 .../generic/pending-4.4/862-gpio_spi_driver.patch  |  373 ++
 .../pending-4.4/890-uart_optional_sysrq.patch      |   25 +
 .../pending-4.4/901-debloat_sock_diag.patch        |   79 +
 .../generic/pending-4.4/902-debloat_proc.patch     |  385 ++
 .../generic/pending-4.4/904-debloat_dma_buf.patch  |   44 +
 .../generic/pending-4.4/910-kobject_uevent.patch   |   21 +
 .../911-kobject_add_broadcast_uevent.patch         |   65 +
 .../pending-4.4/921-use_preinit_as_init.patch      |   12 +
 ...2-always-create-console-node-in-initramfs.patch |   30 +
 .../linux/generic/pending-4.4/930-crashlog.patch   |  317 ++
 ...unsane-filenames-from-deps_initramfs-list.patch |   29 +
 .../generic/pending-4.4/995-mangle_bootargs.patch  |   58 +
 ...98-enable_wilink_platform_without_drivers.patch |   15 +
 268 files changed, 42032 insertions(+)
 create mode 100644 target/linux/generic/config-4.4
 create mode 100644 target/linux/generic/pending-4.4/001-mtdsplit_backport.patch
 create mode 100644 target/linux/generic/pending-4.4/002-phy_drivers_backport.patch
 create mode 100644 target/linux/generic/pending-4.4/003-myloader_backport.patch
 create mode 100644 target/linux/generic/pending-4.4/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch
 create mode 100644 target/linux/generic/pending-4.4/020-bcma-from-4.5.patch
 create mode 100644 target/linux/generic/pending-4.4/021-bcma-from-4.6.patch
 create mode 100644 target/linux/generic/pending-4.4/022-bcma-from-4.8.patch
 create mode 100644 target/linux/generic/pending-4.4/023-bcma-from-4.9.patch
 create mode 100644 target/linux/generic/pending-4.4/025-bcma-from-4.11.patch
 create mode 100644 target/linux/generic/pending-4.4/026-bcma-from-4.12.patch
 create mode 100644 target/linux/generic/pending-4.4/030-1-smsc95xx-Use-skb_cow_head-to-deal-with-cloned-skbs.patch
 create mode 100644 target/linux/generic/pending-4.4/030-6-ch9200-use-skb_cow_head-to-deal-with-cloned-skbs.patch
 create mode 100644 target/linux/generic/pending-4.4/030-7-kaweth-use-skb_cow_head-to-deal-with-cloned-skbs.patch
 create mode 100644 target/linux/generic/pending-4.4/032-fq_codel-add-batch-ability-to-fq_codel_drop.patch
 create mode 100644 target/linux/generic/pending-4.4/033-fq_codel-add-memory-limitation-per-queue.patch
 create mode 100644 target/linux/generic/pending-4.4/034-fq_codel-fix-memory-limitation-drift.patch
 create mode 100644 target/linux/generic/pending-4.4/035-fq_codel-fix-NET_XMIT_CN-behavior.patch
 create mode 100644 target/linux/generic/pending-4.4/041-mtd-spi-nor-include-mtd.h-header-for-struct-mtd_info.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0001-mtd-bcm47xxsflash-use-ioremap_cache-instead-of-KSEG0.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0002-mtd-add-arch-dependency-for-MTD_BCM47XXSFLASH-symbol.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0003-mtd-bcm47xxsflash-use-uncached-MMIO-access-for-BCM53.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0005-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0006-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0007-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch
 create mode 100644 target/linux/generic/pending-4.4/042-0008-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch
 create mode 100644 target/linux/generic/pending-4.4/043-mtd-spi-nor-mx25l3205d-mx25l6405d-append-SECT_4K.patch
 create mode 100644 target/linux/generic/pending-4.4/045-mtd-devices-m25p80-add-support-for-mmap-read-request.patch
 create mode 100644 target/linux/generic/pending-4.4/046-ubifs-silence-error-output-if-MS_SILENT-is-set.patch
 create mode 100644 target/linux/generic/pending-4.4/047-ubifs-silence-early-error-if-MS_SILENT-is-set.patch
 create mode 100644 target/linux/generic/pending-4.4/048-mtd-spi-nor-backport-SPI_NOR_HAS_LOCK-flag.patch
 create mode 100644 target/linux/generic/pending-4.4/050-backport_netfilter_rtcache.patch
 create mode 100644 target/linux/generic/pending-4.4/051-0001-ovl-rename-is_merge-to-is_lowest.patch
 create mode 100644 target/linux/generic/pending-4.4/051-0002-ovl-override-creds-with-the-ones-from-the-superblock.patch
 create mode 100644 target/linux/generic/pending-4.4/051-0005-ovl-proper-cleanup-of-workdir.patch
 create mode 100644 target/linux/generic/pending-4.4/052-01-ubifs-Implement-O_TMPFILE.patch
 create mode 100644 target/linux/generic/pending-4.4/052-02-ubifs-Implement-RENAME_WHITEOUT.patch
 create mode 100644 target/linux/generic/pending-4.4/052-03-ubifs-Implement-RENAME_EXCHANGE.patch
 create mode 100644 target/linux/generic/pending-4.4/052-04-ubifs-Use-move-variable-in-ubifs_rename.patch
 create mode 100644 target/linux/generic/pending-4.4/053-0001-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch
 create mode 100644 target/linux/generic/pending-4.4/053-0002-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch
 create mode 100644 target/linux/generic/pending-4.4/060-mips_decompressor_memmove.patch
 create mode 100644 target/linux/generic/pending-4.4/061-softirq-let-ksoftirqd-do-its-job.patch
 create mode 100644 target/linux/generic/pending-4.4/067-v4.11-mtd-nand-Add-Winbond-manufacturer-id.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.5-0003-net-bgmac-clarify-CONFIG_BCMA-dependency.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.6-0001-bgmac-add-helper-checking-for-BCM4707-BCM53018-chip-.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.6-0002-bgmac-support-Ethernet-device-on-BCM47094-SoC.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.6-0004-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.8-0001-bgmac-Bind-net_device-with-backing-device-structure.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.8-0002-bgmac-Add-support-for-ethtool-statistics.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.8-0003-bgmac-Maintain-some-netdev-statistics.patch
 create mode 100644 target/linux/generic/pending-4.4/070-v4.8-0004-net-ethernet-bgmac-use-phydev-from-struct-net_device.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0001-net-ethernet-bgmac-change-bgmac_-prints-to-dev_-prin.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0002-net-ethernet-bgmac-add-dma_dev-pointer.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0003-net-ethernet-bgmac-move-BCMA-MDIO-Phy-code-into-a-se.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0004-net-ethernet-bgmac-convert-to-feature-flags.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0005-net-ethernet-bgmac-Add-platform-device-support.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0006-net-ethernet-bgmac-Fix-return-value-check-in-bgmac_p.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0007-net-ethernet-bgmac-Remove-redundant-dev_err-call-in-.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.8-0009-net-bgmac-fix-reversed-check-for-MII-registration-er.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.9-0001-net-bgmac-support-Ethernet-core-on-BCM53573-SoCs.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.9-0002-net-bgmac-make-it-clear-when-setting-interface-type-.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.9-0003-net-bgmac-Fix-errant-feature-flag-check.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.9-0004-net-bgmac-fix-spelling-mistake-connecton-connection.patch
 create mode 100644 target/linux/generic/pending-4.4/071-v4.9-0005-net-bgmac-fix-reversed-checks-for-clock-control-flag.patch
 create mode 100644 target/linux/generic/pending-4.4/072-net-add-devm-version-of-alloc_etherdev_mqs-function.patch
 create mode 100644 target/linux/generic/pending-4.4/073-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch
 create mode 100644 target/linux/generic/pending-4.4/073-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch
 create mode 100644 target/linux/generic/pending-4.4/073-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch
 create mode 100644 target/linux/generic/pending-4.4/073-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch
 create mode 100644 target/linux/generic/pending-4.4/074-NET-PHY-adds-driver-for-lantiq-PHY11G.patch
 create mode 100644 target/linux/generic/pending-4.4/078-0001-net-phy-update-Broadcom-drivers-to-v4.5.patch
 create mode 100644 target/linux/generic/pending-4.4/078-0002-net-phy-update-Broadcom-drivers-to-v4.6.patch
 create mode 100644 target/linux/generic/pending-4.4/078-0003-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
 create mode 100644 target/linux/generic/pending-4.4/078-0004-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
 create mode 100644 target/linux/generic/pending-4.4/078-0006-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
 create mode 100644 target/linux/generic/pending-4.4/080-spi-introduce-accelerated-read-support-for-spi-flash.patch
 create mode 100644 target/linux/generic/pending-4.4/081-spi-bcm53xx-add-spi_flash_read-callback-for-MMIO-bas.patch
 create mode 100644 target/linux/generic/pending-4.4/082-0001-USB-core-let-USB-device-know-device-node.patch
 create mode 100644 target/linux/generic/pending-4.4/082-0002-usb-core-usb_alloc_dev-fix-setting-of-portnum.patch
 create mode 100644 target/linux/generic/pending-4.4/083-0001-clk-Add-devm_-clk_hw_-register-unregister-APIs.patch
 create mode 100644 target/linux/generic/pending-4.4/083-0002-clk-Add-clk_hw-OF-clk-providers.patch
 create mode 100644 target/linux/generic/pending-4.4/084-0001-usb-core-Introduce-a-USB-port-LED-trigger.patch
 create mode 100644 target/linux/generic/pending-4.4/084-0002-usb-core-usbport-Use-proper-LED-API-to-fix-potential.patch
 create mode 100644 target/linux/generic/pending-4.4/084-0003-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch
 create mode 100644 target/linux/generic/pending-4.4/085-0001-leds-leds-gpio-Set-of_node-for-created-LED-devices.patch
 create mode 100644 target/linux/generic/pending-4.4/085-0002-leds-gpio-introduce-gpio_blink_set_t.patch
 create mode 100644 target/linux/generic/pending-4.4/085-0003-leds-gpio-switch-to-managed-version-of-led_classdev_.patch
 create mode 100644 target/linux/generic/pending-4.4/085-0004-leds-core-add-OF-variants-of-LED-registering-functio.patch
 create mode 100644 target/linux/generic/pending-4.4/085-0005-leds-gpio-use-OF-variant-of-LED-registering-function.patch
 create mode 100644 target/linux/generic/pending-4.4/086-0001-thermal-of-thermal-Add-devm-version-of-thermal_zone_.patch
 create mode 100644 target/linux/generic/pending-4.4/086-0002-thermal-core-export-apis-to-get-slope-and-offset.patch
 create mode 100644 target/linux/generic/pending-4.4/086-0003-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch
 create mode 100644 target/linux/generic/pending-4.4/086-0004-thermal-broadcom-add-Northstar-thermal-driver.patch
 create mode 100644 target/linux/generic/pending-4.4/086-0005-thermal-broadcom-fix-compilation-of-Northstar-driver.patch
 create mode 100644 target/linux/generic/pending-4.4/087-regmap-make-LZO-cache-optional.patch
 create mode 100644 target/linux/generic/pending-4.4/090-MIPS-c-r4k-Use-IPI-calls-for-CM-indexed-cache-ops.patch
 create mode 100644 target/linux/generic/pending-4.4/091-MIPS-c-r4k-Exclude-sibling-CPUs-in-SMP-calls.patch
 create mode 100644 target/linux/generic/pending-4.4/092-MIPS-ZBOOT-copy-appended-dtb-to-the-end-of-the-kerne.patch
 create mode 100644 target/linux/generic/pending-4.4/093-MIPS-store-the-appended-dtb-address-in-a-variable.patch
 create mode 100644 target/linux/generic/pending-4.4/094-MIPS-c-r4k-Fix-size-calc-when-avoiding-IPIs-for-smal.patch
 create mode 100644 target/linux/generic/pending-4.4/096-arc-add-model-property-in-dts.patch
 create mode 100644 target/linux/generic/pending-4.4/097-MIPS-io.h-Define-ioremap_cache.patch
 create mode 100644 target/linux/generic/pending-4.4/098-usb-dwc2-Remove-unnecessary-kfree.patch
 create mode 100644 target/linux/generic/pending-4.4/101-MIPS-fix-cache-flushing-for-highmem-pages.patch
 create mode 100644 target/linux/generic/pending-4.4/102-ehci_hcd_ignore_oc.patch
 create mode 100644 target/linux/generic/pending-4.4/103-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch
 create mode 100644 target/linux/generic/pending-4.4/105-add-linux-spidev-compatible.patch
 create mode 100644 target/linux/generic/pending-4.4/106-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch
 create mode 100644 target/linux/generic/pending-4.4/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
 create mode 100644 target/linux/generic/pending-4.4/111-jffs2-add-RENAME_EXCHANGE-support.patch
 create mode 100644 target/linux/generic/pending-4.4/120-bridge_allow_receiption_on_disabled_port.patch
 create mode 100644 target/linux/generic/pending-4.4/132-mips_inline_dma_ops.patch
 create mode 100644 target/linux/generic/pending-4.4/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch
 create mode 100644 target/linux/generic/pending-4.4/150-mtd-spi-nor-add-support-for-ESMT_f25l32qa-and-ESMT_f.patch
 create mode 100644 target/linux/generic/pending-4.4/160-usb-gadget-udc-net2280-add-usb2380-support.patch
 create mode 100644 target/linux/generic/pending-4.4/180-Revert-bcma-init-serial-console-directly-from-ChipCo.patch
 create mode 100644 target/linux/generic/pending-4.4/200-fix_localversion.patch
 create mode 100644 target/linux/generic/pending-4.4/201-extra_optimization.patch
 create mode 100644 target/linux/generic/pending-4.4/202-reduce_module_size.patch
 create mode 100644 target/linux/generic/pending-4.4/203-kallsyms_uncompressed.patch
 create mode 100644 target/linux/generic/pending-4.4/204-module_strip.patch
 create mode 100644 target/linux/generic/pending-4.4/205-backtrace_module_info.patch
 create mode 100644 target/linux/generic/pending-4.4/206-mips-disable-vdso.patch
 create mode 100644 target/linux/generic/pending-4.4/207-mips-vdso-dbg-rebuild-after-genvdso.patch
 create mode 100644 target/linux/generic/pending-4.4/208-disable-modorder.patch
 create mode 100644 target/linux/generic/pending-4.4/210-darwin_scripts_include.patch
 create mode 100644 target/linux/generic/pending-4.4/211-sign-file-libressl.patch
 create mode 100644 target/linux/generic/pending-4.4/212-byteshift_portability.patch
 create mode 100644 target/linux/generic/pending-4.4/214-spidev_h_portability.patch
 create mode 100644 target/linux/generic/pending-4.4/220-gc_sections.patch
 create mode 100644 target/linux/generic/pending-4.4/221-module_exports.patch
 create mode 100644 target/linux/generic/pending-4.4/222-arm_zimage_none.patch
 create mode 100644 target/linux/generic/pending-4.4/230-openwrt_lzma_options.patch
 create mode 100644 target/linux/generic/pending-4.4/250-netfilter_depends.patch
 create mode 100644 target/linux/generic/pending-4.4/251-sound_kconfig.patch
 create mode 100644 target/linux/generic/pending-4.4/252-mv_cesa_depends.patch
 create mode 100644 target/linux/generic/pending-4.4/253-ssb_b43_default_on.patch
 create mode 100644 target/linux/generic/pending-4.4/254-textsearch_kconfig_hacks.patch
 create mode 100644 target/linux/generic/pending-4.4/255-lib80211_kconfig_hacks.patch
 create mode 100644 target/linux/generic/pending-4.4/256-crypto_add_kconfig_prompts.patch
 create mode 100644 target/linux/generic/pending-4.4/257-wireless_ext_kconfig_hack.patch
 create mode 100644 target/linux/generic/pending-4.4/258-netfilter_netlink_kconfig_hack.patch
 create mode 100644 target/linux/generic/pending-4.4/259-regmap_dynamic.patch
 create mode 100644 target/linux/generic/pending-4.4/260-crypto_test_dependencies.patch
 create mode 100644 target/linux/generic/pending-4.4/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch
 create mode 100644 target/linux/generic/pending-4.4/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch
 create mode 100644 target/linux/generic/pending-4.4/280-rfkill-stubs.patch
 create mode 100644 target/linux/generic/pending-4.4/300-mips_expose_boot_raw.patch
 create mode 100644 target/linux/generic/pending-4.4/301-mips_image_cmdline_hack.patch
 create mode 100644 target/linux/generic/pending-4.4/302-mips_no_branch_likely.patch
 create mode 100644 target/linux/generic/pending-4.4/304-mips_disable_fpu.patch
 create mode 100644 target/linux/generic/pending-4.4/305-mips_module_reloc.patch
 create mode 100644 target/linux/generic/pending-4.4/306-mips_mem_functions_performance.patch
 create mode 100644 target/linux/generic/pending-4.4/307-mips_highmem_offset.patch
 create mode 100644 target/linux/generic/pending-4.4/308-mips32r2_tune.patch
 create mode 100644 target/linux/generic/pending-4.4/310-arm_module_unresolved_weak_sym.patch
 create mode 100644 target/linux/generic/pending-4.4/320-ppc4xx_optimization.patch
 create mode 100644 target/linux/generic/pending-4.4/321-powerpc_crtsavres_prereq.patch
 create mode 100644 target/linux/generic/pending-4.4/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
 create mode 100644 target/linux/generic/pending-4.4/331-arc-remove-dependency-on-DEVTMPFS.patch
 create mode 100644 target/linux/generic/pending-4.4/332-arc-add-OWRTDTB-section.patch
 create mode 100644 target/linux/generic/pending-4.4/333-arc-enable-unaligned-access-in-kernel-mode.patch
 create mode 100644 target/linux/generic/pending-4.4/400-mtd-add-rootfs-split-support.patch
 create mode 100644 target/linux/generic/pending-4.4/401-mtd-add-support-for-different-partition-parser-types.patch
 create mode 100644 target/linux/generic/pending-4.4/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch
 create mode 100644 target/linux/generic/pending-4.4/403-mtd-hook-mtdsplit-to-Kbuild.patch
 create mode 100644 target/linux/generic/pending-4.4/404-mtd-add-more-helper-functions.patch
 create mode 100644 target/linux/generic/pending-4.4/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
 create mode 100644 target/linux/generic/pending-4.4/411-mtd-partial_eraseblock_write.patch
 create mode 100644 target/linux/generic/pending-4.4/412-mtd-partial_eraseblock_unlock.patch
 create mode 100644 target/linux/generic/pending-4.4/420-mtd-redboot_space.patch
 create mode 100644 target/linux/generic/pending-4.4/430-mtd-add-myloader-partition-parser.patch
 create mode 100644 target/linux/generic/pending-4.4/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
 create mode 100644 target/linux/generic/pending-4.4/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
 create mode 100644 target/linux/generic/pending-4.4/440-block2mtd_init.patch
 create mode 100644 target/linux/generic/pending-4.4/441-block2mtd_probe.patch
 create mode 100644 target/linux/generic/pending-4.4/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch
 create mode 100644 target/linux/generic/pending-4.4/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch
 create mode 100644 target/linux/generic/pending-4.4/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
 create mode 100644 target/linux/generic/pending-4.4/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
 create mode 100644 target/linux/generic/pending-4.4/465-m25p80-mx-disable-software-protection.patch
 create mode 100644 target/linux/generic/pending-4.4/475-mtd-spi-nor-add-macronix-mx25u25635f.patch
 create mode 100644 target/linux/generic/pending-4.4/476-mtd-spi-nor-add-eon-en25q128.patch
 create mode 100644 target/linux/generic/pending-4.4/477-mtd-add-spi-nor-add-mx25u3235f.patch
 create mode 100644 target/linux/generic/pending-4.4/479-enable_mtd_has_lock_for_f25l32pa.patch
 create mode 100644 target/linux/generic/pending-4.4/480-mtd-set-rootfs-to-be-root-dev.patch
 create mode 100644 target/linux/generic/pending-4.4/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
 create mode 100644 target/linux/generic/pending-4.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
 create mode 100644 target/linux/generic/pending-4.4/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
 create mode 100644 target/linux/generic/pending-4.4/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
 create mode 100644 target/linux/generic/pending-4.4/494-mtd-ubi-add-EOF-marker-support.patch
 create mode 100644 target/linux/generic/pending-4.4/530-jffs2_make_lzma_available.patch
 create mode 100644 target/linux/generic/pending-4.4/531-debloat_lzma.patch
 create mode 100644 target/linux/generic/pending-4.4/532-jffs2_eofdetect.patch
 create mode 100644 target/linux/generic/pending-4.4/551-ubifs-fix-default-compression-selection.patch
 create mode 100644 target/linux/generic/pending-4.4/600-netfilter_conntrack_flush.patch
 create mode 100644 target/linux/generic/pending-4.4/610-netfilter_match_bypass_default_checks.patch
 create mode 100644 target/linux/generic/pending-4.4/611-netfilter_match_bypass_default_table.patch
 create mode 100644 target/linux/generic/pending-4.4/612-netfilter_match_reduce_memory_access.patch
 create mode 100644 target/linux/generic/pending-4.4/613-netfilter_optional_tcp_window_check.patch
 create mode 100644 target/linux/generic/pending-4.4/616-net_optimize_xfrm_calls.patch
 create mode 100644 target/linux/generic/pending-4.4/620-net_sched-codel-do-not-defer-queue-length-update.patch
 create mode 100644 target/linux/generic/pending-4.4/630-packet_socket_type.patch
 create mode 100644 target/linux/generic/pending-4.4/640-bridge_no_eap_forward.patch
 create mode 100644 target/linux/generic/pending-4.4/641-bridge_always_accept_eap.patch
 create mode 100644 target/linux/generic/pending-4.4/642-bridge_port_isolate.patch
 create mode 100644 target/linux/generic/pending-4.4/645-bridge_multicast_to_unicast.patch
 create mode 100644 target/linux/generic/pending-4.4/651-wireless_mesh_header.patch
 create mode 100644 target/linux/generic/pending-4.4/653-disable_netlink_trim.patch
 create mode 100644 target/linux/generic/pending-4.4/655-increase_skb_pad.patch
 create mode 100644 target/linux/generic/pending-4.4/660-fq_codel_defaults.patch
 create mode 100644 target/linux/generic/pending-4.4/661-fq_codel_keep_dropped_stats.patch
 create mode 100644 target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch
 create mode 100644 target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch
 create mode 100644 target/linux/generic/pending-4.4/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
 create mode 100644 target/linux/generic/pending-4.4/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
 create mode 100644 target/linux/generic/pending-4.4/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
 create mode 100644 target/linux/generic/pending-4.4/680-NET-skip-GRO-for-foreign-MAC-addresses.patch
 create mode 100644 target/linux/generic/pending-4.4/681-NET-add-of_get_mac_address_mtd.patch
 create mode 100644 target/linux/generic/pending-4.4/700-swconfig.patch
 create mode 100644 target/linux/generic/pending-4.4/701-phy_extension.patch
 create mode 100644 target/linux/generic/pending-4.4/702-phy_add_aneg_done_function.patch
 create mode 100644 target/linux/generic/pending-4.4/703-phy-add-detach-callback-to-struct-phy_driver.patch
 create mode 100644 target/linux/generic/pending-4.4/710-phy-add-mdio_register_board_info.patch
 create mode 100644 target/linux/generic/pending-4.4/720-phy_adm6996.patch
 create mode 100644 target/linux/generic/pending-4.4/721-phy_packets.patch
 create mode 100644 target/linux/generic/pending-4.4/722-phy_mvswitch.patch
 create mode 100644 target/linux/generic/pending-4.4/723-phy_ip175c.patch
 create mode 100644 target/linux/generic/pending-4.4/724-phy_ar8216.patch
 create mode 100644 target/linux/generic/pending-4.4/725-phy_rtl8306.patch
 create mode 100644 target/linux/generic/pending-4.4/726-phy_rtl8366.patch
 create mode 100644 target/linux/generic/pending-4.4/727-phy-rtl8367.patch
 create mode 100644 target/linux/generic/pending-4.4/728-phy-rtl8367b.patch
 create mode 100644 target/linux/generic/pending-4.4/729-phy-tantos.patch
 create mode 100644 target/linux/generic/pending-4.4/730-phy_b53.patch
 create mode 100644 target/linux/generic/pending-4.4/732-phy-ar8216-led-support.patch
 create mode 100644 target/linux/generic/pending-4.4/733-phy_mvsw61xx.patch
 create mode 100644 target/linux/generic/pending-4.4/734-net-phy-at803x-allow-to-configure-via-pdata.patch
 create mode 100644 target/linux/generic/pending-4.4/735-net-phy-at803x-fix-at8033-sgmii-mode.patch
 create mode 100644 target/linux/generic/pending-4.4/736-at803x-fix-reset-handling.patch
 create mode 100644 target/linux/generic/pending-4.4/737-net-phy-at803x-Request-reset-GPIO-only-for-AT8030-PH.patch
 create mode 100644 target/linux/generic/pending-4.4/738-net-phy-at803x-only-the-AT8030-needs-a-hardware-rese.patch
 create mode 100644 target/linux/generic/pending-4.4/739-net-phy-at803x-add-support-for-AT8032.patch
 create mode 100644 target/linux/generic/pending-4.4/773-bgmac-add-srab-switch.patch
 create mode 100644 target/linux/generic/pending-4.4/810-pci_disable_common_quirks.patch
 create mode 100644 target/linux/generic/pending-4.4/811-pci_disable_usb_common_quirks.patch
 create mode 100644 target/linux/generic/pending-4.4/821-usb-Remove-annoying-warning-about-bogus-URB.patch
 create mode 100644 target/linux/generic/pending-4.4/831-ledtrig_netdev.patch
 create mode 100644 target/linux/generic/pending-4.4/834-ledtrig-libata.patch
 create mode 100644 target/linux/generic/pending-4.4/835-misc-owl_loader.patch
 create mode 100644 target/linux/generic/pending-4.4/840-rtc7301.patch
 create mode 100644 target/linux/generic/pending-4.4/841-rtc_pt7c4338.patch
 create mode 100644 target/linux/generic/pending-4.4/861-04_spi_gpio_implement_spi_delay.patch
 create mode 100644 target/linux/generic/pending-4.4/862-gpio_spi_driver.patch
 create mode 100644 target/linux/generic/pending-4.4/890-uart_optional_sysrq.patch
 create mode 100644 target/linux/generic/pending-4.4/901-debloat_sock_diag.patch
 create mode 100644 target/linux/generic/pending-4.4/902-debloat_proc.patch
 create mode 100644 target/linux/generic/pending-4.4/904-debloat_dma_buf.patch
 create mode 100644 target/linux/generic/pending-4.4/910-kobject_uevent.patch
 create mode 100644 target/linux/generic/pending-4.4/911-kobject_add_broadcast_uevent.patch
 create mode 100644 target/linux/generic/pending-4.4/921-use_preinit_as_init.patch
 create mode 100644 target/linux/generic/pending-4.4/922-always-create-console-node-in-initramfs.patch
 create mode 100644 target/linux/generic/pending-4.4/930-crashlog.patch
 create mode 100644 target/linux/generic/pending-4.4/970-remove-unsane-filenames-from-deps_initramfs-list.patch
 create mode 100644 target/linux/generic/pending-4.4/995-mangle_bootargs.patch
 create mode 100644 target/linux/generic/pending-4.4/998-enable_wilink_platform_without_drivers.patch

diff --git a/include/kernel-version.mk b/include/kernel-version.mk
index 320ecd5ce6..6492ad3d51 100644
--- a/include/kernel-version.mk
+++ b/include/kernel-version.mk
@@ -4,9 +4,11 @@ LINUX_RELEASE?=1
 
 LINUX_VERSION-4.9 = .135
 LINUX_VERSION-4.14 = .79
+LINUX_VERSION-4.4 = .121
 
 LINUX_KERNEL_HASH-4.9.135 = e023b0bbe9ea7fc56aa57210342dd18ea3e0900ee207226df1523c6d7df154ce
 LINUX_KERNEL_HASH-4.14.79 = 5619071eceb27f903d2fce1784223796bfbe25528f9690273cdfe82fdd9b933a
+LINUX_KERNEL_HASH-4.4.121 = 44a88268b5088dc326b30c9b9133ac35a9a200b636b7268d08f32abeae6ca729
 
 remove_uri_prefix=$(subst git://,,$(subst http://,,$(subst https://,,$(1))))
 sanitize_uri=$(call qstrip,$(subst @,_,$(subst :,_,$(subst .,_,$(subst -,_,$(subst /,_,$(1)))))))
diff --git a/target/linux/generic/config-4.4 b/target/linux/generic/config-4.4
new file mode 100644
index 0000000000..3285000eb4
--- /dev/null
+++ b/target/linux/generic/config-4.4
@@ -0,0 +1,4857 @@
+CONFIG_32BIT=y
+# CONFIG_6LOWPAN is not set
+# CONFIG_6PACK is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_9P_FS is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_AB8500_CORE is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_ACENIC is not set
+# CONFIG_ACERHDF is not set
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_ACPI_ALS is not set
+# CONFIG_ACPI_APEI is not set
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_EXTLOG is not set
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+# CONFIG_AD2S90 is not set
+# CONFIG_AD5064 is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686 is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5933 is not set
+# CONFIG_AD7150 is not set
+# CONFIG_AD7152 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7280 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD7746 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD8366 is not set
+# CONFIG_AD9523 is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_ADE7753 is not set
+# CONFIG_ADE7754 is not set
+# CONFIG_ADE7758 is not set
+# CONFIG_ADE7759 is not set
+# CONFIG_ADE7854 is not set
+# CONFIG_ADF4350 is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADIS16060 is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16204 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16220 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_ADJD_S311 is not set
+# CONFIG_ADM6996_PHY is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_ADT7316 is not set
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_ADXRS450 is not set
+CONFIG_AEABI=y
+# CONFIG_AFFS_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AGP is not set
+# CONFIG_AHCI_CEVA is not set
+# CONFIG_AHCI_IMX is not set
+# CONFIG_AHCI_MVEBU is not set
+# CONFIG_AHCI_QORIQ is not set
+CONFIG_AIO=y
+# CONFIG_AIRO is not set
+# CONFIG_AIRO_CS is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_AK09911 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_ALIM7101_WDT is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_ALTERA_MBOX is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_ALX is not set
+# CONFIG_AM335X_PHY_USB is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AMD_XGBE is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_AMILO_RFKILL is not set
+# CONFIG_ANDROID is not set
+CONFIG_ANON_INODES=y
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_APM8018X is not set
+# CONFIG_APPLE_GMUX is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AR5523 is not set
+# CONFIG_AR7 is not set
+# CONFIG_AR8216_PHY is not set
+# CONFIG_AR8216_PHY_LEDS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_EXYNOS is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+# CONFIG_ARCH_HI3xxx is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_MULTI_V6 is not set
+# CONFIG_ARCH_MULTI_V7 is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_NSPIRE is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_SHMOBILE_MULTI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_WM8505 is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCNET is not set
+# CONFIG_ARC_EMAC is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_834220 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM_APPENDED_DTB is not set
+# CONFIG_ARM_ARCH_TIMER is not set
+# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
+# CONFIG_ARM_CCI is not set
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI500_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_ARM_CPUIDLE is not set
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_ARM_CRYPTO is not set
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+# CONFIG_ARM_ERRATA_326103 is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+# CONFIG_ARM_ERRATA_411920 is not set
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_KERNMEM_PERMS is not set
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+# CONFIG_ARM_KPROBES_TEST is not set
+# CONFIG_ARM_MHU is not set
+# CONFIG_ARM_MODULE_PLTS is not set
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+# CONFIG_ARM_PSCI is not set
+# CONFIG_ARM_PTDUMP is not set
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_ARM_VIRT_EXT is not set
+# CONFIG_AS3935 is not set
+# CONFIG_ASM9260_TIMER is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_ATA is not set
+# CONFIG_ATAGS is not set
+CONFIG_ATAGS_PROC=y
+# CONFIG_ATALK is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_ATA_ACPI is not set
+CONFIG_ATA_BMDMA=y
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_ATA_PIIX is not set
+CONFIG_ATA_SFF=y
+# CONFIG_ATA_VERBOSE_ERROR is not set
+# CONFIG_ATH10K is not set
+# CONFIG_ATH25 is not set
+# CONFIG_ATH5K is not set
+# CONFIG_ATH6KL is not set
+# CONFIG_ATH79 is not set
+# CONFIG_ATH9K is not set
+# CONFIG_ATH9K_HTC is not set
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL2 is not set
+# CONFIG_ATM is not set
+# CONFIG_ATMEL is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_BR2684 is not set
+CONFIG_ATM_BR2684_IPFILTER=y
+# CONFIG_ATM_CLIP is not set
+CONFIG_ATM_CLIP_NO_ICMP=y
+# CONFIG_ATM_DRIVERS is not set
+# CONFIG_ATM_DUMMY is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_FORE200E is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_LANE is not set
+# CONFIG_ATM_MPOA is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_SOLOS is not set
+# CONFIG_ATM_TCP is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ATP is not set
+# CONFIG_AUDIT is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_AURORA_NB8800 is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTO_ZRELADDR is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_AX25 is not set
+# CONFIG_AX25_DAMA_SLAVE is not set
+# CONFIG_AX88796 is not set
+# CONFIG_AXP288_ADC is not set
+# CONFIG_AXP288_FUEL_GAUGE is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_B44 is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_PANDORA is not set
+# CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_RPI is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+CONFIG_BASE_FULL=y
+CONFIG_BASE_SMALL=0
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_BCM63XX is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BCMA is not set
+# CONFIG_BCMA_DRIVER_GPIO is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMGENET is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BE2NET is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_BGMAC is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_BIG_LITTLE is not set
+# CONFIG_BINARY_PRINTF is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BITREVERSE=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_CPQ_DA is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_BLK_DEV_4DRIVES is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI14XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_DTC2278 is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_HT6560B is not set
+# CONFIG_BLK_DEV_IDEACPI is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_BLK_DEV_IDEPNP is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDE_AU1XXX is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_PLATFORM is not set
+# CONFIG_BLK_DEV_PMEM is not set
+# CONFIG_BLK_DEV_QD65XX is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_UMC8672 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_BLOCK=y
+# CONFIG_BMA180 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_BMC150_MAGN is not set
+# CONFIG_BMG160 is not set
+# CONFIG_BMIPS_GENERIC is not set
+# CONFIG_BMP085 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_BMP280 is not set
+# CONFIG_BNA is not set
+# CONFIG_BNX2 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_BNXT is not set
+# CONFIG_BONDING is not set
+# CONFIG_BOOKE_WDT is not set
+CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_BOOT_RAW=y
+CONFIG_BPF=y
+# CONFIG_BPF_JIT is not set
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPQETHER is not set
+CONFIG_BQL=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_BRCMFMAC is not set
+# CONFIG_BRCMSMAC is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_EBT_802_3 is not set
+# CONFIG_BRIDGE_EBT_AMONG is not set
+# CONFIG_BRIDGE_EBT_ARP is not set
+# CONFIG_BRIDGE_EBT_ARPREPLY is not set
+# CONFIG_BRIDGE_EBT_BROUTE is not set
+# CONFIG_BRIDGE_EBT_DNAT is not set
+# CONFIG_BRIDGE_EBT_IP is not set
+# CONFIG_BRIDGE_EBT_IP6 is not set
+# CONFIG_BRIDGE_EBT_LIMIT is not set
+# CONFIG_BRIDGE_EBT_LOG is not set
+# CONFIG_BRIDGE_EBT_MARK is not set
+# CONFIG_BRIDGE_EBT_MARK_T is not set
+# CONFIG_BRIDGE_EBT_NFLOG is not set
+# CONFIG_BRIDGE_EBT_PKTTYPE is not set
+# CONFIG_BRIDGE_EBT_REDIRECT is not set
+# CONFIG_BRIDGE_EBT_SNAT is not set
+# CONFIG_BRIDGE_EBT_STP is not set
+# CONFIG_BRIDGE_EBT_T_FILTER is not set
+# CONFIG_BRIDGE_EBT_T_NAT is not set
+# CONFIG_BRIDGE_EBT_VLAN is not set
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_NETFILTER is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BROKEN_ON_SMP=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_BT is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BT_ATH3K is not set
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+# CONFIG_BT_BREDR is not set
+# CONFIG_BT_CMTP is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBLUECARD is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBT3C is not set
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIBTUART is not set
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTUSB_RTL is not set
+# CONFIG_BT_HCIDTL1 is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIUART_3WIRE is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIUART_QCA is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_HIDP is not set
+# CONFIG_BT_HS is not set
+# CONFIG_BT_LE is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_RFCOMM is not set
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_SELFTEST is not set
+CONFIG_BUG=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_C2PORT is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CAN is not set
+# CONFIG_CAN_BCM is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_CAN_DEV is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_GW is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_RAW is not set
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CAN_SLCAN is not set
+# CONFIG_CAN_SUN4I is not set
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAPI_AVM is not set
+# CONFIG_CAPI_EICON is not set
+# CONFIG_CAPI_TRACE is not set
+CONFIG_CARDBUS=y
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_CARL9170 is not set
+# CONFIG_CASSINI is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23144 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_OCTEON_SOC is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_CFG80211 is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_CHARGER_TWL4030 is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CIFS is not set
+# CONFIG_CIFS_ACL is not set
+# CONFIG_CIFS_DEBUG is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_CIFS_NFSD_EXPORT is not set
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_SMB2 is not set
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_STATS2 is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CLKSRC_VERSATILE is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_CLOCK_THERMAL is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_CMA is not set
+CONFIG_CMDLINE=""
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# CONFIG_CNIC is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_COMEDI is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_IPROC is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_QCOM is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_COMPACTION is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_CONSTRUCTORS=y
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_COPS is not set
+# CONFIG_CORDIC is not set
+# CONFIG_COREDUMP is not set
+# CONFIG_CORESIGHT is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_CPA_DEBUG is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_IDLE is not set
+# CONFIG_CPU_IDLE_GOV_MENU is not set
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+# CONFIG_CRAMFS is not set
+CONFIG_CRASHLOG=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC32_SARWATE=y
+# CONFIG_CRC32_SELFTEST is not set
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SLICEBY8 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_CRC8 is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC_ITU_T is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CROSS_COMPILE=""
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_AEAD is not set
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_AES_ARM_BS is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
+# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_IMGTEC_HASH is not set
+# CONFIG_CRYPTO_DEV_MARVELL_CESA is not set
+# CONFIG_CRYPTO_DEV_MV_CESA is not set
+# CONFIG_CRYPTO_DEV_MXS_DCP is not set
+# CONFIG_CRYPTO_DEV_QAT_DH895xCC is not set
+# CONFIG_CRYPTO_DEV_QAT_DH895xCCVF is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_SAHARA is not set
+# CONFIG_CRYPTO_DEV_TALITOS is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+# CONFIG_CRYPTO_HASH is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_PCOMP is not set
+# CONFIG_CRYPTO_PCOMP2 is not set
+CONFIG_CRYPTO_PCRYPT=y
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_RNG is not set
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_TWOFISH_COMMON is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_VMAC is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CS5535_MFGPT is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_CUSE is not set
+# CONFIG_CW1200 is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_EEH is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CYPRESS_FIRMWARE is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DCB is not set
+# CONFIG_DDR is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+CONFIG_DEBUG_INFO_REDUCED=y
+# CONFIG_DEBUG_INFO_SPLIT is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_KOBJECT_RELEASE is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+# CONFIG_DEBUG_LOCKDEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_UART_BCM63XX is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_ZBOOT is not set
+# CONFIG_DECNET is not set
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+# CONFIG_DELL_RBTN is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_DEVMEM is not set
+CONFIG_DEVPORT=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_DEVTMPFS is not set
+# CONFIG_DEVTMPFS_MOUNT is not set
+# CONFIG_DGAP is not set
+# CONFIG_DGNC is not set
+# CONFIG_DHT11 is not set
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_DISPLAY_CONNECTOR_ANALOG_TV is not set
+# CONFIG_DISPLAY_CONNECTOR_DVI is not set
+# CONFIG_DISPLAY_CONNECTOR_HDMI is not set
+# CONFIG_DISPLAY_ENCODER_TFP410 is not set
+# CONFIG_DISPLAY_ENCODER_TPD12S015 is not set
+# CONFIG_DISPLAY_PANEL_DPI is not set
+# CONFIG_DISPLAY_PANEL_LGPHILIPS_LB035Q02 is not set
+# CONFIG_DISPLAY_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DISPLAY_PANEL_TPO_TD043MTEA1 is not set
+# CONFIG_DL2K is not set
+# CONFIG_DLM is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_DMADEVICES_DEBUG is not set
+# CONFIG_DMASCC is not set
+# CONFIG_DMATEST is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_DMA_ENGINE is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_MQ_DEFAULT is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DNET is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_DNS_RESOLVER is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_DQL=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_DRM is not set
+# CONFIG_DS1682 is not set
+# CONFIG_DTLK is not set
+# CONFIG_DUMMY is not set
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DVB_DUMMY_FE is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DWMAC_IPQ806X is not set
+# CONFIG_DWMAC_LPC18XX is not set
+# CONFIG_DWMAC_MESON is not set
+# CONFIG_DWMAC_ROCKCHIP is not set
+# CONFIG_DWMAC_SOCFPGA is not set
+# CONFIG_DWMAC_STI is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_EARLY_PRINTK_8250 is not set
+# CONFIG_ECHO is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_EDAC is not set
+# CONFIG_EEEPC_LAPTOP is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_EFS_FS is not set
+# CONFIG_ELF_CORE is not set
+# CONFIG_EMAC_ROCKCHIP is not set
+CONFIG_EMBEDDED=y
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_ENCX24J600 is not set
+# CONFIG_ENIC is not set
+# CONFIG_EPAPR_PARAVIRT is not set
+# CONFIG_EPIC100 is not set
+CONFIG_EPOLL=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_ET131X is not set
+CONFIG_ETHERNET=y
+# CONFIG_ETHOC is not set
+CONFIG_EVENTFD=y
+CONFIG_EXPERT=y
+# CONFIG_EXPORTFS is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_DEBUG is not set
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_EXT4_USE_FOR_EXT2=y
+# CONFIG_EXTCON is not set
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+# CONFIG_EXTCON_USB_GPIO is not set
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_EXTRA_TARGETS=""
+# CONFIG_EXYNOS_ADC is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_F2FS_FS_ENCRYPTION is not set
+# CONFIG_F2FS_FS_POSIX_ACL is not set
+# CONFIG_F2FS_IO_TRACE is not set
+# CONFIG_FAIR_GROUP_SCHED is not set
+# CONFIG_FANOTIFY is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_FS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_FB is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_BIG_ENDIAN is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_BOTH_ENDIAN is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_DA8XX is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_IMX is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_LITTLE_ENDIAN is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_MXS is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_OF is not set
+# CONFIG_FB_OMAP2 is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_PS3 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_FB_SM750 is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_FDDI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_FENCE_TRACE is not set
+# CONFIG_FHANDLE is not set
+CONFIG_FIB_RULES=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_FIREWIRE_SERIAL is not set
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_FLATMEM=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_FM10K is not set
+# CONFIG_FMC is not set
+# CONFIG_FORCEDETH is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+# CONFIG_FPGA is not set
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_FRAME_POINTER is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_FREEZER is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_FSCACHE is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_PQ_MDIO is not set
+# CONFIG_FSL_XGMAC_MDIO is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_FS_DAX is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_FTGMAC100 is not set
+# CONFIG_FTL is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTRACE is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+# CONFIG_FUSION_SPI is not set
+CONFIG_FUTEX=y
+CONFIG_FW_LOADER=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_GACT_PROB=y
+# CONFIG_GADGET_UAC1 is not set
+# CONFIG_GAMEPORT is not set
+# CONFIG_GATEWORKS_GW16083 is not set
+# CONFIG_GCOV is not set
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_GDB_SCRIPTS is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GENWQE is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_GIGASET_CAPI is not set
+# CONFIG_GIGASET_DEBUG is not set
+# CONFIG_GLOB_SELFTEST is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_GPIOLIB is not set
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_BCM_KONA is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_CS5535 is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_ICH is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_PCH is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_RDC321X is not set
+# CONFIG_GPIO_SCH is not set
+# CONFIG_GPIO_SCH311X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_SYSFS is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_ZX is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_CAT=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HCALL_STATS is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HDLC is not set
+# CONFIG_HDLC_CISCO is not set
+# CONFIG_HDLC_FR is not set
+# CONFIG_HDLC_PPP is not set
+# CONFIG_HDLC_RAW is not set
+# CONFIG_HDLC_RAW_ETH is not set
+# CONFIG_HDQ_MASTER_OMAP is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_HERMES is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_HFSPLUS_FS_POSIX_ACL is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFS_FS_POSIX_ACL is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_HID is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_ACRUX_FF is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_CP2112 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GENERIC is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_LOGITECH_DJ is not set
+# CONFIG_HID_LOGITECH_HIDPP is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PID is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGH_RES_TIMERS=y
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HIPPI is not set
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_HOSTAP_CS is not set
+# CONFIG_HOSTAP_PCI is not set
+# CONFIG_HOSTAP_PLX is not set
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HP100 is not set
+CONFIG_HPET_MMAP_DEFAULT=y
+# CONFIG_HPFS_FS is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_HP_WIRELESS is not set
+# CONFIG_HSI is not set
+# CONFIG_HSR is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWSPINLOCK_OMAP is not set
+CONFIG_HW_PERF_EVENTS=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HW_RANDOM_AMD is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_HW_RANDOM_GEODE is not set
+# CONFIG_HW_RANDOM_INTEL is not set
+# CONFIG_HW_RANDOM_IPROC_RNG200 is not set
+# CONFIG_HW_RANDOM_OMAP3_ROM is not set
+# CONFIG_HW_RANDOM_PPC4XX is not set
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_TPM is not set
+# CONFIG_HW_RANDOM_VIA is not set
+# CONFIG_HW_RANDOM_VIRTIO is not set
+# CONFIG_HYPERV is not set
+# CONFIG_HYSDN is not set
+CONFIG_HZ=100
+CONFIG_HZ_100=y
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_24 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_48 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_PERIODIC is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_AU1550 is not set
+# CONFIG_I2C_BCM2835 is not set
+# CONFIG_I2C_BCM_IPROC is not set
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_COMPAT is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_ELEKTOR is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_HID is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_IBM_IIC is not set
+# CONFIG_I2C_IMG is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_MV64XXX is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_OCTEON is not set
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RCAR is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_SCMI is not set
+# CONFIG_I2C_SH_MOBILE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_SMBUS is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VERSATILE is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_IBM_EMAC_DEBUG is not set
+# CONFIG_IBM_EMAC_EMAC4 is not set
+# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_EMAC_RGMII is not set
+# CONFIG_IBM_EMAC_TAH is not set
+# CONFIG_IBM_EMAC_ZMII is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_IDE is not set
+# CONFIG_IDEAPAD_LAPTOP is not set
+# CONFIG_IDE_GD is not set
+# CONFIG_IDE_PROC_FS is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_IEEE802154_ATUSB is not set
+# CONFIG_IFB is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IIO is not set
+# CONFIG_IIO_BUFFER_CB is not set
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKCONFIG_PROC is not set
+# CONFIG_IMAGE_CMDLINE_HACK is not set
+# CONFIG_IMGPDC_WDT is not set
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_IMX_THERMAL is not set
+CONFIG_INET=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_TCP_DIAG is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_INFTL is not set
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_IDEAPAD_SLIDEBAR is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_LEDS is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_PALMAS_PWRBUTTON is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_TPS65218_PWRBUTTON is not set
+# CONFIG_INPUT_TWL4030_PWRBUTTON is not set
+# CONFIG_INPUT_TWL4030_VIBRA is not set
+# CONFIG_INPUT_TWL6040_VIBRA is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEL_IDLE is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_INTEL_MEI is not set
+# CONFIG_INTEL_MEI_ME is not set
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_INTEL_MIC_CARD is not set
+# CONFIG_INTEL_MIC_HOST is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_INTEL_OAKTRAIL is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_INTEL_SOC_PMIC is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_INV_MPU6050_IIO is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IP17XX_PHY is not set
+# CONFIG_IP6_NF_FILTER is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_NAT is not set
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPV6 is not set
+# CONFIG_IPV6_ILA is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_SIT_6RD is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_VTI is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2100_DEBUG is not set
+CONFIG_IPW2100_MONITOR=y
+# CONFIG_IPW2200 is not set
+# CONFIG_IPW2200_DEBUG is not set
+CONFIG_IPW2200_MONITOR=y
+# CONFIG_IPW2200_PROMISCUOUS is not set
+# CONFIG_IPW2200_QOS is not set
+# CONFIG_IPW2200_RADIOTAP is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_IPX is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_FIB_TRIE_STATS is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_MASQUERADE is not set
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_IP_PNP is not set
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+# CONFIG_IRDA is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_IRQ_ALL_CPUS is not set
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_IR_GPIO_CIR is not set
+# CONFIG_IR_HIX5HD2 is not set
+# CONFIG_IR_IGORPLUGUSB is not set
+# CONFIG_IR_IGUANA is not set
+# CONFIG_IR_IMG is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_LIRC_CODEC is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_TTUSBIR is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_ISCSI_TCP is not set
+CONFIG_ISDN=y
+# CONFIG_ISDN_AUDIO is not set
+# CONFIG_ISDN_CAPI is not set
+# CONFIG_ISDN_CAPI_CAPIDRV is not set
+# CONFIG_ISDN_DIVERSION is not set
+# CONFIG_ISDN_DRV_ACT2000 is not set
+# CONFIG_ISDN_DRV_GIGASET is not set
+# CONFIG_ISDN_DRV_HISAX is not set
+# CONFIG_ISDN_DRV_ICN is not set
+# CONFIG_ISDN_DRV_LOOP is not set
+# CONFIG_ISDN_DRV_PCBIT is not set
+# CONFIG_ISDN_DRV_SC is not set
+# CONFIG_ISDN_I4L is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_ISS4xx is not set
+# CONFIG_ITG3200 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_IWLWIFI is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_POSIX_ACL is not set
+# CONFIG_JFFS2_FS_SECURITY is not set
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_LZMA=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_ZLIB is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_JME is not set
+CONFIG_JOLIET=y
+# CONFIG_JSA1212 is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_KALLSYMS is not set
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_UNCOMPRESSED is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_KASAN is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_CAT is not set
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZ4 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_KERNEL_XZ=y
+CONFIG_KERNFS=y
+# CONFIG_KEXEC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_BCM is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_PXA27x is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_SH_KEYSC is not set
+# CONFIG_KEYBOARD_SNVS_PWRKEY is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_TWL4030 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYS is not set
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+# CONFIG_KMX61 is not set
+# CONFIG_KPROBES is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSM is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_GUEST is not set
+# CONFIG_KVM_INTEL is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_L2TP is not set
+# CONFIG_L2TP_ETH is not set
+# CONFIG_L2TP_IP is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_LANMEDIA is not set
+# CONFIG_LANTIQ is not set
+# CONFIG_LANTIQ_PHY is not set
+# CONFIG_LAPB is not set
+# CONFIG_LASAT is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_LBDAF=y
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_INTEL_SS4200 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_NS2 is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
+CONFIG_LEDS_TRIGGER_NETDEV=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LGUEST is not set
+# CONFIG_LIB80211 is not set
+# CONFIG_LIB80211_CRYPT_CCMP is not set
+# CONFIG_LIB80211_CRYPT_TKIP is not set
+# CONFIG_LIB80211_CRYPT_WEP is not set
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_LIBERTAS_USB is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_LIBIPW_DEBUG is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_LIS3L02DQ is not set
+# CONFIG_LKDTM is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_LOCKD is not set
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_LOCKD_V4=y
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_LOGFS is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_LOGO is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+# CONFIG_LOONGSON_MC146818 is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_LTPC is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LUSTRE_FS is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_LZ4HC_COMPRESS is not set
+# CONFIG_LZ4_COMPRESS is not set
+# CONFIG_LZ4_DECOMPRESS is not set
+CONFIG_LZMA_COMPRESS=y
+CONFIG_LZMA_DECOMPRESS=y
+# CONFIG_LZO_COMPRESS is not set
+# CONFIG_LZO_DECOMPRESS is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_MACB is not set
+# CONFIG_MACH_ASM9260 is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_INGENIC is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_JZ4740 is not set
+# CONFIG_MACH_LOONGSON32 is not set
+# CONFIG_MACH_LOONGSON64 is not set
+# CONFIG_MACH_PISTACHIO is not set
+# CONFIG_MACH_TX39XX is not set
+# CONFIG_MACH_TX49XX is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_MACH_XILFPGA is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_MACVTAP is not set
+# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+# CONFIG_MAGIC_SYSRQ_SERIAL is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_MANGLE_BOOTARGS is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_MCB is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_MCPM is not set
+# CONFIG_MD is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_ATTACH is not set
+# CONFIG_MEDIA_CAMERA_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_MEDIA_SUPPORT is not set
+# CONFIG_MEDIA_USB_SUPPORT is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_SAS is not set
+CONFIG_MEMBARRIER=y
+# CONFIG_MEMORY is not set
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_MEN_A21_WDT is not set
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_AXP20X is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_OMAP_USB_HOST is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8921_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MIGRATION is not set
+CONFIG_MII=y
+# CONFIG_MIKROTIK_RB532 is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_MIPS_ALCHEMY is not set
+# CONFIG_MIPS_CDMM is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MIPS_FPU_EMULATOR is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_O32_FP64_SUPPORT is not set
+# CONFIG_MIPS_PARAVIRT is not set
+# CONFIG_MIPS_PLATFORM_DEVICES is not set
+# CONFIG_MIPS_SEAD3 is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_MISDN is not set
+# CONFIG_MISDN_AVMFRITZ is not set
+# CONFIG_MISDN_HFCPCI is not set
+# CONFIG_MISDN_HFCUSB is not set
+# CONFIG_MISDN_INFINEON is not set
+# CONFIG_MISDN_NETJET is not set
+# CONFIG_MISDN_SPEEDFAX is not set
+# CONFIG_MISDN_W6692 is not set
+# CONFIG_MKISS is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX5_CORE is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MMC is not set
+# CONFIG_MMC35240 is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_AU1X is not set
+# CONFIG_MMC_BLOCK is not set
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_MVSDIO is not set
+# CONFIG_MMC_S3C is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_ACPI is not set
+# CONFIG_MMC_SDHCI_BCM_KONA is not set
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_SDHCI_IPROC is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_OF_ESDHC is not set
+# CONFIG_MMC_SDHCI_OF_HLWD is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDRICOH_CS is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_TOSHIBA_PCI is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMIOTRACE is not set
+CONFIG_MMU=y
+CONFIG_MODULES=y
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_MODULE_STRIPPED=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MOST is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_PS2_FOCALTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_MPL115 is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MPLS is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_MSDOS_FS is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_MSI_LAPTOP is not set
+CONFIG_MTD=y
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_MTD_BLOCK2MTD is not set
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_GPIO_ADDR is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_LATCH_ADDR is not set
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# CONFIG_MTD_M25P80 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MYLOADER_PARTS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_NAND_AMS_DELTA is not set
+# CONFIG_MTD_NAND_AR934X is not set
+# CONFIG_MTD_NAND_AR934X_HW_ECC is not set
+# CONFIG_MTD_NAND_ATMEL is not set
+# CONFIG_MTD_NAND_AU1550 is not set
+# CONFIG_MTD_NAND_BCH is not set
+# CONFIG_MTD_NAND_BF5XX is not set
+# CONFIG_MTD_NAND_BRCMNAND is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_CM_X270 is not set
+# CONFIG_MTD_NAND_CS553X is not set
+# CONFIG_MTD_NAND_DAVINCI is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_DENALI_DT is not set
+# CONFIG_MTD_NAND_DENALI_PCI is not set
+CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xff108018
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_ECC is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_FSL_ELBC is not set
+# CONFIG_MTD_NAND_FSL_IFC is not set
+# CONFIG_MTD_NAND_FSL_UPM is not set
+# CONFIG_MTD_NAND_FSMC is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_GPMI_NAND is not set
+# CONFIG_MTD_NAND_HISI504 is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_JZ4740 is not set
+# CONFIG_MTD_NAND_MPC5121_NFC is not set
+# CONFIG_MTD_NAND_MXC is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_NDFC is not set
+# CONFIG_MTD_NAND_NUC900 is not set
+# CONFIG_MTD_NAND_OMAP2 is not set
+# CONFIG_MTD_NAND_OMAP_BCH_BUILD is not set
+# CONFIG_MTD_NAND_ORION is not set
+# CONFIG_MTD_NAND_PASEMI is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_NAND_PXA3xx is not set
+# CONFIG_MTD_NAND_RB4XX is not set
+# CONFIG_MTD_NAND_RB750 is not set
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_S3C2410 is not set
+# CONFIG_MTD_NAND_SHARPSL is not set
+# CONFIG_MTD_NAND_SH_FLCTL is not set
+# CONFIG_MTD_NAND_SOCRATES is not set
+# CONFIG_MTD_NAND_TMIO is not set
+# CONFIG_MTD_NAND_TXX9NDFMC is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_RAM is not set
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_ROM is not set
+CONFIG_MTD_ROOTFS_ROOT_DEV=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_SPINAND_MT29F is not set
+# CONFIG_MTD_SPI_NOR is not set
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_MTD_SPLIT=y
+# CONFIG_MTD_SPLIT_BRNIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_EVA_FW is not set
+# CONFIG_MTD_SPLIT_FIRMWARE is not set
+CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
+# CONFIG_MTD_SPLIT_FIT_FW is not set
+# CONFIG_MTD_SPLIT_JIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_LZMA_FW is not set
+# CONFIG_MTD_SPLIT_MINOR_FW is not set
+# CONFIG_MTD_SPLIT_SEAMA_FW is not set
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_SUPPORT=y
+# CONFIG_MTD_SPLIT_TPLINK_FW is not set
+# CONFIG_MTD_SPLIT_TRX_FW is not set
+# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_WRGG_FW is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UIMAGE_SPLIT is not set
+CONFIG_MULTIUSER=y
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_MV643XX_ETH is not set
+# CONFIG_MVMDIO is not set
+# CONFIG_MVSW61XX_PHY is not set
+# CONFIG_MVSWITCH_PHY is not set
+# CONFIG_MWAVE is not set
+# CONFIG_MWL8K is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NE2000 is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NEC_MARKEINS is not set
+CONFIG_NET=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETFILTER is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_INGRESS is not set
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETROM is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NET_9P is not set
+# CONFIG_NET_ACT_BPF is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_VLAN is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_IND=y
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_U32 is not set
+CONFIG_NET_CORE=y
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_NET_DSA_BCM_SF2 is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6171 is not set
+# CONFIG_NET_DSA_MV88E6352 is not set
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_TAG_DSA is not set
+# CONFIG_NET_DSA_TAG_EDSA is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_EMATCH_CANID is not set
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPGRE_BROADCAST=y
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_NET_KEY_MIGRATE is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_NET_PTP_CLASSIFY is not set
+CONFIG_NET_RX_BUSY_POLL=y
+# CONFIG_NET_SB1000 is not set
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_ATM is not set
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_DSMARK is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_NET_SCH_FQ is not set
+CONFIG_NET_SCH_FQ_CODEL=y
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCTPPROBE is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_NET_VENDOR_8390=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_NET_VENDOR_AGERE=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_NET_VENDOR_ARC=y
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_NET_VENDOR_AURORA=y
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_NET_VENDOR_BROCADE=y
+CONFIG_NET_VENDOR_CAVIUM=y
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_NET_VENDOR_EZCHIP=y
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_NET_VENDOR_FUJITSU=y
+CONFIG_NET_VENDOR_HISILICON=y
+CONFIG_NET_VENDOR_HP=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_IBM=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_NET_VENDOR_QUALCOMM=y
+CONFIG_NET_VENDOR_RDC=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_NET_VENDOR_SYNOPSYS=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_NET_VENDOR_TOSHIBA=y
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_NET_VENDOR_WIZNET=y
+CONFIG_NET_VENDOR_XILINX=y
+CONFIG_NET_VENDOR_XIRCOM=y
+# CONFIG_NET_VRF is not set
+# CONFIG_NET_XGENE is not set
+CONFIG_NEW_LEDS=y
+# CONFIG_NFC is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V2_ACL is not set
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFS_ACL_SUPPORT is not set
+CONFIG_NFS_COMMON=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V2 is not set
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFTL is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IPV4 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_ZONES is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_GRE is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_NAT is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_IPV6 is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_MASQUERADE_IPV4 is not set
+# CONFIG_NF_NAT_MASQUERADE_IPV6 is not set
+# CONFIG_NF_NAT_NEEDED is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_PROTO_GRE is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_TABLES is not set
+# CONFIG_NF_TABLES_NETDEV is not set
+# CONFIG_NI65 is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_NIU is not set
+CONFIG_NLATTR=y
+# CONFIG_NLMON is not set
+# CONFIG_NLM_XLP_BOARD is not set
+# CONFIG_NLM_XLR_BOARD is not set
+# CONFIG_NLS is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_NORTEL_HERMES is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_NO_BOOTMEM is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NS83820 is not set
+# CONFIG_NTB is not set
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_NTP_PPS is not set
+# CONFIG_NVM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_NVMEM_IMX_OCOTP is not set
+# CONFIG_NVRAM is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_NXP_STB220 is not set
+# CONFIG_NXP_STB225 is not set
+# CONFIG_N_GSM is not set
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_OBS600 is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_OF_UNITTEST is not set
+# CONFIG_OMAP2_DSS_DEBUG is not set
+# CONFIG_OMAP2_DSS_DEBUGFS is not set
+# CONFIG_OMAP2_DSS_SDI is not set
+# CONFIG_OMAP_OCP2SCP is not set
+# CONFIG_OMAP_USB2 is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_OPROFILE is not set
+# CONFIG_OPROFILE_EVENT_MULTIPLEX is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_ORION_WATCHDOG is not set
+# CONFIG_OSF_PARTITION is not set
+CONFIG_OVERLAY_FS=y
+# CONFIG_OWL_LOADER is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_PA12203001 is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_32KB is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_PANEL is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_PANTHERLORD_FF is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PARPORT_1284 is not set
+# CONFIG_PARPORT_AX88796 is not set
+# CONFIG_PARPORT_PC is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IMX is not set
+# CONFIG_PATA_ISAPNP is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OCTEON_CF is not set
+# CONFIG_PATA_OF_PLATFORM is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+# CONFIG_PC300TOO is not set
+# CONFIG_PCCARD is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_PCI200SYN is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_PCIE_ALTERA is not set
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIE_IPROC is not set
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_PCI_ATMEL is not set
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
+# CONFIG_PCI_HERMES is not set
+# CONFIG_PCI_HOST_GENERIC is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_LAYERSCAPE is not set
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCI_PRI is not set
+CONFIG_PCI_QUIRKS=y
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCMCIA is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_ATMEL is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_HERMES is not set
+# CONFIG_PCMCIA_LOAD_CIS is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_RAYCS is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_SPECTRUM is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+# CONFIG_PCMCIA_WL3501 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCNET32 is not set
+# CONFIG_PCSPKR_PLATFORM is not set
+# CONFIG_PD6729 is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_PHONET is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
+# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_QCOM_DWC3 is not set
+# CONFIG_PHY_SAMSUNG_USB2 is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_PID_NS is not set
+CONFIG_PINCONF=y
+# CONFIG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+# CONFIG_PINCTRL_MSM8X74 is not set
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINMUX=y
+# CONFIG_PKCS7_MESSAGE_PARSER is not set
+# CONFIG_PL320_MBOX is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_PLIP is not set
+# CONFIG_PLX_HERMES is not set
+# CONFIG_PM is not set
+# CONFIG_PMBUS is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_PM_WAKELOCKS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PPC4xx_GPIO is not set
+# CONFIG_PPC_16K_PAGES is not set
+# CONFIG_PPC_256K_PAGES is not set
+CONFIG_PPC_4K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+# CONFIG_PPC_EMULATED_STATS is not set
+# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
+# CONFIG_PPP is not set
+# CONFIG_PPPOATM is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_DEFLATE is not set
+CONFIG_PPP_FILTER=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPS is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_PARPORT is not set
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_PPTP is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_PRINTK=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_PRINT_STACK_DEPTH=64
+# CONFIG_PRISM2_USB is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_PROC_STRIPPED=y
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILING is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RCU is not set
+# CONFIG_PROVE_RCU_REPEATEDLY is not set
+# CONFIG_PSB6970_PHY is not set
+# CONFIG_PSTORE is not set
+# CONFIG_PTP_1588_CLOCK is not set
+# CONFIG_PTP_1588_CLOCK_IXP46X is not set
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+# CONFIG_PUBLIC_KEY_ALGO_RSA is not set
+# CONFIG_PWM is not set
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_PCA9685 is not set
+# CONFIG_QCA7000 is not set
+# CONFIG_QCOM_SPMI_IADC is not set
+# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
+# CONFIG_QCOM_SPMI_VADC is not set
+# CONFIG_QED is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_R3964 is not set
+# CONFIG_R6040 is not set
+# CONFIG_R8169 is not set
+# CONFIG_R8188EU is not set
+# CONFIG_R8712U is not set
+# CONFIG_R8723AU is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_RALINK is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_RAS is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_RBTREE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_RCU_EXPERT=y
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FAST_NO_HZ is not set
+CONFIG_RCU_KTHREAD_PRIO=0
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=3
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_RC_DECODERS is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_RC_MAP is not set
+# CONFIG_RDS is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_REDWOOD is not set
+# CONFIG_REGMAP is not set
+# CONFIG_REGMAP_I2C is not set
+# CONFIG_REGMAP_MMIO is not set
+# CONFIG_REGMAP_SPI is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_REGULATOR_TI_ABB is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
+# CONFIG_REISERFS_FS_SECURITY is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_RELAY is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_RFD_FTL is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_FULL is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_LEDS is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_ROCKER is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_ROSE is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_RTC_DEBUG is not set
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_ARMADA38X is not set
+# CONFIG_RTC_DRV_AU1XXX is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_EP93XX is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_GENERIC is not set
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+# CONFIG_RTC_DRV_MOXART is not set
+# CONFIG_RTC_DRV_MPC5121 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_OMAP is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_PS3 is not set
+# CONFIG_RTC_DRV_PT7C4338 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_RTC7301 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_SUN6I is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_XGENE is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_RTL8192E is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTL8306_PHY is not set
+# CONFIG_RTL8366RB_PHY is not set
+# CONFIG_RTL8366S_PHY is not set
+# CONFIG_RTL8366_SMI is not set
+# CONFIG_RTL8366_SMI_DEBUG_FS is not set
+# CONFIG_RTL8367B_PHY is not set
+# CONFIG_RTL8367_PHY is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_RTS5208 is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_RUNTIME_DEBUG is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_S2IO is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_DWC is not set
+# CONFIG_SATA_FSL is not set
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PMP is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_RCAR is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_SC92031 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_SCACHE_DEBUGFS is not set
+# CONFIG_SCC is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SCHED_MC is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_SCHED_SMT is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_LPFC is not set
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVSAS_DEBUG is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_PMCRAID is not set
+CONFIG_SCSI_PROC_FS=y
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_ULTRASTOR is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_GSC is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_HMC5843 is not set
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_I5500 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_PWM_FAN is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_SENSORS_VEXPRESS is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_ACCENT is not set
+# CONFIG_SERIAL_8250_BOCA is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_CS is not set
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_DMA=y
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_EM is not set
+# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_FOURPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+# CONFIG_SERIAL_8250_INGENIC is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_MID is not set
+CONFIG_SERIAL_8250_NR_UARTS=2
+# CONFIG_SERIAL_8250_PCI is not set
+# CONFIG_SERIAL_8250_RSA is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_SERIAL_OF_PLATFORM is not set
+# CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_STM32 is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_SUN4I_PS2 is not set
+# CONFIG_SFC is not set
+# CONFIG_SFI is not set
+# CONFIG_SGETMASK_SYSCALL is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP28 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_SG_SPLIT is not set
+CONFIG_SHMEM=y
+# CONFIG_SH_ETH is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_SWARM is not set
+CONFIG_SIGNALFD=y
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+# CONFIG_SIMPLE_GPIO is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SKY2_DEBUG is not set
+# CONFIG_SLAB is not set
+CONFIG_SLABINFO=y
+# CONFIG_SLHC is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_SLIP is not set
+# CONFIG_SLOB is not set
+CONFIG_SLUB=y
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMC9194 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_SMP is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_SND is not set
+# CONFIG_SND_AC97_POWER_SAVE is not set
+# CONFIG_SND_AD1816A is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_ALS100 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_ATMEL_AC97C is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT2320 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FIREWIRE is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_HDA_INTEL is not set
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_HWDEP is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_INTERWAVE is not set
+# CONFIG_SND_INTERWAVE_STB is not set
+# CONFIG_SND_ISA is not set
+# CONFIG_SND_KIRKWOOD_SOC is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_MIPS is not set
+# CONFIG_SND_MIRO is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_MXS_SOC is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_OXYGEN is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_PCM is not set
+# CONFIG_SND_PCMCIA is not set
+# CONFIG_SND_PCM_OSS is not set
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_PCM_TIMER is not set
+# CONFIG_SND_PCM_XRUN_DEBUG is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_PORTMAN2X4 is not set
+# CONFIG_SND_POWERPC_SOC is not set
+# CONFIG_SND_PPC is not set
+CONFIG_SND_PROC_FS=y
+# CONFIG_SND_RAWMIDI is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_RTCTIMER is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_SE6X is not set
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_AU1XAUDIO is not set
+# CONFIG_SND_SOC_AU1XPSC is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_ES8328 is not set
+# CONFIG_SND_SOC_EUKREA_TLV320 is not set
+# CONFIG_SND_SOC_FSL_ASOC_CARD is not set
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# CONFIG_SND_SOC_IMX_ES8328 is not set
+# CONFIG_SND_SOC_IMX_SPDIF is not set
+# CONFIG_SND_SOC_IMX_WM8962 is not set
+# CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH is not set
+# CONFIG_SND_SOC_INTEL_SKL_RT286_MACH is not set
+# CONFIG_SND_SOC_INTEL_SST is not set
+# CONFIG_SND_SOC_MEDIATEK is not set
+# CONFIG_SND_SOC_MPC5200_AC97 is not set
+# CONFIG_SND_SOC_MPC5200_I2S is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1792A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_QCOM is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5677_SPI is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_SUN4I_CODEC is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_TIMER is not set
+# CONFIG_SND_TRIDENT is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_WAVEFRONT is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_SOC_HAS_OMAP2_SDRC is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_SONYPI is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_SOUND is not set
+# CONFIG_SOUND_OSS_CORE is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+# CONFIG_SPARSE_IRQ is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_SPEAKUP is not set
+# CONFIG_SPI is not set
+# CONFIG_SPINLOCK_TEST is not set
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AU1550 is not set
+# CONFIG_SPI_BCM2835 is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_BUTTERFLY is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DEBUG is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_FSL_DSPI is not set
+# CONFIG_SPI_FSL_ESPI is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_GPIO_OLD is not set
+# CONFIG_SPI_IMG_SPFI is not set
+# CONFIG_SPI_LM70_LLP is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_SPI_MPC52xx is not set
+# CONFIG_SPI_MPC52xx_PSC is not set
+# CONFIG_SPI_OCTEON is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ORION is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PPC4xx is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TI_QSPI is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_XWAY is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_SPMI is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_DECOMP_MULTI is not set
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+# CONFIG_SQUASHFS_FILE_CACHE is not set
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_ZLIB is not set
+# CONFIG_SRAM is not set
+# CONFIG_SSB is not set
+# CONFIG_SSB_DEBUG is not set
+# CONFIG_SSB_DRIVER_GPIO is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_PCMCIAHOST is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB_SDIOHOST is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSFDC is not set
+# CONFIG_STACKTRACE is not set
+CONFIG_STACKTRACE_SUPPORT=y
+# CONFIG_STACK_TRACER is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_STAGING_MEDIA is not set
+CONFIG_STANDALONE=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_STDBINUTILS=y
+# CONFIG_STE10XP is not set
+# CONFIG_STE_MODEM_RPROC is not set
+# CONFIG_STK3310 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# CONFIG_STM is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_STMMAC_PCI is not set
+# CONFIG_STMMAC_PLATFORM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+CONFIG_STP=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_SUSPEND is not set
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_SWAP=y
+# CONFIG_SWCONFIG is not set
+# CONFIG_SWCONFIG_B53 is not set
+# CONFIG_SWCONFIG_B53_SPI_DRIVER is not set
+# CONFIG_SWCONFIG_LEDS is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SXGBE_ETH is not set
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_SYNOPSYS_DWC_ETH_QOS is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_SYSCTL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_SYSFS=y
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_SYSTEMPORT is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_T5403 is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_TASKS_RCU is not set
+# CONFIG_TASK_XACCT is not set
+# CONFIG_TC35815 is not set
+# CONFIG_TCG_ATMEL is not set
+# CONFIG_TCG_INFINEON is not set
+# CONFIG_TCG_ST33_I2C is not set
+# CONFIG_TCG_TIS is not set
+# CONFIG_TCG_TIS_I2C_ATMEL is not set
+# CONFIG_TCG_TIS_I2C_INFINEON is not set
+# CONFIG_TCG_TIS_I2C_NUVOTON is not set
+# CONFIG_TCG_TIS_ST33ZP24 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TCG_XEN is not set
+# CONFIG_TCIC is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_TEGRA_AHB is not set
+# CONFIG_TEGRA_HOST1X is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_USER_COPY is not set
+CONFIG_TEXTSEARCH=y
+# CONFIG_TEXTSEARCH_BM is not set
+# CONFIG_TEXTSEARCH_FSM is not set
+# CONFIG_TEXTSEARCH_KMP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_THERMAL_WRITABLE_TRIPS is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_THUNDERBOLT is not set
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_TICK_ONESHOT=y
+# CONFIG_TIFM_CORE is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_TIMB_DMA is not set
+CONFIG_TIMERFD=y
+# CONFIG_TIMER_STATS is not set
+CONFIG_TINY_RCU=y
+# CONFIG_TIPC is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_AM335X_ADC is not set
+# CONFIG_TI_CPSW is not set
+# CONFIG_TI_CPSW_ALE is not set
+# CONFIG_TI_CPTS is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_TI_DAVINCI_CPDMA is not set
+# CONFIG_TI_DAVINCI_MDIO is not set
+# CONFIG_TI_ST is not set
+# CONFIG_TLAN is not set
+# CONFIG_TMD_HERMES is not set
+# CONFIG_TMP006 is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_FT6236 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_S3C2410 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_SUR40 is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_TRACE_SINK is not set
+# CONFIG_TRACING_EVENTS_GPIO is not set
+CONFIG_TRACING_SUPPORT=y
+CONFIG_TRAD_SIGNALS=y
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_TREE_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_TRUSTED_KEYS is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2x7x is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_TTPCI_EEPROM is not set
+CONFIG_TTY=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL4030_MADC is not set
+# CONFIG_TWL6030_GPADC is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_UDF_FS is not set
+CONFIG_UDF_NLS=y
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_UFS_FS is not set
+# CONFIG_UHID is not set
+CONFIG_UID16=y
+# CONFIG_UIO is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_UNIX=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_UPROBES is not set
+# CONFIG_UPROBE_EVENT is not set
+# CONFIG_US5182D is not set
+# CONFIG_USB is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_ADUTUX is not set
+CONFIG_USB_ALI_M5632=y
+# CONFIG_USB_AMD5536UDC is not set
+CONFIG_USB_AN2720=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_ATM is not set
+# CONFIG_USB_BDC_UDC is not set
+CONFIG_USB_BELKIN=y
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_CHAOSKEY is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_CONFIGFS is not set
+# CONFIG_USB_CXACRU is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC2_DEBUG is not set
+# CONFIG_USB_DWC2_DUAL_ROLE is not set
+# CONFIG_USB_DWC2_HOST is not set
+# CONFIG_USB_DWC2_PERIPHERAL is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC3_EXYNOS is not set
+# CONFIG_USB_DWC3_KEYSTONE is not set
+# CONFIG_USB_DWC3_PCI is not set
+# CONFIG_USB_DWC3_QCOM is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_EHCI_ATH79 is not set
+# CONFIG_USB_EHCI_HCD_AT91 is not set
+# CONFIG_USB_EHCI_HCD_PPC_OF is not set
+# CONFIG_USB_EHCI_MSM is not set
+# CONFIG_USB_EHCI_MV is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_GADGET_VBUS_DRAW=2
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+# CONFIG_USB_HID is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_ISP1760 is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_KC2190 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_MSM_OTG is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MXS_PHY is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_CH9200 is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_SR9700 is not set
+# CONFIG_USB_NET_SR9800 is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_OHCI_HCD_PCI is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
+# CONFIG_USB_OHCI_HCD_SSB is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_SPEEDTOUCH is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_TMC is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_UEAGLEATM is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+# CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_XUSBATM is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USELIB is not set
+# CONFIG_USERFAULTFD is not set
+# CONFIG_USE_OF is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_UWB is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VDSO is not set
+# CONFIG_VETH is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_VF610_ADC is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+# CONFIG_VHOST_NET is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_CX2341X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_DM6446_CCDC is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_GO7007 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_IR_I2C is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_OMAP2_VOUT is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_SAA6588 is not set
+# CONFIG_VIDEO_SAA6752HS is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_THS8200 is not set
+# CONFIG_VIDEO_TIMBERDALE is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_USBTV is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_VIDEO_V4L2 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_VPX3220 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_INPUT is not set
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_VITESSE_PHY is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_VMSPLIT_1G is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_2G_OPT is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_VORTEX is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_VT is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_VXGE is not set
+# CONFIG_VXLAN is not set
+# CONFIG_VZ89X is not set
+# CONFIG_W1 is not set
+# CONFIG_W1_CON is not set
+# CONFIG_W1_MASTER_DS1WM is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_GPIO is not set
+# CONFIG_W1_MASTER_MATROX is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+# CONFIG_W1_SLAVE_DS2406 is not set
+# CONFIG_W1_SLAVE_DS2408 is not set
+# CONFIG_W1_SLAVE_DS2413 is not set
+# CONFIG_W1_SLAVE_DS2423 is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_DS2780 is not set
+# CONFIG_W1_SLAVE_DS2781 is not set
+# CONFIG_W1_SLAVE_DS28E04 is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_WAN is not set
+# CONFIG_WANXL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+# CONFIG_WD80x3 is not set
+# CONFIG_WDTPCI is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PRIV=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WILINK_PLATFORM_DATA=y
+# CONFIG_WIMAX is not set
+# CONFIG_WIMAX_GDM72XX is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX is not set
+# CONFIG_WL18XX is not set
+CONFIG_WLAN=y
+# CONFIG_WLCORE is not set
+# CONFIG_WL_MEDIATEK is not set
+CONFIG_WL_TI=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+# CONFIG_X25 is not set
+# CONFIG_X509_CERTIFICATE_PARSER is not set
+# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
+# CONFIG_X86_PKG_TEMP_THERMAL is not set
+CONFIG_X86_SYSFB=y
+# CONFIG_XEN is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_IPCOMP is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_EMACLITE is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_XILLYBUS is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_XMON is not set
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_TEST is not set
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_YAM is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_YENTA is not set
+# CONFIG_YENTA_O2 is not set
+# CONFIG_YENTA_RICOH is not set
+# CONFIG_YENTA_TI is not set
+# CONFIG_YENTA_TOSHIBA is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_ZD1211RW_DEBUG is not set
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_ZLIB_DEFLATE is not set
+# CONFIG_ZLIB_INFLATE is not set
+CONFIG_ZONE_DMA=y
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_ZPOOL is not set
+# CONFIG_ZRAM is not set
+# CONFIG_ZSMALLOC is not set
diff --git a/target/linux/generic/pending-4.4/001-mtdsplit_backport.patch b/target/linux/generic/pending-4.4/001-mtdsplit_backport.patch
new file mode 100644
index 0000000000..b5c485fe13
--- /dev/null
+++ b/target/linux/generic/pending-4.4/001-mtdsplit_backport.patch
@@ -0,0 +1,153 @@
+--- a/drivers/mtd/mtdsplit/mtdsplit_brnimage.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_brnimage.c
+@@ -27,7 +27,7 @@
+ #define BRNIMAGE_MAX_OVERHEAD	(BRNIMAGE_ALIGN_BYTES + BRNIMAGE_FOOTER_SIZE)
+ 
+ static int mtdsplit_parse_brnimage(struct mtd_info *master,
+-				const struct mtd_partition **pparts,
++				struct mtd_partition **pparts,
+ 				struct mtd_part_parser_data *data)
+ {
+ 	struct mtd_partition *parts;
+--- a/drivers/mtd/mtdsplit/mtdsplit_eva.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_eva.c
+@@ -29,7 +29,7 @@ struct eva_image_header {
+ };
+ 
+ static int mtdsplit_parse_eva(struct mtd_info *master,
+-				const struct mtd_partition **pparts,
++				struct mtd_partition **pparts,
+ 				struct mtd_part_parser_data *data)
+ {
+ 	struct mtd_partition *parts;
+--- a/drivers/mtd/mtdsplit/mtdsplit_fit.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_fit.c
+@@ -45,8 +45,7 @@ struct fdt_header {
+ };
+ 
+ static int
+-mtdsplit_fit_parse(struct mtd_info *mtd,
+-		   const struct mtd_partition **pparts,
++mtdsplit_fit_parse(struct mtd_info *mtd, struct mtd_partition **pparts,
+ 	           struct mtd_part_parser_data *data)
+ {
+ 	struct fdt_header hdr;
+--- a/drivers/mtd/mtdsplit/mtdsplit_lzma.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_lzma.c
+@@ -28,7 +28,7 @@ struct lzma_header {
+ };
+ 
+ static int mtdsplit_parse_lzma(struct mtd_info *master,
+-			       const struct mtd_partition **pparts,
++			       struct mtd_partition **pparts,
+ 			       struct mtd_part_parser_data *data)
+ {
+ 	struct lzma_header hdr;
+--- a/drivers/mtd/mtdsplit/mtdsplit_seama.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_seama.c
+@@ -30,7 +30,7 @@ struct seama_header {
+ };
+ 
+ static int mtdsplit_parse_seama(struct mtd_info *master,
+-				const struct mtd_partition **pparts,
++				struct mtd_partition **pparts,
+ 				struct mtd_part_parser_data *data)
+ {
+ 	struct seama_header hdr;
+--- a/drivers/mtd/mtdsplit/mtdsplit_squashfs.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_squashfs.c
+@@ -23,7 +23,7 @@
+ 
+ static int
+ mtdsplit_parse_squashfs(struct mtd_info *master,
+-			const struct mtd_partition **pparts,
++			struct mtd_partition **pparts,
+ 			struct mtd_part_parser_data *data)
+ {
+ 	struct mtd_partition *part;
+--- a/drivers/mtd/mtdsplit/mtdsplit_tplink.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_tplink.c
+@@ -83,8 +83,8 @@ struct tplink_fw_header {
+ };
+ 
+ static int mtdsplit_parse_tplink(struct mtd_info *master,
+-				 const struct mtd_partition **pparts,
+-				 struct mtd_part_parser_data *data)
++				struct mtd_partition **pparts,
++				struct mtd_part_parser_data *data)
+ {
+ 	struct tplink_fw_header hdr;
+ 	size_t hdr_len, retlen, kernel_size;
+--- a/drivers/mtd/mtdsplit/mtdsplit_trx.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_trx.c
+@@ -56,7 +56,7 @@ read_trx_header(struct mtd_info *mtd, si
+ 
+ static int
+ mtdsplit_parse_trx(struct mtd_info *master,
+-		   const struct mtd_partition **pparts,
++		   struct mtd_partition **pparts,
+ 		   struct mtd_part_parser_data *data)
+ {
+ 	struct mtd_partition *parts;
+--- a/drivers/mtd/mtdsplit/mtdsplit_uimage.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_uimage.c
+@@ -81,7 +81,7 @@ read_uimage_header(struct mtd_info *mtd,
+  *      of a valid uImage header if found
+  */
+ static int __mtdsplit_parse_uimage(struct mtd_info *master,
+-				   const struct mtd_partition **pparts,
++				   struct mtd_partition **pparts,
+ 				   struct mtd_part_parser_data *data,
+ 				   ssize_t (*find_header)(u_char *buf, size_t len))
+ {
+@@ -232,7 +232,7 @@ static ssize_t uimage_verify_default(u_c
+ 
+ static int
+ mtdsplit_uimage_parse_generic(struct mtd_info *master,
+-			      const struct mtd_partition **pparts,
++			      struct mtd_partition **pparts,
+ 			      struct mtd_part_parser_data *data)
+ {
+ 	return __mtdsplit_parse_uimage(master, pparts, data,
+@@ -289,7 +289,7 @@ static ssize_t uimage_verify_wndr3700(u_
+ 
+ static int
+ mtdsplit_uimage_parse_netgear(struct mtd_info *master,
+-			      const struct mtd_partition **pparts,
++			      struct mtd_partition **pparts,
+ 			      struct mtd_part_parser_data *data)
+ {
+ 	return __mtdsplit_parse_uimage(master, pparts, data,
+@@ -331,7 +331,7 @@ static ssize_t uimage_find_edimax(u_char
+ 
+ static int
+ mtdsplit_uimage_parse_edimax(struct mtd_info *master,
+-			      const struct mtd_partition **pparts,
++			      struct mtd_partition **pparts,
+ 			      struct mtd_part_parser_data *data)
+ {
+ 	return __mtdsplit_parse_uimage(master, pparts, data,
+--- a/drivers/mtd/mtdsplit/mtdsplit_wrgg.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_wrgg.c
+@@ -51,8 +51,8 @@ struct wrg_header {
+ 
+ 
+ static int mtdsplit_parse_wrgg(struct mtd_info *master,
+-			       const struct mtd_partition **pparts,
+-			       struct mtd_part_parser_data *data)
++				struct mtd_partition **pparts,
++				struct mtd_part_parser_data *data)
+ {
+ 	struct wrgg03_header hdr;
+ 	size_t hdr_len, retlen, kernel_ent_size;
+--- a/drivers/mtd/mtdsplit/mtdsplit_minor.c
++++ b/drivers/mtd/mtdsplit/mtdsplit_minor.c
+@@ -49,7 +49,7 @@ struct minor_header {
+ };
+ 
+ static int mtdsplit_parse_minor(struct mtd_info *master,
+-				const struct mtd_partition **pparts,
++				struct mtd_partition **pparts,
+ 				struct mtd_part_parser_data *data)
+ {
+ 	struct minor_header hdr;
diff --git a/target/linux/generic/pending-4.4/002-phy_drivers_backport.patch b/target/linux/generic/pending-4.4/002-phy_drivers_backport.patch
new file mode 100644
index 0000000000..6c9f30a97d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/002-phy_drivers_backport.patch
@@ -0,0 +1,640 @@
+--- a/drivers/net/phy/adm6996.c
++++ b/drivers/net/phy/adm6996.c
+@@ -289,7 +289,7 @@ static u16
+ adm6996_read_mii_reg(struct adm6996_priv *priv, enum admreg reg)
+ {
+ 	struct phy_device *phydev = priv->priv;
+-	struct mii_bus *bus = phydev->mdio.bus;
++	struct mii_bus *bus = phydev->bus;
+ 
+ 	return bus->read(bus, PHYADDR(reg));
+ }
+@@ -298,7 +298,7 @@ static void
+ adm6996_write_mii_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
+ {
+ 	struct phy_device *phydev = priv->priv;
+-	struct mii_bus *bus = phydev->mdio.bus;
++	struct mii_bus *bus = phydev->bus;
+ 
+ 	bus->write(bus, PHYADDR(reg), val);
+ }
+@@ -1050,13 +1050,13 @@ static int adm6996_config_init(struct ph
+ 	pdev->supported = ADVERTISED_100baseT_Full;
+ 	pdev->advertising = ADVERTISED_100baseT_Full;
+ 
+-	if (pdev->mdio.addr != 0) {
++	if (pdev->addr != 0) {
+ 		pr_info ("%s: PHY overlaps ADM6996, providing fixed PHY 0x%x.\n"
+-				, pdev->attached_dev->name, pdev->mdio.addr);
++				, pdev->attached_dev->name, pdev->addr);
+ 		return 0;
+ 	}
+ 
+-	priv = devm_kzalloc(&pdev->mdio.dev, sizeof(struct adm6996_priv), GFP_KERNEL);
++	priv = devm_kzalloc(&pdev->dev, sizeof(struct adm6996_priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+@@ -1076,7 +1076,7 @@ static int adm6996_config_init(struct ph
+ }
+ 
+ /*
+- * Warning: phydev->priv is NULL if phydev->mdio.addr != 0
++ * Warning: phydev->priv is NULL if phydev->addr != 0
+  */
+ static int adm6996_read_status(struct phy_device *phydev)
+ {
+@@ -1092,7 +1092,7 @@ static int adm6996_read_status(struct ph
+ }
+ 
+ /*
+- * Warning: phydev->priv is NULL if phydev->mdio.addr != 0
++ * Warning: phydev->priv is NULL if phydev->addr != 0
+  */
+ static int adm6996_config_aneg(struct phy_device *phydev)
+ {
+@@ -1101,11 +1101,11 @@ static int adm6996_config_aneg(struct ph
+ 
+ static int adm6996_fixup(struct phy_device *dev)
+ {
+-	struct mii_bus *bus = dev->mdio.bus;
++	struct mii_bus *bus = dev->bus;
+ 	u16 reg;
+ 
+ 	/* Our custom registers are at PHY addresses 0-10. Claim those. */
+-	if (dev->mdio.addr > 10)
++	if (dev->addr > 10)
+ 		return 0;
+ 
+ 	/* look for the switch on the bus */
+@@ -1152,6 +1152,7 @@ static struct phy_driver adm6996_phy_dri
+ 	.config_aneg	= &adm6996_config_aneg,
+ 	.read_status	= &adm6996_read_status,
+ 	.soft_reset	= adm6996_soft_reset,
++	.driver		= { .owner = THIS_MODULE,},
+ };
+ 
+ static int adm6996_gpio_probe(struct platform_device *pdev)
+@@ -1220,7 +1221,7 @@ static int __init adm6996_init(void)
+ 	int err;
+ 
+ 	phy_register_fixup_for_id(PHY_ANY_ID, adm6996_fixup);
+-	err = phy_driver_register(&adm6996_phy_driver, THIS_MODULE);
++	err = phy_driver_register(&adm6996_phy_driver);
+ 	if (err)
+ 		return err;
+ 
+--- a/drivers/net/phy/ar8216.c
++++ b/drivers/net/phy/ar8216.c
+@@ -177,7 +177,7 @@ ar8xxx_phy_check_aneg(struct phy_device
+ 	if (ret & BMCR_ANENABLE)
+ 		return 0;
+ 
+-	dev_info(&phydev->mdio.dev, "ANEG disabled, re-enabling ...\n");
++	dev_info(&phydev->dev, "ANEG disabled, re-enabling ...\n");
+ 	ret |= BMCR_ANENABLE | BMCR_ANRESTART;
+ 	return phy_write(phydev, MII_BMCR, ret);
+ }
+@@ -2007,7 +2007,7 @@ ar8xxx_phy_config_init(struct phy_device
+ 
+ 	priv->phy = phydev;
+ 
+-	if (phydev->mdio.addr != 0) {
++	if (phydev->addr != 0) {
+ 		if (chip_is_ar8316(priv)) {
+ 			/* switch device has been initialized, reinit */
+ 			priv->dev.ports = (AR8216_NUM_PORTS - 1);
+@@ -2055,7 +2055,7 @@ ar8xxx_check_link_states(struct ar8xxx_p
+ 		/* flush ARL entries for this port if it went down*/
+ 		if (!link_new)
+ 			priv->chip->atu_flush_port(priv, i);
+-		dev_info(&priv->phy->mdio.dev, "Port %d is %s\n",
++		dev_info(&priv->phy->dev, "Port %d is %s\n",
+ 			 i, link_new ? "up" : "down");
+ 	}
+ 
+@@ -2074,10 +2074,10 @@ ar8xxx_phy_read_status(struct phy_device
+ 	if (phydev->state == PHY_CHANGELINK)
+ 		ar8xxx_check_link_states(priv);
+ 
+-	if (phydev->mdio.addr != 0)
++	if (phydev->addr != 0)
+ 		return genphy_read_status(phydev);
+ 
+-	ar8216_read_port_link(priv, phydev->mdio.addr, &link);
++	ar8216_read_port_link(priv, phydev->addr, &link);
+ 	phydev->link = !!link.link;
+ 	if (!phydev->link)
+ 		return 0;
+@@ -2107,7 +2107,7 @@ ar8xxx_phy_read_status(struct phy_device
+ static int
+ ar8xxx_phy_config_aneg(struct phy_device *phydev)
+ {
+-	if (phydev->mdio.addr == 0)
++	if (phydev->addr == 0)
+ 		return 0;
+ 
+ 	return genphy_config_aneg(phydev);
+@@ -2162,15 +2162,15 @@ ar8xxx_phy_probe(struct phy_device *phyd
+ 	int ret;
+ 
+ 	/* skip PHYs at unused adresses */
+-	if (phydev->mdio.addr != 0 && phydev->mdio.addr != 4)
++	if (phydev->addr != 0 && phydev->addr != 4)
+ 		return -ENODEV;
+ 
+-	if (!ar8xxx_is_possible(phydev->mdio.bus))
++	if (!ar8xxx_is_possible(phydev->bus))
+ 		return -ENODEV;
+ 
+ 	mutex_lock(&ar8xxx_dev_list_lock);
+ 	list_for_each_entry(priv, &ar8xxx_dev_list, list)
+-		if (priv->mii_bus == phydev->mdio.bus)
++		if (priv->mii_bus == phydev->bus)
+ 			goto found;
+ 
+ 	priv = ar8xxx_create();
+@@ -2179,7 +2179,7 @@ ar8xxx_phy_probe(struct phy_device *phyd
+ 		goto unlock;
+ 	}
+ 
+-	priv->mii_bus = phydev->mdio.bus;
++	priv->mii_bus = phydev->bus;
+ 
+ 	ret = ar8xxx_probe_switch(priv);
+ 	if (ret)
+@@ -2200,7 +2200,7 @@ ar8xxx_phy_probe(struct phy_device *phyd
+ found:
+ 	priv->use_count++;
+ 
+-	if (phydev->mdio.addr == 0) {
++	if (phydev->addr == 0) {
+ 		if (ar8xxx_has_gige(priv)) {
+ 			phydev->supported = SUPPORTED_1000baseT_Full;
+ 			phydev->advertising = ADVERTISED_1000baseT_Full;
+@@ -2288,21 +2288,33 @@ ar8xxx_phy_soft_reset(struct phy_device
+ 	return 0;
+ }
+ 
+-static struct phy_driver ar8xxx_phy_driver[] = {
+-	{
+-		.phy_id		= 0x004d0000,
+-		.name		= "Atheros AR8216/AR8236/AR8316",
+-		.phy_id_mask	= 0xffff0000,
+-		.features	= PHY_BASIC_FEATURES,
+-		.probe		= ar8xxx_phy_probe,
+-		.remove		= ar8xxx_phy_remove,
+-		.detach		= ar8xxx_phy_detach,
+-		.config_init	= ar8xxx_phy_config_init,
+-		.config_aneg	= ar8xxx_phy_config_aneg,
+-		.read_status	= ar8xxx_phy_read_status,
+-		.soft_reset	= ar8xxx_phy_soft_reset,
+-	}
++static struct phy_driver ar8xxx_phy_driver = {
++	.phy_id		= 0x004d0000,
++	.name		= "Atheros AR8216/AR8236/AR8316",
++	.phy_id_mask	= 0xffff0000,
++	.features	= PHY_BASIC_FEATURES,
++	.probe		= ar8xxx_phy_probe,
++	.remove		= ar8xxx_phy_remove,
++	.detach		= ar8xxx_phy_detach,
++	.config_init	= ar8xxx_phy_config_init,
++	.config_aneg	= ar8xxx_phy_config_aneg,
++	.read_status	= ar8xxx_phy_read_status,
++	.soft_reset	= ar8xxx_phy_soft_reset,
++	.driver		= { .owner = THIS_MODULE },
+ };
+ 
+-module_phy_driver(ar8xxx_phy_driver);
++int __init
++ar8xxx_init(void)
++{
++	return phy_driver_register(&ar8xxx_phy_driver);
++}
++
++void __exit
++ar8xxx_exit(void)
++{
++	phy_driver_unregister(&ar8xxx_phy_driver);
++}
++
++module_init(ar8xxx_init);
++module_exit(ar8xxx_exit);
+ MODULE_LICENSE("GPL");
+--- a/drivers/net/phy/ar8327.c
++++ b/drivers/net/phy/ar8327.c
+@@ -627,11 +627,11 @@ ar8327_hw_init(struct ar8xxx_priv *priv)
+ 	if (!priv->chip_data)
+ 		return -ENOMEM;
+ 
+-	if (priv->phy->mdio.dev.of_node)
+-		ret = ar8327_hw_config_of(priv, priv->phy->mdio.dev.of_node);
++	if (priv->phy->dev.of_node)
++		ret = ar8327_hw_config_of(priv, priv->phy->dev.of_node);
+ 	else
+ 		ret = ar8327_hw_config_pdata(priv,
+-					     priv->phy->mdio.dev.platform_data);
++					     priv->phy->dev.platform_data);
+ 
+ 	if (ret)
+ 		return ret;
+--- a/drivers/net/phy/ip17xx.c
++++ b/drivers/net/phy/ip17xx.c
+@@ -1273,7 +1273,7 @@ static int ip17xx_probe(struct phy_devic
+ 	int err;
+ 
+ 	/* We only attach to PHY 0, but use all available PHYs */
+-	if (pdev->mdio.addr != 0)
++	if (pdev->addr != 0)
+ 		return -ENODEV;
+ 
+ 	state = kzalloc(sizeof(*state), GFP_KERNEL);
+@@ -1283,7 +1283,7 @@ static int ip17xx_probe(struct phy_devic
+ 	dev = &state->dev;
+ 
+ 	pdev->priv = state;
+-	state->mii_bus = pdev->mdio.bus;
++	state->mii_bus = pdev->bus;
+ 
+ 	err = get_model(state);
+ 	if (err < 0)
+@@ -1295,7 +1295,7 @@ static int ip17xx_probe(struct phy_devic
+ 	dev->name = state->regs->NAME;
+ 	dev->ops = &ip17xx_ops;
+ 
+-	pr_info("IP17xx: Found %s at %s\n", dev->name, dev_name(&pdev->mdio.dev));
++	pr_info("IP17xx: Found %s at %s\n", dev->name, dev_name(&pdev->dev));
+ 	return 0;
+ 
+ error:
+@@ -1353,25 +1353,58 @@ static int ip17xx_read_status(struct phy
+ 	return 0;
+ }
+ 
+-static struct phy_driver ip17xx_driver[] = {
+-	{
+-		.name		= "IC+ IP17xx",
+-		.phy_id		= 0x02430c00,
+-		.phy_id_mask	= 0x0ffffc00,
+-		.features	= PHY_BASIC_FEATURES,
+-		.probe		= ip17xx_probe,
+-		.remove		= ip17xx_remove,
+-		.config_init	= ip17xx_config_init,
+-		.config_aneg	= ip17xx_config_aneg,
+-		.aneg_done	= ip17xx_aneg_done,
+-		.update_link	= ip17xx_update_link,
+-		.read_status	= ip17xx_read_status,
+-	}
++static struct phy_driver ip17xx_driver = {
++	.name		= "IC+ IP17xx",
++	.phy_id		= 0x02430c00,
++	.phy_id_mask	= 0x0ffffc00,
++	.features	= PHY_BASIC_FEATURES,
++	.probe		= ip17xx_probe,
++	.remove		= ip17xx_remove,
++	.config_init	= ip17xx_config_init,
++	.config_aneg	= ip17xx_config_aneg,
++	.aneg_done	= ip17xx_aneg_done,
++	.update_link	= ip17xx_update_link,
++	.read_status	= ip17xx_read_status,
++	.driver		= { .owner = THIS_MODULE },
+ };
+ 
+-module_phy_driver(ip17xx_driver);
++static struct phy_driver ip175a_driver = {
++	.name		= "IC+ IP175A",
++	.phy_id		= 0x02430c50,
++	.phy_id_mask	= 0x0ffffff0,
++	.features	= PHY_BASIC_FEATURES,
++	.probe		= ip17xx_probe,
++	.remove		= ip17xx_remove,
++	.config_init	= ip17xx_config_init,
++	.config_aneg	= ip17xx_config_aneg,
++	.aneg_done	= ip17xx_aneg_done,
++	.update_link	= ip17xx_update_link,
++	.read_status	= ip17xx_read_status,
++	.driver		= { .owner = THIS_MODULE },
++};
++
++
++int __init ip17xx_init(void)
++{
++	int ret;
++
++	ret = phy_driver_register(&ip175a_driver);
++	if (ret < 0)
++		return ret;
++
++	return phy_driver_register(&ip17xx_driver);
++}
++
++void __exit ip17xx_exit(void)
++{
++	phy_driver_unregister(&ip17xx_driver);
++	phy_driver_unregister(&ip175a_driver);
++}
+ 
+ MODULE_AUTHOR("Patrick Horn <patrick.horn@gmail.com>");
+ MODULE_AUTHOR("Felix Fietkau <nbd@nbd.name>");
+ MODULE_AUTHOR("Martin Mares <mj@ucw.cz>");
+ MODULE_LICENSE("GPL");
++
++module_init(ip17xx_init);
++module_exit(ip17xx_exit);
+--- a/drivers/net/phy/mvswitch.c
++++ b/drivers/net/phy/mvswitch.c
+@@ -50,17 +50,13 @@ struct mvswitch_priv {
+ static inline u16
+ r16(struct phy_device *phydev, int addr, int reg)
+ {
+-	struct mii_bus *bus = phydev->mdio.bus;
+-
+-	return bus->read(bus, addr, reg);
++	return phydev->bus->read(phydev->bus, addr, reg);
+ }
+ 
+ static inline void
+ w16(struct phy_device *phydev, int addr, int reg, u16 val)
+ {
+-	struct mii_bus *bus = phydev->mdio.bus;
+-
+-	bus->write(bus, addr, reg, val);
++	phydev->bus->write(phydev->bus, addr, reg, val);
+ }
+ 
+ 
+@@ -398,13 +394,12 @@ mvswitch_probe(struct phy_device *pdev)
+ static int
+ mvswitch_fixup(struct phy_device *dev)
+ {
+-	struct mii_bus *bus = dev->mdio.bus;
+ 	u16 reg;
+ 
+-	if (dev->mdio.addr != 0x10)
++	if (dev->addr != 0x10)
+ 		return 0;
+ 
+-	reg = bus->read(bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
++	reg = dev->bus->read(dev->bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
+ 	if (reg != MV_IDENT_VALUE)
+ 		return 0;
+ 
+@@ -425,13 +420,14 @@ static struct phy_driver mvswitch_driver
+ 	.config_aneg	= &mvswitch_config_aneg,
+ 	.aneg_done	= &mvswitch_aneg_done,
+ 	.read_status	= &mvswitch_read_status,
++	.driver		= { .owner = THIS_MODULE,},
+ };
+ 
+ static int __init
+ mvswitch_init(void)
+ {
+ 	phy_register_fixup_for_id(PHY_ANY_ID, mvswitch_fixup);
+-	return phy_driver_register(&mvswitch_driver, THIS_MODULE);
++	return phy_driver_register(&mvswitch_driver);
+ }
+ 
+ static void __exit
+--- a/drivers/net/phy/psb6970.c
++++ b/drivers/net/phy/psb6970.c
+@@ -70,16 +70,12 @@ struct psb6970_priv {
+ 
+ static u16 psb6970_mii_read(struct phy_device *phydev, int reg)
+ {
+-	struct mii_bus *bus = phydev->mdio.bus;
+-
+-	return bus->read(bus, PHYADDR(reg));
++	return phydev->bus->read(phydev->bus, PHYADDR(reg));
+ }
+ 
+ static void psb6970_mii_write(struct phy_device *phydev, int reg, u16 val)
+ {
+-	struct mii_bus *bus = phydev->mdio.bus;
+-
+-	bus->write(bus, PHYADDR(reg), val);
++	phydev->bus->write(phydev->bus, PHYADDR(reg), val);
+ }
+ 
+ static int
+@@ -316,11 +312,11 @@ static int psb6970_config_init(struct ph
+ 
+ 	priv->phy = pdev;
+ 
+-	if (pdev->mdio.addr == 0)
++	if (pdev->addr == 0)
+ 		printk(KERN_INFO "%s: psb6970 switch driver attached.\n",
+ 		       pdev->attached_dev->name);
+ 
+-	if (pdev->mdio.addr != 0) {
++	if (pdev->addr != 0) {
+ 		kfree(priv);
+ 		return 0;
+ 	}
+@@ -388,14 +384,14 @@ static void psb6970_remove(struct phy_de
+ 	if (!priv)
+ 		return;
+ 
+-	if (pdev->mdio.addr == 0)
++	if (pdev->addr == 0)
+ 		unregister_switch(&priv->dev);
+ 	kfree(priv);
+ }
+ 
+ static int psb6970_fixup(struct phy_device *dev)
+ {
+-	struct mii_bus *bus = dev->mdio.bus;
++	struct mii_bus *bus = dev->bus;
+ 	u16 reg;
+ 
+ 	/* look for the switch on the bus */
+@@ -419,12 +415,13 @@ static struct phy_driver psb6970_driver
+ 	.config_init = &psb6970_config_init,
+ 	.config_aneg = &psb6970_config_aneg,
+ 	.read_status = &psb6970_read_status,
++	.driver = {.owner = THIS_MODULE},
+ };
+ 
+ int __init psb6970_init(void)
+ {
+ 	phy_register_fixup_for_id(PHY_ANY_ID, psb6970_fixup);
+-	return phy_driver_register(&psb6970_driver, THIS_MODULE);
++	return phy_driver_register(&psb6970_driver);
+ }
+ 
+ module_init(psb6970_init);
+--- a/drivers/net/phy/rtl8306.c
++++ b/drivers/net/phy/rtl8306.c
+@@ -877,7 +877,7 @@ rtl8306_config_init(struct phy_device *p
+ 	int err;
+ 
+ 	/* Only init the switch for the primary PHY */
+-	if (pdev->mdio.addr != 0)
++	if (pdev->addr != 0)
+ 		return 0;
+ 
+ 	val.value.i = 1;
+@@ -887,7 +887,7 @@ rtl8306_config_init(struct phy_device *p
+ 	priv->dev.ops = &rtl8306_ops;
+ 	priv->do_cpu = 0;
+ 	priv->page = -1;
+-	priv->bus = pdev->mdio.bus;
++	priv->bus = pdev->bus;
+ 
+ 	chipid = rtl_get(dev, RTL_REG_CHIPID);
+ 	chipver = rtl_get(dev, RTL_REG_CHIPVER);
+@@ -933,13 +933,13 @@ rtl8306_fixup(struct phy_device *pdev)
+ 	u16 chipid;
+ 
+ 	/* Attach to primary LAN port and WAN port */
+-	if (pdev->mdio.addr != 0 && pdev->mdio.addr != 4)
++	if (pdev->addr != 0 && pdev->addr != 4)
+ 		return 0;
+ 
+ 	memset(&priv, 0, sizeof(priv));
+ 	priv.fixup = true;
+ 	priv.page = -1;
+-	priv.bus = pdev->mdio.bus;
++	priv.bus = pdev->bus;
+ 	chipid = rtl_get(&priv.dev, RTL_REG_CHIPID);
+ 	if (chipid == 0x5988)
+ 		pdev->phy_id = RTL8306_MAGIC;
+@@ -957,14 +957,14 @@ rtl8306_probe(struct phy_device *pdev)
+ 		 * share one rtl_priv instance between virtual phy
+ 		 * devices on the same bus
+ 		 */
+-		if (priv->bus == pdev->mdio.bus)
++		if (priv->bus == pdev->bus)
+ 			goto found;
+ 	}
+ 	priv = kzalloc(sizeof(struct rtl_priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+-	priv->bus = pdev->mdio.bus;
++	priv->bus = pdev->bus;
+ 
+ found:
+ 	pdev->priv = priv;
+@@ -985,7 +985,7 @@ rtl8306_config_aneg(struct phy_device *p
+ 	struct rtl_priv *priv = pdev->priv;
+ 
+ 	/* Only for WAN */
+-	if (pdev->mdio.addr == 0)
++	if (pdev->addr == 0)
+ 		return 0;
+ 
+ 	/* Restart autonegotiation */
+@@ -1001,7 +1001,7 @@ rtl8306_read_status(struct phy_device *p
+ 	struct rtl_priv *priv = pdev->priv;
+ 	struct switch_dev *dev = &priv->dev;
+ 
+-	if (pdev->mdio.addr == 4) {
++	if (pdev->addr == 4) {
+ 		/* WAN */
+ 		pdev->speed = rtl_get(dev, RTL_PORT_REG(4, SPEED)) ? SPEED_100 : SPEED_10;
+ 		pdev->duplex = rtl_get(dev, RTL_PORT_REG(4, DUPLEX)) ? DUPLEX_FULL : DUPLEX_HALF;
+@@ -1044,6 +1044,7 @@ static struct phy_driver rtl8306_driver
+ 	.config_init	= &rtl8306_config_init,
+ 	.config_aneg	= &rtl8306_config_aneg,
+ 	.read_status	= &rtl8306_read_status,
++	.driver		= { .owner = THIS_MODULE,},
+ };
+ 
+ 
+@@ -1051,7 +1052,7 @@ static int __init
+ rtl_init(void)
+ {
+ 	phy_register_fixup_for_id(PHY_ANY_ID, rtl8306_fixup);
+-	return phy_driver_register(&rtl8306_driver, THIS_MODULE);
++	return phy_driver_register(&rtl8306_driver);
+ }
+ 
+ static void __exit
+--- a/drivers/net/phy/b53/b53_mdio.c
++++ b/drivers/net/phy/b53/b53_mdio.c
+@@ -277,11 +277,11 @@ static int b53_phy_probe(struct phy_devi
+ 	int ret;
+ 
+ 	/* allow the generic phy driver to take over */
+-	if (phydev->mdio.addr != B53_PSEUDO_PHY && phydev->mdio.addr != 0)
++	if (phydev->addr != B53_PSEUDO_PHY && phydev->addr != 0)
+ 		return -ENODEV;
+ 
+ 	dev.current_page = 0xff;
+-	dev.priv = phydev->mdio.bus;
++	dev.priv = phydev->bus;
+ 	dev.ops = &b53_mdio_ops;
+ 	dev.pdata = NULL;
+ 	mutex_init(&dev.reg_mutex);
+@@ -305,7 +305,7 @@ static int b53_phy_config_init(struct ph
+ 	struct b53_device *dev;
+ 	int ret;
+ 
+-	dev = b53_switch_alloc(&phydev->mdio.dev, &b53_mdio_ops, phydev->mdio.bus);
++	dev = b53_switch_alloc(&phydev->dev, &b53_mdio_ops, phydev->bus);
+ 	if (!dev)
+ 		return -ENOMEM;
+ 
+@@ -372,6 +372,9 @@ static struct phy_driver b53_phy_driver_
+ 	.config_aneg	= b53_phy_config_aneg,
+ 	.config_init	= b53_phy_config_init,
+ 	.read_status	= b53_phy_read_status,
++	.driver = {
++		.owner = THIS_MODULE,
++	},
+ };
+ 
+ /* BCM53125, BCM53128 */
+@@ -385,6 +388,9 @@ static struct phy_driver b53_phy_driver_
+ 	.config_aneg	= b53_phy_config_aneg,
+ 	.config_init	= b53_phy_config_init,
+ 	.read_status	= b53_phy_read_status,
++	.driver = {
++		.owner = THIS_MODULE,
++	},
+ };
+ 
+ /* BCM5365 */
+@@ -398,21 +404,24 @@ static struct phy_driver b53_phy_driver_
+ 	.config_aneg	= b53_phy_config_aneg,
+ 	.config_init	= b53_phy_config_init,
+ 	.read_status	= b53_phy_read_status,
++	.driver = {
++		.owner = THIS_MODULE,
++	},
+ };
+ 
+ int __init b53_phy_driver_register(void)
+ {
+ 	int ret;
+ 
+-	ret = phy_driver_register(&b53_phy_driver_id1, THIS_MODULE);
++	ret = phy_driver_register(&b53_phy_driver_id1);
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = phy_driver_register(&b53_phy_driver_id2, THIS_MODULE);
++	ret = phy_driver_register(&b53_phy_driver_id2);
+ 	if (ret)
+ 		goto err1;
+ 
+-	ret = phy_driver_register(&b53_phy_driver_id3, THIS_MODULE);
++	ret = phy_driver_register(&b53_phy_driver_id3);
+ 	if (!ret)
+ 		return 0;
+ 
+--- a/drivers/net/phy/b53/b53_phy_fixup.c
++++ b/drivers/net/phy/b53/b53_phy_fixup.c
+@@ -28,10 +28,10 @@
+ 
+ static int b53_phy_fixup(struct phy_device *dev)
+ {
+-	struct mii_bus *bus = dev->mdio.bus;
+ 	u32 phy_id;
++	struct mii_bus *bus = dev->bus;
+ 
+-	if (dev->mdio.addr != B53_PSEUDO_PHY)
++	if (dev->addr != B53_PSEUDO_PHY)
+ 		return 0;
+ 
+ 	/* read the first port's id */
diff --git a/target/linux/generic/pending-4.4/003-myloader_backport.patch b/target/linux/generic/pending-4.4/003-myloader_backport.patch
new file mode 100644
index 0000000000..846b25dc04
--- /dev/null
+++ b/target/linux/generic/pending-4.4/003-myloader_backport.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/myloader.c
++++ b/drivers/mtd/myloader.c
+@@ -33,7 +33,7 @@ struct part_data {
+ };
+ 
+ static int myloader_parse_partitions(struct mtd_info *master,
+-				     const struct mtd_partition **pparts,
++				     struct mtd_partition **pparts,
+ 				     struct mtd_part_parser_data *data)
+ {
+ 	struct part_data *buf;
diff --git a/target/linux/generic/pending-4.4/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch b/target/linux/generic/pending-4.4/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch
new file mode 100644
index 0000000000..f6c9d1edad
--- /dev/null
+++ b/target/linux/generic/pending-4.4/010-Kbuild-don-t-hardcode-path-to-awk-in-scripts-ld-vers.patch
@@ -0,0 +1,24 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 18 Jan 2016 12:27:49 +0100
+Subject: [PATCH] Kbuild: don't hardcode path to awk in scripts/ld-version.sh
+
+On some systems /usr/bin/awk does not exist, or is broken. Find it via
+$PATH instead.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/scripts/ld-version.sh
++++ b/scripts/ld-version.sh
+@@ -1,8 +1,10 @@
+-#!/usr/bin/awk -f
++#!/bin/sh
+ # extract linker version number from stdin and turn into single number
++exec awk '
+ 	{
+ 	gsub(".*\\)", "");
+ 	split($1,a, ".");
+ 	print a[1]*10000000 + a[2]*100000 + a[3]*10000 + a[4]*100 + a[5];
+ 	exit
+ 	}
++'
diff --git a/target/linux/generic/pending-4.4/020-bcma-from-4.5.patch b/target/linux/generic/pending-4.4/020-bcma-from-4.5.patch
new file mode 100644
index 0000000000..c5d7bc7e5e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/020-bcma-from-4.5.patch
@@ -0,0 +1,49 @@
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -672,11 +672,36 @@ static int bcma_device_uevent(struct dev
+ 			      core->id.rev, core->id.class);
+ }
+ 
+-static int __init bcma_modinit(void)
++static unsigned int bcma_bus_registered;
++
++/*
++ * If built-in, bus has to be registered early, before any driver calls
++ * bcma_driver_register.
++ * Otherwise registering driver would trigger BUG in driver_register.
++ */
++static int __init bcma_init_bus_register(void)
+ {
+ 	int err;
+ 
++	if (bcma_bus_registered)
++		return 0;
++
+ 	err = bus_register(&bcma_bus_type);
++	if (!err)
++		bcma_bus_registered = 1;
++
++	return err;
++}
++#ifndef MODULE
++fs_initcall(bcma_init_bus_register);
++#endif
++
++/* Main initialization has to be done with SPI/mtd/NAND/SPROM available */
++static int __init bcma_modinit(void)
++{
++	int err;
++
++	err = bcma_init_bus_register();
+ 	if (err)
+ 		return err;
+ 
+@@ -695,7 +720,7 @@ static int __init bcma_modinit(void)
+ 
+ 	return err;
+ }
+-fs_initcall(bcma_modinit);
++module_init(bcma_modinit);
+ 
+ static void __exit bcma_modexit(void)
+ {
diff --git a/target/linux/generic/pending-4.4/021-bcma-from-4.6.patch b/target/linux/generic/pending-4.4/021-bcma-from-4.6.patch
new file mode 100644
index 0000000000..dede2f1f23
--- /dev/null
+++ b/target/linux/generic/pending-4.4/021-bcma-from-4.6.patch
@@ -0,0 +1,761 @@
+--- a/drivers/bcma/driver_chipcommon.c
++++ b/drivers/bcma/driver_chipcommon.c
+@@ -15,6 +15,8 @@
+ #include <linux/platform_device.h>
+ #include <linux/bcma/bcma.h>
+ 
++static void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
++
+ static inline u32 bcma_cc_write32_masked(struct bcma_drv_cc *cc, u16 offset,
+ 					 u32 mask, u32 value)
+ {
+@@ -113,8 +115,37 @@ int bcma_chipco_watchdog_register(struct
+ 	return 0;
+ }
+ 
++static void bcma_core_chipcommon_flash_detect(struct bcma_drv_cc *cc)
++{
++	struct bcma_bus *bus = cc->core->bus;
++
++	switch (cc->capabilities & BCMA_CC_CAP_FLASHT) {
++	case BCMA_CC_FLASHT_STSER:
++	case BCMA_CC_FLASHT_ATSER:
++		bcma_debug(bus, "Found serial flash\n");
++		bcma_sflash_init(cc);
++		break;
++	case BCMA_CC_FLASHT_PARA:
++		bcma_debug(bus, "Found parallel flash\n");
++		bcma_pflash_init(cc);
++		break;
++	default:
++		bcma_err(bus, "Flash type not supported\n");
++	}
++
++	if (cc->core->id.rev == 38 ||
++	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
++		if (cc->capabilities & BCMA_CC_CAP_NFLASH) {
++			bcma_debug(bus, "Found NAND flash\n");
++			bcma_nflash_init(cc);
++		}
++	}
++}
++
+ void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc)
+ {
++	struct bcma_bus *bus = cc->core->bus;
++
+ 	if (cc->early_setup_done)
+ 		return;
+ 
+@@ -129,6 +160,12 @@ void bcma_core_chipcommon_early_init(str
+ 	if (cc->capabilities & BCMA_CC_CAP_PMU)
+ 		bcma_pmu_early_init(cc);
+ 
++	if (IS_BUILTIN(CONFIG_BCM47XX) && bus->hosttype == BCMA_HOSTTYPE_SOC)
++		bcma_chipco_serial_init(cc);
++
++	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
++		bcma_core_chipcommon_flash_detect(cc);
++
+ 	cc->early_setup_done = true;
+ }
+ 
+@@ -185,11 +222,12 @@ u32 bcma_chipco_watchdog_timer_set(struc
+ 			ticks = 2;
+ 		else if (ticks > maxt)
+ 			ticks = maxt;
+-		bcma_cc_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);
++		bcma_pmu_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);
+ 	} else {
+ 		struct bcma_bus *bus = cc->core->bus;
+ 
+ 		if (bus->chipinfo.id != BCMA_CHIP_ID_BCM4707 &&
++		    bus->chipinfo.id != BCMA_CHIP_ID_BCM47094 &&
+ 		    bus->chipinfo.id != BCMA_CHIP_ID_BCM53018)
+ 			bcma_core_set_clockmode(cc->core,
+ 						ticks ? BCMA_CLKMODE_FAST : BCMA_CLKMODE_DYNAMIC);
+@@ -314,9 +352,9 @@ u32 bcma_chipco_gpio_pulldown(struct bcm
+ 	return res;
+ }
+ 
+-#ifdef CONFIG_BCMA_DRIVER_MIPS
+-void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
++static void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
+ {
++#if IS_BUILTIN(CONFIG_BCM47XX)
+ 	unsigned int irq;
+ 	u32 baud_base;
+ 	u32 i;
+@@ -358,5 +396,5 @@ void bcma_chipco_serial_init(struct bcma
+ 		ports[i].baud_base = baud_base;
+ 		ports[i].reg_shift = 0;
+ 	}
++#endif /* CONFIG_BCM47XX */
+ }
+-#endif /* CONFIG_BCMA_DRIVER_MIPS */
+--- a/drivers/bcma/driver_chipcommon_pmu.c
++++ b/drivers/bcma/driver_chipcommon_pmu.c
+@@ -15,44 +15,44 @@
+ 
+ u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
+-	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
+-	return bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
++	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
++	return bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_pll_read);
+ 
+ void bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset, u32 value)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
+-	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
++	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_pll_write);
+ 
+ void bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,
+ 			     u32 set)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
+-	bcma_cc_read32(cc, BCMA_CC_PLLCTL_ADDR);
+-	bcma_cc_maskset32(cc, BCMA_CC_PLLCTL_DATA, mask, set);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
++	bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);
++	bcma_pmu_maskset32(cc, BCMA_CC_PMU_PLLCTL_DATA, mask, set);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_pll_maskset);
+ 
+ void bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,
+ 				 u32 offset, u32 mask, u32 set)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_CHIPCTL_ADDR, offset);
+-	bcma_cc_read32(cc, BCMA_CC_CHIPCTL_ADDR);
+-	bcma_cc_maskset32(cc, BCMA_CC_CHIPCTL_DATA, mask, set);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_CHIPCTL_ADDR, offset);
++	bcma_pmu_read32(cc, BCMA_CC_PMU_CHIPCTL_ADDR);
++	bcma_pmu_maskset32(cc, BCMA_CC_PMU_CHIPCTL_DATA, mask, set);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_chipctl_maskset);
+ 
+ void bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,
+ 				u32 set)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_REGCTL_ADDR, offset);
+-	bcma_cc_read32(cc, BCMA_CC_REGCTL_ADDR);
+-	bcma_cc_maskset32(cc, BCMA_CC_REGCTL_DATA, mask, set);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_REGCTL_ADDR, offset);
++	bcma_pmu_read32(cc, BCMA_CC_PMU_REGCTL_ADDR);
++	bcma_pmu_maskset32(cc, BCMA_CC_PMU_REGCTL_DATA, mask, set);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_regctl_maskset);
+ 
+@@ -60,18 +60,18 @@ static u32 bcma_pmu_xtalfreq(struct bcma
+ {
+ 	u32 ilp_ctl, alp_hz;
+ 
+-	if (!(bcma_cc_read32(cc, BCMA_CC_PMU_STAT) &
++	if (!(bcma_pmu_read32(cc, BCMA_CC_PMU_STAT) &
+ 	      BCMA_CC_PMU_STAT_EXT_LPO_AVAIL))
+ 		return 0;
+ 
+-	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ,
+-			BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));
++	bcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ,
++			 BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));
+ 	usleep_range(1000, 2000);
+ 
+-	ilp_ctl = bcma_cc_read32(cc, BCMA_CC_PMU_XTAL_FREQ);
++	ilp_ctl = bcma_pmu_read32(cc, BCMA_CC_PMU_XTAL_FREQ);
+ 	ilp_ctl &= BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK;
+ 
+-	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);
+ 
+ 	alp_hz = ilp_ctl * 32768 / 4;
+ 	return (alp_hz + 50000) / 100000 * 100;
+@@ -127,8 +127,8 @@ static void bcma_pmu2_pll_init0(struct b
+ 		mask = (u32)~(BCMA_RES_4314_HT_AVAIL |
+ 			      BCMA_RES_4314_MACPHY_CLK_AVAIL);
+ 
+-		bcma_cc_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);
+-		bcma_cc_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);
++		bcma_pmu_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);
++		bcma_pmu_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);
+ 		bcma_wait_value(cc->core, BCMA_CLKCTLST,
+ 				BCMA_CLKCTLST_HAVEHT, 0, 20000);
+ 		break;
+@@ -140,7 +140,7 @@ static void bcma_pmu2_pll_init0(struct b
+ 
+ 	/* Flush */
+ 	if (cc->pmu.rev >= 2)
+-		bcma_cc_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
++		bcma_pmu_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
+ 
+ 	/* TODO: Do we need to update OTP? */
+ }
+@@ -195,9 +195,9 @@ static void bcma_pmu_resources_init(stru
+ 
+ 	/* Set the resource masks. */
+ 	if (min_msk)
+-		bcma_cc_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);
++		bcma_pmu_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);
+ 	if (max_msk)
+-		bcma_cc_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);
++		bcma_pmu_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);
+ 
+ 	/*
+ 	 * Add some delay; allow resources to come up and settle.
+@@ -269,23 +269,33 @@ static void bcma_pmu_workarounds(struct
+ 
+ void bcma_pmu_early_init(struct bcma_drv_cc *cc)
+ {
++	struct bcma_bus *bus = cc->core->bus;
+ 	u32 pmucap;
+ 
+-	pmucap = bcma_cc_read32(cc, BCMA_CC_PMU_CAP);
++	if (cc->core->id.rev >= 35 &&
++	    cc->capabilities_ext & BCMA_CC_CAP_EXT_AOB_PRESENT) {
++		cc->pmu.core = bcma_find_core(bus, BCMA_CORE_PMU);
++		if (!cc->pmu.core)
++			bcma_warn(bus, "Couldn't find expected PMU core");
++	}
++	if (!cc->pmu.core)
++		cc->pmu.core = cc->core;
++
++	pmucap = bcma_pmu_read32(cc, BCMA_CC_PMU_CAP);
+ 	cc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);
+ 
+-	bcma_debug(cc->core->bus, "Found rev %u PMU (capabilities 0x%08X)\n",
+-		   cc->pmu.rev, pmucap);
++	bcma_debug(bus, "Found rev %u PMU (capabilities 0x%08X)\n", cc->pmu.rev,
++		   pmucap);
+ }
+ 
+ void bcma_pmu_init(struct bcma_drv_cc *cc)
+ {
+ 	if (cc->pmu.rev == 1)
+-		bcma_cc_mask32(cc, BCMA_CC_PMU_CTL,
+-			      ~BCMA_CC_PMU_CTL_NOILPONW);
++		bcma_pmu_mask32(cc, BCMA_CC_PMU_CTL,
++				~BCMA_CC_PMU_CTL_NOILPONW);
+ 	else
+-		bcma_cc_set32(cc, BCMA_CC_PMU_CTL,
+-			     BCMA_CC_PMU_CTL_NOILPONW);
++		bcma_pmu_set32(cc, BCMA_CC_PMU_CTL,
++			       BCMA_CC_PMU_CTL_NOILPONW);
+ 
+ 	bcma_pmu_pll_init(cc);
+ 	bcma_pmu_resources_init(cc);
+@@ -472,8 +482,8 @@ u32 bcma_pmu_get_cpu_clock(struct bcma_d
+ static void bcma_pmu_spuravoid_pll_write(struct bcma_drv_cc *cc, u32 offset,
+ 					 u32 value)
+ {
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
+-	bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);
+ }
+ 
+ void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid)
+@@ -497,20 +507,20 @@ void bcma_pmu_spuravoid_pllupdate(struct
+ 		       bus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;
+ 
+ 		/* RMW only the P1 divider */
+-		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
++		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,
+ 				BCMA_CC_PMU_PLL_CTL0 + phypll_offset);
+-		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
++		tmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
+ 		tmp &= (~(BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK));
+ 		tmp |= (bcm5357_bcm43236_p1div[spuravoid] << BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT);
+-		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
++		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);
+ 
+ 		/* RMW only the int feedback divider */
+-		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
++		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,
+ 				BCMA_CC_PMU_PLL_CTL2 + phypll_offset);
+-		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
++		tmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);
+ 		tmp &= ~(BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK);
+ 		tmp |= (bcm5357_bcm43236_ndiv[spuravoid]) << BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT;
+-		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
++		bcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);
+ 
+ 		tmp = BCMA_CC_PMU_CTL_PLL_UPD;
+ 		break;
+@@ -646,7 +656,7 @@ void bcma_pmu_spuravoid_pllupdate(struct
+ 		break;
+ 	}
+ 
+-	tmp |= bcma_cc_read32(cc, BCMA_CC_PMU_CTL);
+-	bcma_cc_write32(cc, BCMA_CC_PMU_CTL, tmp);
++	tmp |= bcma_pmu_read32(cc, BCMA_CC_PMU_CTL);
++	bcma_pmu_write32(cc, BCMA_CC_PMU_CTL, tmp);
+ }
+ EXPORT_SYMBOL_GPL(bcma_pmu_spuravoid_pllupdate);
+--- a/drivers/bcma/driver_chipcommon_sflash.c
++++ b/drivers/bcma/driver_chipcommon_sflash.c
+@@ -38,6 +38,7 @@ static const struct bcma_sflash_tbl_e bc
+ 	{ "M25P32", 0x15, 0x10000, 64, },
+ 	{ "M25P64", 0x16, 0x10000, 128, },
+ 	{ "M25FL128", 0x17, 0x10000, 256, },
++	{ "MX25L25635F", 0x18, 0x10000, 512, },
+ 	{ NULL },
+ };
+ 
+--- a/drivers/bcma/scan.c
++++ b/drivers/bcma/scan.c
+@@ -98,6 +98,9 @@ static const struct bcma_device_id_name
+ 	{ BCMA_CORE_SHIM, "SHIM" },
+ 	{ BCMA_CORE_PCIE2, "PCIe Gen2" },
+ 	{ BCMA_CORE_ARM_CR4, "ARM CR4" },
++	{ BCMA_CORE_GCI, "GCI" },
++	{ BCMA_CORE_CMEM, "CNDS DDR2/3 memory controller" },
++	{ BCMA_CORE_ARM_CA7, "ARM CA7" },
+ 	{ BCMA_CORE_DEFAULT, "Default" },
+ };
+ 
+@@ -315,6 +318,8 @@ static int bcma_get_next_core(struct bcm
+ 		switch (core->id.id) {
+ 		case BCMA_CORE_4706_MAC_GBIT_COMMON:
+ 		case BCMA_CORE_NS_CHIPCOMMON_B:
++		case BCMA_CORE_PMU:
++		case BCMA_CORE_GCI:
+ 		/* Not used yet: case BCMA_CORE_OOB_ROUTER: */
+ 			break;
+ 		default:
+--- a/drivers/net/wireless/b43/main.c
++++ b/drivers/net/wireless/b43/main.c
+@@ -1215,10 +1215,10 @@ void b43_wireless_core_phy_pll_reset(str
+ 	case B43_BUS_BCMA:
+ 		bcma_cc = &dev->dev->bdev->bus->drv_cc;
+ 
+-		bcma_cc_write32(bcma_cc, BCMA_CC_CHIPCTL_ADDR, 0);
+-		bcma_cc_mask32(bcma_cc, BCMA_CC_CHIPCTL_DATA, ~0x4);
+-		bcma_cc_set32(bcma_cc, BCMA_CC_CHIPCTL_DATA, 0x4);
+-		bcma_cc_mask32(bcma_cc, BCMA_CC_CHIPCTL_DATA, ~0x4);
++		bcma_cc_write32(bcma_cc, BCMA_CC_PMU_CHIPCTL_ADDR, 0);
++		bcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);
++		bcma_cc_set32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, 0x4);
++		bcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);
+ 		break;
+ #endif
+ #ifdef CONFIG_B43_SSB
+--- a/include/linux/bcma/bcma.h
++++ b/include/linux/bcma/bcma.h
+@@ -151,6 +151,8 @@ struct bcma_host_ops {
+ #define BCMA_CORE_PCIE2			0x83C	/* PCI Express Gen2 */
+ #define BCMA_CORE_USB30_DEV		0x83D
+ #define BCMA_CORE_ARM_CR4		0x83E
++#define BCMA_CORE_GCI			0x840
++#define BCMA_CORE_CMEM			0x846	/* CNDS DDR2/3 memory controller */
+ #define BCMA_CORE_ARM_CA7		0x847
+ #define BCMA_CORE_SYS_MEM		0x849
+ #define BCMA_CORE_DEFAULT		0xFFF
+@@ -200,6 +202,7 @@ struct bcma_host_ops {
+ #define  BCMA_PKG_ID_BCM4707	1
+ #define  BCMA_PKG_ID_BCM4708	2
+ #define  BCMA_PKG_ID_BCM4709	0
++#define BCMA_CHIP_ID_BCM47094	53030
+ #define BCMA_CHIP_ID_BCM53018	53018
+ 
+ /* Board types (on PCI usually equals to the subsystem dev id) */
+--- a/include/linux/bcma/bcma_driver_chipcommon.h
++++ b/include/linux/bcma/bcma_driver_chipcommon.h
+@@ -217,6 +217,11 @@
+ #define	 BCMA_CC_CLKDIV_JTAG_SHIFT	8
+ #define	 BCMA_CC_CLKDIV_UART		0x000000FF
+ #define BCMA_CC_CAP_EXT			0x00AC		/* Capabilities */
++#define  BCMA_CC_CAP_EXT_SECI_PRESENT	0x00000001
++#define  BCMA_CC_CAP_EXT_GSIO_PRESENT	0x00000002
++#define  BCMA_CC_CAP_EXT_GCI_PRESENT	0x00000004
++#define  BCMA_CC_CAP_EXT_SECI_PUART_PRESENT		0x00000008    /* UART present */
++#define  BCMA_CC_CAP_EXT_AOB_PRESENT	0x00000040
+ #define BCMA_CC_PLLONDELAY		0x00B0		/* Rev >= 4 only */
+ #define BCMA_CC_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
+ #define BCMA_CC_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
+@@ -351,12 +356,12 @@
+ #define BCMA_CC_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
+ #define BCMA_CC_PMU_RES_REQT		0x0644 /* PMU res req timer */
+ #define BCMA_CC_PMU_RES_REQM		0x0648 /* PMU res req mask */
+-#define BCMA_CC_CHIPCTL_ADDR		0x0650
+-#define BCMA_CC_CHIPCTL_DATA		0x0654
+-#define BCMA_CC_REGCTL_ADDR		0x0658
+-#define BCMA_CC_REGCTL_DATA		0x065C
+-#define BCMA_CC_PLLCTL_ADDR		0x0660
+-#define BCMA_CC_PLLCTL_DATA		0x0664
++#define BCMA_CC_PMU_CHIPCTL_ADDR	0x0650
++#define BCMA_CC_PMU_CHIPCTL_DATA	0x0654
++#define BCMA_CC_PMU_REGCTL_ADDR		0x0658
++#define BCMA_CC_PMU_REGCTL_DATA		0x065C
++#define BCMA_CC_PMU_PLLCTL_ADDR		0x0660
++#define BCMA_CC_PMU_PLLCTL_DATA		0x0664
+ #define BCMA_CC_PMU_STRAPOPT		0x0668 /* (corerev >= 28) */
+ #define BCMA_CC_PMU_XTAL_FREQ		0x066C /* (pmurev >= 10) */
+ #define  BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK	0x00001FFF
+@@ -566,17 +571,16 @@
+  * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
+  */
+ struct bcma_chipcommon_pmu {
++	struct bcma_device *core;	/* Can be separated core or just ChipCommon one */
+ 	u8 rev;			/* PMU revision */
+ 	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
+ };
+ 
+-#ifdef CONFIG_BCMA_DRIVER_MIPS
++#ifdef CONFIG_BCMA_PFLASH
+ struct bcma_pflash {
+ 	bool present;
+-	u8 buswidth;
+-	u32 window;
+-	u32 window_size;
+ };
++#endif
+ 
+ #ifdef CONFIG_BCMA_SFLASH
+ struct bcma_sflash {
+@@ -602,6 +606,7 @@ struct bcma_nflash {
+ };
+ #endif
+ 
++#ifdef CONFIG_BCMA_DRIVER_MIPS
+ struct bcma_serial_port {
+ 	void *regs;
+ 	unsigned long clockspeed;
+@@ -621,8 +626,9 @@ struct bcma_drv_cc {
+ 	/* Fast Powerup Delay constant */
+ 	u16 fast_pwrup_delay;
+ 	struct bcma_chipcommon_pmu pmu;
+-#ifdef CONFIG_BCMA_DRIVER_MIPS
++#ifdef CONFIG_BCMA_PFLASH
+ 	struct bcma_pflash pflash;
++#endif
+ #ifdef CONFIG_BCMA_SFLASH
+ 	struct bcma_sflash sflash;
+ #endif
+@@ -630,6 +636,7 @@ struct bcma_drv_cc {
+ 	struct bcma_nflash nflash;
+ #endif
+ 
++#ifdef CONFIG_BCMA_DRIVER_MIPS
+ 	int nr_serial_ports;
+ 	struct bcma_serial_port serial_ports[4];
+ #endif /* CONFIG_BCMA_DRIVER_MIPS */
+@@ -662,6 +669,19 @@ struct bcma_drv_cc_b {
+ #define bcma_cc_maskset32(cc, offset, mask, set) \
+ 	bcma_cc_write32(cc, offset, (bcma_cc_read32(cc, offset) & (mask)) | (set))
+ 
++/* PMU registers access */
++#define bcma_pmu_read32(cc, offset) \
++	bcma_read32((cc)->pmu.core, offset)
++#define bcma_pmu_write32(cc, offset, val) \
++	bcma_write32((cc)->pmu.core, offset, val)
++
++#define bcma_pmu_mask32(cc, offset, mask) \
++	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) & (mask))
++#define bcma_pmu_set32(cc, offset, set) \
++	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) | (set))
++#define bcma_pmu_maskset32(cc, offset, mask, set) \
++	bcma_pmu_write32(cc, offset, (bcma_pmu_read32(cc, offset) & (mask)) | (set))
++
+ extern u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks);
+ 
+ extern u32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc);
+--- a/drivers/bcma/bcma_private.h
++++ b/drivers/bcma/bcma_private.h
+@@ -45,10 +45,6 @@ int bcma_sprom_get(struct bcma_bus *bus)
+ void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);
+ void bcma_core_chipcommon_init(struct bcma_drv_cc *cc);
+ void bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);
+-#ifdef CONFIG_BCMA_DRIVER_MIPS
+-void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
+-extern struct platform_device bcma_pflash_dev;
+-#endif /* CONFIG_BCMA_DRIVER_MIPS */
+ 
+ /* driver_chipcommon_b.c */
+ int bcma_core_chipcommon_b_init(struct bcma_drv_cc_b *ccb);
+@@ -60,6 +56,21 @@ void bcma_pmu_init(struct bcma_drv_cc *c
+ u32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc);
+ u32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc);
+ 
++/**************************************************
++ * driver_chipcommon_sflash.c
++ **************************************************/
++
++#ifdef CONFIG_BCMA_PFLASH
++extern struct platform_device bcma_pflash_dev;
++int bcma_pflash_init(struct bcma_drv_cc *cc);
++#else
++static inline int bcma_pflash_init(struct bcma_drv_cc *cc)
++{
++	bcma_err(cc->core->bus, "Parallel flash not supported\n");
++	return 0;
++}
++#endif /* CONFIG_BCMA_PFLASH */
++
+ #ifdef CONFIG_BCMA_SFLASH
+ /* driver_chipcommon_sflash.c */
+ int bcma_sflash_init(struct bcma_drv_cc *cc);
+--- a/drivers/bcma/driver_gpio.c
++++ b/drivers/bcma/driver_gpio.c
+@@ -197,6 +197,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
+ 	case BCMA_CHIP_ID_BCM4707:
+ 	case BCMA_CHIP_ID_BCM5357:
+ 	case BCMA_CHIP_ID_BCM53572:
++	case BCMA_CHIP_ID_BCM47094:
+ 		chip->ngpio	= 32;
+ 		break;
+ 	default:
+--- a/drivers/bcma/driver_mips.c
++++ b/drivers/bcma/driver_mips.c
+@@ -14,8 +14,6 @@
+ 
+ #include <linux/bcma/bcma.h>
+ 
+-#include <linux/mtd/physmap.h>
+-#include <linux/platform_device.h>
+ #include <linux/serial.h>
+ #include <linux/serial_core.h>
+ #include <linux/serial_reg.h>
+@@ -32,26 +30,6 @@ enum bcma_boot_dev {
+ 	BCMA_BOOT_DEV_NAND,
+ };
+ 
+-static const char * const part_probes[] = { "bcm47xxpart", NULL };
+-
+-static struct physmap_flash_data bcma_pflash_data = {
+-	.part_probe_types	= part_probes,
+-};
+-
+-static struct resource bcma_pflash_resource = {
+-	.name	= "bcma_pflash",
+-	.flags  = IORESOURCE_MEM,
+-};
+-
+-struct platform_device bcma_pflash_dev = {
+-	.name		= "physmap-flash",
+-	.dev		= {
+-		.platform_data  = &bcma_pflash_data,
+-	},
+-	.resource	= &bcma_pflash_resource,
+-	.num_resources	= 1,
+-};
+-
+ /* The 47162a0 hangs when reading MIPS DMP registers registers */
+ static inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)
+ {
+@@ -272,48 +250,11 @@ static enum bcma_boot_dev bcma_boot_dev(
+ 	return BCMA_BOOT_DEV_SERIAL;
+ }
+ 
+-static void bcma_core_mips_flash_detect(struct bcma_drv_mips *mcore)
++static void bcma_core_mips_nvram_init(struct bcma_drv_mips *mcore)
+ {
+ 	struct bcma_bus *bus = mcore->core->bus;
+-	struct bcma_drv_cc *cc = &bus->drv_cc;
+-	struct bcma_pflash *pflash = &cc->pflash;
+ 	enum bcma_boot_dev boot_dev;
+ 
+-	switch (cc->capabilities & BCMA_CC_CAP_FLASHT) {
+-	case BCMA_CC_FLASHT_STSER:
+-	case BCMA_CC_FLASHT_ATSER:
+-		bcma_debug(bus, "Found serial flash\n");
+-		bcma_sflash_init(cc);
+-		break;
+-	case BCMA_CC_FLASHT_PARA:
+-		bcma_debug(bus, "Found parallel flash\n");
+-		pflash->present = true;
+-		pflash->window = BCMA_SOC_FLASH2;
+-		pflash->window_size = BCMA_SOC_FLASH2_SZ;
+-
+-		if ((bcma_read32(cc->core, BCMA_CC_FLASH_CFG) &
+-		     BCMA_CC_FLASH_CFG_DS) == 0)
+-			pflash->buswidth = 1;
+-		else
+-			pflash->buswidth = 2;
+-
+-		bcma_pflash_data.width = pflash->buswidth;
+-		bcma_pflash_resource.start = pflash->window;
+-		bcma_pflash_resource.end = pflash->window + pflash->window_size;
+-
+-		break;
+-	default:
+-		bcma_err(bus, "Flash type not supported\n");
+-	}
+-
+-	if (cc->core->id.rev == 38 ||
+-	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
+-		if (cc->capabilities & BCMA_CC_CAP_NFLASH) {
+-			bcma_debug(bus, "Found NAND flash\n");
+-			bcma_nflash_init(cc);
+-		}
+-	}
+-
+ 	/* Determine flash type this SoC boots from */
+ 	boot_dev = bcma_boot_dev(bus);
+ 	switch (boot_dev) {
+@@ -337,13 +278,10 @@ static void bcma_core_mips_flash_detect(
+ 
+ void bcma_core_mips_early_init(struct bcma_drv_mips *mcore)
+ {
+-	struct bcma_bus *bus = mcore->core->bus;
+-
+ 	if (mcore->early_setup_done)
+ 		return;
+ 
+-	bcma_chipco_serial_init(&bus->drv_cc);
+-	bcma_core_mips_flash_detect(mcore);
++	bcma_core_mips_nvram_init(mcore);
+ 
+ 	mcore->early_setup_done = true;
+ }
+--- a/drivers/bcma/host_pci.c
++++ b/drivers/bcma/host_pci.c
+@@ -294,7 +294,8 @@ static const struct pci_device_id bcma_p
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4358) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4360) },
+-	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4365) },
++	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_DELL, 0x0016) },
++	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_FOXCONN, 0xe092) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a0) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a9) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43aa) },
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -70,6 +70,11 @@ config BCMA_DRIVER_MIPS
+ 
+ 	  If unsure, say N
+ 
++config BCMA_PFLASH
++	bool
++	depends on BCMA_DRIVER_MIPS
++	default y
++
+ config BCMA_SFLASH
+ 	bool
+ 	depends on BCMA_DRIVER_MIPS
+--- a/drivers/bcma/Makefile
++++ b/drivers/bcma/Makefile
+@@ -1,6 +1,7 @@
+ bcma-y					+= main.o scan.o core.o sprom.o
+ bcma-y					+= driver_chipcommon.o driver_chipcommon_pmu.o
+ bcma-y					+= driver_chipcommon_b.o
++bcma-$(CONFIG_BCMA_PFLASH)		+= driver_chipcommon_pflash.o
+ bcma-$(CONFIG_BCMA_SFLASH)		+= driver_chipcommon_sflash.o
+ bcma-$(CONFIG_BCMA_NFLASH)		+= driver_chipcommon_nflash.o
+ bcma-$(CONFIG_BCMA_DRIVER_PCI)		+= driver_pci.o
+--- /dev/null
++++ b/drivers/bcma/driver_chipcommon_pflash.c
+@@ -0,0 +1,49 @@
++/*
++ * Broadcom specific AMBA
++ * ChipCommon parallel flash
++ *
++ * Licensed under the GNU/GPL. See COPYING for details.
++ */
++
++#include "bcma_private.h"
++
++#include <linux/bcma/bcma.h>
++#include <linux/mtd/physmap.h>
++#include <linux/platform_device.h>
++
++static const char * const part_probes[] = { "bcm47xxpart", NULL };
++
++static struct physmap_flash_data bcma_pflash_data = {
++	.part_probe_types	= part_probes,
++};
++
++static struct resource bcma_pflash_resource = {
++	.name	= "bcma_pflash",
++	.flags  = IORESOURCE_MEM,
++};
++
++struct platform_device bcma_pflash_dev = {
++	.name		= "physmap-flash",
++	.dev		= {
++		.platform_data  = &bcma_pflash_data,
++	},
++	.resource	= &bcma_pflash_resource,
++	.num_resources	= 1,
++};
++
++int bcma_pflash_init(struct bcma_drv_cc *cc)
++{
++	struct bcma_pflash *pflash = &cc->pflash;
++
++	pflash->present = true;
++
++	if (!(bcma_read32(cc->core, BCMA_CC_FLASH_CFG) & BCMA_CC_FLASH_CFG_DS))
++		bcma_pflash_data.width = 1;
++	else
++		bcma_pflash_data.width = 2;
++
++	bcma_pflash_resource.start = BCMA_SOC_FLASH2;
++	bcma_pflash_resource.end = BCMA_SOC_FLASH2 + BCMA_SOC_FLASH2_SZ;
++
++	return 0;
++}
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -136,7 +136,6 @@ static bool bcma_is_core_needed_early(u1
+ 	return false;
+ }
+ 
+-#if defined(CONFIG_OF) && defined(CONFIG_OF_ADDRESS)
+ static struct device_node *bcma_of_find_child_device(struct platform_device *parent,
+ 						     struct bcma_device *core)
+ {
+@@ -184,7 +183,7 @@ static unsigned int bcma_of_get_irq(stru
+ 	struct of_phandle_args out_irq;
+ 	int ret;
+ 
+-	if (!parent || !parent->dev.of_node)
++	if (!IS_ENABLED(CONFIG_OF_IRQ) || !parent || !parent->dev.of_node)
+ 		return 0;
+ 
+ 	ret = bcma_of_irq_parse(parent, core, &out_irq, num);
+@@ -202,23 +201,15 @@ static void bcma_of_fill_device(struct p
+ {
+ 	struct device_node *node;
+ 
++	if (!IS_ENABLED(CONFIG_OF_IRQ))
++		return;
++
+ 	node = bcma_of_find_child_device(parent, core);
+ 	if (node)
+ 		core->dev.of_node = node;
+ 
+ 	core->irq = bcma_of_get_irq(parent, core, 0);
+ }
+-#else
+-static void bcma_of_fill_device(struct platform_device *parent,
+-				struct bcma_device *core)
+-{
+-}
+-static inline unsigned int bcma_of_get_irq(struct platform_device *parent,
+-					   struct bcma_device *core, int num)
+-{
+-	return 0;
+-}
+-#endif /* CONFIG_OF */
+ 
+ unsigned int bcma_core_irq(struct bcma_device *core, int num)
+ {
+@@ -350,7 +341,7 @@ static int bcma_register_devices(struct
+ 		bcma_register_core(bus, core);
+ 	}
+ 
+-#ifdef CONFIG_BCMA_DRIVER_MIPS
++#ifdef CONFIG_BCMA_PFLASH
+ 	if (bus->drv_cc.pflash.present) {
+ 		err = platform_device_register(&bcma_pflash_dev);
+ 		if (err)
diff --git a/target/linux/generic/pending-4.4/022-bcma-from-4.8.patch b/target/linux/generic/pending-4.4/022-bcma-from-4.8.patch
new file mode 100644
index 0000000000..3ff4e94967
--- /dev/null
+++ b/target/linux/generic/pending-4.4/022-bcma-from-4.8.patch
@@ -0,0 +1,52 @@
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -76,9 +76,16 @@ config BCMA_PFLASH
+ 	default y
+ 
+ config BCMA_SFLASH
+-	bool
+-	depends on BCMA_DRIVER_MIPS
++	bool "ChipCommon-attached serial flash support"
++	depends on BCMA_HOST_SOC
+ 	default y
++	help
++	  Some cheap devices have serial flash connected to the ChipCommon
++	  instead of independent SPI controller. It requires using a separated
++	  driver that implements ChipCommon specific interface communication.
++
++	  Enabling this symbol will let bcma recognize serial flash and register
++	  it as platform device.
+ 
+ config BCMA_NFLASH
+ 	bool
+--- a/drivers/bcma/driver_chipcommon_b.c
++++ b/drivers/bcma/driver_chipcommon_b.c
+@@ -33,11 +33,12 @@ static bool bcma_wait_reg(struct bcma_bu
+ void bcma_chipco_b_mii_write(struct bcma_drv_cc_b *ccb, u32 offset, u32 value)
+ {
+ 	struct bcma_bus *bus = ccb->core->bus;
++	void __iomem *mii = ccb->mii;
+ 
+-	writel(offset, ccb->mii + 0x00);
+-	bcma_wait_reg(bus, ccb->mii + 0x00, 0x0100, 0x0000, 100);
+-	writel(value, ccb->mii + 0x04);
+-	bcma_wait_reg(bus, ccb->mii + 0x00, 0x0100, 0x0000, 100);
++	writel(offset, mii + BCMA_CCB_MII_MNG_CTL);
++	bcma_wait_reg(bus, mii + BCMA_CCB_MII_MNG_CTL, 0x0100, 0x0000, 100);
++	writel(value, mii + BCMA_CCB_MII_MNG_CMD_DATA);
++	bcma_wait_reg(bus, mii + BCMA_CCB_MII_MNG_CTL, 0x0100, 0x0000, 100);
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_b_mii_write);
+ 
+--- a/include/linux/bcma/bcma_driver_chipcommon.h
++++ b/include/linux/bcma/bcma_driver_chipcommon.h
+@@ -504,6 +504,9 @@
+ #define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
+ #define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
+ 
++#define BCMA_CCB_MII_MNG_CTL		0x0000
++#define BCMA_CCB_MII_MNG_CMD_DATA	0x0004
++
+ /* BCM4331 ChipControl numbers. */
+ #define BCMA_CHIPCTL_4331_BT_COEXIST		BIT(0)	/* 0 disable */
+ #define BCMA_CHIPCTL_4331_SECI			BIT(1)	/* 0 SECI is disabled (JATG functional) */
diff --git a/target/linux/generic/pending-4.4/023-bcma-from-4.9.patch b/target/linux/generic/pending-4.4/023-bcma-from-4.9.patch
new file mode 100644
index 0000000000..027054c162
--- /dev/null
+++ b/target/linux/generic/pending-4.4/023-bcma-from-4.9.patch
@@ -0,0 +1,108 @@
+--- a/drivers/bcma/driver_chipcommon.c
++++ b/drivers/bcma/driver_chipcommon.c
+@@ -36,12 +36,31 @@ u32 bcma_chipco_get_alp_clock(struct bcm
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_get_alp_clock);
+ 
++static bool bcma_core_cc_has_pmu_watchdog(struct bcma_drv_cc *cc)
++{
++	struct bcma_bus *bus = cc->core->bus;
++
++	if (cc->capabilities & BCMA_CC_CAP_PMU) {
++		if (bus->chipinfo.id == BCMA_CHIP_ID_BCM53573) {
++			WARN(bus->chipinfo.rev <= 1, "No watchdog available\n");
++			/* 53573B0 and 53573B1 have bugged PMU watchdog. It can
++			 * be enabled but timer can't be bumped. Use CC one
++			 * instead.
++			 */
++			return false;
++		}
++		return true;
++	} else {
++		return false;
++	}
++}
++
+ static u32 bcma_chipco_watchdog_get_max_timer(struct bcma_drv_cc *cc)
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+ 	u32 nb;
+ 
+-	if (cc->capabilities & BCMA_CC_CAP_PMU) {
++	if (bcma_core_cc_has_pmu_watchdog(cc)) {
+ 		if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
+ 			nb = 32;
+ 		else if (cc->core->id.rev < 26)
+@@ -95,9 +114,16 @@ static int bcma_chipco_watchdog_ticks_pe
+ 
+ int bcma_chipco_watchdog_register(struct bcma_drv_cc *cc)
+ {
++	struct bcma_bus *bus = cc->core->bus;
+ 	struct bcm47xx_wdt wdt = {};
+ 	struct platform_device *pdev;
+ 
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM53573 &&
++	    bus->chipinfo.rev <= 1) {
++		pr_debug("No watchdog on 53573A0 / 53573A1\n");
++		return 0;
++	}
++
+ 	wdt.driver_data = cc;
+ 	wdt.timer_set = bcma_chipco_watchdog_timer_set_wdt;
+ 	wdt.timer_set_ms = bcma_chipco_watchdog_timer_set_ms_wdt;
+@@ -105,7 +131,7 @@ int bcma_chipco_watchdog_register(struct
+ 		bcma_chipco_watchdog_get_max_timer(cc) / cc->ticks_per_ms;
+ 
+ 	pdev = platform_device_register_data(NULL, "bcm47xx-wdt",
+-					     cc->core->bus->num, &wdt,
++					     bus->num, &wdt,
+ 					     sizeof(wdt));
+ 	if (IS_ERR(pdev))
+ 		return PTR_ERR(pdev);
+@@ -217,7 +243,7 @@ u32 bcma_chipco_watchdog_timer_set(struc
+ 	u32 maxt;
+ 
+ 	maxt = bcma_chipco_watchdog_get_max_timer(cc);
+-	if (cc->capabilities & BCMA_CC_CAP_PMU) {
++	if (bcma_core_cc_has_pmu_watchdog(cc)) {
+ 		if (ticks == 1)
+ 			ticks = 2;
+ 		else if (ticks > maxt)
+--- a/include/linux/bcma/bcma.h
++++ b/include/linux/bcma/bcma.h
+@@ -204,6 +204,9 @@ struct bcma_host_ops {
+ #define  BCMA_PKG_ID_BCM4709	0
+ #define BCMA_CHIP_ID_BCM47094	53030
+ #define BCMA_CHIP_ID_BCM53018	53018
++#define BCMA_CHIP_ID_BCM53573	53573
++#define  BCMA_PKG_ID_BCM53573	0
++#define  BCMA_PKG_ID_BCM47189	1
+ 
+ /* Board types (on PCI usually equals to the subsystem dev id) */
+ /* BCM4313 */
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -209,6 +209,8 @@ static void bcma_of_fill_device(struct p
+ 		core->dev.of_node = node;
+ 
+ 	core->irq = bcma_of_get_irq(parent, core, 0);
++
++	of_dma_configure(&core->dev, node);
+ }
+ 
+ unsigned int bcma_core_irq(struct bcma_device *core, int num)
+@@ -248,12 +250,12 @@ void bcma_prepare_core(struct bcma_bus *
+ 		core->irq = bus->host_pci->irq;
+ 		break;
+ 	case BCMA_HOSTTYPE_SOC:
+-		core->dev.dma_mask = &core->dev.coherent_dma_mask;
+-		if (bus->host_pdev) {
++		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
+ 			core->dma_dev = &bus->host_pdev->dev;
+ 			core->dev.parent = &bus->host_pdev->dev;
+ 			bcma_of_fill_device(bus->host_pdev, core);
+ 		} else {
++			core->dev.dma_mask = &core->dev.coherent_dma_mask;
+ 			core->dma_dev = &core->dev;
+ 		}
+ 		break;
diff --git a/target/linux/generic/pending-4.4/025-bcma-from-4.11.patch b/target/linux/generic/pending-4.4/025-bcma-from-4.11.patch
new file mode 100644
index 0000000000..a3b0321986
--- /dev/null
+++ b/target/linux/generic/pending-4.4/025-bcma-from-4.11.patch
@@ -0,0 +1,85 @@
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -136,17 +136,17 @@ static bool bcma_is_core_needed_early(u1
+ 	return false;
+ }
+ 
+-static struct device_node *bcma_of_find_child_device(struct platform_device *parent,
++static struct device_node *bcma_of_find_child_device(struct device *parent,
+ 						     struct bcma_device *core)
+ {
+ 	struct device_node *node;
+ 	u64 size;
+ 	const __be32 *reg;
+ 
+-	if (!parent || !parent->dev.of_node)
++	if (!parent->of_node)
+ 		return NULL;
+ 
+-	for_each_child_of_node(parent->dev.of_node, node) {
++	for_each_child_of_node(parent->of_node, node) {
+ 		reg = of_get_address(node, 0, &size, NULL);
+ 		if (!reg)
+ 			continue;
+@@ -156,7 +156,7 @@ static struct device_node *bcma_of_find_
+ 	return NULL;
+ }
+ 
+-static int bcma_of_irq_parse(struct platform_device *parent,
++static int bcma_of_irq_parse(struct device *parent,
+ 			     struct bcma_device *core,
+ 			     struct of_phandle_args *out_irq, int num)
+ {
+@@ -169,7 +169,7 @@ static int bcma_of_irq_parse(struct plat
+ 			return rc;
+ 	}
+ 
+-	out_irq->np = parent->dev.of_node;
++	out_irq->np = parent->of_node;
+ 	out_irq->args_count = 1;
+ 	out_irq->args[0] = num;
+ 
+@@ -177,13 +177,13 @@ static int bcma_of_irq_parse(struct plat
+ 	return of_irq_parse_raw(laddr, out_irq);
+ }
+ 
+-static unsigned int bcma_of_get_irq(struct platform_device *parent,
++static unsigned int bcma_of_get_irq(struct device *parent,
+ 				    struct bcma_device *core, int num)
+ {
+ 	struct of_phandle_args out_irq;
+ 	int ret;
+ 
+-	if (!IS_ENABLED(CONFIG_OF_IRQ) || !parent || !parent->dev.of_node)
++	if (!IS_ENABLED(CONFIG_OF_IRQ) || !parent->of_node)
+ 		return 0;
+ 
+ 	ret = bcma_of_irq_parse(parent, core, &out_irq, num);
+@@ -196,7 +196,7 @@ static unsigned int bcma_of_get_irq(stru
+ 	return irq_create_of_mapping(&out_irq);
+ }
+ 
+-static void bcma_of_fill_device(struct platform_device *parent,
++static void bcma_of_fill_device(struct device *parent,
+ 				struct bcma_device *core)
+ {
+ 	struct device_node *node;
+@@ -227,7 +227,7 @@ unsigned int bcma_core_irq(struct bcma_d
+ 			return mips_irq <= 4 ? mips_irq + 2 : 0;
+ 		}
+ 		if (bus->host_pdev)
+-			return bcma_of_get_irq(bus->host_pdev, core, num);
++			return bcma_of_get_irq(&bus->host_pdev->dev, core, num);
+ 		return 0;
+ 	case BCMA_HOSTTYPE_SDIO:
+ 		return 0;
+@@ -253,7 +253,8 @@ void bcma_prepare_core(struct bcma_bus *
+ 		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
+ 			core->dma_dev = &bus->host_pdev->dev;
+ 			core->dev.parent = &bus->host_pdev->dev;
+-			bcma_of_fill_device(bus->host_pdev, core);
++			if (core->dev.parent)
++				bcma_of_fill_device(core->dev.parent, core);
+ 		} else {
+ 			core->dev.dma_mask = &core->dev.coherent_dma_mask;
+ 			core->dma_dev = &core->dev;
diff --git a/target/linux/generic/pending-4.4/026-bcma-from-4.12.patch b/target/linux/generic/pending-4.4/026-bcma-from-4.12.patch
new file mode 100644
index 0000000000..bd7d643cbb
--- /dev/null
+++ b/target/linux/generic/pending-4.4/026-bcma-from-4.12.patch
@@ -0,0 +1,47 @@
+--- a/drivers/bcma/driver_gpio.c
++++ b/drivers/bcma/driver_gpio.c
+@@ -190,8 +190,7 @@ int bcma_gpio_init(struct bcma_drv_cc *c
+ 	chip->owner		= THIS_MODULE;
+ 	chip->dev		= bcma_bus_get_host_dev(bus);
+ #if IS_BUILTIN(CONFIG_OF)
+-	if (cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)
+-		chip->of_node	= cc->core->dev.of_node;
++	chip->of_node		= cc->core->dev.of_node;
+ #endif
+ 	switch (bus->chipinfo.id) {
+ 	case BCMA_CHIP_ID_BCM4707:
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -201,9 +201,6 @@ static void bcma_of_fill_device(struct d
+ {
+ 	struct device_node *node;
+ 
+-	if (!IS_ENABLED(CONFIG_OF_IRQ))
+-		return;
+-
+ 	node = bcma_of_find_child_device(parent, core);
+ 	if (node)
+ 		core->dev.of_node = node;
+@@ -242,19 +239,18 @@ void bcma_prepare_core(struct bcma_bus *
+ 	core->dev.release = bcma_release_core_dev;
+ 	core->dev.bus = &bcma_bus_type;
+ 	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
++	core->dev.parent = bcma_bus_get_host_dev(bus);
++	if (core->dev.parent)
++		bcma_of_fill_device(core->dev.parent, core);
+ 
+ 	switch (bus->hosttype) {
+ 	case BCMA_HOSTTYPE_PCI:
+-		core->dev.parent = &bus->host_pci->dev;
+ 		core->dma_dev = &bus->host_pci->dev;
+ 		core->irq = bus->host_pci->irq;
+ 		break;
+ 	case BCMA_HOSTTYPE_SOC:
+ 		if (IS_ENABLED(CONFIG_OF) && bus->host_pdev) {
+ 			core->dma_dev = &bus->host_pdev->dev;
+-			core->dev.parent = &bus->host_pdev->dev;
+-			if (core->dev.parent)
+-				bcma_of_fill_device(core->dev.parent, core);
+ 		} else {
+ 			core->dev.dma_mask = &core->dev.coherent_dma_mask;
+ 			core->dma_dev = &core->dev;
diff --git a/target/linux/generic/pending-4.4/030-1-smsc95xx-Use-skb_cow_head-to-deal-with-cloned-skbs.patch b/target/linux/generic/pending-4.4/030-1-smsc95xx-Use-skb_cow_head-to-deal-with-cloned-skbs.patch
new file mode 100644
index 0000000000..36fb936e32
--- /dev/null
+++ b/target/linux/generic/pending-4.4/030-1-smsc95xx-Use-skb_cow_head-to-deal-with-cloned-skbs.patch
@@ -0,0 +1,40 @@
+From e9156cd26a495a18706e796f02a81fee41ec14f4 Mon Sep 17 00:00:00 2001
+From: James Hughes <james.hughes@raspberrypi.org>
+Date: Wed, 19 Apr 2017 11:13:40 +0100
+Subject: [PATCH] smsc95xx: Use skb_cow_head to deal with cloned skbs
+
+The driver was failing to check that the SKB wasn't cloned
+before adding checksum data.
+Replace existing handling to extend/copy the header buffer
+with skb_cow_head.
+
+Signed-off-by: James Hughes <james.hughes@raspberrypi.org>
+Acked-by: Eric Dumazet <edumazet@google.com>
+Acked-by: Woojung Huh <Woojung.Huh@microchip.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/smsc95xx.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/usb/smsc95xx.c
++++ b/drivers/net/usb/smsc95xx.c
+@@ -1835,13 +1835,13 @@ static struct sk_buff *smsc95xx_tx_fixup
+ 	/* We do not advertise SG, so skbs should be already linearized */
+ 	BUG_ON(skb_shinfo(skb)->nr_frags);
+ 
+-	if (skb_headroom(skb) < overhead) {
+-		struct sk_buff *skb2 = skb_copy_expand(skb,
+-			overhead, 0, flags);
++	/* Make writable and expand header space by overhead if required */
++	if (skb_cow_head(skb, overhead)) {
++		/* Must deallocate here as returning NULL to indicate error
++		 * means the skb won't be deallocated in the caller.
++		 */
+ 		dev_kfree_skb_any(skb);
+-		skb = skb2;
+-		if (!skb)
+-			return NULL;
++		return NULL;
+ 	}
+ 
+ 	if (csum) {
diff --git a/target/linux/generic/pending-4.4/030-6-ch9200-use-skb_cow_head-to-deal-with-cloned-skbs.patch b/target/linux/generic/pending-4.4/030-6-ch9200-use-skb_cow_head-to-deal-with-cloned-skbs.patch
new file mode 100644
index 0000000000..2e8bba57e0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/030-6-ch9200-use-skb_cow_head-to-deal-with-cloned-skbs.patch
@@ -0,0 +1,38 @@
+From 6bc6895bdd6744e0136eaa4a11fbdb20a7db4e40 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Wed, 19 Apr 2017 09:59:25 -0700
+Subject: [PATCH] ch9200: use skb_cow_head() to deal with cloned skbs
+
+We need to ensure there is enough headroom to push extra header,
+but we also need to check if we are allowed to change headers.
+
+skb_cow_head() is the proper helper to deal with this.
+
+Fixes: 4a476bd6d1d9 ("usbnet: New driver for QinHeng CH9200 devices")
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: James Hughes <james.hughes@raspberrypi.org>
+Cc: Matthew Garrett <mjg59@srcf.ucam.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/ch9200.c | 9 ++-------
+ 1 file changed, 2 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/usb/ch9200.c
++++ b/drivers/net/usb/ch9200.c
+@@ -255,14 +255,9 @@ static struct sk_buff *ch9200_tx_fixup(s
+ 	tx_overhead = 0x40;
+ 
+ 	len = skb->len;
+-	if (skb_headroom(skb) < tx_overhead) {
+-		struct sk_buff *skb2;
+-
+-		skb2 = skb_copy_expand(skb, tx_overhead, 0, flags);
++	if (skb_cow_head(skb, tx_overhead)) {
+ 		dev_kfree_skb_any(skb);
+-		skb = skb2;
+-		if (!skb)
+-			return NULL;
++		return NULL;
+ 	}
+ 
+ 	__skb_push(skb, tx_overhead);
diff --git a/target/linux/generic/pending-4.4/030-7-kaweth-use-skb_cow_head-to-deal-with-cloned-skbs.patch b/target/linux/generic/pending-4.4/030-7-kaweth-use-skb_cow_head-to-deal-with-cloned-skbs.patch
new file mode 100644
index 0000000000..541c694bec
--- /dev/null
+++ b/target/linux/generic/pending-4.4/030-7-kaweth-use-skb_cow_head-to-deal-with-cloned-skbs.patch
@@ -0,0 +1,43 @@
+From 39fba7835aacda65284a86e611774cbba71dac20 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Wed, 19 Apr 2017 09:59:26 -0700
+Subject: [PATCH] kaweth: use skb_cow_head() to deal with cloned skbs
+
+We can use skb_cow_head() to properly deal with clones,
+especially the ones coming from TCP stack that allow their head being
+modified. This avoids a copy.
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: James Hughes <james.hughes@raspberrypi.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/kaweth.c | 18 ++++++------------
+ 1 file changed, 6 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/usb/kaweth.c
++++ b/drivers/net/usb/kaweth.c
+@@ -812,18 +812,12 @@ static netdev_tx_t kaweth_start_xmit(str
+ 	}
+ 
+ 	/* We now decide whether we can put our special header into the sk_buff */
+-	if (skb_cloned(skb) || skb_headroom(skb) < 2) {
+-		/* no such luck - we make our own */
+-		struct sk_buff *copied_skb;
+-		copied_skb = skb_copy_expand(skb, 2, 0, GFP_ATOMIC);
+-		dev_kfree_skb_irq(skb);
+-		skb = copied_skb;
+-		if (!copied_skb) {
+-			kaweth->stats.tx_errors++;
+-			netif_start_queue(net);
+-			spin_unlock_irq(&kaweth->device_lock);
+-			return NETDEV_TX_OK;
+-		}
++	if (skb_cow_head(skb, 2)) {
++		kaweth->stats.tx_errors++;
++		netif_start_queue(net);
++		spin_unlock_irq(&kaweth->device_lock);
++		dev_kfree_skb_any(skb);
++		return NETDEV_TX_OK;
+ 	}
+ 
+ 	private_header = (__le16 *)__skb_push(skb, 2);
diff --git a/target/linux/generic/pending-4.4/032-fq_codel-add-batch-ability-to-fq_codel_drop.patch b/target/linux/generic/pending-4.4/032-fq_codel-add-batch-ability-to-fq_codel_drop.patch
new file mode 100644
index 0000000000..d1390348cb
--- /dev/null
+++ b/target/linux/generic/pending-4.4/032-fq_codel-add-batch-ability-to-fq_codel_drop.patch
@@ -0,0 +1,189 @@
+From: Eric Dumazet <edumazet@google.com>
+Date: Sun, 1 May 2016 16:47:26 -0700
+Subject: [PATCH] fq_codel: add batch ability to fq_codel_drop()
+
+In presence of inelastic flows and stress, we can call
+fq_codel_drop() for every packet entering fq_codel qdisc.
+
+fq_codel_drop() is quite expensive, as it does a linear scan
+of 4 KB of memory to find a fat flow.
+Once found, it drops the oldest packet of this flow.
+
+Instead of dropping a single packet, try to drop 50% of the backlog
+of this fat flow, with a configurable limit of 64 packets per round.
+
+TCA_FQ_CODEL_DROP_BATCH_SIZE is the new attribute to make this
+limit configurable.
+
+With this strategy the 4 KB search is amortized to a single cache line
+per drop [1], so fq_codel_drop() no longer appears at the top of kernel
+profile in presence of few inelastic flows.
+
+[1] Assuming a 64byte cache line, and 1024 buckets
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Reported-by: Dave Taht <dave.taht@gmail.com>
+Cc: Jonathan Morton <chromatix99@gmail.com>
+Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
+Acked-by: Dave Taht
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -711,6 +711,7 @@ enum {
+ 	TCA_FQ_CODEL_FLOWS,
+ 	TCA_FQ_CODEL_QUANTUM,
+ 	TCA_FQ_CODEL_CE_THRESHOLD,
++	TCA_FQ_CODEL_DROP_BATCH_SIZE,
+ 	__TCA_FQ_CODEL_MAX
+ };
+ 
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -57,6 +57,7 @@ struct fq_codel_sched_data {
+ 	u32		flows_cnt;	/* number of flows */
+ 	u32		perturbation;	/* hash perturbation */
+ 	u32		quantum;	/* psched_mtu(qdisc_dev(sch)); */
++	u32		drop_batch_size;
+ 	struct codel_params cparams;
+ 	struct codel_stats cstats;
+ 	u32		drop_overlimit;
+@@ -133,17 +134,20 @@ static inline void flow_queue_add(struct
+ 	skb->next = NULL;
+ }
+ 
+-static unsigned int fq_codel_drop(struct Qdisc *sch)
++static unsigned int fq_codel_drop(struct Qdisc *sch, unsigned int max_packets)
+ {
+ 	struct fq_codel_sched_data *q = qdisc_priv(sch);
+ 	struct sk_buff *skb;
+ 	unsigned int maxbacklog = 0, idx = 0, i, len;
+ 	struct fq_codel_flow *flow;
++	unsigned int threshold;
+ 
+-	/* Queue is full! Find the fat flow and drop packet from it.
++	/* Queue is full! Find the fat flow and drop packet(s) from it.
+ 	 * This might sound expensive, but with 1024 flows, we scan
+ 	 * 4KB of memory, and we dont need to handle a complex tree
+ 	 * in fast path (packet queue/enqueue) with many cache misses.
++	 * In stress mode, we'll try to drop 64 packets from the flow,
++	 * amortizing this linear lookup to one cache line per drop.
+ 	 */
+ 	for (i = 0; i < q->flows_cnt; i++) {
+ 		if (q->backlogs[i] > maxbacklog) {
+@@ -151,15 +155,24 @@ static unsigned int fq_codel_drop(struct
+ 			idx = i;
+ 		}
+ 	}
++
++	/* Our goal is to drop half of this fat flow backlog */
++	threshold = maxbacklog >> 1;
++
+ 	flow = &q->flows[idx];
+-	skb = dequeue_head(flow);
+-	len = qdisc_pkt_len(skb);
++	len = 0;
++	i = 0;
++	do {
++		skb = dequeue_head(flow);
++		len += qdisc_pkt_len(skb);
++		kfree_skb(skb);
++	} while (++i < max_packets && len < threshold);
++
++	flow->dropped += i;
+ 	q->backlogs[idx] -= len;
+-	sch->q.qlen--;
+-	qdisc_qstats_drop(sch);
+-	qdisc_qstats_backlog_dec(sch, skb);
+-	kfree_skb(skb);
+-	flow->dropped++;
++	sch->qstats.drops += i;
++	sch->qstats.backlog -= len;
++	sch->q.qlen -= i;
+ 	return idx;
+ }
+ 
+@@ -168,14 +181,14 @@ static unsigned int fq_codel_qdisc_drop(
+ 	unsigned int prev_backlog;
+ 
+ 	prev_backlog = sch->qstats.backlog;
+-	fq_codel_drop(sch);
++	fq_codel_drop(sch, 1U);
+ 	return prev_backlog - sch->qstats.backlog;
+ }
+ 
+ static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+ {
+ 	struct fq_codel_sched_data *q = qdisc_priv(sch);
+-	unsigned int idx, prev_backlog;
++	unsigned int idx, prev_backlog, prev_qlen;
+ 	struct fq_codel_flow *flow;
+ 	int uninitialized_var(ret);
+ 
+@@ -204,16 +217,22 @@ static int fq_codel_enqueue(struct sk_bu
+ 		return NET_XMIT_SUCCESS;
+ 
+ 	prev_backlog = sch->qstats.backlog;
+-	q->drop_overlimit++;
+-	/* Return Congestion Notification only if we dropped a packet
+-	 * from this flow.
++	prev_qlen = sch->q.qlen;
++
++	/* fq_codel_drop() is quite expensive, as it performs a linear search
++	 * in q->backlogs[] to find a fat flow.
++	 * So instead of dropping a single packet, drop half of its backlog
++	 * with a 64 packets limit to not add a too big cpu spike here.
+ 	 */
+-	if (fq_codel_drop(sch) == idx)
+-		return NET_XMIT_CN;
++	ret = fq_codel_drop(sch, q->drop_batch_size);
++
++	q->drop_overlimit += prev_qlen - sch->q.qlen;
+ 
+-	/* As we dropped a packet, better let upper stack know this */
+-	qdisc_tree_reduce_backlog(sch, 1, prev_backlog - sch->qstats.backlog);
+-	return NET_XMIT_SUCCESS;
++	/* As we dropped packet(s), better let upper stack know this */
++	qdisc_tree_reduce_backlog(sch, prev_qlen - sch->q.qlen,
++				  prev_backlog - sch->qstats.backlog);
++
++	return ret == idx ? NET_XMIT_CN : NET_XMIT_SUCCESS;
+ }
+ 
+ /* This is the specific function called from codel_dequeue()
+@@ -323,6 +342,7 @@ static const struct nla_policy fq_codel_
+ 	[TCA_FQ_CODEL_FLOWS]	= { .type = NLA_U32 },
+ 	[TCA_FQ_CODEL_QUANTUM]	= { .type = NLA_U32 },
+ 	[TCA_FQ_CODEL_CE_THRESHOLD] = { .type = NLA_U32 },
++	[TCA_FQ_CODEL_DROP_BATCH_SIZE] = { .type = NLA_U32 },
+ };
+ 
+ static int fq_codel_change(struct Qdisc *sch, struct nlattr *opt)
+@@ -374,6 +394,9 @@ static int fq_codel_change(struct Qdisc
+ 	if (tb[TCA_FQ_CODEL_QUANTUM])
+ 		q->quantum = max(256U, nla_get_u32(tb[TCA_FQ_CODEL_QUANTUM]));
+ 
++	if (tb[TCA_FQ_CODEL_DROP_BATCH_SIZE])
++		q->drop_batch_size = min(1U, nla_get_u32(tb[TCA_FQ_CODEL_DROP_BATCH_SIZE]));
++
+ 	while (sch->q.qlen > sch->limit) {
+ 		struct sk_buff *skb = fq_codel_dequeue(sch);
+ 
+@@ -419,6 +442,7 @@ static int fq_codel_init(struct Qdisc *s
+ 
+ 	sch->limit = 10*1024;
+ 	q->flows_cnt = 1024;
++	q->drop_batch_size = 64;
+ 	q->quantum = psched_mtu(qdisc_dev(sch));
+ 	q->perturbation = prandom_u32();
+ 	INIT_LIST_HEAD(&q->new_flows);
+@@ -476,6 +500,8 @@ static int fq_codel_dump(struct Qdisc *s
+ 			q->cparams.ecn) ||
+ 	    nla_put_u32(skb, TCA_FQ_CODEL_QUANTUM,
+ 			q->quantum) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_DROP_BATCH_SIZE,
++			q->drop_batch_size) ||
+ 	    nla_put_u32(skb, TCA_FQ_CODEL_FLOWS,
+ 			q->flows_cnt))
+ 		goto nla_put_failure;
diff --git a/target/linux/generic/pending-4.4/033-fq_codel-add-memory-limitation-per-queue.patch b/target/linux/generic/pending-4.4/033-fq_codel-add-memory-limitation-per-queue.patch
new file mode 100644
index 0000000000..455add9eae
--- /dev/null
+++ b/target/linux/generic/pending-4.4/033-fq_codel-add-memory-limitation-per-queue.patch
@@ -0,0 +1,182 @@
+From: Eric Dumazet <edumazet@google.com>
+Date: Fri, 6 May 2016 08:55:12 -0700
+Subject: [PATCH] fq_codel: add memory limitation per queue
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+On small embedded routers, one wants to control maximal amount of
+memory used by fq_codel, instead of controlling number of packets or
+bytes, since GRO/TSO make these not practical.
+
+Assuming skb->truesize is accurate, we have to keep track of
+skb->truesize sum for skbs in queue.
+
+This patch adds a new TCA_FQ_CODEL_MEMORY_LIMIT attribute.
+
+I chose a default value of 32 MBytes, which looks reasonable even
+for heavy duty usages. (Prior fq_codel users should not be hurt
+when they upgrade their kernels)
+
+Two fields are added to tc_fq_codel_qd_stats to report :
+ - Current memory usage
+ - Number of drops caused by memory limits
+
+# tc qd replace dev eth1 root est 1sec 4sec fq_codel memory_limit 4M
+..
+# tc -s -d qd sh dev eth1
+qdisc fq_codel 8008: root refcnt 257 limit 10240p flows 1024
+ quantum 1514 target 5.0ms interval 100.0ms memory_limit 4Mb ecn
+ Sent 2083566791363 bytes 1376214889 pkt (dropped 4994406, overlimits 0
+requeues 21705223)
+ rate 9841Mbit 812549pps backlog 3906120b 376p requeues 21705223
+  maxpacket 68130 drop_overlimit 4994406 new_flow_count 28855414
+  ecn_mark 0 memory_used 4190048 drop_overmemory 4994406
+  new_flows_len 1 old_flows_len 177
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: Jesper Dangaard Brouer <brouer@redhat.com>
+Cc: Dave Tht <dave.taht@gmail.com>
+Cc: Sebastian Mller <moeller0@gmx.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -712,6 +712,7 @@ enum {
+ 	TCA_FQ_CODEL_QUANTUM,
+ 	TCA_FQ_CODEL_CE_THRESHOLD,
+ 	TCA_FQ_CODEL_DROP_BATCH_SIZE,
++	TCA_FQ_CODEL_MEMORY_LIMIT,
+ 	__TCA_FQ_CODEL_MAX
+ };
+ 
+@@ -736,6 +737,8 @@ struct tc_fq_codel_qd_stats {
+ 	__u32	new_flows_len;	/* count of flows in new list */
+ 	__u32	old_flows_len;	/* count of flows in old list */
+ 	__u32	ce_mark;	/* packets above ce_threshold */
++	__u32	memory_usage;	/* in bytes */
++	__u32	drop_overmemory;
+ };
+ 
+ struct tc_fq_codel_cl_stats {
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -58,8 +58,11 @@ struct fq_codel_sched_data {
+ 	u32		perturbation;	/* hash perturbation */
+ 	u32		quantum;	/* psched_mtu(qdisc_dev(sch)); */
+ 	u32		drop_batch_size;
++	u32		memory_limit;
+ 	struct codel_params cparams;
+ 	struct codel_stats cstats;
++	u32		memory_usage;
++	u32		drop_overmemory;
+ 	u32		drop_overlimit;
+ 	u32		new_flow_count;
+ 
+@@ -141,6 +144,7 @@ static unsigned int fq_codel_drop(struct
+ 	unsigned int maxbacklog = 0, idx = 0, i, len;
+ 	struct fq_codel_flow *flow;
+ 	unsigned int threshold;
++	unsigned int mem = 0;
+ 
+ 	/* Queue is full! Find the fat flow and drop packet(s) from it.
+ 	 * This might sound expensive, but with 1024 flows, we scan
+@@ -165,11 +169,13 @@ static unsigned int fq_codel_drop(struct
+ 	do {
+ 		skb = dequeue_head(flow);
+ 		len += qdisc_pkt_len(skb);
++		mem += skb->truesize;
+ 		kfree_skb(skb);
+ 	} while (++i < max_packets && len < threshold);
+ 
+ 	flow->dropped += i;
+ 	q->backlogs[idx] -= len;
++	q->memory_usage -= mem;
+ 	sch->qstats.drops += i;
+ 	sch->qstats.backlog -= len;
+ 	sch->q.qlen -= i;
+@@ -191,6 +197,7 @@ static int fq_codel_enqueue(struct sk_bu
+ 	unsigned int idx, prev_backlog, prev_qlen;
+ 	struct fq_codel_flow *flow;
+ 	int uninitialized_var(ret);
++	bool memory_limited;
+ 
+ 	idx = fq_codel_classify(skb, sch, &ret);
+ 	if (idx == 0) {
+@@ -213,7 +220,9 @@ static int fq_codel_enqueue(struct sk_bu
+ 		flow->deficit = q->quantum;
+ 		flow->dropped = 0;
+ 	}
+-	if (++sch->q.qlen <= sch->limit)
++	q->memory_usage += skb->truesize;
++	memory_limited = q->memory_usage > q->memory_limit;
++	if (++sch->q.qlen <= sch->limit && !memory_limited)
+ 		return NET_XMIT_SUCCESS;
+ 
+ 	prev_backlog = sch->qstats.backlog;
+@@ -227,7 +236,8 @@ static int fq_codel_enqueue(struct sk_bu
+ 	ret = fq_codel_drop(sch, q->drop_batch_size);
+ 
+ 	q->drop_overlimit += prev_qlen - sch->q.qlen;
+-
++	if (memory_limited)
++		q->drop_overmemory += prev_qlen - sch->q.qlen;
+ 	/* As we dropped packet(s), better let upper stack know this */
+ 	qdisc_tree_reduce_backlog(sch, prev_qlen - sch->q.qlen,
+ 				  prev_backlog - sch->qstats.backlog);
+@@ -296,6 +306,7 @@ begin:
+ 			list_del_init(&flow->flowchain);
+ 		goto begin;
+ 	}
++	q->memory_usage -= skb->truesize;
+ 	qdisc_bstats_update(sch, skb);
+ 	flow->deficit -= qdisc_pkt_len(skb);
+ 	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
+@@ -343,6 +354,7 @@ static const struct nla_policy fq_codel_
+ 	[TCA_FQ_CODEL_QUANTUM]	= { .type = NLA_U32 },
+ 	[TCA_FQ_CODEL_CE_THRESHOLD] = { .type = NLA_U32 },
+ 	[TCA_FQ_CODEL_DROP_BATCH_SIZE] = { .type = NLA_U32 },
++	[TCA_FQ_CODEL_MEMORY_LIMIT] = { .type = NLA_U32 },
+ };
+ 
+ static int fq_codel_change(struct Qdisc *sch, struct nlattr *opt)
+@@ -397,7 +409,11 @@ static int fq_codel_change(struct Qdisc
+ 	if (tb[TCA_FQ_CODEL_DROP_BATCH_SIZE])
+ 		q->drop_batch_size = min(1U, nla_get_u32(tb[TCA_FQ_CODEL_DROP_BATCH_SIZE]));
+ 
+-	while (sch->q.qlen > sch->limit) {
++	if (tb[TCA_FQ_CODEL_MEMORY_LIMIT])
++		q->memory_limit = min(1U << 31, nla_get_u32(tb[TCA_FQ_CODEL_MEMORY_LIMIT]));
++
++	while (sch->q.qlen > sch->limit ||
++	       q->memory_usage > q->memory_limit) {
+ 		struct sk_buff *skb = fq_codel_dequeue(sch);
+ 
+ 		q->cstats.drop_len += qdisc_pkt_len(skb);
+@@ -442,6 +458,7 @@ static int fq_codel_init(struct Qdisc *s
+ 
+ 	sch->limit = 10*1024;
+ 	q->flows_cnt = 1024;
++	q->memory_limit = 32 << 20; /* 32 MBytes */
+ 	q->drop_batch_size = 64;
+ 	q->quantum = psched_mtu(qdisc_dev(sch));
+ 	q->perturbation = prandom_u32();
+@@ -502,6 +519,8 @@ static int fq_codel_dump(struct Qdisc *s
+ 			q->quantum) ||
+ 	    nla_put_u32(skb, TCA_FQ_CODEL_DROP_BATCH_SIZE,
+ 			q->drop_batch_size) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_MEMORY_LIMIT,
++			q->memory_limit) ||
+ 	    nla_put_u32(skb, TCA_FQ_CODEL_FLOWS,
+ 			q->flows_cnt))
+ 		goto nla_put_failure;
+@@ -530,6 +549,8 @@ static int fq_codel_dump_stats(struct Qd
+ 	st.qdisc_stats.ecn_mark = q->cstats.ecn_mark;
+ 	st.qdisc_stats.new_flow_count = q->new_flow_count;
+ 	st.qdisc_stats.ce_mark = q->cstats.ce_mark;
++	st.qdisc_stats.memory_usage  = q->memory_usage;
++	st.qdisc_stats.drop_overmemory = q->drop_overmemory;
+ 
+ 	list_for_each(pos, &q->new_flows)
+ 		st.qdisc_stats.new_flows_len++;
diff --git a/target/linux/generic/pending-4.4/034-fq_codel-fix-memory-limitation-drift.patch b/target/linux/generic/pending-4.4/034-fq_codel-fix-memory-limitation-drift.patch
new file mode 100644
index 0000000000..45fff7bae9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/034-fq_codel-fix-memory-limitation-drift.patch
@@ -0,0 +1,40 @@
+From: Eric Dumazet <edumazet@google.com>
+Date: Sun, 15 May 2016 18:16:38 -0700
+Subject: [PATCH] fq_codel: fix memory limitation drift
+
+memory_usage must be decreased in dequeue_func(), not in
+fq_codel_dequeue(), otherwise packets dropped by Codel algo
+are missing this decrease.
+
+Also we need to clear memory_usage in fq_codel_reset()
+
+Fixes: 95b58430abe7 ("fq_codel: add memory limitation per queue")
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+---
+
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -259,6 +259,7 @@ static struct sk_buff *dequeue(struct co
+ 	if (flow->head) {
+ 		skb = dequeue_head(flow);
+ 		q->backlogs[flow - q->flows] -= qdisc_pkt_len(skb);
++		q->memory_usage -= skb->truesize;
+ 		sch->q.qlen--;
+ 	}
+ 	return skb;
+@@ -306,7 +307,6 @@ begin:
+ 			list_del_init(&flow->flowchain);
+ 		goto begin;
+ 	}
+-	q->memory_usage -= skb->truesize;
+ 	qdisc_bstats_update(sch, skb);
+ 	flow->deficit -= qdisc_pkt_len(skb);
+ 	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
+@@ -343,6 +343,7 @@ static void fq_codel_reset(struct Qdisc
+ 	}
+ 	memset(q->backlogs, 0, q->flows_cnt * sizeof(u32));
+ 	sch->q.qlen = 0;
++	q->memory_usage = 0;
+ }
+ 
+ static const struct nla_policy fq_codel_policy[TCA_FQ_CODEL_MAX + 1] = {
diff --git a/target/linux/generic/pending-4.4/035-fq_codel-fix-NET_XMIT_CN-behavior.patch b/target/linux/generic/pending-4.4/035-fq_codel-fix-NET_XMIT_CN-behavior.patch
new file mode 100644
index 0000000000..a1902fea07
--- /dev/null
+++ b/target/linux/generic/pending-4.4/035-fq_codel-fix-NET_XMIT_CN-behavior.patch
@@ -0,0 +1,70 @@
+From: Eric Dumazet <edumazet@google.com>
+Date: Sat, 4 Jun 2016 12:55:13 -0700
+Subject: [PATCH] fq_codel: fix NET_XMIT_CN behavior
+
+My prior attempt to fix the backlogs of parents failed.
+
+If we return NET_XMIT_CN, our parents wont increase their backlog,
+so our qdisc_tree_reduce_backlog() should take this into account.
+
+v2: Florian Westphal pointed out that we could drop the packet,
+so we need to save qdisc_pkt_len(skb) in a temp variable before
+calling fq_codel_drop()
+
+Fixes: 9d18562a2278 ("fq_codel: add batch ability to fq_codel_drop()")
+Fixes: 2ccccf5fb43f ("net_sched: update hierarchical backlog too")
+Reported-by: Stas Nichiporovich <stasn77@gmail.com>
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: WANG Cong <xiyou.wangcong@gmail.com>
+Cc: Jamal Hadi Salim <jhs@mojatatu.com>
+---
+
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -197,6 +197,7 @@ static int fq_codel_enqueue(struct sk_bu
+ 	unsigned int idx, prev_backlog, prev_qlen;
+ 	struct fq_codel_flow *flow;
+ 	int uninitialized_var(ret);
++	unsigned int pkt_len;
+ 	bool memory_limited;
+ 
+ 	idx = fq_codel_classify(skb, sch, &ret);
+@@ -228,6 +229,8 @@ static int fq_codel_enqueue(struct sk_bu
+ 	prev_backlog = sch->qstats.backlog;
+ 	prev_qlen = sch->q.qlen;
+ 
++	/* save this packet length as it might be dropped by fq_codel_drop() */
++	pkt_len = qdisc_pkt_len(skb);
+ 	/* fq_codel_drop() is quite expensive, as it performs a linear search
+ 	 * in q->backlogs[] to find a fat flow.
+ 	 * So instead of dropping a single packet, drop half of its backlog
+@@ -235,14 +238,23 @@ static int fq_codel_enqueue(struct sk_bu
+ 	 */
+ 	ret = fq_codel_drop(sch, q->drop_batch_size);
+ 
+-	q->drop_overlimit += prev_qlen - sch->q.qlen;
++	prev_qlen -= sch->q.qlen;
++	prev_backlog -= sch->qstats.backlog;
++	q->drop_overlimit += prev_qlen;
+ 	if (memory_limited)
+-		q->drop_overmemory += prev_qlen - sch->q.qlen;
+-	/* As we dropped packet(s), better let upper stack know this */
+-	qdisc_tree_reduce_backlog(sch, prev_qlen - sch->q.qlen,
+-				  prev_backlog - sch->qstats.backlog);
++		q->drop_overmemory += prev_qlen;
+ 
+-	return ret == idx ? NET_XMIT_CN : NET_XMIT_SUCCESS;
++	/* As we dropped packet(s), better let upper stack know this.
++	 * If we dropped a packet for this flow, return NET_XMIT_CN,
++	 * but in this case, our parents wont increase their backlogs.
++	 */
++	if (ret == idx) {
++		qdisc_tree_reduce_backlog(sch, prev_qlen - 1,
++					  prev_backlog - pkt_len);
++		return NET_XMIT_CN;
++	}
++	qdisc_tree_reduce_backlog(sch, prev_qlen, prev_backlog);
++	return NET_XMIT_SUCCESS;
+ }
+ 
+ /* This is the specific function called from codel_dequeue()
diff --git a/target/linux/generic/pending-4.4/041-mtd-spi-nor-include-mtd.h-header-for-struct-mtd_info.patch b/target/linux/generic/pending-4.4/041-mtd-spi-nor-include-mtd.h-header-for-struct-mtd_info.patch
new file mode 100644
index 0000000000..8214013c56
--- /dev/null
+++ b/target/linux/generic/pending-4.4/041-mtd-spi-nor-include-mtd.h-header-for-struct-mtd_info.patch
@@ -0,0 +1,39 @@
+From 2c81de771f38e54324ede3f24118f4852570b384 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Thu, 26 Nov 2015 09:05:04 +0100
+Subject: [PATCH] mtd: spi-nor: include mtd.h header for struct mtd_info
+ definition
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+So far struct spi_nor was using just a pointer to struct mtd_info so it
+wasn't needed to have it fully defined there. After recent change we
+embed whole struct so we need to include a proper header.
+
+Fixes: 1976367173a4 ("mtd: spi-nor: embed struct mtd_info within struct spi_nor")
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ include/linux/mtd/spi-nor.h | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/include/linux/mtd/spi-nor.h
++++ b/include/linux/mtd/spi-nor.h
+@@ -12,6 +12,7 @@
+ 
+ #include <linux/bitops.h>
+ #include <linux/mtd/cfi.h>
++#include <linux/mtd/mtd.h>
+ 
+ /*
+  * Manufacturer IDs
+@@ -117,8 +118,6 @@ enum spi_nor_option_flags {
+ 	SNOR_F_USE_FSR		= BIT(0),
+ };
+ 
+-struct mtd_info;
+-
+ /**
+  * struct spi_nor - Structure for defining a the SPI NOR layer
+  * @mtd:		point to a mtd_info structure
diff --git a/target/linux/generic/pending-4.4/042-0001-mtd-bcm47xxsflash-use-ioremap_cache-instead-of-KSEG0.patch b/target/linux/generic/pending-4.4/042-0001-mtd-bcm47xxsflash-use-ioremap_cache-instead-of-KSEG0.patch
new file mode 100644
index 0000000000..89f1e5eccf
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0001-mtd-bcm47xxsflash-use-ioremap_cache-instead-of-KSEG0.patch
@@ -0,0 +1,138 @@
+From 5651d6aaf489d1db48c253cf884b40214e91c2c5 Mon Sep 17 00:00:00 2001
+From: Brian Norris <computersforpeace@gmail.com>
+Date: Fri, 26 Feb 2016 11:50:28 +0100
+Subject: [PATCH] mtd: bcm47xxsflash: use ioremap_cache() instead of
+ KSEG0ADDR()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Using KSEG0ADDR makes code highly MIPS dependent and not portable.
+Thanks to the fix a68f376 ("MIPS: io.h: Define `ioremap_cache'") we can
+use ioremap_cache which is generic and supported on MIPS as well now.
+
+KSEG0ADDR was translating 0x1c000000 into 0x9c000000. With ioremap_cache
+we use MIPS's __ioremap (and then remap_area_pages). This results in
+different address (e.g. 0xc0080000) but it still should be cached as
+expected and it was successfully tested with BCM47186B0.
+
+Other than that drivers/bcma/driver_chipcommon_sflash.c nicely setups a
+struct resource for access window, but we wren't using it. Use it now
+and drop duplicated info.
+
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+---
+
+--- a/drivers/bcma/driver_chipcommon_sflash.c
++++ b/drivers/bcma/driver_chipcommon_sflash.c
+@@ -146,7 +146,6 @@ int bcma_sflash_init(struct bcma_drv_cc
+ 		return -ENOTSUPP;
+ 	}
+ 
+-	sflash->window = BCMA_SOC_FLASH2;
+ 	sflash->blocksize = e->blocksize;
+ 	sflash->numblocks = e->numblocks;
+ 	sflash->size = sflash->blocksize * sflash->numblocks;
+--- a/drivers/mtd/devices/bcm47xxsflash.c
++++ b/drivers/mtd/devices/bcm47xxsflash.c
+@@ -2,6 +2,7 @@
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
++#include <linux/ioport.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/platform_device.h>
+ #include <linux/bcma/bcma.h>
+@@ -109,8 +110,7 @@ static int bcm47xxsflash_read(struct mtd
+ 	if ((from + len) > mtd->size)
+ 		return -EINVAL;
+ 
+-	memcpy_fromio(buf, (void __iomem *)KSEG0ADDR(b47s->window + from),
+-		      len);
++	memcpy_fromio(buf, b47s->window + from, len);
+ 	*retlen = len;
+ 
+ 	return len;
+@@ -275,15 +275,33 @@ static void bcm47xxsflash_bcma_cc_write(
+ 
+ static int bcm47xxsflash_bcma_probe(struct platform_device *pdev)
+ {
+-	struct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);
++	struct device *dev = &pdev->dev;
++	struct bcma_sflash *sflash = dev_get_platdata(dev);
+ 	struct bcm47xxsflash *b47s;
++	struct resource *res;
+ 	int err;
+ 
+-	b47s = devm_kzalloc(&pdev->dev, sizeof(*b47s), GFP_KERNEL);
++	b47s = devm_kzalloc(dev, sizeof(*b47s), GFP_KERNEL);
+ 	if (!b47s)
+ 		return -ENOMEM;
+ 	sflash->priv = b47s;
+ 
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(dev, "invalid resource\n");
++		return -EINVAL;
++	}
++	if (!devm_request_mem_region(dev, res->start, resource_size(res),
++				     res->name)) {
++		dev_err(dev, "can't request region for resource %pR\n", res);
++		return -EBUSY;
++	}
++	b47s->window = ioremap_cache(res->start, resource_size(res));
++	if (!b47s->window) {
++		dev_err(dev, "ioremap failed for resource %pR\n", res);
++		return -ENOMEM;
++	}
++
+ 	b47s->bcma_cc = container_of(sflash, struct bcma_drv_cc, sflash);
+ 	b47s->cc_read = bcm47xxsflash_bcma_cc_read;
+ 	b47s->cc_write = bcm47xxsflash_bcma_cc_write;
+@@ -297,7 +315,6 @@ static int bcm47xxsflash_bcma_probe(stru
+ 		break;
+ 	}
+ 
+-	b47s->window = sflash->window;
+ 	b47s->blocksize = sflash->blocksize;
+ 	b47s->numblocks = sflash->numblocks;
+ 	b47s->size = sflash->size;
+@@ -306,6 +323,7 @@ static int bcm47xxsflash_bcma_probe(stru
+ 	err = mtd_device_parse_register(&b47s->mtd, probes, NULL, NULL, 0);
+ 	if (err) {
+ 		pr_err("Failed to register MTD device: %d\n", err);
++		iounmap(b47s->window);
+ 		return err;
+ 	}
+ 
+@@ -321,6 +339,7 @@ static int bcm47xxsflash_bcma_remove(str
+ 	struct bcm47xxsflash *b47s = sflash->priv;
+ 
+ 	mtd_device_unregister(&b47s->mtd);
++	iounmap(b47s->window);
+ 
+ 	return 0;
+ }
+--- a/drivers/mtd/devices/bcm47xxsflash.h
++++ b/drivers/mtd/devices/bcm47xxsflash.h
+@@ -65,7 +65,8 @@ struct bcm47xxsflash {
+ 
+ 	enum bcm47xxsflash_type type;
+ 
+-	u32 window;
++	void __iomem *window;
++
+ 	u32 blocksize;
+ 	u16 numblocks;
+ 	u32 size;
+--- a/include/linux/bcma/bcma_driver_chipcommon.h
++++ b/include/linux/bcma/bcma_driver_chipcommon.h
+@@ -588,7 +588,6 @@ struct bcma_pflash {
+ #ifdef CONFIG_BCMA_SFLASH
+ struct bcma_sflash {
+ 	bool present;
+-	u32 window;
+ 	u32 blocksize;
+ 	u16 numblocks;
+ 	u32 size;
diff --git a/target/linux/generic/pending-4.4/042-0002-mtd-add-arch-dependency-for-MTD_BCM47XXSFLASH-symbol.patch b/target/linux/generic/pending-4.4/042-0002-mtd-add-arch-dependency-for-MTD_BCM47XXSFLASH-symbol.patch
new file mode 100644
index 0000000000..b7ff055ab1
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0002-mtd-add-arch-dependency-for-MTD_BCM47XXSFLASH-symbol.patch
@@ -0,0 +1,41 @@
+From efacc699139e13f9d3ed8b47df92acb88ff8479f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Tue, 19 Jul 2016 09:08:32 +0200
+Subject: [PATCH] mtd: add arch dependency for MTD_BCM47XXSFLASH symbol
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We dropped strict MIPS dependency for bcm47xxsflash driver in:
+commit 5651d6aaf489 ("mtd: bcm47xxsflash: use ioremap_cache() instead of
+KSEG0ADDR()") but using ioremap_cache still limits building it to few
+selected architectures only.
+
+A recent commit 57d8f7dd2132 ("bcma: allow enabling serial flash support
+on non-MIPS SoCs") automatically dropped MIPS dependency for
+MTD_BCM47XXSFLASH which broke building e.g. on powerpc and cris.
+
+The bcma change is alright as it doesn't break building bcma code in any
+way. MTD_BCM47XXSFLASH on the other hand should be limited to archs
+which need it and can build it (by providing ioremap_cache).
+
+Fixes: 57d8f7dd2132 ("bcma: allow enabling serial flash support on non-MIPS SoCs")
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Cc: Brian Norris <computersforpeace@gmail.com>
+Acked-by: Brian Norris <computersforpeace@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/mtd/devices/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/mtd/devices/Kconfig
++++ b/drivers/mtd/devices/Kconfig
+@@ -114,7 +114,7 @@ config MTD_SST25L
+ 
+ config MTD_BCM47XXSFLASH
+ 	tristate "R/O support for serial flash on BCMA bus"
+-	depends on BCMA_SFLASH
++	depends on BCMA_SFLASH && (MIPS || ARM)
+ 	help
+ 	  BCMA bus can have various flash memories attached, they are
+ 	  registered by bcma as platform devices. This enables driver for
diff --git a/target/linux/generic/pending-4.4/042-0003-mtd-bcm47xxsflash-use-uncached-MMIO-access-for-BCM53.patch b/target/linux/generic/pending-4.4/042-0003-mtd-bcm47xxsflash-use-uncached-MMIO-access-for-BCM53.patch
new file mode 100644
index 0000000000..c2f2d21d03
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0003-mtd-bcm47xxsflash-use-uncached-MMIO-access-for-BCM53.patch
@@ -0,0 +1,59 @@
+From 64ad46379fcf14f437553f654d1adcd3d0e0d7f9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 15 Aug 2016 14:21:28 +0200
+Subject: [PATCH] mtd: bcm47xxsflash: use uncached MMIO access for BCM53573
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+BCM53573 is a new series of Broadcom's SoCs. It's based on ARM and uses
+this old ChipCommon-based flash access. Early tests resulted in flash
+corruptions that were tracked down to using cached MMIO for flash read
+access. Switch to ioremap_nocache conditionally to support BCM53573 and
+don't break performance on old MIPS devices.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/devices/bcm47xxsflash.c | 24 +++++++++++++++++++-----
+ 1 file changed, 19 insertions(+), 5 deletions(-)
+
+--- a/drivers/mtd/devices/bcm47xxsflash.c
++++ b/drivers/mtd/devices/bcm47xxsflash.c
+@@ -296,16 +296,30 @@ static int bcm47xxsflash_bcma_probe(stru
+ 		dev_err(dev, "can't request region for resource %pR\n", res);
+ 		return -EBUSY;
+ 	}
+-	b47s->window = ioremap_cache(res->start, resource_size(res));
+-	if (!b47s->window) {
+-		dev_err(dev, "ioremap failed for resource %pR\n", res);
+-		return -ENOMEM;
+-	}
+ 
+ 	b47s->bcma_cc = container_of(sflash, struct bcma_drv_cc, sflash);
+ 	b47s->cc_read = bcm47xxsflash_bcma_cc_read;
+ 	b47s->cc_write = bcm47xxsflash_bcma_cc_write;
+ 
++	/*
++	 * On old MIPS devices cache was magically invalidated when needed,
++	 * allowing us to use cached access and gain some performance. Trying
++	 * the same on ARM based BCM53573 results in flash corruptions, we need
++	 * to use uncached access for it.
++	 *
++	 * It may be arch specific, but right now there is only 1 ARM SoC using
++	 * this driver, so let's follow Broadcom's reference code and check
++	 * ChipCommon revision.
++	 */
++	if (b47s->bcma_cc->core->id.rev == 54)
++		b47s->window = ioremap_nocache(res->start, resource_size(res));
++	else
++		b47s->window = ioremap_cache(res->start, resource_size(res));
++	if (!b47s->window) {
++		dev_err(dev, "ioremap failed for resource %pR\n", res);
++		return -ENOMEM;
++	}
++
+ 	switch (b47s->bcma_cc->capabilities & BCMA_CC_CAP_FLASHT) {
+ 	case BCMA_CC_FLASHT_STSER:
+ 		b47s->type = BCM47XXSFLASH_TYPE_ST;
diff --git a/target/linux/generic/pending-4.4/042-0005-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch b/target/linux/generic/pending-4.4/042-0005-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch
new file mode 100644
index 0000000000..a68eaa4594
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0005-mtd-bcm47xxsflash-use-platform_-set-get-_drvdata.patch
@@ -0,0 +1,63 @@
+From be5e5099183301fb7920f8f6b66bd3ac1f820a97 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 16 Jan 2017 17:28:18 +0100
+Subject: [PATCH] mtd: bcm47xxsflash: use platform_(set|get)_drvdata
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We have generic place & helpers for storing platform driver data so
+there is no reason for using custom priv pointer.
+
+This allows cleaning up struct bcma_sflash from unneeded fields.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Kalle Valo <kvalo@codeaurora.org>
+Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/devices/bcm47xxsflash.c         | 6 +++---
+ include/linux/bcma/bcma_driver_chipcommon.h | 3 ---
+ 2 files changed, 3 insertions(+), 6 deletions(-)
+
+--- a/drivers/mtd/devices/bcm47xxsflash.c
++++ b/drivers/mtd/devices/bcm47xxsflash.c
+@@ -284,7 +284,6 @@ static int bcm47xxsflash_bcma_probe(stru
+ 	b47s = devm_kzalloc(dev, sizeof(*b47s), GFP_KERNEL);
+ 	if (!b47s)
+ 		return -ENOMEM;
+-	sflash->priv = b47s;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!res) {
+@@ -334,6 +333,8 @@ static int bcm47xxsflash_bcma_probe(stru
+ 	b47s->size = sflash->size;
+ 	bcm47xxsflash_fill_mtd(b47s, &pdev->dev);
+ 
++	platform_set_drvdata(pdev, b47s);
++
+ 	err = mtd_device_parse_register(&b47s->mtd, probes, NULL, NULL, 0);
+ 	if (err) {
+ 		pr_err("Failed to register MTD device: %d\n", err);
+@@ -349,8 +350,7 @@ static int bcm47xxsflash_bcma_probe(stru
+ 
+ static int bcm47xxsflash_bcma_remove(struct platform_device *pdev)
+ {
+-	struct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);
+-	struct bcm47xxsflash *b47s = sflash->priv;
++	struct bcm47xxsflash *b47s = platform_get_drvdata(pdev);
+ 
+ 	mtd_device_unregister(&b47s->mtd);
+ 	iounmap(b47s->window);
+--- a/include/linux/bcma/bcma_driver_chipcommon.h
++++ b/include/linux/bcma/bcma_driver_chipcommon.h
+@@ -591,9 +591,6 @@ struct bcma_sflash {
+ 	u32 blocksize;
+ 	u16 numblocks;
+ 	u32 size;
+-
+-	struct mtd_info *mtd;
+-	void *priv;
+ };
+ #endif
+ 
diff --git a/target/linux/generic/pending-4.4/042-0006-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch b/target/linux/generic/pending-4.4/042-0006-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch
new file mode 100644
index 0000000000..ecdae2a871
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0006-mtd-bcm47xxsflash-support-reading-flash-out-of-mappi.patch
@@ -0,0 +1,81 @@
+From ccc38234fdc70120be79e7fb2df5c27ca5cd4c8a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 8 Feb 2017 23:53:44 +0100
+Subject: [PATCH] mtd: bcm47xxsflash: support reading flash out of mapping
+ window
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+For reading flash content we use MMIO but it's possible to read only
+first 16 MiB this way. It's simply an arch design/limitation.
+To support flash sizes bigger than 16 MiB implement indirect access
+using ChipCommon registers.
+This has been tested using MX25L25635F.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Marek Vasut <marek.vasut@gmail.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/devices/bcm47xxsflash.c | 24 +++++++++++++++++++++---
+ drivers/mtd/devices/bcm47xxsflash.h |  3 +++
+ 2 files changed, 24 insertions(+), 3 deletions(-)
+
+--- a/drivers/mtd/devices/bcm47xxsflash.c
++++ b/drivers/mtd/devices/bcm47xxsflash.c
+@@ -105,15 +105,33 @@ static int bcm47xxsflash_read(struct mtd
+ 			      size_t *retlen, u_char *buf)
+ {
+ 	struct bcm47xxsflash *b47s = mtd->priv;
++	size_t orig_len = len;
+ 
+ 	/* Check address range */
+ 	if ((from + len) > mtd->size)
+ 		return -EINVAL;
+ 
+-	memcpy_fromio(buf, b47s->window + from, len);
+-	*retlen = len;
++	/* Read as much as possible using fast MMIO window */
++	if (from < BCM47XXSFLASH_WINDOW_SZ) {
++		size_t memcpy_len;
+ 
+-	return len;
++		memcpy_len = min(len, (size_t)(BCM47XXSFLASH_WINDOW_SZ - from));
++		memcpy_fromio(buf, b47s->window + from, memcpy_len);
++		from += memcpy_len;
++		len -= memcpy_len;
++		buf += memcpy_len;
++	}
++
++	/* Use indirect access for content out of the window */
++	for (; len; len--) {
++		b47s->cc_write(b47s, BCMA_CC_FLASHADDR, from++);
++		bcm47xxsflash_cmd(b47s, OPCODE_ST_READ4B);
++		*buf++ = b47s->cc_read(b47s, BCMA_CC_FLASHDATA);
++	}
++
++	*retlen = orig_len;
++
++	return orig_len;
+ }
+ 
+ static int bcm47xxsflash_write_st(struct mtd_info *mtd, u32 offset, size_t len,
+--- a/drivers/mtd/devices/bcm47xxsflash.h
++++ b/drivers/mtd/devices/bcm47xxsflash.h
+@@ -3,6 +3,8 @@
+ 
+ #include <linux/mtd/mtd.h>
+ 
++#define BCM47XXSFLASH_WINDOW_SZ			SZ_16M
++
+ /* Used for ST flashes only. */
+ #define OPCODE_ST_WREN		0x0006		/* Write Enable */
+ #define OPCODE_ST_WRDIS		0x0004		/* Write Disable */
+@@ -16,6 +18,7 @@
+ #define OPCODE_ST_RES		0x03ab		/* Read Electronic Signature */
+ #define OPCODE_ST_CSA		0x1000		/* Keep chip select asserted */
+ #define OPCODE_ST_SSE		0x0220		/* Sub-sector Erase */
++#define OPCODE_ST_READ4B	0x6313		/* Read Data Bytes in 4Byte addressing mode */
+ 
+ /* Used for Atmel flashes only. */
+ #define OPCODE_AT_READ				0x07e8
diff --git a/target/linux/generic/pending-4.4/042-0007-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch b/target/linux/generic/pending-4.4/042-0007-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch
new file mode 100644
index 0000000000..4ef7e7f5d8
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0007-mtd-bcm47xxpart-move-TRX-parsing-code-to-separated-f.patch
@@ -0,0 +1,180 @@
+From b522d7b0ebe3539340c2a6d46d787ae3d33bcb92 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 10 Jan 2017 23:15:24 +0100
+Subject: [PATCH] mtd: bcm47xxpart: move TRX parsing code to separated function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This change simplifies main parsing loop logic a bit. In future it may
+be useful for moving TRX support to separated module / parser (if we
+implement support for them at some point).
+Finally parsing TRX at the end puts us in a better position as we have
+better flash layout knowledge. It may be useful e.g. if it appears there
+is more than 1 TRX partition.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Marek Vasut <marek.vasut@gmail.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/bcm47xxpart.c | 121 ++++++++++++++++++++++++++++------------------
+ 1 file changed, 74 insertions(+), 47 deletions(-)
+
+--- a/drivers/mtd/bcm47xxpart.c
++++ b/drivers/mtd/bcm47xxpart.c
+@@ -83,6 +83,67 @@ out_default:
+ 	return "rootfs";
+ }
+ 
++static int bcm47xxpart_parse_trx(struct mtd_info *master,
++				 struct mtd_partition *trx,
++				 struct mtd_partition *parts,
++				 size_t parts_len)
++{
++	struct trx_header header;
++	size_t bytes_read;
++	int curr_part = 0;
++	int i, err;
++
++	if (parts_len < 3) {
++		pr_warn("No enough space to add TRX partitions!\n");
++		return -ENOMEM;
++	}
++
++	err = mtd_read(master, trx->offset, sizeof(header), &bytes_read,
++		       (uint8_t *)&header);
++	if (err && !mtd_is_bitflip(err)) {
++		pr_err("mtd_read error while reading TRX header: %d\n", err);
++		return err;
++	}
++
++	i = 0;
++
++	/* We have LZMA loader if offset[2] points to sth */
++	if (header.offset[2]) {
++		bcm47xxpart_add_part(&parts[curr_part++], "loader",
++				     trx->offset + header.offset[i], 0);
++		i++;
++	}
++
++	if (header.offset[i]) {
++		bcm47xxpart_add_part(&parts[curr_part++], "linux",
++				     trx->offset + header.offset[i], 0);
++		i++;
++	}
++
++	if (header.offset[i]) {
++		size_t offset = trx->offset + header.offset[i];
++		const char *name = bcm47xxpart_trx_data_part_name(master,
++								  offset);
++
++		bcm47xxpart_add_part(&parts[curr_part++], name, offset, 0);
++		i++;
++	}
++
++	/*
++	 * Assume that every partition ends at the beginning of the one it is
++	 * followed by.
++	 */
++	for (i = 0; i < curr_part; i++) {
++		u64 next_part_offset = (i < curr_part - 1) ?
++					parts[i + 1].offset :
++					trx->offset + trx->size;
++
++		parts[i].size = next_part_offset - parts[i].offset;
++	}
++
++	return curr_part;
++}
++
+ static int bcm47xxpart_parse(struct mtd_info *master,
+ 			     struct mtd_partition **pparts,
+ 			     struct mtd_part_parser_data *data)
+@@ -93,9 +154,7 @@ static int bcm47xxpart_parse(struct mtd_
+ 	size_t bytes_read;
+ 	uint32_t offset;
+ 	uint32_t blocksize = master->erasesize;
+-	struct trx_header *trx;
+ 	int trx_part = -1;
+-	int last_trx_part = -1;
+ 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
+ 	int err;
+ 
+@@ -182,54 +241,14 @@ static int bcm47xxpart_parse(struct mtd_
+ 
+ 		/* TRX */
+ 		if (buf[0x000 / 4] == TRX_MAGIC) {
+-			if (BCM47XXPART_MAX_PARTS - curr_part < 4) {
+-				pr_warn("Not enough partitions left to register trx, scanning stopped!\n");
+-				break;
+-			}
+-
+-			trx = (struct trx_header *)buf;
++			struct trx_header *trx;
+ 
+ 			trx_part = curr_part;
+ 			bcm47xxpart_add_part(&parts[curr_part++], "firmware",
+ 					     offset, 0);
+ 
+-			i = 0;
+-			/* We have LZMA loader if offset[2] points to sth */
+-			if (trx->offset[2]) {
+-				bcm47xxpart_add_part(&parts[curr_part++],
+-						     "loader",
+-						     offset + trx->offset[i],
+-						     0);
+-				i++;
+-			}
+-
+-			if (trx->offset[i]) {
+-				bcm47xxpart_add_part(&parts[curr_part++],
+-						     "linux",
+-						     offset + trx->offset[i],
+-						     0);
+-				i++;
+-			}
+-
+-			/*
+-			 * Pure rootfs size is known and can be calculated as:
+-			 * trx->length - trx->offset[i]. We don't fill it as
+-			 * we want to have jffs2 (overlay) in the same mtd.
+-			 */
+-			if (trx->offset[i]) {
+-				const char *name;
+-
+-				name = bcm47xxpart_trx_data_part_name(master, offset + trx->offset[i]);
+-				bcm47xxpart_add_part(&parts[curr_part++],
+-						     name,
+-						     offset + trx->offset[i],
+-						     0);
+-				i++;
+-			}
+-
+-			last_trx_part = curr_part - 1;
+-
+ 			/* Jump to the end of TRX */
++			trx = (struct trx_header *)buf;
+ 			offset = roundup(offset + trx->length, blocksize);
+ 			/* Next loop iteration will increase the offset */
+ 			offset -= blocksize;
+@@ -307,9 +326,17 @@ static int bcm47xxpart_parse(struct mtd_
+ 				       parts[i + 1].offset : master->size;
+ 
+ 		parts[i].size = next_part_offset - parts[i].offset;
+-		if (i == last_trx_part && trx_part >= 0)
+-			parts[trx_part].size = next_part_offset -
+-					       parts[trx_part].offset;
++	}
++
++	/* If there was TRX parse it now */
++	if (trx_part >= 0) {
++		int num_parts;
++
++		num_parts = bcm47xxpart_parse_trx(master, &parts[trx_part],
++						  parts + curr_part,
++						  BCM47XXPART_MAX_PARTS - curr_part);
++		if (num_parts > 0)
++			curr_part += num_parts;
+ 	}
+ 
+ 	*pparts = parts;
diff --git a/target/linux/generic/pending-4.4/042-0008-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch b/target/linux/generic/pending-4.4/042-0008-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch
new file mode 100644
index 0000000000..6c6c8397df
--- /dev/null
+++ b/target/linux/generic/pending-4.4/042-0008-mtd-bcm47xxpart-support-layouts-with-multiple-TRX-pa.patch
@@ -0,0 +1,112 @@
+From 89a0d9a9f1941a086a82bc7cd73d275cec98ba14 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 10 Jan 2017 23:15:25 +0100
+Subject: [PATCH] mtd: bcm47xxpart: support layouts with multiple TRX
+ partitions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some devices may have an extra TRX partition used as failsafe one. If
+we detect such partition we should set a proper name for it and don't
+parse it.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Marek Vasut <marek.vasut@gmail.com>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/bcm47xxpart.c | 56 ++++++++++++++++++++++++++++++++++++++---------
+ 1 file changed, 46 insertions(+), 10 deletions(-)
+
+--- a/drivers/mtd/bcm47xxpart.c
++++ b/drivers/mtd/bcm47xxpart.c
+@@ -9,6 +9,7 @@
+  *
+  */
+ 
++#include <linux/bcm47xx_nvram.h>
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/slab.h>
+@@ -144,6 +145,30 @@ static int bcm47xxpart_parse_trx(struct
+ 	return curr_part;
+ }
+ 
++/**
++ * bcm47xxpart_bootpartition - gets index of TRX partition used by bootloader
++ *
++ * Some devices may have more than one TRX partition. In such case one of them
++ * is the main one and another a failsafe one. Bootloader may fallback to the
++ * failsafe firmware if it detects corruption of the main image.
++ *
++ * This function provides info about currently used TRX partition. It's the one
++ * containing kernel started by the bootloader.
++ */
++static int bcm47xxpart_bootpartition(void)
++{
++	char buf[4];
++	int bootpartition;
++
++	/* Check CFE environment variable */
++	if (bcm47xx_nvram_getenv("bootpartition", buf, sizeof(buf)) > 0) {
++		if (!kstrtoint(buf, 0, &bootpartition))
++			return bootpartition;
++	}
++
++	return 0;
++}
++
+ static int bcm47xxpart_parse(struct mtd_info *master,
+ 			     struct mtd_partition **pparts,
+ 			     struct mtd_part_parser_data *data)
+@@ -154,7 +179,8 @@ static int bcm47xxpart_parse(struct mtd_
+ 	size_t bytes_read;
+ 	uint32_t offset;
+ 	uint32_t blocksize = master->erasesize;
+-	int trx_part = -1;
++	int trx_parts[2]; /* Array with indexes of TRX partitions */
++	int trx_num = 0; /* Number of found TRX partitions */
+ 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
+ 	int err;
+ 
+@@ -243,7 +269,11 @@ static int bcm47xxpart_parse(struct mtd_
+ 		if (buf[0x000 / 4] == TRX_MAGIC) {
+ 			struct trx_header *trx;
+ 
+-			trx_part = curr_part;
++			if (trx_num >= ARRAY_SIZE(trx_parts))
++				pr_warn("No enough space to store another TRX found at 0x%X\n",
++					offset);
++			else
++				trx_parts[trx_num++] = curr_part;
+ 			bcm47xxpart_add_part(&parts[curr_part++], "firmware",
+ 					     offset, 0);
+ 
+@@ -329,14 +359,20 @@ static int bcm47xxpart_parse(struct mtd_
+ 	}
+ 
+ 	/* If there was TRX parse it now */
+-	if (trx_part >= 0) {
+-		int num_parts;
++	for (i = 0; i < trx_num; i++) {
++		struct mtd_partition *trx = &parts[trx_parts[i]];
+ 
+-		num_parts = bcm47xxpart_parse_trx(master, &parts[trx_part],
+-						  parts + curr_part,
+-						  BCM47XXPART_MAX_PARTS - curr_part);
+-		if (num_parts > 0)
+-			curr_part += num_parts;
++		if (i == bcm47xxpart_bootpartition()) {
++			int num_parts;
++
++			num_parts = bcm47xxpart_parse_trx(master, trx,
++							  parts + curr_part,
++							  BCM47XXPART_MAX_PARTS - curr_part);
++			if (num_parts > 0)
++				curr_part += num_parts;
++		} else {
++			trx->name = "failsafe";
++		}
+ 	}
+ 
+ 	*pparts = parts;
diff --git a/target/linux/generic/pending-4.4/043-mtd-spi-nor-mx25l3205d-mx25l6405d-append-SECT_4K.patch b/target/linux/generic/pending-4.4/043-mtd-spi-nor-mx25l3205d-mx25l6405d-append-SECT_4K.patch
new file mode 100644
index 0000000000..b7fd046a23
--- /dev/null
+++ b/target/linux/generic/pending-4.4/043-mtd-spi-nor-mx25l3205d-mx25l6405d-append-SECT_4K.patch
@@ -0,0 +1,27 @@
+From 0501f2e5ff28a02295e42fc9e7164a20ef4c30d5 Mon Sep 17 00:00:00 2001
+From: Andreas Fenkart <afenkart@gmail.com>
+Date: Thu, 5 Nov 2015 10:04:23 +0100
+Subject: [PATCH] mtd: spi-nor: mx25l3205d/mx25l6405d: append SECT_4K
+
+according datasheet both chips can erase 4kByte sectors individually
+
+Signed-off-by: Andreas Fenkart <andreas.fenkart@dev.digitalstrom.org>
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -715,9 +715,9 @@ static const struct flash_info spi_nor_i
+ 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
+ 	{ "mx25l8005",   INFO(0xc22014, 0, 64 * 1024,  16, 0) },
+ 	{ "mx25l1606e",  INFO(0xc22015, 0, 64 * 1024,  32, SECT_4K) },
+-	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, 0) },
++	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
+-	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, 0) },
++	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
diff --git a/target/linux/generic/pending-4.4/045-mtd-devices-m25p80-add-support-for-mmap-read-request.patch b/target/linux/generic/pending-4.4/045-mtd-devices-m25p80-add-support-for-mmap-read-request.patch
new file mode 100644
index 0000000000..c4c7e6e01d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/045-mtd-devices-m25p80-add-support-for-mmap-read-request.patch
@@ -0,0 +1,46 @@
+From 08922f644878c9163ada8df3ef9def89be1d5e90 Mon Sep 17 00:00:00 2001
+From: Vignesh R <vigneshr@ti.com>
+Date: Tue, 29 Mar 2016 11:16:17 +0530
+Subject: [PATCH] mtd: devices: m25p80: add support for mmap read request
+
+Certain SPI controllers may provide accelerated hardware interface to
+read from m25p80 type flash devices in order to provide better read
+performance. SPI core supports such devices with spi_flash_read() API.
+Call spi_flash_read(), if supported, to make use of such interface.
+
+Signed-off-by: Vignesh R <vigneshr@ti.com>
+[Brian: add memset()]
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+---
+
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -131,6 +131,28 @@ static int m25p80_read(struct spi_nor *n
+ 	/* convert the dummy cycles to the number of bytes */
+ 	dummy /= 8;
+ 
++	if (spi_flash_read_supported(spi)) {
++		struct spi_flash_read_message msg;
++		int ret;
++
++		memset(&msg, 0, sizeof(msg));
++
++		msg.buf = buf;
++		msg.from = from;
++		msg.len = len;
++		msg.read_opcode = nor->read_opcode;
++		msg.addr_width = nor->addr_width;
++		msg.dummy_bytes = dummy;
++		/* TODO: Support other combinations */
++		msg.opcode_nbits = SPI_NBITS_SINGLE;
++		msg.addr_nbits = SPI_NBITS_SINGLE;
++		msg.data_nbits = m25p80_rx_nbits(nor);
++
++		ret = spi_flash_read(spi, &msg);
++		*retlen = msg.retlen;
++		return ret;
++	}
++
+ 	spi_message_init(&m);
+ 	memset(t, 0, (sizeof t));
+ 
diff --git a/target/linux/generic/pending-4.4/046-ubifs-silence-error-output-if-MS_SILENT-is-set.patch b/target/linux/generic/pending-4.4/046-ubifs-silence-error-output-if-MS_SILENT-is-set.patch
new file mode 100644
index 0000000000..95de680989
--- /dev/null
+++ b/target/linux/generic/pending-4.4/046-ubifs-silence-error-output-if-MS_SILENT-is-set.patch
@@ -0,0 +1,32 @@
+From 1ae92642e5900316011736072b4fa91710840620 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 18 Jun 2016 17:53:45 +0200
+Subject: [PATCH] ubifs: Silence error output if MS_SILENT is set
+
+This change completes commit
+90bea5a3f0 ("UBIFS: respect MS_SILENT mount flag")
+which already implements support for MS_SILENT except for that one
+error message which is still being displayed despite MS_SILENT being
+set. Suppress that error message as well in case MS_SILENT is set.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+[rw: massaged commit message]
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+ fs/ubifs/super.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/fs/ubifs/super.c
++++ b/fs/ubifs/super.c
+@@ -2107,8 +2107,9 @@ static struct dentry *ubifs_mount(struct
+ 	 */
+ 	ubi = open_ubi(name, UBI_READONLY);
+ 	if (IS_ERR(ubi)) {
+-		pr_err("UBIFS error (pid: %d): cannot open \"%s\", error %d",
+-		       current->pid, name, (int)PTR_ERR(ubi));
++		if (!(flags & MS_SILENT))
++			pr_err("UBIFS error (pid: %d): cannot open \"%s\", error %d",
++			       current->pid, name, (int)PTR_ERR(ubi));
+ 		return ERR_CAST(ubi);
+ 	}
+ 
diff --git a/target/linux/generic/pending-4.4/047-ubifs-silence-early-error-if-MS_SILENT-is-set.patch b/target/linux/generic/pending-4.4/047-ubifs-silence-early-error-if-MS_SILENT-is-set.patch
new file mode 100644
index 0000000000..189b96c41c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/047-ubifs-silence-early-error-if-MS_SILENT-is-set.patch
@@ -0,0 +1,54 @@
+From dccbc9197d2c3614f2fd6811874e1d982e4415f0 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 19 Jul 2016 00:26:55 +0200
+Subject: [PATCH] ubifs: Silence early error messages if MS_SILENT is set
+
+Probe-mounting a volume too small for UBIFS results in kernel log
+polution which might irritate users.
+Address this by silencing errors which may happen during boot if the
+rootfs is e.g. squashfs (and thus rather small) stored on a UBI volume.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+ fs/ubifs/super.c | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+--- a/fs/ubifs/super.c
++++ b/fs/ubifs/super.c
+@@ -520,19 +520,19 @@ static int init_constants_early(struct u
+ 	c->max_write_shift = fls(c->max_write_size) - 1;
+ 
+ 	if (c->leb_size < UBIFS_MIN_LEB_SZ) {
+-		ubifs_err(c, "too small LEBs (%d bytes), min. is %d bytes",
+-			  c->leb_size, UBIFS_MIN_LEB_SZ);
++		ubifs_errc(c, "too small LEBs (%d bytes), min. is %d bytes",
++			   c->leb_size, UBIFS_MIN_LEB_SZ);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (c->leb_cnt < UBIFS_MIN_LEB_CNT) {
+-		ubifs_err(c, "too few LEBs (%d), min. is %d",
+-			  c->leb_cnt, UBIFS_MIN_LEB_CNT);
++		ubifs_errc(c, "too few LEBs (%d), min. is %d",
++			   c->leb_cnt, UBIFS_MIN_LEB_CNT);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!is_power_of_2(c->min_io_size)) {
+-		ubifs_err(c, "bad min. I/O size %d", c->min_io_size);
++		ubifs_errc(c, "bad min. I/O size %d", c->min_io_size);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -543,8 +543,8 @@ static int init_constants_early(struct u
+ 	if (c->max_write_size < c->min_io_size ||
+ 	    c->max_write_size % c->min_io_size ||
+ 	    !is_power_of_2(c->max_write_size)) {
+-		ubifs_err(c, "bad write buffer size %d for %d min. I/O unit",
+-			  c->max_write_size, c->min_io_size);
++		ubifs_errc(c, "bad write buffer size %d for %d min. I/O unit",
++			   c->max_write_size, c->min_io_size);
+ 		return -EINVAL;
+ 	}
+ 
diff --git a/target/linux/generic/pending-4.4/048-mtd-spi-nor-backport-SPI_NOR_HAS_LOCK-flag.patch b/target/linux/generic/pending-4.4/048-mtd-spi-nor-backport-SPI_NOR_HAS_LOCK-flag.patch
new file mode 100644
index 0000000000..69a5432fa7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/048-mtd-spi-nor-backport-SPI_NOR_HAS_LOCK-flag.patch
@@ -0,0 +1,47 @@
+From 76a4707de5e18dc32d9cb4e990686140c5664a15 Mon Sep 17 00:00:00 2001
+From: Brian Norris <computersforpeace@gmail.com>
+Date: Fri, 29 Jan 2016 11:25:35 -0800
+Subject: [PATCH] mtd: spi-nor: add SPI_NOR_HAS_LOCK flag
+
+We can't determine this purely by manufacturer type (see commit
+67b9bcd36906 ("mtd: spi-nor: fix Spansion regressions (aliased with
+Winbond)")), and it's not autodetectable by anything like SFDP. So make
+a new flag for it.
+
+Signed-off-by: Brian Norris <computersforpeace@gmail.com>
+Reviewed-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
+Tested-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -68,6 +68,7 @@ struct flash_info {
+ #define	SPI_NOR_DUAL_READ	0x20    /* Flash supports Dual Read */
+ #define	SPI_NOR_QUAD_READ	0x40    /* Flash supports Quad Read */
+ #define	USE_FSR			0x80	/* use flag status register */
++#define	SPI_NOR_HAS_LOCK	0x100	/* Flash supports lock/unlock via SR */
+ };
+ 
+ #define JEDEC_MFR(info)	((info)->id[0])
+@@ -1163,7 +1164,8 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 
+ 	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
+ 	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
+-	    JEDEC_MFR(info) == SNOR_MFR_SST) {
++	    JEDEC_MFR(info) == SNOR_MFR_SST ||
++	    info->flags & SPI_NOR_HAS_LOCK) {
+ 		write_enable(nor);
+ 		write_sr(nor, 0);
+ 	}
+@@ -1179,7 +1181,8 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 	mtd->_read = spi_nor_read;
+ 
+ 	/* NOR protection support for STmicro/Micron chips and similar */
+-	if (JEDEC_MFR(info) == SNOR_MFR_MICRON) {
++	if (JEDEC_MFR(info) == SNOR_MFR_MICRON ||
++		info->flags & SPI_NOR_HAS_LOCK) {
+ 		nor->flash_lock = stm_lock;
+ 		nor->flash_unlock = stm_unlock;
+ 		nor->flash_is_locked = stm_is_locked;
diff --git a/target/linux/generic/pending-4.4/050-backport_netfilter_rtcache.patch b/target/linux/generic/pending-4.4/050-backport_netfilter_rtcache.patch
new file mode 100644
index 0000000000..ddf5ba96b6
--- /dev/null
+++ b/target/linux/generic/pending-4.4/050-backport_netfilter_rtcache.patch
@@ -0,0 +1,531 @@
+Subject: netfilter: conntrack: cache route for forwarded connections
+
+... to avoid per-packet FIB lookup if possible.
+
+The cached dst is re-used provided the input interface
+is the same as that of the previous packet in the same direction.
+
+If not, the cached dst is invalidated.
+
+For ipv6 we also need to store sernum, else dst_check doesn't work,
+pointed out by Eric Dumazet.
+
+This should speed up forwarding when conntrack is already in use
+anyway, especially when using reverse path filtering -- active RPF
+enforces two FIB lookups for each packet.
+
+Before the routing cache removal this didn't matter since RPF was performed
+only when route cache didn't yield a result; but without route cache it
+comes at higher price.
+
+Julian Anastasov suggested to add NETDEV_UNREGISTER handler to
+avoid holding on to dsts of 'frozen' conntracks.
+
+Signed-off-by: Florian Westphal <fw@strlen.de>
+
+--- a/include/net/netfilter/nf_conntrack_extend.h
++++ b/include/net/netfilter/nf_conntrack_extend.h
+@@ -30,6 +30,9 @@ enum nf_ct_ext_id {
+ #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
+ 	NF_CT_EXT_SYNPROXY,
+ #endif
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
++	NF_CT_EXT_RTCACHE,
++#endif
+ 	NF_CT_EXT_NUM,
+ };
+ 
+@@ -43,6 +46,7 @@ enum nf_ct_ext_id {
+ #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
+ #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
+ #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
++#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
+ 
+ /* Extensions: optional stuff which isn't permanently in struct. */
+ struct nf_ct_ext {
+--- /dev/null
++++ b/include/net/netfilter/nf_conntrack_rtcache.h
+@@ -0,0 +1,34 @@
++#include <linux/gfp.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_extend.h>
++
++struct dst_entry;
++
++struct nf_conn_dst_cache {
++	struct dst_entry *dst;
++	int iif;
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++	u32 cookie;
++#endif
++
++};
++
++struct nf_conn_rtcache {
++	struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
++};
++
++static inline
++struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
++{
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
++	return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
++#else
++	return NULL;
++#endif
++}
++
++static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
++					  enum ip_conntrack_dir dir)
++{
++	return rtc->cached_dst[dir].iif;
++}
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -114,6 +114,18 @@ config NF_CONNTRACK_EVENTS
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_RTCACHE
++	tristate "Cache route entries in conntrack objects"
++	depends on NETFILTER_ADVANCED
++	depends on NF_CONNTRACK
++	help
++	  If this option is enabled, the connection tracking code will
++	  cache routing information for each connection that is being
++	  forwarded, at a cost of 32 bytes per conntrack object.
++
++	  To compile it as a module, choose M here.  If unsure, say N.
++	  The module will be called nf_conntrack_rtcache.
++
+ config NF_CONNTRACK_TIMEOUT
+ 	bool  'Connection tracking timeout'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -16,6 +16,9 @@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += n
+ # connection tracking
+ obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
+ 
++# optional conntrack route cache extension
++obj-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
++
+ # SCTP protocol connection tracking
+ obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
+ obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
+--- /dev/null
++++ b/net/netfilter/nf_conntrack_rtcache.c
+@@ -0,0 +1,413 @@
++/* route cache for netfilter.
++ *
++ * (C) 2014 Red Hat GmbH
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
++
++#include <linux/types.h>
++#include <linux/netfilter.h>
++#include <linux/skbuff.h>
++#include <linux/stddef.h>
++#include <linux/kernel.h>
++#include <linux/netdevice.h>
++#include <linux/export.h>
++#include <linux/module.h>
++
++#include <net/dst.h>
++
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_core.h>
++#include <net/netfilter/nf_conntrack_extend.h>
++#include <net/netfilter/nf_conntrack_rtcache.h>
++
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++#include <net/ip6_fib.h>
++#endif
++
++static void __nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc,
++				      enum ip_conntrack_dir dir)
++{
++	struct dst_entry *dst = rtc->cached_dst[dir].dst;
++
++	dst_release(dst);
++}
++
++static void nf_conn_rtcache_destroy(struct nf_conn *ct)
++{
++	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
++
++	if (!rtc)
++		return;
++
++	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
++	__nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
++}
++
++static void nf_ct_rtcache_ext_add(struct nf_conn *ct)
++{
++	struct nf_conn_rtcache *rtc;
++
++	rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
++	if (rtc) {
++		rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
++		rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
++		rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
++		rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
++	}
++}
++
++static struct nf_conn_rtcache *nf_ct_rtcache_find_usable(struct nf_conn *ct)
++{
++	if (nf_ct_is_untracked(ct))
++		return NULL;
++	return nf_ct_rtcache_find(ct);
++}
++
++static struct dst_entry *
++nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc,
++			enum ip_conntrack_dir dir)
++{
++	return rtc->cached_dst[dir].dst;
++}
++
++static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
++{
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++	if (pf == NFPROTO_IPV6) {
++		const struct rt6_info *rt = (const struct rt6_info *)dst;
++
++		if (rt->rt6i_node)
++			return (u32)rt->rt6i_node->fn_sernum;
++	}
++#endif
++	return 0;
++}
++
++static void nf_conn_rtcache_dst_set(int pf,
++				    struct nf_conn_rtcache *rtc,
++				    struct dst_entry *dst,
++				    enum ip_conntrack_dir dir, int iif)
++{
++	if (rtc->cached_dst[dir].iif != iif)
++		rtc->cached_dst[dir].iif = iif;
++
++	if (rtc->cached_dst[dir].dst != dst) {
++		struct dst_entry *old;
++
++		dst_hold(dst);
++
++		old = xchg(&rtc->cached_dst[dir].dst, dst);
++		dst_release(old);
++
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++		if (pf == NFPROTO_IPV6)
++			rtc->cached_dst[dir].cookie =
++				nf_rtcache_get_cookie(pf, dst);
++#endif
++	}
++}
++
++static void nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc,
++					 enum ip_conntrack_dir dir)
++{
++	struct dst_entry *old;
++
++	pr_debug("Invalidate iif %d for dir %d on cache %p\n",
++		 rtc->cached_dst[dir].iif, dir, rtc);
++
++	old = xchg(&rtc->cached_dst[dir].dst, NULL);
++	dst_release(old);
++	rtc->cached_dst[dir].iif = -1;
++}
++
++static unsigned int nf_rtcache_in(u_int8_t pf,
++				  struct sk_buff *skb,
++				  const struct nf_hook_state *state)
++{
++	struct nf_conn_rtcache *rtc;
++	enum ip_conntrack_info ctinfo;
++	enum ip_conntrack_dir dir;
++	struct dst_entry *dst;
++	struct nf_conn *ct;
++	int iif;
++	u32 cookie;
++
++	if (skb_dst(skb) || skb->sk)
++		return NF_ACCEPT;
++
++	ct = nf_ct_get(skb, &ctinfo);
++	if (!ct)
++		return NF_ACCEPT;
++
++	rtc = nf_ct_rtcache_find_usable(ct);
++	if (!rtc)
++		return NF_ACCEPT;
++
++	/* if iif changes, don't use cache and let ip stack
++	 * do route lookup.
++	 *
++	 * If rp_filter is enabled it might toss skb, so
++	 * we don't want to avoid these checks.
++	 */
++	dir = CTINFO2DIR(ctinfo);
++	iif = nf_conn_rtcache_iif_get(rtc, dir);
++	if (state->in->ifindex != iif) {
++		pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
++			 ct, iif, state->in->ifindex);
++		return NF_ACCEPT;
++	}
++	dst = nf_conn_rtcache_dst_get(rtc, dir);
++	if (dst == NULL)
++		return NF_ACCEPT;
++
++	cookie = nf_rtcache_get_cookie(pf, dst);
++
++	dst = dst_check(dst, cookie);
++	pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
++	if (likely(dst))
++		skb_dst_set_noref(skb, dst);
++	else
++		nf_conn_rtcache_dst_obsolete(rtc, dir);
++
++	return NF_ACCEPT;
++}
++
++static unsigned int nf_rtcache_forward(u_int8_t pf,
++				       struct sk_buff *skb,
++				       const struct nf_hook_state *state)
++{
++	struct nf_conn_rtcache *rtc;
++	enum ip_conntrack_info ctinfo;
++	enum ip_conntrack_dir dir;
++	struct nf_conn *ct;
++	struct dst_entry *dst = skb_dst(skb);
++	int iif;
++
++	ct = nf_ct_get(skb, &ctinfo);
++	if (!ct)
++		return NF_ACCEPT;
++
++	if (dst && dst_xfrm(dst))
++		return NF_ACCEPT;
++
++	if (!nf_ct_is_confirmed(ct)) {
++		if (WARN_ON(nf_ct_rtcache_find(ct)))
++			return NF_ACCEPT;
++		nf_ct_rtcache_ext_add(ct);
++		return NF_ACCEPT;
++	}
++
++	rtc = nf_ct_rtcache_find_usable(ct);
++	if (!rtc)
++		return NF_ACCEPT;
++
++	dir = CTINFO2DIR(ctinfo);
++	iif = nf_conn_rtcache_iif_get(rtc, dir);
++	pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
++		 ct, skb, dir, iif, state->in->ifindex);
++	if (likely(state->in->ifindex == iif))
++		return NF_ACCEPT;
++
++	nf_conn_rtcache_dst_set(pf, rtc, skb_dst(skb), dir, state->in->ifindex);
++	return NF_ACCEPT;
++}
++
++static unsigned int nf_rtcache_in4(void *priv,
++				  struct sk_buff *skb,
++				  const struct nf_hook_state *state)
++{
++	return nf_rtcache_in(NFPROTO_IPV4, skb, state);
++}
++
++static unsigned int nf_rtcache_forward4(void *priv,
++				       struct sk_buff *skb,
++				       const struct nf_hook_state *state)
++{
++	return nf_rtcache_forward(NFPROTO_IPV4, skb, state);
++}
++
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++static unsigned int nf_rtcache_in6(void *priv,
++				  struct sk_buff *skb,
++				  const struct nf_hook_state *state)
++{
++	return nf_rtcache_in(NFPROTO_IPV6, skb, state);
++}
++
++static unsigned int nf_rtcache_forward6(void *priv,
++				       struct sk_buff *skb,
++				       const struct nf_hook_state *state)
++{
++ 	return nf_rtcache_forward(NFPROTO_IPV6, skb, state);
++}
++#endif
++
++static int nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
++{
++	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
++	struct net_device *dev = data;
++
++	if (!rtc)
++		return 0;
++
++	if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
++	    dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
++		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
++		nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
++	}
++
++	return 0;
++}
++
++static int nf_rtcache_netdev_event(struct notifier_block *this,
++				   unsigned long event, void *ptr)
++{
++	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
++	struct net *net = dev_net(dev);
++
++	if (event == NETDEV_DOWN)
++		nf_ct_iterate_cleanup(net, nf_rtcache_dst_remove, dev, 0, 0);
++
++	return NOTIFY_DONE;
++}
++
++static struct notifier_block nf_rtcache_notifier = {
++	.notifier_call = nf_rtcache_netdev_event,
++};
++
++static struct nf_hook_ops rtcache_ops[] = {
++	{
++		.hook		= nf_rtcache_in4,
++		.pf		= NFPROTO_IPV4,
++		.hooknum	= NF_INET_PRE_ROUTING,
++		.priority       = NF_IP_PRI_LAST,
++	},
++	{
++		.hook           = nf_rtcache_forward4,
++		.pf             = NFPROTO_IPV4,
++		.hooknum        = NF_INET_FORWARD,
++		.priority       = NF_IP_PRI_LAST,
++	},
++#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
++	{
++		.hook		= nf_rtcache_in6,
++		.pf		= NFPROTO_IPV6,
++		.hooknum	= NF_INET_PRE_ROUTING,
++		.priority       = NF_IP_PRI_LAST,
++	},
++	{
++		.hook           = nf_rtcache_forward6,
++		.pf             = NFPROTO_IPV6,
++		.hooknum        = NF_INET_FORWARD,
++		.priority       = NF_IP_PRI_LAST,
++	},
++#endif
++};
++
++static struct nf_ct_ext_type rtcache_extend __read_mostly = {
++	.len	= sizeof(struct nf_conn_rtcache),
++	.align	= __alignof__(struct nf_conn_rtcache),
++	.id	= NF_CT_EXT_RTCACHE,
++	.destroy = nf_conn_rtcache_destroy,
++};
++
++static int __init nf_conntrack_rtcache_init(void)
++{
++	int ret = nf_ct_extend_register(&rtcache_extend);
++
++	if (ret < 0) {
++		pr_err("nf_conntrack_rtcache: Unable to register extension\n");
++		return ret;
++	}
++
++	ret = nf_register_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
++	if (ret < 0) {
++		nf_ct_extend_unregister(&rtcache_extend);
++		return ret;
++	}
++
++	ret = register_netdevice_notifier(&nf_rtcache_notifier);
++	if (ret) {
++		nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
++		nf_ct_extend_unregister(&rtcache_extend);
++	}
++
++	return ret;
++}
++
++static int nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
++{
++	struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
++
++	return rtc != NULL;
++}
++
++static bool __exit nf_conntrack_rtcache_wait_for_dying(struct net *net)
++{
++	bool wait = false;
++	int cpu;
++
++	for_each_possible_cpu(cpu) {
++		struct nf_conntrack_tuple_hash *h;
++		struct hlist_nulls_node *n;
++		struct nf_conn *ct;
++		struct ct_pcpu *pcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);
++
++		rcu_read_lock();
++		spin_lock_bh(&pcpu->lock);
++
++		hlist_nulls_for_each_entry(h, n, &pcpu->dying, hnnode) {
++			ct = nf_ct_tuplehash_to_ctrack(h);
++			if (nf_ct_rtcache_find(ct) != NULL) {
++				wait = true;
++				break;
++			}
++		}
++		spin_unlock_bh(&pcpu->lock);
++		rcu_read_unlock();
++	}
++
++	return wait;
++}
++
++static void __exit nf_conntrack_rtcache_fini(void)
++{
++	struct net *net;
++	int count = 0;
++
++	/* remove hooks so no new connections get rtcache extension */
++	nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
++
++	synchronize_net();
++
++	unregister_netdevice_notifier(&nf_rtcache_notifier);
++
++	rtnl_lock();
++
++	/* zap all conntracks with rtcache extension */
++	for_each_net(net)
++		nf_ct_iterate_cleanup(net, nf_rtcache_ext_remove, NULL, 0, 0);
++
++	for_each_net(net) {
++		/* .. and make sure they're gone from dying list, too */
++		while (nf_conntrack_rtcache_wait_for_dying(net)) {
++			msleep(200);
++			WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
++		}
++	}
++
++	rtnl_unlock();
++	synchronize_net();
++	nf_ct_extend_unregister(&rtcache_extend);
++}
++module_init(nf_conntrack_rtcache_init);
++module_exit(nf_conntrack_rtcache_fini);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Florian Westphal <fw@strlen.de>");
++MODULE_DESCRIPTION("Conntrack route cache extension");
diff --git a/target/linux/generic/pending-4.4/051-0001-ovl-rename-is_merge-to-is_lowest.patch b/target/linux/generic/pending-4.4/051-0001-ovl-rename-is_merge-to-is_lowest.patch
new file mode 100644
index 0000000000..79140b9008
--- /dev/null
+++ b/target/linux/generic/pending-4.4/051-0001-ovl-rename-is_merge-to-is_lowest.patch
@@ -0,0 +1,72 @@
+From 56656e960b555cb98bc414382566dcb59aae99a2 Mon Sep 17 00:00:00 2001
+From: Miklos Szeredi <mszeredi@redhat.com>
+Date: Mon, 21 Mar 2016 17:31:46 +0100
+Subject: [PATCH] ovl: rename is_merge to is_lowest
+
+The 'is_merge' is an historical naming from when only a single lower layer
+could exist.  With the introduction of multiple lower layers the meaning of
+this flag was changed to mean only the "lowest layer" (while all lower
+layers were being merged).
+
+So now 'is_merge' is inaccurate and hence renaming to 'is_lowest'
+
+Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
+---
+ fs/overlayfs/readdir.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/fs/overlayfs/readdir.c
++++ b/fs/overlayfs/readdir.c
+@@ -36,7 +36,7 @@ struct ovl_dir_cache {
+ 
+ struct ovl_readdir_data {
+ 	struct dir_context ctx;
+-	bool is_merge;
++	bool is_lowest;
+ 	struct rb_root root;
+ 	struct list_head *list;
+ 	struct list_head middle;
+@@ -139,9 +139,9 @@ static int ovl_cache_entry_add_rb(struct
+ 	return 0;
+ }
+ 
+-static int ovl_fill_lower(struct ovl_readdir_data *rdd,
+-			  const char *name, int namelen,
+-			  loff_t offset, u64 ino, unsigned int d_type)
++static int ovl_fill_lowest(struct ovl_readdir_data *rdd,
++			   const char *name, int namelen,
++			   loff_t offset, u64 ino, unsigned int d_type)
+ {
+ 	struct ovl_cache_entry *p;
+ 
+@@ -193,10 +193,10 @@ static int ovl_fill_merge(struct dir_con
+ 		container_of(ctx, struct ovl_readdir_data, ctx);
+ 
+ 	rdd->count++;
+-	if (!rdd->is_merge)
++	if (!rdd->is_lowest)
+ 		return ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);
+ 	else
+-		return ovl_fill_lower(rdd, name, namelen, offset, ino, d_type);
++		return ovl_fill_lowest(rdd, name, namelen, offset, ino, d_type);
+ }
+ 
+ static int ovl_check_whiteouts(struct dentry *dir, struct ovl_readdir_data *rdd)
+@@ -289,7 +289,7 @@ static int ovl_dir_read_merged(struct de
+ 		.ctx.actor = ovl_fill_merge,
+ 		.list = list,
+ 		.root = RB_ROOT,
+-		.is_merge = false,
++		.is_lowest = false,
+ 	};
+ 	int idx, next;
+ 
+@@ -306,7 +306,7 @@ static int ovl_dir_read_merged(struct de
+ 			 * allows offsets to be reasonably constant
+ 			 */
+ 			list_add(&rdd.middle, rdd.list);
+-			rdd.is_merge = true;
++			rdd.is_lowest = true;
+ 			err = ovl_dir_read(&realpath, &rdd);
+ 			list_del(&rdd.middle);
+ 		}
diff --git a/target/linux/generic/pending-4.4/051-0002-ovl-override-creds-with-the-ones-from-the-superblock.patch b/target/linux/generic/pending-4.4/051-0002-ovl-override-creds-with-the-ones-from-the-superblock.patch
new file mode 100644
index 0000000000..208bc61ec5
--- /dev/null
+++ b/target/linux/generic/pending-4.4/051-0002-ovl-override-creds-with-the-ones-from-the-superblock.patch
@@ -0,0 +1,336 @@
+From 3fe6e52f062643676eb4518d68cee3bc1272091b Mon Sep 17 00:00:00 2001
+From: Antonio Murdaca <amurdaca@redhat.com>
+Date: Thu, 7 Apr 2016 15:48:25 +0200
+Subject: [PATCH] ovl: override creds with the ones from the superblock mounter
+
+In user namespace the whiteout creation fails with -EPERM because the
+current process isn't capable(CAP_SYS_ADMIN) when setting xattr.
+
+A simple reproducer:
+
+$ mkdir upper lower work merged lower/dir
+$ sudo mount -t overlay overlay -olowerdir=lower,upperdir=upper,workdir=work merged
+$ unshare -m -p -f -U -r bash
+
+Now as root in the user namespace:
+
+\# touch merged/dir/{1,2,3} # this will force a copy up of lower/dir
+\# rm -fR merged/*
+
+This ends up failing with -EPERM after the files in dir has been
+correctly deleted:
+
+unlinkat(4, "2", 0)                     = 0
+unlinkat(4, "1", 0)                     = 0
+unlinkat(4, "3", 0)                     = 0
+close(4)                                = 0
+unlinkat(AT_FDCWD, "merged/dir", AT_REMOVEDIR) = -1 EPERM (Operation not
+permitted)
+
+Interestingly, if you don't place files in merged/dir you can remove it,
+meaning if upper/dir does not exist, creating the char device file works
+properly in that same location.
+
+This patch uses ovl_sb_creator_cred() to get the cred struct from the
+superblock mounter and override the old cred with these new ones so that
+the whiteout creation is possible because overlay is wrong in assuming that
+the creds it will get with prepare_creds will be in the initial user
+namespace.  The old cap_raise game is removed in favor of just overriding
+the old cred struct.
+
+This patch also drops from ovl_copy_up_one() the following two lines:
+
+override_cred->fsuid = stat->uid;
+override_cred->fsgid = stat->gid;
+
+This is because the correct uid and gid are taken directly with the stat
+struct and correctly set with ovl_set_attr().
+
+Signed-off-by: Antonio Murdaca <runcom@redhat.com>
+Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
+---
+ fs/overlayfs/copy_up.c   | 26 +------------------
+ fs/overlayfs/dir.c       | 67 ++++--------------------------------------------
+ fs/overlayfs/overlayfs.h |  1 +
+ fs/overlayfs/readdir.c   | 14 +++-------
+ fs/overlayfs/super.c     | 18 ++++++++++++-
+ 5 files changed, 27 insertions(+), 99 deletions(-)
+
+--- a/fs/overlayfs/copy_up.c
++++ b/fs/overlayfs/copy_up.c
+@@ -317,7 +317,6 @@ int ovl_copy_up_one(struct dentry *paren
+ 	struct dentry *upperdir;
+ 	struct dentry *upperdentry;
+ 	const struct cred *old_cred;
+-	struct cred *override_cred;
+ 	char *link = NULL;
+ 
+ 	if (WARN_ON(!workdir))
+@@ -336,28 +335,7 @@ int ovl_copy_up_one(struct dentry *paren
+ 			return PTR_ERR(link);
+ 	}
+ 
+-	err = -ENOMEM;
+-	override_cred = prepare_creds();
+-	if (!override_cred)
+-		goto out_free_link;
+-
+-	override_cred->fsuid = stat->uid;
+-	override_cred->fsgid = stat->gid;
+-	/*
+-	 * CAP_SYS_ADMIN for copying up extended attributes
+-	 * CAP_DAC_OVERRIDE for create
+-	 * CAP_FOWNER for chmod, timestamp update
+-	 * CAP_FSETID for chmod
+-	 * CAP_CHOWN for chown
+-	 * CAP_MKNOD for mknod
+-	 */
+-	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
+-	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+-	cap_raise(override_cred->cap_effective, CAP_FOWNER);
+-	cap_raise(override_cred->cap_effective, CAP_FSETID);
+-	cap_raise(override_cred->cap_effective, CAP_CHOWN);
+-	cap_raise(override_cred->cap_effective, CAP_MKNOD);
+-	old_cred = override_creds(override_cred);
++	old_cred = ovl_override_creds(dentry->d_sb);
+ 
+ 	err = -EIO;
+ 	if (lock_rename(workdir, upperdir) != NULL) {
+@@ -380,9 +358,7 @@ int ovl_copy_up_one(struct dentry *paren
+ out_unlock:
+ 	unlock_rename(workdir, upperdir);
+ 	revert_creds(old_cred);
+-	put_cred(override_cred);
+ 
+-out_free_link:
+ 	if (link)
+ 		free_page((unsigned long) link);
+ 
+--- a/fs/overlayfs/dir.c
++++ b/fs/overlayfs/dir.c
+@@ -408,28 +408,13 @@ static int ovl_create_or_link(struct den
+ 		err = ovl_create_upper(dentry, inode, &stat, link, hardlink);
+ 	} else {
+ 		const struct cred *old_cred;
+-		struct cred *override_cred;
+ 
+-		err = -ENOMEM;
+-		override_cred = prepare_creds();
+-		if (!override_cred)
+-			goto out_iput;
+-
+-		/*
+-		 * CAP_SYS_ADMIN for setting opaque xattr
+-		 * CAP_DAC_OVERRIDE for create in workdir, rename
+-		 * CAP_FOWNER for removing whiteout from sticky dir
+-		 */
+-		cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
+-		cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+-		cap_raise(override_cred->cap_effective, CAP_FOWNER);
+-		old_cred = override_creds(override_cred);
++		old_cred = ovl_override_creds(dentry->d_sb);
+ 
+ 		err = ovl_create_over_whiteout(dentry, inode, &stat, link,
+ 					       hardlink);
+ 
+ 		revert_creds(old_cred);
+-		put_cred(override_cred);
+ 	}
+ 
+ 	if (!err)
+@@ -659,32 +644,11 @@ static int ovl_do_remove(struct dentry *
+ 	if (OVL_TYPE_PURE_UPPER(type)) {
+ 		err = ovl_remove_upper(dentry, is_dir);
+ 	} else {
+-		const struct cred *old_cred;
+-		struct cred *override_cred;
+-
+-		err = -ENOMEM;
+-		override_cred = prepare_creds();
+-		if (!override_cred)
+-			goto out_drop_write;
+-
+-		/*
+-		 * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir
+-		 * CAP_DAC_OVERRIDE for create in workdir, rename
+-		 * CAP_FOWNER for removing whiteout from sticky dir
+-		 * CAP_FSETID for chmod of opaque dir
+-		 * CAP_CHOWN for chown of opaque dir
+-		 */
+-		cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
+-		cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+-		cap_raise(override_cred->cap_effective, CAP_FOWNER);
+-		cap_raise(override_cred->cap_effective, CAP_FSETID);
+-		cap_raise(override_cred->cap_effective, CAP_CHOWN);
+-		old_cred = override_creds(override_cred);
++		const struct cred *old_cred = ovl_override_creds(dentry->d_sb);
+ 
+ 		err = ovl_remove_and_whiteout(dentry, is_dir);
+ 
+ 		revert_creds(old_cred);
+-		put_cred(override_cred);
+ 	}
+ out_drop_write:
+ 	ovl_drop_write(dentry);
+@@ -723,7 +687,6 @@ static int ovl_rename2(struct inode *old
+ 	bool new_is_dir = false;
+ 	struct dentry *opaquedir = NULL;
+ 	const struct cred *old_cred = NULL;
+-	struct cred *override_cred = NULL;
+ 
+ 	err = -EINVAL;
+ 	if (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))
+@@ -792,26 +755,8 @@ static int ovl_rename2(struct inode *old
+ 	old_opaque = !OVL_TYPE_PURE_UPPER(old_type);
+ 	new_opaque = !OVL_TYPE_PURE_UPPER(new_type);
+ 
+-	if (old_opaque || new_opaque) {
+-		err = -ENOMEM;
+-		override_cred = prepare_creds();
+-		if (!override_cred)
+-			goto out_drop_write;
+-
+-		/*
+-		 * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir
+-		 * CAP_DAC_OVERRIDE for create in workdir
+-		 * CAP_FOWNER for removing whiteout from sticky dir
+-		 * CAP_FSETID for chmod of opaque dir
+-		 * CAP_CHOWN for chown of opaque dir
+-		 */
+-		cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
+-		cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+-		cap_raise(override_cred->cap_effective, CAP_FOWNER);
+-		cap_raise(override_cred->cap_effective, CAP_FSETID);
+-		cap_raise(override_cred->cap_effective, CAP_CHOWN);
+-		old_cred = override_creds(override_cred);
+-	}
++	if (old_opaque || new_opaque)
++		old_cred = ovl_override_creds(old->d_sb);
+ 
+ 	if (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {
+ 		opaquedir = ovl_check_empty_and_clear(new);
+@@ -942,10 +887,8 @@ out_dput_old:
+ out_unlock:
+ 	unlock_rename(new_upperdir, old_upperdir);
+ out_revert_creds:
+-	if (old_opaque || new_opaque) {
++	if (old_opaque || new_opaque)
+ 		revert_creds(old_cred);
+-		put_cred(override_cred);
+-	}
+ out_drop_write:
+ 	ovl_drop_write(old);
+ out:
+--- a/fs/overlayfs/overlayfs.h
++++ b/fs/overlayfs/overlayfs.h
+@@ -150,6 +150,7 @@ void ovl_drop_write(struct dentry *dentr
+ bool ovl_dentry_is_opaque(struct dentry *dentry);
+ void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
+ bool ovl_is_whiteout(struct dentry *dentry);
++const struct cred *ovl_override_creds(struct super_block *sb);
+ void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
+ 			  unsigned int flags);
+--- a/fs/overlayfs/readdir.c
++++ b/fs/overlayfs/readdir.c
+@@ -36,6 +36,7 @@ struct ovl_dir_cache {
+ 
+ struct ovl_readdir_data {
+ 	struct dir_context ctx;
++	struct dentry *dentry;
+ 	bool is_lowest;
+ 	struct rb_root root;
+ 	struct list_head *list;
+@@ -205,17 +206,8 @@ static int ovl_check_whiteouts(struct de
+ 	struct ovl_cache_entry *p;
+ 	struct dentry *dentry;
+ 	const struct cred *old_cred;
+-	struct cred *override_cred;
+-
+-	override_cred = prepare_creds();
+-	if (!override_cred)
+-		return -ENOMEM;
+ 
+-	/*
+-	 * CAP_DAC_OVERRIDE for lookup
+-	 */
+-	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+-	old_cred = override_creds(override_cred);
++	old_cred = ovl_override_creds(rdd->dentry->d_sb);
+ 
+ 	err = mutex_lock_killable(&dir->d_inode->i_mutex);
+ 	if (!err) {
+@@ -231,7 +223,6 @@ static int ovl_check_whiteouts(struct de
+ 		mutex_unlock(&dir->d_inode->i_mutex);
+ 	}
+ 	revert_creds(old_cred);
+-	put_cred(override_cred);
+ 
+ 	return err;
+ }
+@@ -287,6 +278,7 @@ static int ovl_dir_read_merged(struct de
+ 	struct path realpath;
+ 	struct ovl_readdir_data rdd = {
+ 		.ctx.actor = ovl_fill_merge,
++		.dentry = dentry,
+ 		.list = list,
+ 		.root = RB_ROOT,
+ 		.is_lowest = false,
+--- a/fs/overlayfs/super.c
++++ b/fs/overlayfs/super.c
+@@ -42,6 +42,8 @@ struct ovl_fs {
+ 	long lower_namelen;
+ 	/* pathnames of lower and upper dirs, for show_options */
+ 	struct ovl_config config;
++	/* creds of process who forced instantiation of super block */
++	const struct cred *creator_cred;
+ };
+ 
+ struct ovl_dir_cache;
+@@ -246,6 +248,13 @@ bool ovl_is_whiteout(struct dentry *dent
+ 	return inode && IS_WHITEOUT(inode);
+ }
+ 
++const struct cred *ovl_override_creds(struct super_block *sb)
++{
++	struct ovl_fs *ofs = sb->s_fs_info;
++
++	return override_creds(ofs->creator_cred);
++}
++
+ static bool ovl_is_opaquedir(struct dentry *dentry)
+ {
+ 	int res;
+@@ -587,6 +596,7 @@ static void ovl_put_super(struct super_b
+ 	kfree(ufs->config.lowerdir);
+ 	kfree(ufs->config.upperdir);
+ 	kfree(ufs->config.workdir);
++	put_cred(ufs->creator_cred);
+ 	kfree(ufs);
+ }
+ 
+@@ -1087,10 +1097,14 @@ static int ovl_fill_super(struct super_b
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
++	ufs->creator_cred = prepare_creds();
++	if (!ufs->creator_cred)
++		goto out_put_lower_mnt;
++
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+-		goto out_put_lower_mnt;
++		goto out_put_cred;
+ 
+ 	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
+ 	if (!root_dentry)
+@@ -1123,6 +1137,8 @@ static int ovl_fill_super(struct super_b
+ 
+ out_free_oe:
+ 	kfree(oe);
++out_put_cred:
++	put_cred(ufs->creator_cred);
+ out_put_lower_mnt:
+ 	for (i = 0; i < ufs->numlower; i++)
+ 		mntput(ufs->lower_mnt[i]);
diff --git a/target/linux/generic/pending-4.4/051-0005-ovl-proper-cleanup-of-workdir.patch b/target/linux/generic/pending-4.4/051-0005-ovl-proper-cleanup-of-workdir.patch
new file mode 100644
index 0000000000..7225fc8cd9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/051-0005-ovl-proper-cleanup-of-workdir.patch
@@ -0,0 +1,131 @@
+From eea2fb4851e9dcbab6b991aaf47e2e024f1f55a0 Mon Sep 17 00:00:00 2001
+From: Miklos Szeredi <mszeredi@redhat.com>
+Date: Thu, 1 Sep 2016 11:11:59 +0200
+Subject: [PATCH] ovl: proper cleanup of workdir
+
+When mounting overlayfs it needs a clean "work" directory under the
+supplied workdir.
+
+Previously the mount code removed this directory if it already existed and
+created a new one.  If the removal failed (e.g. directory was not empty)
+then it fell back to a read-only mount not using the workdir.
+
+While this has never been reported, it is possible to get a non-empty
+"work" dir from a previous mount of overlayfs in case of crash in the
+middle of an operation using the work directory.
+
+In this case the left over state should be discarded and the overlay
+filesystem will be consistent, guaranteed by the atomicity of operations on
+moving to/from the workdir to the upper layer.
+
+This patch implements cleaning out any files left in workdir.  It is
+implemented using real recursion for simplicity, but the depth is limited
+to 2, because the worst case is that of a directory containing whiteouts
+under "work".
+
+Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
+Cc: <stable@vger.kernel.org>
+---
+ fs/overlayfs/overlayfs.h |  2 ++
+ fs/overlayfs/readdir.c   | 63 +++++++++++++++++++++++++++++++++++++++++++++++-
+ fs/overlayfs/super.c     |  2 +-
+ 3 files changed, 65 insertions(+), 2 deletions(-)
+
+--- a/fs/overlayfs/overlayfs.h
++++ b/fs/overlayfs/overlayfs.h
+@@ -164,6 +164,8 @@ extern const struct file_operations ovl_
+ int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
+ void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
+ void ovl_cache_free(struct list_head *list);
++void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
++			 struct dentry *dentry, int level);
+ 
+ /* inode.c */
+ int ovl_setattr(struct dentry *dentry, struct iattr *attr);
+--- a/fs/overlayfs/readdir.c
++++ b/fs/overlayfs/readdir.c
+@@ -247,7 +247,7 @@ static inline int ovl_dir_read(struct pa
+ 			err = rdd->err;
+ 	} while (!err && rdd->count);
+ 
+-	if (!err && rdd->first_maybe_whiteout)
++	if (!err && rdd->first_maybe_whiteout && rdd->dentry)
+ 		err = ovl_check_whiteouts(realpath->dentry, rdd);
+ 
+ 	fput(realfile);
+@@ -573,3 +573,64 @@ void ovl_cleanup_whiteouts(struct dentry
+ 	}
+ 	mutex_unlock(&upper->d_inode->i_mutex);
+ }
++
++static void ovl_workdir_cleanup_recurse(struct path *path, int level)
++{
++	int err;
++	struct inode *dir = path->dentry->d_inode;
++	LIST_HEAD(list);
++	struct ovl_cache_entry *p;
++	struct ovl_readdir_data rdd = {
++		.ctx.actor = ovl_fill_merge,
++		.dentry = NULL,
++		.list = &list,
++		.root = RB_ROOT,
++		.is_lowest = false,
++	};
++
++	err = ovl_dir_read(path, &rdd);
++	if (err)
++		goto out;
++
++	mutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);
++	list_for_each_entry(p, &list, l_node) {
++		struct dentry *dentry;
++
++		if (p->name[0] == '.') {
++			if (p->len == 1)
++				continue;
++			if (p->len == 2 && p->name[1] == '.')
++				continue;
++		}
++		dentry = lookup_one_len(p->name, path->dentry, p->len);
++		if (IS_ERR(dentry))
++			continue;
++		if (dentry->d_inode)
++			ovl_workdir_cleanup(dir, path->mnt, dentry, level);
++		dput(dentry);
++	}
++	mutex_unlock(&dir->i_mutex);
++out:
++	ovl_cache_free(&list);
++}
++
++void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
++			 struct dentry *dentry, int level)
++{
++	int err;
++
++	if (!d_is_dir(dentry) || level > 1) {
++		ovl_cleanup(dir, dentry);
++		return;
++	}
++
++	err = ovl_do_rmdir(dir, dentry);
++	if (err) {
++		struct path path = { .mnt = mnt, .dentry = dentry };
++
++		mutex_unlock(&dir->i_mutex);
++		ovl_workdir_cleanup_recurse(&path, level + 1);
++		mutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);
++		ovl_cleanup(dir, dentry);
++	}
++}
+--- a/fs/overlayfs/super.c
++++ b/fs/overlayfs/super.c
+@@ -784,7 +784,7 @@ retry:
+ 				goto out_dput;
+ 
+ 			retried = true;
+-			ovl_cleanup(dir, work);
++			ovl_workdir_cleanup(dir, mnt, work, 0);
+ 			dput(work);
+ 			goto retry;
+ 		}
diff --git a/target/linux/generic/pending-4.4/052-01-ubifs-Implement-O_TMPFILE.patch b/target/linux/generic/pending-4.4/052-01-ubifs-Implement-O_TMPFILE.patch
new file mode 100644
index 0000000000..1c55a89acf
--- /dev/null
+++ b/target/linux/generic/pending-4.4/052-01-ubifs-Implement-O_TMPFILE.patch
@@ -0,0 +1,99 @@
+From: Richard Weinberger <richard@nod.at>
+Date: Tue, 13 Sep 2016 16:18:55 +0200
+Subject: [PATCH] ubifs: Implement O_TMPFILE
+
+This patchs adds O_TMPFILE support to UBIFS.
+A temp file is a reference to an unlinked inode, a user
+holding the reference can use it. As soon it is being closed
+all data vanishes.
+
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+
+--- a/fs/ubifs/dir.c
++++ b/fs/ubifs/dir.c
+@@ -301,6 +301,76 @@ out_budg:
+ 	return err;
+ }
+ 
++static int ubifs_tmpfile(struct inode *dir, struct dentry *dentry,
++			 umode_t mode)
++{
++	struct inode *inode;
++	struct ubifs_info *c = dir->i_sb->s_fs_info;
++	struct ubifs_budget_req req = { .new_ino = 1, .new_dent = 1};
++	struct ubifs_budget_req ino_req = { .dirtied_ino = 1 };
++	struct ubifs_inode *ui, *dir_ui = ubifs_inode(dir);
++	int err, instantiated = 0;
++
++	/*
++	 * Budget request settings: new dirty inode, new direntry,
++	 * budget for dirtied inode will be released via writeback.
++	 */
++
++	dbg_gen("dent '%pd', mode %#hx in dir ino %lu",
++		dentry, mode, dir->i_ino);
++
++	err = ubifs_budget_space(c, &req);
++	if (err)
++		return err;
++
++	err = ubifs_budget_space(c, &ino_req);
++	if (err) {
++		ubifs_release_budget(c, &req);
++		return err;
++	}
++
++	inode = ubifs_new_inode(c, dir, mode);
++	if (IS_ERR(inode)) {
++		err = PTR_ERR(inode);
++		goto out_budg;
++	}
++	ui = ubifs_inode(inode);
++
++	err = ubifs_init_security(dir, inode, &dentry->d_name);
++	if (err)
++		goto out_inode;
++
++	mutex_lock(&ui->ui_mutex);
++	insert_inode_hash(inode);
++	d_tmpfile(dentry, inode);
++	ubifs_assert(ui->dirty);
++	instantiated = 1;
++	mutex_unlock(&ui->ui_mutex);
++
++	mutex_lock(&dir_ui->ui_mutex);
++	err = ubifs_jnl_update(c, dir, &dentry->d_name, inode, 1, 0);
++	if (err)
++		goto out_cancel;
++	mutex_unlock(&dir_ui->ui_mutex);
++
++	ubifs_release_budget(c, &req);
++
++	return 0;
++
++out_cancel:
++	mutex_unlock(&dir_ui->ui_mutex);
++out_inode:
++	make_bad_inode(inode);
++	if (!instantiated)
++		iput(inode);
++out_budg:
++	ubifs_release_budget(c, &req);
++	if (!instantiated)
++		ubifs_release_budget(c, &ino_req);
++	ubifs_err(c, "cannot create temporary file, error %d", err);
++	return err;
++}
++
+ /**
+  * vfs_dent_type - get VFS directory entry type.
+  * @type: UBIFS directory entry type
+@@ -1195,6 +1265,7 @@ const struct inode_operations ubifs_dir_
+ #ifdef CONFIG_UBIFS_ATIME_SUPPORT
+ 	.update_time = ubifs_update_time,
+ #endif
++	.tmpfile     = ubifs_tmpfile,
+ };
+ 
+ const struct file_operations ubifs_dir_operations = {
diff --git a/target/linux/generic/pending-4.4/052-02-ubifs-Implement-RENAME_WHITEOUT.patch b/target/linux/generic/pending-4.4/052-02-ubifs-Implement-RENAME_WHITEOUT.patch
new file mode 100644
index 0000000000..c2ec904939
--- /dev/null
+++ b/target/linux/generic/pending-4.4/052-02-ubifs-Implement-RENAME_WHITEOUT.patch
@@ -0,0 +1,343 @@
+From: Richard Weinberger <richard@nod.at>
+Date: Tue, 13 Sep 2016 16:18:56 +0200
+Subject: [PATCH] ubifs: Implement RENAME_WHITEOUT
+
+Adds RENAME_WHITEOUT support to UBIFS, we implement
+it in the same way as ext4 and xfs do.
+For an overview of other ways to implement it please
+refere to commit 7dcf5c3e4527 ("xfs: add RENAME_WHITEOUT support").
+
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+
+--- a/fs/ubifs/dir.c
++++ b/fs/ubifs/dir.c
+@@ -301,8 +301,8 @@ out_budg:
+ 	return err;
+ }
+ 
+-static int ubifs_tmpfile(struct inode *dir, struct dentry *dentry,
+-			 umode_t mode)
++static int do_tmpfile(struct inode *dir, struct dentry *dentry,
++		      umode_t mode, struct inode **whiteout)
+ {
+ 	struct inode *inode;
+ 	struct ubifs_info *c = dir->i_sb->s_fs_info;
+@@ -336,14 +336,27 @@ static int ubifs_tmpfile(struct inode *d
+ 	}
+ 	ui = ubifs_inode(inode);
+ 
++	if (whiteout) {
++		init_special_inode(inode, inode->i_mode, WHITEOUT_DEV);
++		ubifs_assert(inode->i_op == &ubifs_file_inode_operations);
++	}
++
+ 	err = ubifs_init_security(dir, inode, &dentry->d_name);
+ 	if (err)
+ 		goto out_inode;
+ 
+ 	mutex_lock(&ui->ui_mutex);
+ 	insert_inode_hash(inode);
+-	d_tmpfile(dentry, inode);
++
++	if (whiteout) {
++		mark_inode_dirty(inode);
++		drop_nlink(inode);
++		*whiteout = inode;
++	} else {
++		d_tmpfile(dentry, inode);
++	}
+ 	ubifs_assert(ui->dirty);
++
+ 	instantiated = 1;
+ 	mutex_unlock(&ui->ui_mutex);
+ 
+@@ -371,6 +384,12 @@ out_budg:
+ 	return err;
+ }
+ 
++static int ubifs_tmpfile(struct inode *dir, struct dentry *dentry,
++			 umode_t mode)
++{
++	return do_tmpfile(dir, dentry, mode, NULL);
++}
++
+ /**
+  * vfs_dent_type - get VFS directory entry type.
+  * @type: UBIFS directory entry type
+@@ -1003,37 +1022,43 @@ out_budg:
+ }
+ 
+ /**
+- * lock_3_inodes - a wrapper for locking three UBIFS inodes.
++ * lock_4_inodes - a wrapper for locking three UBIFS inodes.
+  * @inode1: first inode
+  * @inode2: second inode
+  * @inode3: third inode
++ * @inode4: fouth inode
+  *
+  * This function is used for 'ubifs_rename()' and @inode1 may be the same as
+- * @inode2 whereas @inode3 may be %NULL.
++ * @inode2 whereas @inode3 and @inode4 may be %NULL.
+  *
+  * We do not implement any tricks to guarantee strict lock ordering, because
+  * VFS has already done it for us on the @i_mutex. So this is just a simple
+  * wrapper function.
+  */
+-static void lock_3_inodes(struct inode *inode1, struct inode *inode2,
+-			  struct inode *inode3)
++static void lock_4_inodes(struct inode *inode1, struct inode *inode2,
++			  struct inode *inode3, struct inode *inode4)
+ {
+ 	mutex_lock_nested(&ubifs_inode(inode1)->ui_mutex, WB_MUTEX_1);
+ 	if (inode2 != inode1)
+ 		mutex_lock_nested(&ubifs_inode(inode2)->ui_mutex, WB_MUTEX_2);
+ 	if (inode3)
+ 		mutex_lock_nested(&ubifs_inode(inode3)->ui_mutex, WB_MUTEX_3);
++	if (inode4)
++		mutex_lock_nested(&ubifs_inode(inode4)->ui_mutex, WB_MUTEX_4);
+ }
+ 
+ /**
+- * unlock_3_inodes - a wrapper for unlocking three UBIFS inodes for rename.
++ * unlock_4_inodes - a wrapper for unlocking three UBIFS inodes for rename.
+  * @inode1: first inode
+  * @inode2: second inode
+  * @inode3: third inode
++ * @inode4: fouth inode
+  */
+-static void unlock_3_inodes(struct inode *inode1, struct inode *inode2,
+-			    struct inode *inode3)
++static void unlock_4_inodes(struct inode *inode1, struct inode *inode2,
++			    struct inode *inode3, struct inode *inode4)
+ {
++	if (inode4)
++		mutex_unlock(&ubifs_inode(inode4)->ui_mutex);
+ 	if (inode3)
+ 		mutex_unlock(&ubifs_inode(inode3)->ui_mutex);
+ 	if (inode1 != inode2)
+@@ -1042,12 +1067,15 @@ static void unlock_3_inodes(struct inode
+ }
+ 
+ static int ubifs_rename(struct inode *old_dir, struct dentry *old_dentry,
+-			struct inode *new_dir, struct dentry *new_dentry)
++			struct inode *new_dir, struct dentry *new_dentry,
++			unsigned int flags)
+ {
+ 	struct ubifs_info *c = old_dir->i_sb->s_fs_info;
+ 	struct inode *old_inode = d_inode(old_dentry);
+ 	struct inode *new_inode = d_inode(new_dentry);
++	struct inode *whiteout = NULL;
+ 	struct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);
++	struct ubifs_inode *whiteout_ui = NULL;
+ 	int err, release, sync = 0, move = (new_dir != old_dir);
+ 	int is_dir = S_ISDIR(old_inode->i_mode);
+ 	int unlink = !!new_inode;
+@@ -1069,9 +1097,13 @@ static int ubifs_rename(struct inode *ol
+ 	 * separately.
+ 	 */
+ 
+-	dbg_gen("dent '%pd' ino %lu in dir ino %lu to dent '%pd' in dir ino %lu",
++	dbg_gen("dent '%pd' ino %lu in dir ino %lu to dent '%pd' in dir ino %lu flags 0x%x",
+ 		old_dentry, old_inode->i_ino, old_dir->i_ino,
+-		new_dentry, new_dir->i_ino);
++		new_dentry, new_dir->i_ino, flags);
++
++	if (flags & ~(RENAME_NOREPLACE | RENAME_WHITEOUT))
++		return -EINVAL;
++
+ 	ubifs_assert(mutex_is_locked(&old_dir->i_mutex));
+ 	ubifs_assert(mutex_is_locked(&new_dir->i_mutex));
+ 	if (unlink)
+@@ -1093,7 +1125,32 @@ static int ubifs_rename(struct inode *ol
+ 		return err;
+ 	}
+ 
+-	lock_3_inodes(old_dir, new_dir, new_inode);
++	if (flags & RENAME_WHITEOUT) {
++		union ubifs_dev_desc *dev = NULL;
++
++		dev = kmalloc(sizeof(union ubifs_dev_desc), GFP_NOFS);
++		if (!dev) {
++			ubifs_release_budget(c, &req);
++			ubifs_release_budget(c, &ino_req);
++			return -ENOMEM;
++		}
++
++		err = do_tmpfile(old_dir, old_dentry, S_IFCHR | WHITEOUT_MODE, &whiteout);
++		if (err) {
++			ubifs_release_budget(c, &req);
++			ubifs_release_budget(c, &ino_req);
++			kfree(dev);
++			return err;
++		}
++
++		whiteout->i_state |= I_LINKABLE;
++		whiteout_ui = ubifs_inode(whiteout);
++		whiteout_ui->data = dev;
++		whiteout_ui->data_len = ubifs_encode_dev(dev, MKDEV(0, 0));
++		ubifs_assert(!whiteout_ui->dirty);
++	}
++
++	lock_4_inodes(old_dir, new_dir, new_inode, whiteout);
+ 
+ 	/*
+ 	 * Like most other Unix systems, set the @i_ctime for inodes on a
+@@ -1163,12 +1220,34 @@ static int ubifs_rename(struct inode *ol
+ 		if (unlink && IS_SYNC(new_inode))
+ 			sync = 1;
+ 	}
+-	err = ubifs_jnl_rename(c, old_dir, old_dentry, new_dir, new_dentry,
++
++	if (whiteout) {
++		struct ubifs_budget_req wht_req = { .dirtied_ino = 1,
++				.dirtied_ino_d = \
++				ALIGN(ubifs_inode(whiteout)->data_len, 8) };
++
++		err = ubifs_budget_space(c, &wht_req);
++		if (err) {
++			ubifs_release_budget(c, &req);
++			ubifs_release_budget(c, &ino_req);
++			kfree(whiteout_ui->data);
++			whiteout_ui->data_len = 0;
++			iput(whiteout);
++			return err;
++		}
++
++		inc_nlink(whiteout);
++		mark_inode_dirty(whiteout);
++		whiteout->i_state &= ~I_LINKABLE;
++		iput(whiteout);
++	}
++
++	err = ubifs_jnl_rename(c, old_dir, old_dentry, new_dir, new_dentry, whiteout,
+ 			       sync);
+ 	if (err)
+ 		goto out_cancel;
+ 
+-	unlock_3_inodes(old_dir, new_dir, new_inode);
++	unlock_4_inodes(old_dir, new_dir, new_inode, whiteout);
+ 	ubifs_release_budget(c, &req);
+ 
+ 	mutex_lock(&old_inode_ui->ui_mutex);
+@@ -1201,7 +1280,11 @@ out_cancel:
+ 				inc_nlink(old_dir);
+ 		}
+ 	}
+-	unlock_3_inodes(old_dir, new_dir, new_inode);
++	if (whiteout) {
++		drop_nlink(whiteout);
++		iput(whiteout);
++	}
++	unlock_4_inodes(old_dir, new_dir, new_inode, whiteout);
+ 	ubifs_release_budget(c, &ino_req);
+ 	ubifs_release_budget(c, &req);
+ 	return err;
+@@ -1255,7 +1338,7 @@ const struct inode_operations ubifs_dir_
+ 	.mkdir       = ubifs_mkdir,
+ 	.rmdir       = ubifs_rmdir,
+ 	.mknod       = ubifs_mknod,
+-	.rename      = ubifs_rename,
++	.rename2     = ubifs_rename,
+ 	.setattr     = ubifs_setattr,
+ 	.getattr     = ubifs_getattr,
+ 	.setxattr    = ubifs_setxattr,
+--- a/fs/ubifs/journal.c
++++ b/fs/ubifs/journal.c
+@@ -917,14 +917,15 @@ int ubifs_jnl_delete_inode(struct ubifs_
+  * @sync: non-zero if the write-buffer has to be synchronized
+  *
+  * This function implements the re-name operation which may involve writing up
+- * to 3 inodes and 2 directory entries. It marks the written inodes as clean
++ * to 4 inodes and 2 directory entries. It marks the written inodes as clean
+  * and returns zero on success. In case of failure, a negative error code is
+  * returned.
+  */
+ int ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,
+ 		     const struct dentry *old_dentry,
+ 		     const struct inode *new_dir,
+-		     const struct dentry *new_dentry, int sync)
++		     const struct dentry *new_dentry,
++		     const struct inode *whiteout, int sync)
+ {
+ 	void *p;
+ 	union ubifs_key key;
+@@ -980,13 +981,19 @@ int ubifs_jnl_rename(struct ubifs_info *
+ 	zero_dent_node_unused(dent);
+ 	ubifs_prep_grp_node(c, dent, dlen1, 0);
+ 
+-	/* Make deletion dent */
+ 	dent2 = (void *)dent + aligned_dlen1;
+ 	dent2->ch.node_type = UBIFS_DENT_NODE;
+ 	dent_key_init_flash(c, &dent2->key, old_dir->i_ino,
+ 			    &old_dentry->d_name);
+-	dent2->inum = 0;
+-	dent2->type = DT_UNKNOWN;
++
++	if (whiteout) {
++		dent2->inum = cpu_to_le64(whiteout->i_ino);
++		dent2->type = get_dent_type(whiteout->i_mode);
++	} else {
++		/* Make deletion dent */
++		dent2->inum = 0;
++		dent2->type = DT_UNKNOWN;
++	}
+ 	dent2->nlen = cpu_to_le16(old_dentry->d_name.len);
+ 	memcpy(dent2->name, old_dentry->d_name.name, old_dentry->d_name.len);
+ 	dent2->name[old_dentry->d_name.len] = '\0';
+@@ -1035,16 +1042,26 @@ int ubifs_jnl_rename(struct ubifs_info *
+ 	if (err)
+ 		goto out_ro;
+ 
+-	err = ubifs_add_dirt(c, lnum, dlen2);
+-	if (err)
+-		goto out_ro;
+-
+-	dent_key_init(c, &key, old_dir->i_ino, &old_dentry->d_name);
+-	err = ubifs_tnc_remove_nm(c, &key, &old_dentry->d_name);
+-	if (err)
+-		goto out_ro;
++	offs += aligned_dlen1;
++	if (whiteout) {
++		dent_key_init(c, &key, old_dir->i_ino, &old_dentry->d_name);
++		err = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen2, &old_dentry->d_name);
++		if (err)
++			goto out_ro;
++
++		ubifs_delete_orphan(c, whiteout->i_ino);
++	} else {
++		err = ubifs_add_dirt(c, lnum, dlen2);
++		if (err)
++			goto out_ro;
++
++		dent_key_init(c, &key, old_dir->i_ino, &old_dentry->d_name);
++		err = ubifs_tnc_remove_nm(c, &key, &old_dentry->d_name);
++		if (err)
++			goto out_ro;
++	}
+ 
+-	offs += aligned_dlen1 + aligned_dlen2;
++	offs += aligned_dlen2;
+ 	if (new_inode) {
+ 		ino_key_init(c, &key, new_inode->i_ino);
+ 		err = ubifs_tnc_add(c, &key, lnum, offs, ilen);
+--- a/fs/ubifs/ubifs.h
++++ b/fs/ubifs/ubifs.h
+@@ -180,6 +180,7 @@ enum {
+ 	WB_MUTEX_1 = 0,
+ 	WB_MUTEX_2 = 1,
+ 	WB_MUTEX_3 = 2,
++	WB_MUTEX_4 = 3,
+ };
+ 
+ /*
+@@ -1546,7 +1547,8 @@ int ubifs_jnl_delete_inode(struct ubifs_
+ int ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,
+ 		     const struct dentry *old_dentry,
+ 		     const struct inode *new_dir,
+-		     const struct dentry *new_dentry, int sync);
++		     const struct dentry *new_dentry,
++		     const struct inode *whiteout, int sync);
+ int ubifs_jnl_truncate(struct ubifs_info *c, const struct inode *inode,
+ 		       loff_t old_size, loff_t new_size);
+ int ubifs_jnl_delete_xattr(struct ubifs_info *c, const struct inode *host,
diff --git a/target/linux/generic/pending-4.4/052-03-ubifs-Implement-RENAME_EXCHANGE.patch b/target/linux/generic/pending-4.4/052-03-ubifs-Implement-RENAME_EXCHANGE.patch
new file mode 100644
index 0000000000..1830cd0eeb
--- /dev/null
+++ b/target/linux/generic/pending-4.4/052-03-ubifs-Implement-RENAME_EXCHANGE.patch
@@ -0,0 +1,267 @@
+From: Richard Weinberger <richard@nod.at>
+Date: Tue, 13 Sep 2016 16:18:57 +0200
+Subject: [PATCH] ubifs: Implement RENAME_EXCHANGE
+
+Adds RENAME_EXCHANGE to UBIFS, the operation itself
+is completely disjunct from a regular rename() that's
+why we dispatch very early in ubifs_reaname().
+
+RENAME_EXCHANGE used by the renameat2() system call
+allows the caller to exchange two paths atomically.
+Both paths have to exist and have to be on the same
+filesystem.
+
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+
+--- a/fs/ubifs/dir.c
++++ b/fs/ubifs/dir.c
+@@ -1101,11 +1101,6 @@ static int ubifs_rename(struct inode *ol
+ 		old_dentry, old_inode->i_ino, old_dir->i_ino,
+ 		new_dentry, new_dir->i_ino, flags);
+ 
+-	if (flags & ~(RENAME_NOREPLACE | RENAME_WHITEOUT))
+-		return -EINVAL;
+-
+-	ubifs_assert(mutex_is_locked(&old_dir->i_mutex));
+-	ubifs_assert(mutex_is_locked(&new_dir->i_mutex));
+ 	if (unlink)
+ 		ubifs_assert(mutex_is_locked(&new_inode->i_mutex));
+ 
+@@ -1290,6 +1285,64 @@ out_cancel:
+ 	return err;
+ }
+ 
++static int ubifs_xrename(struct inode *old_dir, struct dentry *old_dentry,
++			struct inode *new_dir, struct dentry *new_dentry)
++{
++	struct ubifs_info *c = old_dir->i_sb->s_fs_info;
++	struct ubifs_budget_req req = { .new_dent = 1, .mod_dent = 1,
++				.dirtied_ino = 2 };
++	int sync = IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir);
++	struct inode *fst_inode = d_inode(old_dentry);
++	struct inode *snd_inode = d_inode(new_dentry);
++	struct timespec time;
++	int err;
++
++	ubifs_assert(fst_inode && snd_inode);
++
++	lock_4_inodes(old_dir, new_dir, NULL, NULL);
++
++	time = ubifs_current_time(old_dir);
++	fst_inode->i_ctime = time;
++	snd_inode->i_ctime = time;
++	old_dir->i_mtime = old_dir->i_ctime = time;
++	new_dir->i_mtime = new_dir->i_ctime = time;
++
++	if (old_dir != new_dir) {
++		if (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {
++			inc_nlink(new_dir);
++			drop_nlink(old_dir);
++		}
++		else if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {
++			drop_nlink(new_dir);
++			inc_nlink(old_dir);
++		}
++	}
++
++	err = ubifs_jnl_xrename(c, old_dir, old_dentry, new_dir, new_dentry,
++				sync);
++
++	unlock_4_inodes(old_dir, new_dir, NULL, NULL);
++	ubifs_release_budget(c, &req);
++
++	return err;
++}
++
++static int ubifs_rename2(struct inode *old_dir, struct dentry *old_dentry,
++			struct inode *new_dir, struct dentry *new_dentry,
++			unsigned int flags)
++{
++	if (flags & ~(RENAME_NOREPLACE | RENAME_WHITEOUT | RENAME_EXCHANGE))
++		return -EINVAL;
++
++	ubifs_assert(mutex_is_locked(&old_dir->i_mutex));
++	ubifs_assert(mutex_is_locked(&new_dir->i_mutex));
++
++	if (flags & RENAME_EXCHANGE)
++		return ubifs_xrename(old_dir, old_dentry, new_dir, new_dentry);
++
++	return ubifs_rename(old_dir, old_dentry, new_dir, new_dentry, flags);
++}
++
+ int ubifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
+ 		  struct kstat *stat)
+ {
+@@ -1338,7 +1391,7 @@ const struct inode_operations ubifs_dir_
+ 	.mkdir       = ubifs_mkdir,
+ 	.rmdir       = ubifs_rmdir,
+ 	.mknod       = ubifs_mknod,
+-	.rename2     = ubifs_rename,
++	.rename2     = ubifs_rename2,
+ 	.setattr     = ubifs_setattr,
+ 	.getattr     = ubifs_getattr,
+ 	.setxattr    = ubifs_setxattr,
+--- a/fs/ubifs/journal.c
++++ b/fs/ubifs/journal.c
+@@ -908,6 +908,147 @@ int ubifs_jnl_delete_inode(struct ubifs_
+ }
+ 
+ /**
++ * ubifs_jnl_xrename - cross rename two directory entries.
++ * @c: UBIFS file-system description object
++ * @fst_dir: parent inode of 1st directory entry to exchange
++ * @fst_dentry: 1st directory entry to exchange
++ * @snd_dir: parent inode of 2nd directory entry to exchange
++ * @snd_dentry: 2nd directory entry to exchange
++ * @sync: non-zero if the write-buffer has to be synchronized
++ *
++ * This function implements the cross rename operation which may involve
++ * writing 2 inodes and 2 directory entries. It marks the written inodes as clean
++ * and returns zero on success. In case of failure, a negative error code is
++ * returned.
++ */
++int ubifs_jnl_xrename(struct ubifs_info *c, const struct inode *fst_dir,
++		      const struct dentry *fst_dentry,
++		      const struct inode *snd_dir,
++		      const struct dentry *snd_dentry, int sync)
++{
++	union ubifs_key key;
++	struct ubifs_dent_node *dent1, *dent2;
++	int err, dlen1, dlen2, lnum, offs, len, plen = UBIFS_INO_NODE_SZ;
++	int aligned_dlen1, aligned_dlen2;
++	int twoparents = (fst_dir != snd_dir);
++	const struct inode *fst_inode = d_inode(fst_dentry);
++	const struct inode *snd_inode = d_inode(snd_dentry);
++	void *p;
++
++	dbg_jnl("dent '%pd' in dir ino %lu between dent '%pd' in dir ino %lu",
++		fst_dentry, fst_dir->i_ino, snd_dentry, snd_dir->i_ino);
++
++	ubifs_assert(ubifs_inode(fst_dir)->data_len == 0);
++	ubifs_assert(ubifs_inode(snd_dir)->data_len == 0);
++	ubifs_assert(mutex_is_locked(&ubifs_inode(fst_dir)->ui_mutex));
++	ubifs_assert(mutex_is_locked(&ubifs_inode(snd_dir)->ui_mutex));
++
++	dlen1 = UBIFS_DENT_NODE_SZ + snd_dentry->d_name.len + 1;
++	dlen2 = UBIFS_DENT_NODE_SZ + fst_dentry->d_name.len + 1;
++	aligned_dlen1 = ALIGN(dlen1, 8);
++	aligned_dlen2 = ALIGN(dlen2, 8);
++
++	len = aligned_dlen1 + aligned_dlen2 + ALIGN(plen, 8);
++	if (twoparents)
++		len += plen;
++
++	dent1 = kmalloc(len, GFP_NOFS);
++	if (!dent1)
++		return -ENOMEM;
++
++	/* Make reservation before allocating sequence numbers */
++	err = make_reservation(c, BASEHD, len);
++	if (err)
++		goto out_free;
++
++	/* Make new dent for 1st entry */
++	dent1->ch.node_type = UBIFS_DENT_NODE;
++	dent_key_init_flash(c, &dent1->key, snd_dir->i_ino, &snd_dentry->d_name);
++	dent1->inum = cpu_to_le64(fst_inode->i_ino);
++	dent1->type = get_dent_type(fst_inode->i_mode);
++	dent1->nlen = cpu_to_le16(snd_dentry->d_name.len);
++	memcpy(dent1->name, snd_dentry->d_name.name, snd_dentry->d_name.len);
++	dent1->name[snd_dentry->d_name.len] = '\0';
++	zero_dent_node_unused(dent1);
++	ubifs_prep_grp_node(c, dent1, dlen1, 0);
++
++	/* Make new dent for 2nd entry */
++	dent2 = (void *)dent1 + aligned_dlen1;
++	dent2->ch.node_type = UBIFS_DENT_NODE;
++	dent_key_init_flash(c, &dent2->key, fst_dir->i_ino, &fst_dentry->d_name);
++	dent2->inum = cpu_to_le64(snd_inode->i_ino);
++	dent2->type = get_dent_type(snd_inode->i_mode);
++	dent2->nlen = cpu_to_le16(fst_dentry->d_name.len);
++	memcpy(dent2->name, fst_dentry->d_name.name, fst_dentry->d_name.len);
++	dent2->name[fst_dentry->d_name.len] = '\0';
++	zero_dent_node_unused(dent2);
++	ubifs_prep_grp_node(c, dent2, dlen2, 0);
++
++	p = (void *)dent2 + aligned_dlen2;
++	if (!twoparents)
++		pack_inode(c, p, fst_dir, 1);
++	else {
++		pack_inode(c, p, fst_dir, 0);
++		p += ALIGN(plen, 8);
++		pack_inode(c, p, snd_dir, 1);
++	}
++
++	err = write_head(c, BASEHD, dent1, len, &lnum, &offs, sync);
++	if (err)
++		goto out_release;
++	if (!sync) {
++		struct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;
++
++		ubifs_wbuf_add_ino_nolock(wbuf, fst_dir->i_ino);
++		ubifs_wbuf_add_ino_nolock(wbuf, snd_dir->i_ino);
++	}
++	release_head(c, BASEHD);
++
++	dent_key_init(c, &key, snd_dir->i_ino, &snd_dentry->d_name);
++	err = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen1, &snd_dentry->d_name);
++	if (err)
++		goto out_ro;
++
++	offs += aligned_dlen1;
++	dent_key_init(c, &key, fst_dir->i_ino, &fst_dentry->d_name);
++	err = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen2, &fst_dentry->d_name);
++	if (err)
++		goto out_ro;
++
++	offs += aligned_dlen2;
++
++	ino_key_init(c, &key, fst_dir->i_ino);
++	err = ubifs_tnc_add(c, &key, lnum, offs, plen);
++	if (err)
++		goto out_ro;
++
++	if (twoparents) {
++		offs += ALIGN(plen, 8);
++		ino_key_init(c, &key, snd_dir->i_ino);
++		err = ubifs_tnc_add(c, &key, lnum, offs, plen);
++		if (err)
++			goto out_ro;
++	}
++
++	finish_reservation(c);
++
++	mark_inode_clean(c, ubifs_inode(fst_dir));
++	if (twoparents)
++		mark_inode_clean(c, ubifs_inode(snd_dir));
++	kfree(dent1);
++	return 0;
++
++out_release:
++	release_head(c, BASEHD);
++out_ro:
++	ubifs_ro_mode(c, err);
++	finish_reservation(c);
++out_free:
++	kfree(dent1);
++	return err;
++}
++
++/**
+  * ubifs_jnl_rename - rename a directory entry.
+  * @c: UBIFS file-system description object
+  * @old_dir: parent inode of directory entry to rename
+--- a/fs/ubifs/ubifs.h
++++ b/fs/ubifs/ubifs.h
+@@ -1544,6 +1544,10 @@ int ubifs_jnl_write_data(struct ubifs_in
+ 			 const union ubifs_key *key, const void *buf, int len);
+ int ubifs_jnl_write_inode(struct ubifs_info *c, const struct inode *inode);
+ int ubifs_jnl_delete_inode(struct ubifs_info *c, const struct inode *inode);
++int ubifs_jnl_xrename(struct ubifs_info *c, const struct inode *fst_dir,
++		      const struct dentry *fst_dentry,
++		      const struct inode *snd_dir,
++		      const struct dentry *snd_dentry, int sync);
+ int ubifs_jnl_rename(struct ubifs_info *c, const struct inode *old_dir,
+ 		     const struct dentry *old_dentry,
+ 		     const struct inode *new_dir,
diff --git a/target/linux/generic/pending-4.4/052-04-ubifs-Use-move-variable-in-ubifs_rename.patch b/target/linux/generic/pending-4.4/052-04-ubifs-Use-move-variable-in-ubifs_rename.patch
new file mode 100644
index 0000000000..81129359d3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/052-04-ubifs-Use-move-variable-in-ubifs_rename.patch
@@ -0,0 +1,30 @@
+From: Richard Weinberger <richard@nod.at>
+Date: Tue, 13 Sep 2016 16:18:58 +0200
+Subject: [PATCH] ubifs: Use move variable in ubifs_rename()
+
+...to make the code more consistent since we use
+move already in other places.
+
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+
+--- a/fs/ubifs/journal.c
++++ b/fs/ubifs/journal.c
+@@ -1100,7 +1100,7 @@ int ubifs_jnl_rename(struct ubifs_info *
+ 	aligned_dlen1 = ALIGN(dlen1, 8);
+ 	aligned_dlen2 = ALIGN(dlen2, 8);
+ 	len = aligned_dlen1 + aligned_dlen2 + ALIGN(ilen, 8) + ALIGN(plen, 8);
+-	if (old_dir != new_dir)
++	if (move)
+ 		len += plen;
+ 	dent = kmalloc(len, GFP_NOFS);
+ 	if (!dent)
+@@ -1216,7 +1216,7 @@ int ubifs_jnl_rename(struct ubifs_info *
+ 	if (err)
+ 		goto out_ro;
+ 
+-	if (old_dir != new_dir) {
++	if (move) {
+ 		offs += ALIGN(plen, 8);
+ 		ino_key_init(c, &key, new_dir->i_ino);
+ 		err = ubifs_tnc_add(c, &key, lnum, offs, plen);
diff --git a/target/linux/generic/pending-4.4/053-0001-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch b/target/linux/generic/pending-4.4/053-0001-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch
new file mode 100644
index 0000000000..662584ca61
--- /dev/null
+++ b/target/linux/generic/pending-4.4/053-0001-ubifs-Drop-softlimit-and-delta-fields-from-struct-ub.patch
@@ -0,0 +1,82 @@
+From 854826c9d526fd81077742c3b000e3f7fcaef3ce Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 20 Sep 2016 10:36:14 +0200
+Subject: [PATCH] ubifs: Drop softlimit and delta fields from struct ubifs_wbuf
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Values of these fields are set during init and never modified. They are
+used (read) in a single function only. There isn't really any reason to
+keep them in a struct. It only makes struct just a bit bigger without
+any visible gain.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+ fs/ubifs/io.c    | 18 ++++++++++--------
+ fs/ubifs/ubifs.h |  5 -----
+ 2 files changed, 10 insertions(+), 13 deletions(-)
+
+--- a/fs/ubifs/io.c
++++ b/fs/ubifs/io.c
+@@ -452,16 +452,22 @@ static enum hrtimer_restart wbuf_timer_c
+  */
+ static void new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
+ {
++	ktime_t softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
++	unsigned long long delta;
++
++	delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
++	delta *= 1000000000ULL;
++
+ 	ubifs_assert(!hrtimer_active(&wbuf->timer));
++	ubifs_assert(delta <= ULONG_MAX);
+ 
+ 	if (wbuf->no_timer)
+ 		return;
+ 	dbg_io("set timer for jhead %s, %llu-%llu millisecs",
+ 	       dbg_jhead(wbuf->jhead),
+-	       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),
+-	       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,
+-		       USEC_PER_SEC));
+-	hrtimer_start_range_ns(&wbuf->timer, wbuf->softlimit, wbuf->delta,
++	       div_u64(ktime_to_ns(softlimit), USEC_PER_SEC),
++	       div_u64(ktime_to_ns(softlimit) + delta, USEC_PER_SEC));
++	hrtimer_start_range_ns(&wbuf->timer, softlimit, delta,
+ 			       HRTIMER_MODE_REL);
+ }
+ 
+@@ -1059,10 +1065,6 @@ int ubifs_wbuf_init(struct ubifs_info *c
+ 
+ 	hrtimer_init(&wbuf->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+ 	wbuf->timer.function = wbuf_timer_callback_nolock;
+-	wbuf->softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
+-	wbuf->delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
+-	wbuf->delta *= 1000000000ULL;
+-	ubifs_assert(wbuf->delta <= ULONG_MAX);
+ 	return 0;
+ }
+ 
+--- a/fs/ubifs/ubifs.h
++++ b/fs/ubifs/ubifs.h
+@@ -668,9 +668,6 @@ typedef int (*ubifs_lpt_scan_callback)(s
+  * @io_mutex: serializes write-buffer I/O
+  * @lock: serializes @buf, @lnum, @offs, @avail, @used, @next_ino and @inodes
+  *        fields
+- * @softlimit: soft write-buffer timeout interval
+- * @delta: hard and soft timeouts delta (the timer expire interval is @softlimit
+- *         and @softlimit + @delta)
+  * @timer: write-buffer timer
+  * @no_timer: non-zero if this write-buffer does not have a timer
+  * @need_sync: non-zero if the timer expired and the wbuf needs sync'ing
+@@ -699,8 +696,6 @@ struct ubifs_wbuf {
+ 	int (*sync_callback)(struct ubifs_info *c, int lnum, int free, int pad);
+ 	struct mutex io_mutex;
+ 	spinlock_t lock;
+-	ktime_t softlimit;
+-	unsigned long long delta;
+ 	struct hrtimer timer;
+ 	unsigned int no_timer:1;
+ 	unsigned int need_sync:1;
diff --git a/target/linux/generic/pending-4.4/053-0002-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch b/target/linux/generic/pending-4.4/053-0002-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch
new file mode 100644
index 0000000000..9313cd557e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/053-0002-ubifs-Use-dirty_writeback_interval-value-for-wbuf-ti.patch
@@ -0,0 +1,66 @@
+From 1b7fc2c0069f3864a3dda15430b7aded31c0bfcc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 20 Sep 2016 10:36:15 +0200
+Subject: [PATCH] ubifs: Use dirty_writeback_interval value for wbuf timer
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Right now wbuf timer has hardcoded timeouts and there is no place for
+manual adjustments. Some projects / cases many need that though. Few
+file systems allow doing that by respecting dirty_writeback_interval
+that can be set using sysctl (dirty_writeback_centisecs).
+
+Lowering dirty_writeback_interval could be some way of dealing with user
+space apps lacking proper fsyncs. This is definitely *not* a perfect
+solution but we don't have ideal (user space) world. There were already
+advanced discussions on this matter, mostly when ext4 was introduced and
+it wasn't behaving as ext3. Anyway, the final decision was to add some
+hacks to the ext4, as trying to fix whole user space or adding new API
+was pointless.
+
+We can't (and shouldn't?) just follow ext4. We can't e.g. sync on close
+as this would cause too many commits and flash wearing. On the other
+hand we still should allow some trade-off between -o sync and default
+wbuf timeout. Respecting dirty_writeback_interval should allow some sane
+cutomizations if used warily.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
+Signed-off-by: Richard Weinberger <richard@nod.at>
+---
+ fs/ubifs/io.c    | 8 ++++----
+ fs/ubifs/ubifs.h | 4 ----
+ 2 files changed, 4 insertions(+), 8 deletions(-)
+
+--- a/fs/ubifs/io.c
++++ b/fs/ubifs/io.c
+@@ -452,11 +452,11 @@ static enum hrtimer_restart wbuf_timer_c
+  */
+ static void new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
+ {
+-	ktime_t softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
+-	unsigned long long delta;
++	ktime_t softlimit = ms_to_ktime(dirty_writeback_interval * 10);
++	unsigned long long delta = dirty_writeback_interval;
+ 
+-	delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
+-	delta *= 1000000000ULL;
++	/* centi to milli, milli to nano, then 10% */
++	delta *= 10ULL * NSEC_PER_MSEC / 10ULL;
+ 
+ 	ubifs_assert(!hrtimer_active(&wbuf->timer));
+ 	ubifs_assert(delta <= ULONG_MAX);
+--- a/fs/ubifs/ubifs.h
++++ b/fs/ubifs/ubifs.h
+@@ -106,10 +106,6 @@
+  */
+ #define BGT_NAME_PATTERN "ubifs_bgt%d_%d"
+ 
+-/* Write-buffer synchronization timeout interval in seconds */
+-#define WBUF_TIMEOUT_SOFTLIMIT 3
+-#define WBUF_TIMEOUT_HARDLIMIT 5
+-
+ /* Maximum possible inode number (only 32-bit inodes are supported now) */
+ #define MAX_INUM 0xFFFFFFFF
+ 
diff --git a/target/linux/generic/pending-4.4/060-mips_decompressor_memmove.patch b/target/linux/generic/pending-4.4/060-mips_decompressor_memmove.patch
new file mode 100644
index 0000000000..d215b80ab2
--- /dev/null
+++ b/target/linux/generic/pending-4.4/060-mips_decompressor_memmove.patch
@@ -0,0 +1,22 @@
+--- a/arch/mips/boot/compressed/string.c
++++ b/arch/mips/boot/compressed/string.c
+@@ -26,3 +26,19 @@ void *memset(void *s, int c, size_t n)
+ 		ss[i] = c;
+ 	return s;
+ }
++
++void *memmove(void *__dest, __const void *__src, size_t count)
++{
++	unsigned char *d = __dest;
++	const unsigned char *s = __src;
++
++	if (__dest == __src)
++		return __dest;
++
++	if (__dest < __src)
++		return memcpy(__dest, __src, count);
++
++	while (count--)
++		d[count] = s[count];
++	return __dest;
++}
diff --git a/target/linux/generic/pending-4.4/061-softirq-let-ksoftirqd-do-its-job.patch b/target/linux/generic/pending-4.4/061-softirq-let-ksoftirqd-do-its-job.patch
new file mode 100644
index 0000000000..a2de48093c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/061-softirq-let-ksoftirqd-do-its-job.patch
@@ -0,0 +1,83 @@
+From: Eric Dumazet <edumazet@google.com>
+Date: Wed, 31 Aug 2016 10:42:29 -0700
+Subject: [PATCH] softirq: let ksoftirqd do its job
+
+A while back, Paolo and Hannes sent an RFC patch adding threaded-able
+napi poll loop support : (https://patchwork.ozlabs.org/patch/620657/)
+
+The problem seems to be that softirqs are very aggressive and are often
+handled by the current process, even if we are under stress and that
+ksoftirqd was scheduled, so that innocent threads would have more chance
+to make progress.
+
+This patch makes sure that if ksoftirq is running, we let it
+perform the softirq work.
+
+Jonathan Corbet summarized the issue in https://lwn.net/Articles/687617/
+
+Tested:
+
+ - NIC receiving traffic handled by CPU 0
+ - UDP receiver running on CPU 0, using a single UDP socket.
+ - Incoming flood of UDP packets targeting the UDP socket.
+
+Before the patch, the UDP receiver could almost never get cpu cycles and
+could only receive ~2,000 packets per second.
+
+After the patch, cpu cycles are split 50/50 between user application and
+ksoftirqd/0, and we can effectively read ~900,000 packets per second,
+a huge improvement in DOS situation. (Note that more packets are now
+dropped by the NIC itself, since the BH handlers get less cpu cycles to
+drain RX ring buffer)
+
+Since the load runs in well identified threads context, an admin can
+more easily tune process scheduling parameters if needed.
+
+Reported-by: Paolo Abeni <pabeni@redhat.com>
+Reported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: David Miller <davem@davemloft.net
+Cc: Jesper Dangaard Brouer <jbrouer@redhat.com>
+Cc: Peter Zijlstra <peterz@infradead.org>
+Cc: Rik van Riel <riel@redhat.com>
+---
+
+--- a/kernel/softirq.c
++++ b/kernel/softirq.c
+@@ -78,6 +78,17 @@ static void wakeup_softirqd(void)
+ }
+ 
+ /*
++ * If ksoftirqd is scheduled, we do not want to process pending softirqs
++ * right now. Let ksoftirqd handle this at its own rate, to get fairness.
++ */
++static bool ksoftirqd_running(void)
++{
++	struct task_struct *tsk = __this_cpu_read(ksoftirqd);
++
++	return tsk && (tsk->state == TASK_RUNNING);
++}
++
++/*
+  * preempt_count and SOFTIRQ_OFFSET usage:
+  * - preempt_count is changed by SOFTIRQ_OFFSET on entering or leaving
+  *   softirq processing.
+@@ -313,7 +324,7 @@ asmlinkage __visible void do_softirq(voi
+ 
+ 	pending = local_softirq_pending();
+ 
+-	if (pending)
++	if (pending && !ksoftirqd_running())
+ 		do_softirq_own_stack();
+ 
+ 	local_irq_restore(flags);
+@@ -340,6 +351,9 @@ void irq_enter(void)
+ 
+ static inline void invoke_softirq(void)
+ {
++	if (ksoftirqd_running())
++		return;
++
+ 	if (!force_irqthreads) {
+ #ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK
+ 		/*
diff --git a/target/linux/generic/pending-4.4/067-v4.11-mtd-nand-Add-Winbond-manufacturer-id.patch b/target/linux/generic/pending-4.4/067-v4.11-mtd-nand-Add-Winbond-manufacturer-id.patch
new file mode 100644
index 0000000000..d102d89b20
--- /dev/null
+++ b/target/linux/generic/pending-4.4/067-v4.11-mtd-nand-Add-Winbond-manufacturer-id.patch
@@ -0,0 +1,34 @@
+From a4077ce5871304f8a78f80b74b18b6052a410f1a Mon Sep 17 00:00:00 2001
+From: "Andrey Jr. Melnikov" <temnota.am@gmail.com>
+Date: Thu, 8 Dec 2016 19:57:08 +0300
+Subject: [PATCH] mtd: nand: Add Winbond manufacturer id
+
+Add WINBOND manufacturer id.
+
+Signed-off-by: Andrey Jr. Melnikov <temnota.am@gmail.com>
+Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
+---
+ drivers/mtd/nand/nand_ids.c | 1 +
+ include/linux/mtd/nand.h    | 1 +
+ 2 files changed, 2 insertions(+)
+
+--- a/drivers/mtd/nand/nand_ids.c
++++ b/drivers/mtd/nand/nand_ids.c
+@@ -181,6 +181,7 @@ struct nand_manufacturers nand_manuf_ids
+ 	{NAND_MFR_SANDISK, "SanDisk"},
+ 	{NAND_MFR_INTEL, "Intel"},
+ 	{NAND_MFR_ATO, "ATO"},
++	{NAND_MFR_WINBOND, "Winbond"},
+ 	{0x0, "Unknown"}
+ };
+ 
+--- a/include/linux/mtd/nand.h
++++ b/include/linux/mtd/nand.h
+@@ -736,6 +736,7 @@ struct nand_chip {
+ #define NAND_MFR_SANDISK	0x45
+ #define NAND_MFR_INTEL		0x89
+ #define NAND_MFR_ATO		0x9b
++#define NAND_MFR_WINBOND	0xef
+ 
+ /* The maximum expected count of bytes in the NAND ID sequence */
+ #define NAND_MAX_ID_LEN 8
diff --git a/target/linux/generic/pending-4.4/070-v4.5-0003-net-bgmac-clarify-CONFIG_BCMA-dependency.patch b/target/linux/generic/pending-4.4/070-v4.5-0003-net-bgmac-clarify-CONFIG_BCMA-dependency.patch
new file mode 100644
index 0000000000..cd0d09887f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.5-0003-net-bgmac-clarify-CONFIG_BCMA-dependency.patch
@@ -0,0 +1,46 @@
+From 1f820f538f7396db7fd40684b9c3620816acc5a3 Mon Sep 17 00:00:00 2001
+From: Arnd Bergmann <arnd@arndb.de>
+Date: Fri, 29 Jan 2016 12:39:12 +0100
+Subject: [PATCH] net: bgmac: clarify CONFIG_BCMA dependency
+
+The bgmac driver depends on BCMA_HOST_SOC, which is only used
+when CONFIG_BCMA is enabled. However, it is a bool option and can
+be set when CONFIG_BCMA=m, and then bgmac can be built-in, leading
+to an obvious link error:
+
+drivers/built-in.o: In function `bgmac_init':
+:(.init.text+0x7f2c): undefined reference to `__bcma_driver_register'
+drivers/built-in.o: In function `bgmac_exit':
+:(.exit.text+0x110a): undefined reference to `bcma_driver_unregister'
+
+To avoid this case, we need to depend on both BCMA and BCMA_SOC,
+as this patch does. I'm also trying to make the dependency more
+readable by splitting it into three lines, and adding a COMPILE_TEST
+alternative so we can test-build it in all configurations that
+support BCMA.
+
+The added dependency on FIXED_PHY addresses a related issue where
+we cannot call fixed_phy_register() when CONFIG_FIXED_PHY=m and
+CONFIG_BGMAC=y.
+
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/Kconfig | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/Kconfig
++++ b/drivers/net/ethernet/broadcom/Kconfig
+@@ -151,8 +151,11 @@ config BNX2X_VXLAN
+ 
+ config BGMAC
+ 	tristate "BCMA bus GBit core support"
+-	depends on BCMA_HOST_SOC && HAS_DMA && (BCM47XX || ARCH_BCM_5301X)
++	depends on BCMA && BCMA_HOST_SOC
++	depends on HAS_DMA
++	depends on BCM47XX || ARCH_BCM_5301X || COMPILE_TEST
+ 	select PHYLIB
++	select FIXED_PHY
+ 	---help---
+ 	  This driver supports GBit MAC and BCM4706 GBit MAC cores on BCMA bus.
+ 	  They can be found on BCM47xx SoCs and provide gigabit ethernet.
diff --git a/target/linux/generic/pending-4.4/070-v4.6-0001-bgmac-add-helper-checking-for-BCM4707-BCM53018-chip-.patch b/target/linux/generic/pending-4.4/070-v4.6-0001-bgmac-add-helper-checking-for-BCM4707-BCM53018-chip-.patch
new file mode 100644
index 0000000000..94a37d4437
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.6-0001-bgmac-add-helper-checking-for-BCM4707-BCM53018-chip-.patch
@@ -0,0 +1,106 @@
+From 387b75f8b31437792e8334390fdf5cf060d1e3da Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Tue, 2 Feb 2016 07:47:14 +0100
+Subject: [PATCH] bgmac: add helper checking for BCM4707 / BCM53018 chip id
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Chipsets with BCM4707 / BCM53018 ID require special handling at a few
+places in the code. It's likely there will be more IDs to check in the
+future. To simplify it add this trivial helper.
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 30 ++++++++++++++++--------------
+ 1 file changed, 16 insertions(+), 14 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -26,6 +26,17 @@ static const struct bcma_device_id bgmac
+ };
+ MODULE_DEVICE_TABLE(bcma, bgmac_bcma_tbl);
+ 
++static inline bool bgmac_is_bcm4707_family(struct bgmac *bgmac)
++{
++	switch (bgmac->core->bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM4707:
++	case BCMA_CHIP_ID_BCM53018:
++		return true;
++	default:
++		return false;
++	}
++}
++
+ static bool bgmac_wait_value(struct bcma_device *core, u16 reg, u32 mask,
+ 			     u32 value, int timeout)
+ {
+@@ -991,11 +1002,9 @@ static void bgmac_mac_speed(struct bgmac
+ static void bgmac_miiconfig(struct bgmac *bgmac)
+ {
+ 	struct bcma_device *core = bgmac->core;
+-	struct bcma_chipinfo *ci = &core->bus->chipinfo;
+ 	u8 imode;
+ 
+-	if (ci->id == BCMA_CHIP_ID_BCM4707 ||
+-	    ci->id == BCMA_CHIP_ID_BCM53018) {
++	if (bgmac_is_bcm4707_family(bgmac)) {
+ 		bcma_awrite32(core, BCMA_IOCTL,
+ 			      bcma_aread32(core, BCMA_IOCTL) | 0x40 |
+ 			      BGMAC_BCMA_IOCTL_SW_CLKEN);
+@@ -1059,9 +1068,7 @@ static void bgmac_chip_reset(struct bgma
+ 	}
+ 
+ 	/* Request Misc PLL for corerev > 2 */
+-	if (core->id.rev > 2 &&
+-	    ci->id != BCMA_CHIP_ID_BCM4707 &&
+-	    ci->id != BCMA_CHIP_ID_BCM53018) {
++	if (core->id.rev > 2 && !bgmac_is_bcm4707_family(bgmac)) {
+ 		bgmac_set(bgmac, BCMA_CLKCTLST,
+ 			  BGMAC_BCMA_CLKCTLST_MISC_PLL_REQ);
+ 		bgmac_wait_value(bgmac->core, BCMA_CLKCTLST,
+@@ -1197,8 +1204,7 @@ static void bgmac_enable(struct bgmac *b
+ 		break;
+ 	}
+ 
+-	if (ci->id != BCMA_CHIP_ID_BCM4707 &&
+-	    ci->id != BCMA_CHIP_ID_BCM53018) {
++	if (!bgmac_is_bcm4707_family(bgmac)) {
+ 		rxq_ctl = bgmac_read(bgmac, BGMAC_RXQ_CTL);
+ 		rxq_ctl &= ~BGMAC_RXQ_CTL_MDP_MASK;
+ 		bp_clk = bcma_pmu_get_bus_clock(&bgmac->core->bus->drv_cc) /
+@@ -1477,14 +1483,12 @@ static int bgmac_fixed_phy_register(stru
+ 
+ static int bgmac_mii_register(struct bgmac *bgmac)
+ {
+-	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
+ 	struct mii_bus *mii_bus;
+ 	struct phy_device *phy_dev;
+ 	char bus_id[MII_BUS_ID_SIZE + 3];
+ 	int i, err = 0;
+ 
+-	if (ci->id == BCMA_CHIP_ID_BCM4707 ||
+-	    ci->id == BCMA_CHIP_ID_BCM53018)
++	if (bgmac_is_bcm4707_family(bgmac))
+ 		return bgmac_fixed_phy_register(bgmac);
+ 
+ 	mii_bus = mdiobus_alloc();
+@@ -1555,7 +1559,6 @@ static void bgmac_mii_unregister(struct
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipattach */
+ static int bgmac_probe(struct bcma_device *core)
+ {
+-	struct bcma_chipinfo *ci = &core->bus->chipinfo;
+ 	struct net_device *net_dev;
+ 	struct bgmac *bgmac;
+ 	struct ssb_sprom *sprom = &core->bus->sprom;
+@@ -1641,8 +1644,7 @@ static int bgmac_probe(struct bcma_devic
+ 	bgmac_chip_reset(bgmac);
+ 
+ 	/* For Northstar, we have to take all GMAC core out of reset */
+-	if (ci->id == BCMA_CHIP_ID_BCM4707 ||
+-	    ci->id == BCMA_CHIP_ID_BCM53018) {
++	if (bgmac_is_bcm4707_family(bgmac)) {
+ 		struct bcma_device *ns_core;
+ 		int ns_gmac;
+ 
diff --git a/target/linux/generic/pending-4.4/070-v4.6-0002-bgmac-support-Ethernet-device-on-BCM47094-SoC.patch b/target/linux/generic/pending-4.4/070-v4.6-0002-bgmac-support-Ethernet-device-on-BCM47094-SoC.patch
new file mode 100644
index 0000000000..41e470b314
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.6-0002-bgmac-support-Ethernet-device-on-BCM47094-SoC.patch
@@ -0,0 +1,39 @@
+From 9e4e6206c67ae11d68fc96882256f37c237087d4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Mon, 22 Feb 2016 22:51:13 +0100
+Subject: [PATCH] bgmac: support Ethernet device on BCM47094 SoC
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It needs very similar workarounds to the one on BCM4707. It was tested
+on D-Link DIR-885L home router.
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -30,6 +30,7 @@ static inline bool bgmac_is_bcm4707_fami
+ {
+ 	switch (bgmac->core->bus->chipinfo.id) {
+ 	case BCMA_CHIP_ID_BCM4707:
++	case BCMA_CHIP_ID_BCM47094:
+ 	case BCMA_CHIP_ID_BCM53018:
+ 		return true;
+ 	default:
+@@ -1056,8 +1057,9 @@ static void bgmac_chip_reset(struct bgma
+ 	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg == BCMA_PKG_ID_BCM47188))
+ 		iost &= ~BGMAC_BCMA_IOST_ATTACHED;
+ 
+-	/* 3GMAC: for BCM4707, only do core reset at bgmac_probe() */
+-	if (ci->id != BCMA_CHIP_ID_BCM4707) {
++	/* 3GMAC: for BCM4707 & BCM47094, only do core reset at bgmac_probe() */
++	if (ci->id != BCMA_CHIP_ID_BCM4707 &&
++	    ci->id != BCMA_CHIP_ID_BCM47094) {
+ 		flags = 0;
+ 		if (iost & BGMAC_BCMA_IOST_ATTACHED) {
+ 			flags = BGMAC_BCMA_IOCTL_SW_CLKEN;
diff --git a/target/linux/generic/pending-4.4/070-v4.6-0004-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch b/target/linux/generic/pending-4.4/070-v4.6-0004-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch
new file mode 100644
index 0000000000..a5fcaab51c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.6-0004-bgmac-fix-MAC-soft-reset-bit-for-corerev-4.patch
@@ -0,0 +1,34 @@
+From c02bc350f9dbce7d637c394a6e1c4d29dc5b28b2 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 12 Apr 2016 18:27:29 +0200
+Subject: [PATCH] bgmac: fix MAC soft-reset bit for corerev > 4
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Only core revisions older than 4 use BGMAC_CMDCFG_SR_REV0. This mainly
+fixes support for BCM4708A0KF SoCs with Ethernet core rev 5 (it means
+only some devices as most of BCM4708A0KF-s got core rev 4).
+This was tested for regressions on BCM47094 which doesn't seem to care
+which bit gets used.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -199,9 +199,9 @@
+ #define  BGMAC_CMDCFG_TAI			0x00000200
+ #define  BGMAC_CMDCFG_HD			0x00000400	/* Set if in half duplex mode */
+ #define  BGMAC_CMDCFG_HD_SHIFT			10
+-#define  BGMAC_CMDCFG_SR_REV0			0x00000800	/* Set to reset mode, for other revs */
+-#define  BGMAC_CMDCFG_SR_REV4			0x00002000	/* Set to reset mode, only for core rev 4 */
+-#define  BGMAC_CMDCFG_SR(rev)  ((rev == 4) ? BGMAC_CMDCFG_SR_REV4 : BGMAC_CMDCFG_SR_REV0)
++#define  BGMAC_CMDCFG_SR_REV0			0x00000800	/* Set to reset mode, for core rev 0-3 */
++#define  BGMAC_CMDCFG_SR_REV4			0x00002000	/* Set to reset mode, for core rev >= 4 */
++#define  BGMAC_CMDCFG_SR(rev)  ((rev >= 4) ? BGMAC_CMDCFG_SR_REV4 : BGMAC_CMDCFG_SR_REV0)
+ #define  BGMAC_CMDCFG_ML			0x00008000	/* Set to activate mac loopback mode */
+ #define  BGMAC_CMDCFG_AE			0x00400000
+ #define  BGMAC_CMDCFG_CFE			0x00800000
diff --git a/target/linux/generic/pending-4.4/070-v4.8-0001-bgmac-Bind-net_device-with-backing-device-structure.patch b/target/linux/generic/pending-4.4/070-v4.8-0001-bgmac-Bind-net_device-with-backing-device-structure.patch
new file mode 100644
index 0000000000..8f6d9a9ee7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.8-0001-bgmac-Bind-net_device-with-backing-device-structure.patch
@@ -0,0 +1,25 @@
+From 2022e9d50798aa592887ccb5a7d045e537f3855f Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 7 Jun 2016 15:06:13 -0700
+Subject: [PATCH 1/3] bgmac: Bind net_device with backing device structure
+
+In preparation for allowing different helpers to be utilized against
+network devices created by the bgmac driver, make sure that we bind the
+net_device with core->dev.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1604,6 +1604,7 @@ static int bgmac_probe(struct bcma_devic
+ 	bgmac->net_dev = net_dev;
+ 	bgmac->core = core;
+ 	bcma_set_drvdata(core, bgmac);
++	SET_NETDEV_DEV(net_dev, &core->dev);
+ 
+ 	/* Defaults */
+ 	memcpy(bgmac->net_dev->dev_addr, mac, ETH_ALEN);
diff --git a/target/linux/generic/pending-4.4/070-v4.8-0002-bgmac-Add-support-for-ethtool-statistics.patch b/target/linux/generic/pending-4.4/070-v4.8-0002-bgmac-Add-support-for-ethtool-statistics.patch
new file mode 100644
index 0000000000..585282b0aa
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.8-0002-bgmac-Add-support-for-ethtool-statistics.patch
@@ -0,0 +1,175 @@
+From f6613d4fa937fa8388f2c1cb4e69ccc25e9e2336 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 7 Jun 2016 15:06:14 -0700
+Subject: [PATCH 2/3] bgmac: Add support for ethtool statistics
+
+Read the statistics from the BGMAC's builtin MAC and return them to
+user-space using the standard ethtool helpers.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 124 ++++++++++++++++++++++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac.h |   4 +-
+ 2 files changed, 126 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1387,6 +1387,127 @@ static const struct net_device_ops bgmac
+  * ethtool_ops
+  **************************************************/
+ 
++struct bgmac_stat {
++	u8 size;
++	u32 offset;
++	const char *name;
++};
++
++static struct bgmac_stat bgmac_get_strings_stats[] = {
++	{ 8, BGMAC_TX_GOOD_OCTETS, "tx_good_octets" },
++	{ 4, BGMAC_TX_GOOD_PKTS, "tx_good" },
++	{ 8, BGMAC_TX_OCTETS, "tx_octets" },
++	{ 4, BGMAC_TX_PKTS, "tx_pkts" },
++	{ 4, BGMAC_TX_BROADCAST_PKTS, "tx_broadcast" },
++	{ 4, BGMAC_TX_MULTICAST_PKTS, "tx_multicast" },
++	{ 4, BGMAC_TX_LEN_64, "tx_64" },
++	{ 4, BGMAC_TX_LEN_65_TO_127, "tx_65_127" },
++	{ 4, BGMAC_TX_LEN_128_TO_255, "tx_128_255" },
++	{ 4, BGMAC_TX_LEN_256_TO_511, "tx_256_511" },
++	{ 4, BGMAC_TX_LEN_512_TO_1023, "tx_512_1023" },
++	{ 4, BGMAC_TX_LEN_1024_TO_1522, "tx_1024_1522" },
++	{ 4, BGMAC_TX_LEN_1523_TO_2047, "tx_1523_2047" },
++	{ 4, BGMAC_TX_LEN_2048_TO_4095, "tx_2048_4095" },
++	{ 4, BGMAC_TX_LEN_4096_TO_8191, "tx_4096_8191" },
++	{ 4, BGMAC_TX_LEN_8192_TO_MAX, "tx_8192_max" },
++	{ 4, BGMAC_TX_JABBER_PKTS, "tx_jabber" },
++	{ 4, BGMAC_TX_OVERSIZE_PKTS, "tx_oversize" },
++	{ 4, BGMAC_TX_FRAGMENT_PKTS, "tx_fragment" },
++	{ 4, BGMAC_TX_UNDERRUNS, "tx_underruns" },
++	{ 4, BGMAC_TX_TOTAL_COLS, "tx_total_cols" },
++	{ 4, BGMAC_TX_SINGLE_COLS, "tx_single_cols" },
++	{ 4, BGMAC_TX_MULTIPLE_COLS, "tx_multiple_cols" },
++	{ 4, BGMAC_TX_EXCESSIVE_COLS, "tx_excessive_cols" },
++	{ 4, BGMAC_TX_LATE_COLS, "tx_late_cols" },
++	{ 4, BGMAC_TX_DEFERED, "tx_defered" },
++	{ 4, BGMAC_TX_CARRIER_LOST, "tx_carrier_lost" },
++	{ 4, BGMAC_TX_PAUSE_PKTS, "tx_pause" },
++	{ 4, BGMAC_TX_UNI_PKTS, "tx_unicast" },
++	{ 4, BGMAC_TX_Q0_PKTS, "tx_q0" },
++	{ 8, BGMAC_TX_Q0_OCTETS, "tx_q0_octets" },
++	{ 4, BGMAC_TX_Q1_PKTS, "tx_q1" },
++	{ 8, BGMAC_TX_Q1_OCTETS, "tx_q1_octets" },
++	{ 4, BGMAC_TX_Q2_PKTS, "tx_q2" },
++	{ 8, BGMAC_TX_Q2_OCTETS, "tx_q2_octets" },
++	{ 4, BGMAC_TX_Q3_PKTS, "tx_q3" },
++	{ 8, BGMAC_TX_Q3_OCTETS, "tx_q3_octets" },
++	{ 8, BGMAC_RX_GOOD_OCTETS, "rx_good_octets" },
++	{ 4, BGMAC_RX_GOOD_PKTS, "rx_good" },
++	{ 8, BGMAC_RX_OCTETS, "rx_octets" },
++	{ 4, BGMAC_RX_PKTS, "rx_pkts" },
++	{ 4, BGMAC_RX_BROADCAST_PKTS, "rx_broadcast" },
++	{ 4, BGMAC_RX_MULTICAST_PKTS, "rx_multicast" },
++	{ 4, BGMAC_RX_LEN_64, "rx_64" },
++	{ 4, BGMAC_RX_LEN_65_TO_127, "rx_65_127" },
++	{ 4, BGMAC_RX_LEN_128_TO_255, "rx_128_255" },
++	{ 4, BGMAC_RX_LEN_256_TO_511, "rx_256_511" },
++	{ 4, BGMAC_RX_LEN_512_TO_1023, "rx_512_1023" },
++	{ 4, BGMAC_RX_LEN_1024_TO_1522, "rx_1024_1522" },
++	{ 4, BGMAC_RX_LEN_1523_TO_2047, "rx_1523_2047" },
++	{ 4, BGMAC_RX_LEN_2048_TO_4095, "rx_2048_4095" },
++	{ 4, BGMAC_RX_LEN_4096_TO_8191, "rx_4096_8191" },
++	{ 4, BGMAC_RX_LEN_8192_TO_MAX, "rx_8192_max" },
++	{ 4, BGMAC_RX_JABBER_PKTS, "rx_jabber" },
++	{ 4, BGMAC_RX_OVERSIZE_PKTS, "rx_oversize" },
++	{ 4, BGMAC_RX_FRAGMENT_PKTS, "rx_fragment" },
++	{ 4, BGMAC_RX_MISSED_PKTS, "rx_missed" },
++	{ 4, BGMAC_RX_CRC_ALIGN_ERRS, "rx_crc_align" },
++	{ 4, BGMAC_RX_UNDERSIZE, "rx_undersize" },
++	{ 4, BGMAC_RX_CRC_ERRS, "rx_crc" },
++	{ 4, BGMAC_RX_ALIGN_ERRS, "rx_align" },
++	{ 4, BGMAC_RX_SYMBOL_ERRS, "rx_symbol" },
++	{ 4, BGMAC_RX_PAUSE_PKTS, "rx_pause" },
++	{ 4, BGMAC_RX_NONPAUSE_PKTS, "rx_nonpause" },
++	{ 4, BGMAC_RX_SACHANGES, "rx_sa_changes" },
++	{ 4, BGMAC_RX_UNI_PKTS, "rx_unicast" },
++};
++
++#define BGMAC_STATS_LEN	ARRAY_SIZE(bgmac_get_strings_stats)
++
++static int bgmac_get_sset_count(struct net_device *dev, int string_set)
++{
++	switch (string_set) {
++	case ETH_SS_STATS:
++		return BGMAC_STATS_LEN;
++	}
++
++	return -EOPNOTSUPP;
++}
++
++static void bgmac_get_strings(struct net_device *dev, u32 stringset,
++			      u8 *data)
++{
++	int i;
++
++	if (stringset != ETH_SS_STATS)
++		return;
++
++	for (i = 0; i < BGMAC_STATS_LEN; i++)
++		strlcpy(data + i * ETH_GSTRING_LEN,
++			bgmac_get_strings_stats[i].name, ETH_GSTRING_LEN);
++}
++
++static void bgmac_get_ethtool_stats(struct net_device *dev,
++				    struct ethtool_stats *ss, uint64_t *data)
++{
++	struct bgmac *bgmac = netdev_priv(dev);
++	const struct bgmac_stat *s;
++	unsigned int i;
++	u64 val;
++
++	if (!netif_running(dev))
++		return;
++
++	for (i = 0; i < BGMAC_STATS_LEN; i++) {
++		s = &bgmac_get_strings_stats[i];
++		val = 0;
++		if (s->size == 8)
++			val = (u64)bgmac_read(bgmac, s->offset + 4) << 32;
++		val |= bgmac_read(bgmac, s->offset);
++		data[i] = val;
++	}
++}
++
+ static int bgmac_get_settings(struct net_device *net_dev,
+ 			      struct ethtool_cmd *cmd)
+ {
+@@ -1411,6 +1532,9 @@ static void bgmac_get_drvinfo(struct net
+ }
+ 
+ static const struct ethtool_ops bgmac_ethtool_ops = {
++	.get_strings		= bgmac_get_strings,
++	.get_sset_count		= bgmac_get_sset_count,
++	.get_ethtool_stats	= bgmac_get_ethtool_stats,
+ 	.get_settings		= bgmac_get_settings,
+ 	.set_settings		= bgmac_set_settings,
+ 	.get_drvinfo		= bgmac_get_drvinfo,
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -123,7 +123,7 @@
+ #define BGMAC_TX_LEN_1024_TO_1522		0x334
+ #define BGMAC_TX_LEN_1523_TO_2047		0x338
+ #define BGMAC_TX_LEN_2048_TO_4095		0x33c
+-#define BGMAC_TX_LEN_4095_TO_8191		0x340
++#define BGMAC_TX_LEN_4096_TO_8191		0x340
+ #define BGMAC_TX_LEN_8192_TO_MAX		0x344
+ #define BGMAC_TX_JABBER_PKTS			0x348		/* Error */
+ #define BGMAC_TX_OVERSIZE_PKTS			0x34c		/* Error */
+@@ -166,7 +166,7 @@
+ #define BGMAC_RX_LEN_1024_TO_1522		0x3e4
+ #define BGMAC_RX_LEN_1523_TO_2047		0x3e8
+ #define BGMAC_RX_LEN_2048_TO_4095		0x3ec
+-#define BGMAC_RX_LEN_4095_TO_8191		0x3f0
++#define BGMAC_RX_LEN_4096_TO_8191		0x3f0
+ #define BGMAC_RX_LEN_8192_TO_MAX		0x3f4
+ #define BGMAC_RX_JABBER_PKTS			0x3f8		/* Error */
+ #define BGMAC_RX_OVERSIZE_PKTS			0x3fc		/* Error */
diff --git a/target/linux/generic/pending-4.4/070-v4.8-0003-bgmac-Maintain-some-netdev-statistics.patch b/target/linux/generic/pending-4.4/070-v4.8-0003-bgmac-Maintain-some-netdev-statistics.patch
new file mode 100644
index 0000000000..1dbe1743df
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.8-0003-bgmac-Maintain-some-netdev-statistics.patch
@@ -0,0 +1,68 @@
+From 6d490f62a4c7f11c552591bdd08eda3636aa0db9 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 7 Jun 2016 15:06:15 -0700
+Subject: [PATCH 3/3] bgmac: Maintain some netdev statistics
+
+Add a few netdev statistics to report transmitted and received bytes and
+packets and a few obvious errors.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -246,6 +246,8 @@ err_dma_head:
+ 
+ err_drop:
+ 	dev_kfree_skb(skb);
++	net_dev->stats.tx_dropped++;
++	net_dev->stats.tx_errors++;
+ 	return NETDEV_TX_OK;
+ }
+ 
+@@ -285,6 +287,8 @@ static void bgmac_dma_tx_free(struct bgm
+ 				       DMA_TO_DEVICE);
+ 
+ 		if (slot->skb) {
++			bgmac->net_dev->stats.tx_bytes += slot->skb->len;
++			bgmac->net_dev->stats.tx_packets++;
+ 			bytes_compl += slot->skb->len;
+ 			pkts_compl++;
+ 
+@@ -468,6 +472,7 @@ static int bgmac_dma_rx_read(struct bgma
+ 				bgmac_err(bgmac, "Found poisoned packet at slot %d, DMA issue!\n",
+ 					  ring->start);
+ 				put_page(virt_to_head_page(buf));
++				bgmac->net_dev->stats.rx_errors++;
+ 				break;
+ 			}
+ 
+@@ -475,6 +480,8 @@ static int bgmac_dma_rx_read(struct bgma
+ 				bgmac_err(bgmac, "Found oversized packet at slot %d, DMA issue!\n",
+ 					  ring->start);
+ 				put_page(virt_to_head_page(buf));
++				bgmac->net_dev->stats.rx_length_errors++;
++				bgmac->net_dev->stats.rx_errors++;
+ 				break;
+ 			}
+ 
+@@ -485,6 +492,7 @@ static int bgmac_dma_rx_read(struct bgma
+ 			if (unlikely(!skb)) {
+ 				bgmac_err(bgmac, "build_skb failed\n");
+ 				put_page(virt_to_head_page(buf));
++				bgmac->net_dev->stats.rx_errors++;
+ 				break;
+ 			}
+ 			skb_put(skb, BGMAC_RX_FRAME_OFFSET +
+@@ -494,6 +502,8 @@ static int bgmac_dma_rx_read(struct bgma
+ 
+ 			skb_checksum_none_assert(skb);
+ 			skb->protocol = eth_type_trans(skb, bgmac->net_dev);
++			bgmac->net_dev->stats.rx_bytes += len;
++			bgmac->net_dev->stats.rx_packets++;
+ 			napi_gro_receive(&bgmac->napi, skb);
+ 			handled++;
+ 		} while (0);
diff --git a/target/linux/generic/pending-4.4/070-v4.8-0004-net-ethernet-bgmac-use-phydev-from-struct-net_device.patch b/target/linux/generic/pending-4.4/070-v4.8-0004-net-ethernet-bgmac-use-phydev-from-struct-net_device.patch
new file mode 100644
index 0000000000..7ce6a09ec3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/070-v4.8-0004-net-ethernet-bgmac-use-phydev-from-struct-net_device.patch
@@ -0,0 +1,105 @@
+From b21fcb259313bcf7d4f73ecd5e44948995c8957c Mon Sep 17 00:00:00 2001
+From: Philippe Reynes <tremyfr@gmail.com>
+Date: Sun, 19 Jun 2016 22:37:05 +0200
+Subject: [PATCH 1/2] net: ethernet: bgmac: use phydev from struct net_device
+
+The private structure contain a pointer to phydev, but the structure
+net_device already contain such pointer. So we can remove the pointer
+phydev in the private structure, and update the driver to use the
+one contained in struct net_device.
+
+Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 17 ++++++-----------
+ drivers/net/ethernet/broadcom/bgmac.h |  1 -
+ 2 files changed, 6 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1324,7 +1324,7 @@ static int bgmac_open(struct net_device
+ 	}
+ 	napi_enable(&bgmac->napi);
+ 
+-	phy_start(bgmac->phy_dev);
++	phy_start(net_dev->phydev);
+ 
+ 	netif_start_queue(net_dev);
+ 
+@@ -1337,7 +1337,7 @@ static int bgmac_stop(struct net_device
+ 
+ 	netif_carrier_off(net_dev);
+ 
+-	phy_stop(bgmac->phy_dev);
++	phy_stop(net_dev->phydev);
+ 
+ 	napi_disable(&bgmac->napi);
+ 	bgmac_chip_intrs_off(bgmac);
+@@ -1375,12 +1375,10 @@ static int bgmac_set_mac_address(struct
+ 
+ static int bgmac_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)
+ {
+-	struct bgmac *bgmac = netdev_priv(net_dev);
+-
+ 	if (!netif_running(net_dev))
+ 		return -EINVAL;
+ 
+-	return phy_mii_ioctl(bgmac->phy_dev, ifr, cmd);
++	return phy_mii_ioctl(net_dev->phydev, ifr, cmd);
+ }
+ 
+ static const struct net_device_ops bgmac_netdev_ops = {
+@@ -1523,7 +1521,7 @@ static int bgmac_get_settings(struct net
+ {
+ 	struct bgmac *bgmac = netdev_priv(net_dev);
+ 
+-	return phy_ethtool_gset(bgmac->phy_dev, cmd);
++	return phy_ethtool_gset(net_dev->phydev, cmd);
+ }
+ 
+ static int bgmac_set_settings(struct net_device *net_dev,
+@@ -1531,7 +1529,7 @@ static int bgmac_set_settings(struct net
+ {
+ 	struct bgmac *bgmac = netdev_priv(net_dev);
+ 
+-	return phy_ethtool_sset(bgmac->phy_dev, cmd);
++	return phy_ethtool_sset(net_dev->phydev, cmd);
+ }
+ 
+ static void bgmac_get_drvinfo(struct net_device *net_dev,
+@@ -1568,7 +1566,7 @@ static int bgmac_mii_write(struct mii_bu
+ static void bgmac_adjust_link(struct net_device *net_dev)
+ {
+ 	struct bgmac *bgmac = netdev_priv(net_dev);
+-	struct phy_device *phy_dev = bgmac->phy_dev;
++	struct phy_device *phy_dev = net_dev->phydev;
+ 	bool update = false;
+ 
+ 	if (phy_dev->link) {
+@@ -1612,8 +1610,6 @@ static int bgmac_fixed_phy_register(stru
+ 		return err;
+ 	}
+ 
+-	bgmac->phy_dev = phy_dev;
+-
+ 	return err;
+ }
+ 
+@@ -1666,7 +1662,6 @@ static int bgmac_mii_register(struct bgm
+ 		err = PTR_ERR(phy_dev);
+ 		goto err_unregister_bus;
+ 	}
+-	bgmac->phy_dev = phy_dev;
+ 
+ 	return err;
+ 
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -441,7 +441,6 @@ struct bgmac {
+ 	struct net_device *net_dev;
+ 	struct napi_struct napi;
+ 	struct mii_bus *mii_bus;
+-	struct phy_device *phy_dev;
+ 
+ 	/* DMA */
+ 	struct bgmac_dma_ring tx_ring[BGMAC_MAX_TX_RINGS];
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0001-net-ethernet-bgmac-change-bgmac_-prints-to-dev_-prin.patch b/target/linux/generic/pending-4.4/071-v4.8-0001-net-ethernet-bgmac-change-bgmac_-prints-to-dev_-prin.patch
new file mode 100644
index 0000000000..3837b60943
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0001-net-ethernet-bgmac-change-bgmac_-prints-to-dev_-prin.patch
@@ -0,0 +1,407 @@
+From d00a8281bcc962027dfe409c2f3e3f0546be9200 Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Thu, 7 Jul 2016 19:08:53 -0400
+Subject: [PATCH 1/5] net: ethernet: bgmac: change bgmac_* prints to dev_*
+ prints
+
+The bgmac_* print wrappers call dev_* prints with the dev pointer from
+the bcma core.  In anticipation of removing the bcma requirement for
+this driver, these must be changed to not reference that struct.  So,
+simply change all of the bgmac_* prints to their dev_* counterparts.  In
+some cases netdev_* prints are more appropriate, so change those as
+well.
+
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Tested-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 103 +++++++++++++++++-----------------
+ drivers/net/ethernet/broadcom/bgmac.h |  14 +----
+ 2 files changed, 55 insertions(+), 62 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -50,7 +50,7 @@ static bool bgmac_wait_value(struct bcma
+ 			return true;
+ 		udelay(10);
+ 	}
+-	pr_err("Timeout waiting for reg 0x%X\n", reg);
++	dev_err(&core->dev, "Timeout waiting for reg 0x%X\n", reg);
+ 	return false;
+ }
+ 
+@@ -84,8 +84,8 @@ static void bgmac_dma_tx_reset(struct bg
+ 		udelay(10);
+ 	}
+ 	if (i)
+-		bgmac_err(bgmac, "Timeout suspending DMA TX ring 0x%X (BGMAC_DMA_TX_STAT: 0x%08X)\n",
+-			  ring->mmio_base, val);
++		dev_err(bgmac->dev, "Timeout suspending DMA TX ring 0x%X (BGMAC_DMA_TX_STAT: 0x%08X)\n",
++			ring->mmio_base, val);
+ 
+ 	/* Remove SUSPEND bit */
+ 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL, 0);
+@@ -93,13 +93,13 @@ static void bgmac_dma_tx_reset(struct bg
+ 			      ring->mmio_base + BGMAC_DMA_TX_STATUS,
+ 			      BGMAC_DMA_TX_STAT, BGMAC_DMA_TX_STAT_DISABLED,
+ 			      10000)) {
+-		bgmac_warn(bgmac, "DMA TX ring 0x%X wasn't disabled on time, waiting additional 300us\n",
+-			   ring->mmio_base);
++		dev_warn(bgmac->dev, "DMA TX ring 0x%X wasn't disabled on time, waiting additional 300us\n",
++			 ring->mmio_base);
+ 		udelay(300);
+ 		val = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_STATUS);
+ 		if ((val & BGMAC_DMA_TX_STAT) != BGMAC_DMA_TX_STAT_DISABLED)
+-			bgmac_err(bgmac, "Reset of DMA TX ring 0x%X failed\n",
+-				  ring->mmio_base);
++			dev_err(bgmac->dev, "Reset of DMA TX ring 0x%X failed\n",
++				ring->mmio_base);
+ 	}
+ }
+ 
+@@ -161,7 +161,7 @@ static netdev_tx_t bgmac_dma_tx_add(stru
+ 	int i;
+ 
+ 	if (skb->len > BGMAC_DESC_CTL1_LEN) {
+-		bgmac_err(bgmac, "Too long skb (%d)\n", skb->len);
++		netdev_err(bgmac->net_dev, "Too long skb (%d)\n", skb->len);
+ 		goto err_drop;
+ 	}
+ 
+@@ -174,7 +174,7 @@ static netdev_tx_t bgmac_dma_tx_add(stru
+ 	 * even when ring->end overflows
+ 	 */
+ 	if (ring->end - ring->start + nr_frags + 1 >= BGMAC_TX_RING_SLOTS) {
+-		bgmac_err(bgmac, "TX ring is full, queue should be stopped!\n");
++		netdev_err(bgmac->net_dev, "TX ring is full, queue should be stopped!\n");
+ 		netif_stop_queue(net_dev);
+ 		return NETDEV_TX_BUSY;
+ 	}
+@@ -241,8 +241,8 @@ err_dma:
+ 	}
+ 
+ err_dma_head:
+-	bgmac_err(bgmac, "Mapping error of skb on ring 0x%X\n",
+-		  ring->mmio_base);
++	netdev_err(bgmac->net_dev, "Mapping error of skb on ring 0x%X\n",
++		   ring->mmio_base);
+ 
+ err_drop:
+ 	dev_kfree_skb(skb);
+@@ -321,8 +321,8 @@ static void bgmac_dma_rx_reset(struct bg
+ 			      ring->mmio_base + BGMAC_DMA_RX_STATUS,
+ 			      BGMAC_DMA_RX_STAT, BGMAC_DMA_RX_STAT_DISABLED,
+ 			      10000))
+-		bgmac_err(bgmac, "Reset of ring 0x%X RX failed\n",
+-			  ring->mmio_base);
++		dev_err(bgmac->dev, "Reset of ring 0x%X RX failed\n",
++			ring->mmio_base);
+ }
+ 
+ static void bgmac_dma_rx_enable(struct bgmac *bgmac,
+@@ -374,7 +374,7 @@ static int bgmac_dma_rx_skb_for_slot(str
+ 	dma_addr = dma_map_single(dma_dev, buf + BGMAC_RX_BUF_OFFSET,
+ 				  BGMAC_RX_BUF_SIZE, DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(dma_dev, dma_addr)) {
+-		bgmac_err(bgmac, "DMA mapping error\n");
++		netdev_err(bgmac->net_dev, "DMA mapping error\n");
+ 		put_page(virt_to_head_page(buf));
+ 		return -ENOMEM;
+ 	}
+@@ -469,16 +469,16 @@ static int bgmac_dma_rx_read(struct bgma
+ 
+ 			/* Check for poison and drop or pass the packet */
+ 			if (len == 0xdead && flags == 0xbeef) {
+-				bgmac_err(bgmac, "Found poisoned packet at slot %d, DMA issue!\n",
+-					  ring->start);
++				netdev_err(bgmac->net_dev, "Found poisoned packet at slot %d, DMA issue!\n",
++					   ring->start);
+ 				put_page(virt_to_head_page(buf));
+ 				bgmac->net_dev->stats.rx_errors++;
+ 				break;
+ 			}
+ 
+ 			if (len > BGMAC_RX_ALLOC_SIZE) {
+-				bgmac_err(bgmac, "Found oversized packet at slot %d, DMA issue!\n",
+-					  ring->start);
++				netdev_err(bgmac->net_dev, "Found oversized packet at slot %d, DMA issue!\n",
++					   ring->start);
+ 				put_page(virt_to_head_page(buf));
+ 				bgmac->net_dev->stats.rx_length_errors++;
+ 				bgmac->net_dev->stats.rx_errors++;
+@@ -490,7 +490,7 @@ static int bgmac_dma_rx_read(struct bgma
+ 
+ 			skb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);
+ 			if (unlikely(!skb)) {
+-				bgmac_err(bgmac, "build_skb failed\n");
++				netdev_err(bgmac->net_dev, "build_skb failed\n");
+ 				put_page(virt_to_head_page(buf));
+ 				bgmac->net_dev->stats.rx_errors++;
+ 				break;
+@@ -644,7 +644,7 @@ static int bgmac_dma_alloc(struct bgmac
+ 	BUILD_BUG_ON(BGMAC_MAX_RX_RINGS > ARRAY_SIZE(ring_base));
+ 
+ 	if (!(bcma_aread32(bgmac->core, BCMA_IOST) & BCMA_IOST_DMA64)) {
+-		bgmac_err(bgmac, "Core does not report 64-bit DMA\n");
++		dev_err(bgmac->dev, "Core does not report 64-bit DMA\n");
+ 		return -ENOTSUPP;
+ 	}
+ 
+@@ -658,8 +658,8 @@ static int bgmac_dma_alloc(struct bgmac
+ 						     &ring->dma_base,
+ 						     GFP_KERNEL);
+ 		if (!ring->cpu_base) {
+-			bgmac_err(bgmac, "Allocation of TX ring 0x%X failed\n",
+-				  ring->mmio_base);
++			dev_err(bgmac->dev, "Allocation of TX ring 0x%X failed\n",
++				ring->mmio_base);
+ 			goto err_dma_free;
+ 		}
+ 
+@@ -683,8 +683,8 @@ static int bgmac_dma_alloc(struct bgmac
+ 						     &ring->dma_base,
+ 						     GFP_KERNEL);
+ 		if (!ring->cpu_base) {
+-			bgmac_err(bgmac, "Allocation of RX ring 0x%X failed\n",
+-				  ring->mmio_base);
++			dev_err(bgmac->dev, "Allocation of RX ring 0x%X failed\n",
++				ring->mmio_base);
+ 			err = -ENOMEM;
+ 			goto err_dma_free;
+ 		}
+@@ -803,8 +803,8 @@ static u16 bgmac_phy_read(struct bgmac *
+ 	bcma_write32(core, phy_access_addr, tmp);
+ 
+ 	if (!bgmac_wait_value(core, phy_access_addr, BGMAC_PA_START, 0, 1000)) {
+-		bgmac_err(bgmac, "Reading PHY %d register 0x%X failed\n",
+-			  phyaddr, reg);
++		dev_err(bgmac->dev, "Reading PHY %d register 0x%X failed\n",
++			phyaddr, reg);
+ 		return 0xffff;
+ 	}
+ 
+@@ -836,7 +836,7 @@ static int bgmac_phy_write(struct bgmac
+ 
+ 	bgmac_write(bgmac, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
+ 	if (bgmac_read(bgmac, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
+-		bgmac_warn(bgmac, "Error setting MDIO int\n");
++		dev_warn(bgmac->dev, "Error setting MDIO int\n");
+ 
+ 	tmp = BGMAC_PA_START;
+ 	tmp |= BGMAC_PA_WRITE;
+@@ -846,8 +846,8 @@ static int bgmac_phy_write(struct bgmac
+ 	bcma_write32(core, phy_access_addr, tmp);
+ 
+ 	if (!bgmac_wait_value(core, phy_access_addr, BGMAC_PA_START, 0, 1000)) {
+-		bgmac_err(bgmac, "Writing to PHY %d register 0x%X failed\n",
+-			  phyaddr, reg);
++		dev_err(bgmac->dev, "Writing to PHY %d register 0x%X failed\n",
++			phyaddr, reg);
+ 		return -ETIMEDOUT;
+ 	}
+ 
+@@ -900,7 +900,7 @@ static void bgmac_phy_reset(struct bgmac
+ 	bgmac_phy_write(bgmac, bgmac->phyaddr, MII_BMCR, BMCR_RESET);
+ 	udelay(100);
+ 	if (bgmac_phy_read(bgmac, bgmac->phyaddr, MII_BMCR) & BMCR_RESET)
+-		bgmac_err(bgmac, "PHY reset failed\n");
++		dev_err(bgmac->dev, "PHY reset failed\n");
+ 	bgmac_phy_init(bgmac);
+ }
+ 
+@@ -1001,7 +1001,8 @@ static void bgmac_mac_speed(struct bgmac
+ 		set |= BGMAC_CMDCFG_ES_2500;
+ 		break;
+ 	default:
+-		bgmac_err(bgmac, "Unsupported speed: %d\n", bgmac->mac_speed);
++		dev_err(bgmac->dev, "Unsupported speed: %d\n",
++			bgmac->mac_speed);
+ 	}
+ 
+ 	if (bgmac->mac_duplex == DUPLEX_HALF)
+@@ -1100,8 +1101,8 @@ static void bgmac_chip_reset(struct bgma
+ 
+ 		if (bcm47xx_nvram_getenv("et_swtype", buf, sizeof(buf)) > 0) {
+ 			if (kstrtou8(buf, 0, &et_swtype))
+-				bgmac_err(bgmac, "Failed to parse et_swtype (%s)\n",
+-					  buf);
++				dev_err(bgmac->dev, "Failed to parse et_swtype (%s)\n",
++					buf);
+ 			et_swtype &= 0x0f;
+ 			et_swtype <<= 4;
+ 			sw_type = et_swtype;
+@@ -1264,7 +1265,7 @@ static irqreturn_t bgmac_interrupt(int i
+ 
+ 	int_status &= ~(BGMAC_IS_TX0 | BGMAC_IS_RX);
+ 	if (int_status)
+-		bgmac_err(bgmac, "Unknown IRQs: 0x%08X\n", int_status);
++		dev_err(bgmac->dev, "Unknown IRQs: 0x%08X\n", int_status);
+ 
+ 	/* Disable new interrupts until handling existing ones */
+ 	bgmac_chip_intrs_off(bgmac);
+@@ -1318,7 +1319,7 @@ static int bgmac_open(struct net_device
+ 	err = request_irq(bgmac->core->irq, bgmac_interrupt, IRQF_SHARED,
+ 			  KBUILD_MODNAME, net_dev);
+ 	if (err < 0) {
+-		bgmac_err(bgmac, "IRQ request error: %d!\n", err);
++		dev_err(bgmac->dev, "IRQ request error: %d!\n", err);
+ 		bgmac_dma_cleanup(bgmac);
+ 		return err;
+ 	}
+@@ -1599,14 +1600,14 @@ static int bgmac_fixed_phy_register(stru
+ 
+ 	phy_dev = fixed_phy_register(PHY_POLL, &fphy_status, -1, NULL);
+ 	if (!phy_dev || IS_ERR(phy_dev)) {
+-		bgmac_err(bgmac, "Failed to register fixed PHY device\n");
++		dev_err(bgmac->dev, "Failed to register fixed PHY device\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	err = phy_connect_direct(bgmac->net_dev, phy_dev, bgmac_adjust_link,
+ 				 PHY_INTERFACE_MODE_MII);
+ 	if (err) {
+-		bgmac_err(bgmac, "Connecting PHY failed\n");
++		dev_err(bgmac->dev, "Connecting PHY failed\n");
+ 		return err;
+ 	}
+ 
+@@ -1646,7 +1647,7 @@ static int bgmac_mii_register(struct bgm
+ 
+ 	err = mdiobus_register(mii_bus);
+ 	if (err) {
+-		bgmac_err(bgmac, "Registration of mii bus failed\n");
++		dev_err(bgmac->dev, "Registration of mii bus failed\n");
+ 		goto err_free_irq;
+ 	}
+ 
+@@ -1658,7 +1659,7 @@ static int bgmac_mii_register(struct bgm
+ 	phy_dev = phy_connect(bgmac->net_dev, bus_id, &bgmac_adjust_link,
+ 			      PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phy_dev)) {
+-		bgmac_err(bgmac, "PHY connecton failed\n");
++		dev_err(bgmac->dev, "PHY connecton failed\n");
+ 		err = PTR_ERR(phy_dev);
+ 		goto err_unregister_bus;
+ 	}
+@@ -1707,7 +1708,8 @@ static int bgmac_probe(struct bcma_devic
+ 		mac = sprom->et2mac;
+ 		break;
+ 	default:
+-		pr_err("Unsupported core_unit %d\n", core->core_unit);
++		dev_err(&core->dev, "Unsupported core_unit %d\n",
++			core->core_unit);
+ 		return -ENOTSUPP;
+ 	}
+ 
+@@ -1730,6 +1732,7 @@ static int bgmac_probe(struct bcma_devic
+ 	net_dev->irq = core->irq;
+ 	net_dev->ethtool_ops = &bgmac_ethtool_ops;
+ 	bgmac = netdev_priv(net_dev);
++	bgmac->dev = &core->dev;
+ 	bgmac->net_dev = net_dev;
+ 	bgmac->core = core;
+ 	bcma_set_drvdata(core, bgmac);
+@@ -1741,7 +1744,7 @@ static int bgmac_probe(struct bcma_devic
+ 	/* On BCM4706 we need common core to access PHY */
+ 	if (core->id.id == BCMA_CORE_4706_MAC_GBIT &&
+ 	    !core->bus->drv_gmac_cmn.core) {
+-		bgmac_err(bgmac, "GMAC CMN core not found (required for BCM4706)\n");
++		dev_err(bgmac->dev, "GMAC CMN core not found (required for BCM4706)\n");
+ 		err = -ENODEV;
+ 		goto err_netdev_free;
+ 	}
+@@ -1760,15 +1763,15 @@ static int bgmac_probe(struct bcma_devic
+ 	}
+ 	bgmac->phyaddr &= BGMAC_PHY_MASK;
+ 	if (bgmac->phyaddr == BGMAC_PHY_MASK) {
+-		bgmac_err(bgmac, "No PHY found\n");
++		dev_err(bgmac->dev, "No PHY found\n");
+ 		err = -ENODEV;
+ 		goto err_netdev_free;
+ 	}
+-	bgmac_info(bgmac, "Found PHY addr: %d%s\n", bgmac->phyaddr,
+-		   bgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");
++	dev_info(bgmac->dev, "Found PHY addr: %d%s\n", bgmac->phyaddr,
++		 bgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");
+ 
+ 	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
+-		bgmac_err(bgmac, "PCI setup not implemented\n");
++		dev_err(bgmac->dev, "PCI setup not implemented\n");
+ 		err = -ENOTSUPP;
+ 		goto err_netdev_free;
+ 	}
+@@ -1797,7 +1800,7 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	err = bgmac_dma_alloc(bgmac);
+ 	if (err) {
+-		bgmac_err(bgmac, "Unable to alloc memory for DMA\n");
++		dev_err(bgmac->dev, "Unable to alloc memory for DMA\n");
+ 		goto err_netdev_free;
+ 	}
+ 
+@@ -1811,16 +1814,16 @@ static int bgmac_probe(struct bcma_devic
+ 	bgmac->has_robosw = !!(core->bus->sprom.boardflags_lo &
+ 			       BGMAC_BFL_ENETROBO);
+ 	if (bgmac->has_robosw)
+-		bgmac_warn(bgmac, "Support for Roboswitch not implemented\n");
++		dev_warn(bgmac->dev, "Support for Roboswitch not implemented\n");
+ 
+ 	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
+-		bgmac_warn(bgmac, "Support for ADMtek ethernet switch not implemented\n");
++		dev_warn(bgmac->dev, "Support for ADMtek ethernet switch not implemented\n");
+ 
+ 	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
+ 
+ 	err = bgmac_mii_register(bgmac);
+ 	if (err) {
+-		bgmac_err(bgmac, "Cannot register MDIO\n");
++		dev_err(bgmac->dev, "Cannot connect to phy\n");
+ 		goto err_dma_free;
+ 	}
+ 
+@@ -1830,7 +1833,7 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	err = register_netdev(bgmac->net_dev);
+ 	if (err) {
+-		bgmac_err(bgmac, "Cannot register net device\n");
++		dev_err(bgmac->dev, "Cannot register net device\n");
+ 		goto err_mii_unregister;
+ 	}
+ 
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -1,17 +1,6 @@
+ #ifndef _BGMAC_H
+ #define _BGMAC_H
+ 
+-#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
+-
+-#define bgmac_err(bgmac, fmt, ...) \
+-	dev_err(&(bgmac)->core->dev, fmt, ##__VA_ARGS__)
+-#define bgmac_warn(bgmac, fmt, ...) \
+-	dev_warn(&(bgmac)->core->dev, fmt,  ##__VA_ARGS__)
+-#define bgmac_info(bgmac, fmt, ...) \
+-	dev_info(&(bgmac)->core->dev, fmt,  ##__VA_ARGS__)
+-#define bgmac_dbg(bgmac, fmt, ...) \
+-	dev_dbg(&(bgmac)->core->dev, fmt, ##__VA_ARGS__)
+-
+ #include <linux/bcma/bcma.h>
+ #include <linux/brcmphy.h>
+ #include <linux/netdevice.h>
+@@ -438,6 +427,8 @@ struct bgmac_rx_header {
+ struct bgmac {
+ 	struct bcma_device *core;
+ 	struct bcma_device *cmn; /* Reference to CMN core for BCM4706 */
++
++	struct device *dev;
+ 	struct net_device *net_dev;
+ 	struct napi_struct napi;
+ 	struct mii_bus *mii_bus;
+@@ -489,5 +480,4 @@ static inline void bgmac_set(struct bgma
+ {
+ 	bgmac_maskset(bgmac, offset, ~0, set);
+ }
+-
+ #endif /* _BGMAC_H */
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0002-net-ethernet-bgmac-add-dma_dev-pointer.patch b/target/linux/generic/pending-4.4/071-v4.8-0002-net-ethernet-bgmac-add-dma_dev-pointer.patch
new file mode 100644
index 0000000000..dd5b8772e3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0002-net-ethernet-bgmac-add-dma_dev-pointer.patch
@@ -0,0 +1,112 @@
+From a0b68486f6f680c7c0352a47c60042d7d95ffd87 Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Thu, 7 Jul 2016 19:08:54 -0400
+Subject: [PATCH 2/5] net: ethernet: bgmac: add dma_dev pointer
+
+The dma buffer allocation, etc references a dma_dev device pointer from
+the bcma core.  In anticipation of removing the bcma requirement for
+this driver, these must be changed to not reference that struct.  Add a
+dma_dev device pointer to the bgmac stuct and reference that instead.
+
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Tested-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 17 +++++++++--------
+ drivers/net/ethernet/broadcom/bgmac.h |  1 +
+ 2 files changed, 10 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -152,7 +152,7 @@ static netdev_tx_t bgmac_dma_tx_add(stru
+ 				    struct bgmac_dma_ring *ring,
+ 				    struct sk_buff *skb)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	struct net_device *net_dev = bgmac->net_dev;
+ 	int index = ring->end % BGMAC_TX_RING_SLOTS;
+ 	struct bgmac_slot_info *slot = &ring->slots[index];
+@@ -254,7 +254,7 @@ err_drop:
+ /* Free transmitted packets */
+ static void bgmac_dma_tx_free(struct bgmac *bgmac, struct bgmac_dma_ring *ring)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	int empty_slot;
+ 	bool freed = false;
+ 	unsigned bytes_compl = 0, pkts_compl = 0;
+@@ -355,7 +355,7 @@ static void bgmac_dma_rx_enable(struct b
+ static int bgmac_dma_rx_skb_for_slot(struct bgmac *bgmac,
+ 				     struct bgmac_slot_info *slot)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	dma_addr_t dma_addr;
+ 	struct bgmac_rx_header *rx;
+ 	void *buf;
+@@ -444,7 +444,7 @@ static int bgmac_dma_rx_read(struct bgma
+ 	end_slot /= sizeof(struct bgmac_dma_desc);
+ 
+ 	while (ring->start != end_slot) {
+-		struct device *dma_dev = bgmac->core->dma_dev;
++		struct device *dma_dev = bgmac->dma_dev;
+ 		struct bgmac_slot_info *slot = &ring->slots[ring->start];
+ 		struct bgmac_rx_header *rx = slot->buf + BGMAC_RX_BUF_OFFSET;
+ 		struct sk_buff *skb;
+@@ -547,7 +547,7 @@ static bool bgmac_dma_unaligned(struct b
+ static void bgmac_dma_tx_ring_free(struct bgmac *bgmac,
+ 				   struct bgmac_dma_ring *ring)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	struct bgmac_dma_desc *dma_desc = ring->cpu_base;
+ 	struct bgmac_slot_info *slot;
+ 	int i;
+@@ -573,7 +573,7 @@ static void bgmac_dma_tx_ring_free(struc
+ static void bgmac_dma_rx_ring_free(struct bgmac *bgmac,
+ 				   struct bgmac_dma_ring *ring)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	struct bgmac_slot_info *slot;
+ 	int i;
+ 
+@@ -594,7 +594,7 @@ static void bgmac_dma_ring_desc_free(str
+ 				     struct bgmac_dma_ring *ring,
+ 				     int num_slots)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	int size;
+ 
+ 	if (!ring->cpu_base)
+@@ -632,7 +632,7 @@ static void bgmac_dma_free(struct bgmac
+ 
+ static int bgmac_dma_alloc(struct bgmac *bgmac)
+ {
+-	struct device *dma_dev = bgmac->core->dma_dev;
++	struct device *dma_dev = bgmac->dma_dev;
+ 	struct bgmac_dma_ring *ring;
+ 	static const u16 ring_base[] = { BGMAC_DMA_BASE0, BGMAC_DMA_BASE1,
+ 					 BGMAC_DMA_BASE2, BGMAC_DMA_BASE3, };
+@@ -1733,6 +1733,7 @@ static int bgmac_probe(struct bcma_devic
+ 	net_dev->ethtool_ops = &bgmac_ethtool_ops;
+ 	bgmac = netdev_priv(net_dev);
+ 	bgmac->dev = &core->dev;
++	bgmac->dma_dev = core->dma_dev;
+ 	bgmac->net_dev = net_dev;
+ 	bgmac->core = core;
+ 	bcma_set_drvdata(core, bgmac);
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -429,6 +429,7 @@ struct bgmac {
+ 	struct bcma_device *cmn; /* Reference to CMN core for BCM4706 */
+ 
+ 	struct device *dev;
++	struct device *dma_dev;
+ 	struct net_device *net_dev;
+ 	struct napi_struct napi;
+ 	struct mii_bus *mii_bus;
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0003-net-ethernet-bgmac-move-BCMA-MDIO-Phy-code-into-a-se.patch b/target/linux/generic/pending-4.4/071-v4.8-0003-net-ethernet-bgmac-move-BCMA-MDIO-Phy-code-into-a-se.patch
new file mode 100644
index 0000000000..bc7b246cc1
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0003-net-ethernet-bgmac-move-BCMA-MDIO-Phy-code-into-a-se.patch
@@ -0,0 +1,676 @@
+From 55954f3bfdacc5908515b0c306cea23e77fab740 Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Thu, 7 Jul 2016 19:08:55 -0400
+Subject: [PATCH 3/5] net: ethernet: bgmac: move BCMA MDIO Phy code into a
+ separate file
+
+Move the BCMA MDIO phy into a separate file, as it is very tightly
+coupled with the BCMA bus.  This will help with the upcoming BCMA
+removal from the bgmac driver.  Optimally, this should be moved into
+phy drivers, but it is too tightly coupled with the bgmac driver to
+effectively move it without more changes to the driver.
+
+Note: the phy_reset was intentionally removed, as the mdio phy subsystem
+automatically resets the phy if a reset function pointer is present.  In
+addition to the moving of the driver, this reset function is added.
+
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Tested-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/Makefile          |   2 +-
+ drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c | 264 ++++++++++++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac.c           | 246 +++-------------------
+ drivers/net/ethernet/broadcom/bgmac.h           |   3 +
+ 4 files changed, 298 insertions(+), 217 deletions(-)
+ create mode 100644 drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
+
+--- a/drivers/net/ethernet/broadcom/Makefile
++++ b/drivers/net/ethernet/broadcom/Makefile
+@@ -10,6 +10,6 @@ obj-$(CONFIG_CNIC) += cnic.o
+ obj-$(CONFIG_BNX2X) += bnx2x/
+ obj-$(CONFIG_SB1250_MAC) += sb1250-mac.o
+ obj-$(CONFIG_TIGON3) += tg3.o
+-obj-$(CONFIG_BGMAC) += bgmac.o
++obj-$(CONFIG_BGMAC) += bgmac.o bgmac-bcma-mdio.o
+ obj-$(CONFIG_SYSTEMPORT) += bcmsysport.o
+ obj-$(CONFIG_BNXT) += bnxt/
+--- /dev/null
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
+@@ -0,0 +1,275 @@
++/*
++ * Driver for (BCM4706)? GBit MAC core on BCMA bus.
++ *
++ * Copyright (C) 2012 Rafa Miecki <zajec5@gmail.com>
++ *
++ * Licensed under the GNU/GPL. See COPYING for details.
++ */
++
++#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
++
++#include <linux/bcma/bcma.h>
++#include <linux/brcmphy.h>
++#include "bgmac.h"
++
++struct bcma_mdio {
++	struct bcma_device *core;
++	u8 phyaddr;
++};
++
++static bool bcma_mdio_wait_value(struct bcma_device *core, u16 reg, u32 mask,
++				 u32 value, int timeout)
++{
++	u32 val;
++	int i;
++
++	for (i = 0; i < timeout / 10; i++) {
++		val = bcma_read32(core, reg);
++		if ((val & mask) == value)
++			return true;
++		udelay(10);
++	}
++	dev_err(&core->dev, "Timeout waiting for reg 0x%X\n", reg);
++	return false;
++}
++
++/**************************************************
++ * PHY ops
++ **************************************************/
++
++static u16 bcma_mdio_phy_read(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg)
++{
++	struct bcma_device *core;
++	u16 phy_access_addr;
++	u16 phy_ctl_addr;
++	u32 tmp;
++
++	BUILD_BUG_ON(BGMAC_PA_DATA_MASK != BCMA_GMAC_CMN_PA_DATA_MASK);
++	BUILD_BUG_ON(BGMAC_PA_ADDR_MASK != BCMA_GMAC_CMN_PA_ADDR_MASK);
++	BUILD_BUG_ON(BGMAC_PA_ADDR_SHIFT != BCMA_GMAC_CMN_PA_ADDR_SHIFT);
++	BUILD_BUG_ON(BGMAC_PA_REG_MASK != BCMA_GMAC_CMN_PA_REG_MASK);
++	BUILD_BUG_ON(BGMAC_PA_REG_SHIFT != BCMA_GMAC_CMN_PA_REG_SHIFT);
++	BUILD_BUG_ON(BGMAC_PA_WRITE != BCMA_GMAC_CMN_PA_WRITE);
++	BUILD_BUG_ON(BGMAC_PA_START != BCMA_GMAC_CMN_PA_START);
++	BUILD_BUG_ON(BGMAC_PC_EPA_MASK != BCMA_GMAC_CMN_PC_EPA_MASK);
++	BUILD_BUG_ON(BGMAC_PC_MCT_MASK != BCMA_GMAC_CMN_PC_MCT_MASK);
++	BUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);
++	BUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);
++
++	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
++		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
++		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
++	} else {
++		core = bcma_mdio->core;
++		phy_access_addr = BGMAC_PHY_ACCESS;
++		phy_ctl_addr = BGMAC_PHY_CNTL;
++	}
++
++	tmp = bcma_read32(core, phy_ctl_addr);
++	tmp &= ~BGMAC_PC_EPA_MASK;
++	tmp |= phyaddr;
++	bcma_write32(core, phy_ctl_addr, tmp);
++
++	tmp = BGMAC_PA_START;
++	tmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;
++	tmp |= reg << BGMAC_PA_REG_SHIFT;
++	bcma_write32(core, phy_access_addr, tmp);
++
++	if (!bcma_mdio_wait_value(core, phy_access_addr, BGMAC_PA_START, 0,
++				  1000)) {
++		dev_err(&core->dev, "Reading PHY %d register 0x%X failed\n",
++			phyaddr, reg);
++		return 0xffff;
++	}
++
++	return bcma_read32(core, phy_access_addr) & BGMAC_PA_DATA_MASK;
++}
++
++/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphywr */
++static int bcma_mdio_phy_write(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg,
++			       u16 value)
++{
++	struct bcma_device *core;
++	u16 phy_access_addr;
++	u16 phy_ctl_addr;
++	u32 tmp;
++
++	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
++		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
++		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
++	} else {
++		core = bcma_mdio->core;
++		phy_access_addr = BGMAC_PHY_ACCESS;
++		phy_ctl_addr = BGMAC_PHY_CNTL;
++	}
++
++	tmp = bcma_read32(core, phy_ctl_addr);
++	tmp &= ~BGMAC_PC_EPA_MASK;
++	tmp |= phyaddr;
++	bcma_write32(core, phy_ctl_addr, tmp);
++
++	bcma_write32(bcma_mdio->core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
++	if (bcma_read32(bcma_mdio->core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
++		dev_warn(&core->dev, "Error setting MDIO int\n");
++
++	tmp = BGMAC_PA_START;
++	tmp |= BGMAC_PA_WRITE;
++	tmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;
++	tmp |= reg << BGMAC_PA_REG_SHIFT;
++	tmp |= value;
++	bcma_write32(core, phy_access_addr, tmp);
++
++	if (!bcma_mdio_wait_value(core, phy_access_addr, BGMAC_PA_START, 0,
++				  1000)) {
++		dev_err(&core->dev, "Writing to PHY %d register 0x%X failed\n",
++			phyaddr, reg);
++		return -ETIMEDOUT;
++	}
++
++	return 0;
++}
++
++/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyinit */
++static void bcma_mdio_phy_init(struct bcma_mdio *bcma_mdio)
++{
++	struct bcma_chipinfo *ci = &bcma_mdio->core->bus->chipinfo;
++	u8 i;
++
++	if (ci->id == BCMA_CHIP_ID_BCM5356) {
++		for (i = 0; i < 5; i++) {
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x008b);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x15, 0x0100);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x12, 0x2aaa);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
++		}
++	}
++	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
++	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
++	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {
++		struct bcma_drv_cc *cc = &bcma_mdio->core->bus->drv_cc;
++
++		bcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);
++		bcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);
++		for (i = 0; i < 5; i++) {
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5284);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x0010);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5296);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x1073);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9073);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x52b6);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9273);
++			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
++		}
++	}
++}
++
++/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
++static int bcma_mdio_phy_reset(struct mii_bus *bus)
++{
++	struct bcma_mdio *bcma_mdio = bus->priv;
++	u8 phyaddr = bcma_mdio->phyaddr;
++
++	if (bcma_mdio->phyaddr == BGMAC_PHY_NOREGS)
++		return 0;
++
++	bcma_mdio_phy_write(bcma_mdio, phyaddr, MII_BMCR, BMCR_RESET);
++	udelay(100);
++	if (bcma_mdio_phy_read(bcma_mdio, phyaddr, MII_BMCR) & BMCR_RESET)
++		dev_err(&bcma_mdio->core->dev, "PHY reset failed\n");
++	bcma_mdio_phy_init(bcma_mdio);
++
++	return 0;
++}
++
++/**************************************************
++ * MII
++ **************************************************/
++
++static int bcma_mdio_mii_read(struct mii_bus *bus, int mii_id, int regnum)
++{
++	return bcma_mdio_phy_read(bus->priv, mii_id, regnum);
++}
++
++static int bcma_mdio_mii_write(struct mii_bus *bus, int mii_id, int regnum,
++			       u16 value)
++{
++	return bcma_mdio_phy_write(bus->priv, mii_id, regnum, value);
++}
++
++struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr)
++{
++	struct bcma_mdio *bcma_mdio;
++	struct mii_bus *mii_bus;
++	int i, err;
++
++	bcma_mdio = kzalloc(sizeof(*bcma_mdio), GFP_KERNEL);
++	if (!bcma_mdio)
++		return ERR_PTR(-ENOMEM);
++
++	mii_bus = mdiobus_alloc();
++	if (!mii_bus) {
++		err = -ENOMEM;
++		goto err;
++	}
++
++	mii_bus->name = "bcma_mdio mii bus";
++	sprintf(mii_bus->id, "%s-%d-%d", "bcma_mdio", core->bus->num,
++		core->core_unit);
++	mii_bus->priv = bcma_mdio;
++	mii_bus->read = bcma_mdio_mii_read;
++	mii_bus->write = bcma_mdio_mii_write;
++	mii_bus->reset = bcma_mdio_phy_reset;
++	mii_bus->parent = &core->dev;
++	mii_bus->phy_mask = ~(1 << phyaddr);
++ 
++	mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
++	if (!mii_bus->irq) {
++		err = -ENOMEM;
++		goto err_free_bus;
++	}
++	for (i = 0; i < PHY_MAX_ADDR; i++)
++		mii_bus->irq[i] = PHY_POLL;
++
++	bcma_mdio->core = core;
++	bcma_mdio->phyaddr = phyaddr;
++
++	err = mdiobus_register(mii_bus);
++	if (err) {
++		dev_err(&core->dev, "Registration of mii bus failed\n");
++		goto err_free_irq;
++	}
++
++	return mii_bus;
++
++err_free_irq:
++	kfree(mii_bus->irq);
++err_free_bus:
++	mdiobus_free(mii_bus);
++err:
++	kfree(bcma_mdio);
++	return ERR_PTR(err);
++}
++
++void bcma_mdio_mii_unregister(struct mii_bus *mii_bus)
++{
++	struct bcma_mdio *bcma_mdio;
++
++	if (!mii_bus)
++		return;
++
++	bcma_mdio = mii_bus->priv;
++
++	mdiobus_unregister(mii_bus);
++	kfree(mii_bus->irq);
++	mdiobus_free(mii_bus);
++	kfree(bcma_mdio);
++}
++
++MODULE_AUTHOR("Rafa Miecki");
++MODULE_LICENSE("GPL");
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -759,150 +759,6 @@ error:
+ 	return err;
+ }
+ 
+-/**************************************************
+- * PHY ops
+- **************************************************/
+-
+-static u16 bgmac_phy_read(struct bgmac *bgmac, u8 phyaddr, u8 reg)
+-{
+-	struct bcma_device *core;
+-	u16 phy_access_addr;
+-	u16 phy_ctl_addr;
+-	u32 tmp;
+-
+-	BUILD_BUG_ON(BGMAC_PA_DATA_MASK != BCMA_GMAC_CMN_PA_DATA_MASK);
+-	BUILD_BUG_ON(BGMAC_PA_ADDR_MASK != BCMA_GMAC_CMN_PA_ADDR_MASK);
+-	BUILD_BUG_ON(BGMAC_PA_ADDR_SHIFT != BCMA_GMAC_CMN_PA_ADDR_SHIFT);
+-	BUILD_BUG_ON(BGMAC_PA_REG_MASK != BCMA_GMAC_CMN_PA_REG_MASK);
+-	BUILD_BUG_ON(BGMAC_PA_REG_SHIFT != BCMA_GMAC_CMN_PA_REG_SHIFT);
+-	BUILD_BUG_ON(BGMAC_PA_WRITE != BCMA_GMAC_CMN_PA_WRITE);
+-	BUILD_BUG_ON(BGMAC_PA_START != BCMA_GMAC_CMN_PA_START);
+-	BUILD_BUG_ON(BGMAC_PC_EPA_MASK != BCMA_GMAC_CMN_PC_EPA_MASK);
+-	BUILD_BUG_ON(BGMAC_PC_MCT_MASK != BCMA_GMAC_CMN_PC_MCT_MASK);
+-	BUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);
+-	BUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);
+-
+-	if (bgmac->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
+-		core = bgmac->core->bus->drv_gmac_cmn.core;
+-		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
+-		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
+-	} else {
+-		core = bgmac->core;
+-		phy_access_addr = BGMAC_PHY_ACCESS;
+-		phy_ctl_addr = BGMAC_PHY_CNTL;
+-	}
+-
+-	tmp = bcma_read32(core, phy_ctl_addr);
+-	tmp &= ~BGMAC_PC_EPA_MASK;
+-	tmp |= phyaddr;
+-	bcma_write32(core, phy_ctl_addr, tmp);
+-
+-	tmp = BGMAC_PA_START;
+-	tmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;
+-	tmp |= reg << BGMAC_PA_REG_SHIFT;
+-	bcma_write32(core, phy_access_addr, tmp);
+-
+-	if (!bgmac_wait_value(core, phy_access_addr, BGMAC_PA_START, 0, 1000)) {
+-		dev_err(bgmac->dev, "Reading PHY %d register 0x%X failed\n",
+-			phyaddr, reg);
+-		return 0xffff;
+-	}
+-
+-	return bcma_read32(core, phy_access_addr) & BGMAC_PA_DATA_MASK;
+-}
+-
+-/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphywr */
+-static int bgmac_phy_write(struct bgmac *bgmac, u8 phyaddr, u8 reg, u16 value)
+-{
+-	struct bcma_device *core;
+-	u16 phy_access_addr;
+-	u16 phy_ctl_addr;
+-	u32 tmp;
+-
+-	if (bgmac->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
+-		core = bgmac->core->bus->drv_gmac_cmn.core;
+-		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
+-		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
+-	} else {
+-		core = bgmac->core;
+-		phy_access_addr = BGMAC_PHY_ACCESS;
+-		phy_ctl_addr = BGMAC_PHY_CNTL;
+-	}
+-
+-	tmp = bcma_read32(core, phy_ctl_addr);
+-	tmp &= ~BGMAC_PC_EPA_MASK;
+-	tmp |= phyaddr;
+-	bcma_write32(core, phy_ctl_addr, tmp);
+-
+-	bgmac_write(bgmac, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
+-	if (bgmac_read(bgmac, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
+-		dev_warn(bgmac->dev, "Error setting MDIO int\n");
+-
+-	tmp = BGMAC_PA_START;
+-	tmp |= BGMAC_PA_WRITE;
+-	tmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;
+-	tmp |= reg << BGMAC_PA_REG_SHIFT;
+-	tmp |= value;
+-	bcma_write32(core, phy_access_addr, tmp);
+-
+-	if (!bgmac_wait_value(core, phy_access_addr, BGMAC_PA_START, 0, 1000)) {
+-		dev_err(bgmac->dev, "Writing to PHY %d register 0x%X failed\n",
+-			phyaddr, reg);
+-		return -ETIMEDOUT;
+-	}
+-
+-	return 0;
+-}
+-
+-/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyinit */
+-static void bgmac_phy_init(struct bgmac *bgmac)
+-{
+-	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
+-	struct bcma_drv_cc *cc = &bgmac->core->bus->drv_cc;
+-	u8 i;
+-
+-	if (ci->id == BCMA_CHIP_ID_BCM5356) {
+-		for (i = 0; i < 5; i++) {
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x008b);
+-			bgmac_phy_write(bgmac, i, 0x15, 0x0100);
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000f);
+-			bgmac_phy_write(bgmac, i, 0x12, 0x2aaa);
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000b);
+-		}
+-	}
+-	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
+-	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
+-	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {
+-		bcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);
+-		bcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);
+-		for (i = 0; i < 5; i++) {
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000f);
+-			bgmac_phy_write(bgmac, i, 0x16, 0x5284);
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000b);
+-			bgmac_phy_write(bgmac, i, 0x17, 0x0010);
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000f);
+-			bgmac_phy_write(bgmac, i, 0x16, 0x5296);
+-			bgmac_phy_write(bgmac, i, 0x17, 0x1073);
+-			bgmac_phy_write(bgmac, i, 0x17, 0x9073);
+-			bgmac_phy_write(bgmac, i, 0x16, 0x52b6);
+-			bgmac_phy_write(bgmac, i, 0x17, 0x9273);
+-			bgmac_phy_write(bgmac, i, 0x1f, 0x000b);
+-		}
+-	}
+-}
+-
+-/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
+-static void bgmac_phy_reset(struct bgmac *bgmac)
+-{
+-	if (bgmac->phyaddr == BGMAC_PHY_NOREGS)
+-		return;
+-
+-	bgmac_phy_write(bgmac, bgmac->phyaddr, MII_BMCR, BMCR_RESET);
+-	udelay(100);
+-	if (bgmac_phy_read(bgmac, bgmac->phyaddr, MII_BMCR) & BMCR_RESET)
+-		dev_err(bgmac->dev, "PHY reset failed\n");
+-	bgmac_phy_init(bgmac);
+-}
+ 
+ /**************************************************
+  * Chip ops
+@@ -1159,7 +1015,8 @@ static void bgmac_chip_reset(struct bgma
+ 	else
+ 		bgmac_set(bgmac, BGMAC_PHY_CNTL, BGMAC_PC_MTE);
+ 	bgmac_miiconfig(bgmac);
+-	bgmac_phy_init(bgmac);
++	if (bgmac->mii_bus)
++		bgmac->mii_bus->reset(bgmac->mii_bus);
+ 
+ 	netdev_reset_queue(bgmac->net_dev);
+ }
+@@ -1553,17 +1410,6 @@ static const struct ethtool_ops bgmac_et
+  * MII
+  **************************************************/
+ 
+-static int bgmac_mii_read(struct mii_bus *bus, int mii_id, int regnum)
+-{
+-	return bgmac_phy_read(bus->priv, mii_id, regnum);
+-}
+-
+-static int bgmac_mii_write(struct mii_bus *bus, int mii_id, int regnum,
+-			   u16 value)
+-{
+-	return bgmac_phy_write(bus->priv, mii_id, regnum, value);
+-}
+-
+ static void bgmac_adjust_link(struct net_device *net_dev)
+ {
+ 	struct bgmac *bgmac = netdev_priv(net_dev);
+@@ -1588,7 +1434,7 @@ static void bgmac_adjust_link(struct net
+ 	}
+ }
+ 
+-static int bgmac_fixed_phy_register(struct bgmac *bgmac)
++static int bgmac_phy_connect_direct(struct bgmac *bgmac)
+ {
+ 	struct fixed_phy_status fphy_status = {
+ 		.link = 1,
+@@ -1614,81 +1460,24 @@ static int bgmac_fixed_phy_register(stru
+ 	return err;
+ }
+ 
+-static int bgmac_mii_register(struct bgmac *bgmac)
++static int bgmac_phy_connect(struct bgmac *bgmac)
+ {
+-	struct mii_bus *mii_bus;
+ 	struct phy_device *phy_dev;
+ 	char bus_id[MII_BUS_ID_SIZE + 3];
+-	int i, err = 0;
+-
+-	if (bgmac_is_bcm4707_family(bgmac))
+-		return bgmac_fixed_phy_register(bgmac);
+-
+-	mii_bus = mdiobus_alloc();
+-	if (!mii_bus)
+-		return -ENOMEM;
+-
+-	mii_bus->name = "bgmac mii bus";
+-	sprintf(mii_bus->id, "%s-%d-%d", "bgmac", bgmac->core->bus->num,
+-		bgmac->core->core_unit);
+-	mii_bus->priv = bgmac;
+-	mii_bus->read = bgmac_mii_read;
+-	mii_bus->write = bgmac_mii_write;
+-	mii_bus->parent = &bgmac->core->dev;
+-	mii_bus->phy_mask = ~(1 << bgmac->phyaddr);
+-
+-	mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+-	if (!mii_bus->irq) {
+-		err = -ENOMEM;
+-		goto err_free_bus;
+-	}
+-	for (i = 0; i < PHY_MAX_ADDR; i++)
+-		mii_bus->irq[i] = PHY_POLL;
+-
+-	err = mdiobus_register(mii_bus);
+-	if (err) {
+-		dev_err(bgmac->dev, "Registration of mii bus failed\n");
+-		goto err_free_irq;
+-	}
+-
+-	bgmac->mii_bus = mii_bus;
+ 
+ 	/* Connect to the PHY */
+-	snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,
++	snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, bgmac->mii_bus->id,
+ 		 bgmac->phyaddr);
+ 	phy_dev = phy_connect(bgmac->net_dev, bus_id, &bgmac_adjust_link,
+ 			      PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phy_dev)) {
+ 		dev_err(bgmac->dev, "PHY connecton failed\n");
+-		err = PTR_ERR(phy_dev);
+-		goto err_unregister_bus;
++		return PTR_ERR(phy_dev);
+ 	}
+ 
+-	return err;
+-
+-err_unregister_bus:
+-	mdiobus_unregister(mii_bus);
+-err_free_irq:
+-	kfree(mii_bus->irq);
+-err_free_bus:
+-	mdiobus_free(mii_bus);
+-	return err;
+-}
+-
+-static void bgmac_mii_unregister(struct bgmac *bgmac)
+-{
+-	struct mii_bus *mii_bus = bgmac->mii_bus;
+-
+-	mdiobus_unregister(mii_bus);
+-	kfree(mii_bus->irq);
+-	mdiobus_free(mii_bus);
++	return 0;
+ }
+ 
+-/**************************************************
+- * BCMA bus ops
+- **************************************************/
+-
+-/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipattach */
+ static int bgmac_probe(struct bcma_device *core)
+ {
+ 	struct net_device *net_dev;
+@@ -1809,9 +1598,6 @@ static int bgmac_probe(struct bcma_devic
+ 	if (bcm47xx_nvram_getenv("et0_no_txint", NULL, 0) == 0)
+ 		bgmac->int_mask &= ~BGMAC_IS_TX_MASK;
+ 
+-	/* TODO: reset the external phy. Specs are needed */
+-	bgmac_phy_reset(bgmac);
+-
+ 	bgmac->has_robosw = !!(core->bus->sprom.boardflags_lo &
+ 			       BGMAC_BFL_ENETROBO);
+ 	if (bgmac->has_robosw)
+@@ -1822,10 +1608,25 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
+ 
+-	err = bgmac_mii_register(bgmac);
++	if (!bgmac_is_bcm4707_family(bgmac)) {
++		struct mii_bus *mii_bus;
++
++		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
++		if (!IS_ERR(mii_bus)) {
++			err = PTR_ERR(mii_bus);
++			goto err_dma_free;
++		}
++
++		bgmac->mii_bus = mii_bus;
++	}
++
++	if (!bgmac->mii_bus)
++		err = bgmac_phy_connect_direct(bgmac);
++	else
++		err = bgmac_phy_connect(bgmac);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Cannot connect to phy\n");
+-		goto err_dma_free;
++		goto err_mii_unregister;
+ 	}
+ 
+ 	net_dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+@@ -1835,18 +1636,19 @@ static int bgmac_probe(struct bcma_devic
+ 	err = register_netdev(bgmac->net_dev);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Cannot register net device\n");
+-		goto err_mii_unregister;
++		goto err_phy_disconnect;
+ 	}
+ 
+ 	netif_carrier_off(net_dev);
+ 
+ 	return 0;
+ 
++err_phy_disconnect:
++	phy_disconnect(net_dev->phydev);
+ err_mii_unregister:
+-	bgmac_mii_unregister(bgmac);
++	bcma_mdio_mii_unregister(bgmac->mii_bus);
+ err_dma_free:
+ 	bgmac_dma_free(bgmac);
+-
+ err_netdev_free:
+ 	bcma_set_drvdata(core, NULL);
+ 	free_netdev(net_dev);
+@@ -1859,7 +1661,8 @@ static void bgmac_remove(struct bcma_dev
+ 	struct bgmac *bgmac = bcma_get_drvdata(core);
+ 
+ 	unregister_netdev(bgmac->net_dev);
+-	bgmac_mii_unregister(bgmac);
++	phy_disconnect(bgmac->net_dev->phydev);
++	bcma_mdio_mii_unregister(bgmac->mii_bus);
+ 	netif_napi_del(&bgmac->napi);
+ 	bgmac_dma_free(bgmac);
+ 	bcma_set_drvdata(core, NULL);
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -456,6 +456,9 @@ struct bgmac {
+ 	bool loopback;
+ };
+ 
++struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
++void bcma_mdio_mii_unregister(struct mii_bus *mii_bus);
++
+ static inline u32 bgmac_read(struct bgmac *bgmac, u16 offset)
+ {
+ 	return bcma_read32(bgmac->core, offset);
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0004-net-ethernet-bgmac-convert-to-feature-flags.patch b/target/linux/generic/pending-4.4/071-v4.8-0004-net-ethernet-bgmac-convert-to-feature-flags.patch
new file mode 100644
index 0000000000..0f627919d0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0004-net-ethernet-bgmac-convert-to-feature-flags.patch
@@ -0,0 +1,384 @@
+From db791eb2970bad193b1dc95a4461b222dd22cb64 Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Thu, 7 Jul 2016 19:08:56 -0400
+Subject: [PATCH 4/5] net: ethernet: bgmac: convert to feature flags
+
+The bgmac driver is using the bcma provides device ID and revision, as
+well as the SoC ID and package, to determine which features are
+necessary to enable, reset, etc in the driver.   In anticipation of
+removing the bcma requirement for this driver, these must be changed to
+not reference that struct.  In place of that, each "feature" has been
+given a flag, and the flags are enabled for their respective device and
+SoC.
+
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Tested-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 167 ++++++++++++++++++++++++----------
+ drivers/net/ethernet/broadcom/bgmac.h |  21 ++++-
+ 2 files changed, 140 insertions(+), 48 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -109,7 +109,7 @@ static void bgmac_dma_tx_enable(struct b
+ 	u32 ctl;
+ 
+ 	ctl = bgmac_read(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL);
+-	if (bgmac->core->id.rev >= 4) {
++	if (bgmac->feature_flags & BGMAC_FEAT_TX_MASK_SETUP) {
+ 		ctl &= ~BGMAC_DMA_TX_BL_MASK;
+ 		ctl |= BGMAC_DMA_TX_BL_128 << BGMAC_DMA_TX_BL_SHIFT;
+ 
+@@ -335,7 +335,7 @@ static void bgmac_dma_rx_enable(struct b
+ 	/* preserve ONLY bits 16-17 from current hardware value */
+ 	ctl &= BGMAC_DMA_RX_ADDREXT_MASK;
+ 
+-	if (bgmac->core->id.rev >= 4) {
++	if (bgmac->feature_flags & BGMAC_FEAT_RX_MASK_SETUP) {
+ 		ctl &= ~BGMAC_DMA_RX_BL_MASK;
+ 		ctl |= BGMAC_DMA_RX_BL_128 << BGMAC_DMA_RX_BL_SHIFT;
+ 
+@@ -772,14 +772,20 @@ static void bgmac_cmdcfg_maskset(struct
+ {
+ 	u32 cmdcfg = bgmac_read(bgmac, BGMAC_CMDCFG);
+ 	u32 new_val = (cmdcfg & mask) | set;
++	u32 cmdcfg_sr;
+ 
+-	bgmac_set(bgmac, BGMAC_CMDCFG, BGMAC_CMDCFG_SR(bgmac->core->id.rev));
++	if (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV4;
++	else
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV0;
++
++	bgmac_set(bgmac, BGMAC_CMDCFG, cmdcfg_sr);
+ 	udelay(2);
+ 
+ 	if (new_val != cmdcfg || force)
+ 		bgmac_write(bgmac, BGMAC_CMDCFG, new_val);
+ 
+-	bgmac_mask(bgmac, BGMAC_CMDCFG, ~BGMAC_CMDCFG_SR(bgmac->core->id.rev));
++	bgmac_mask(bgmac, BGMAC_CMDCFG, ~cmdcfg_sr);
+ 	udelay(2);
+ }
+ 
+@@ -808,7 +814,7 @@ static void bgmac_chip_stats_update(stru
+ {
+ 	int i;
+ 
+-	if (bgmac->core->id.id != BCMA_CORE_4706_MAC_GBIT) {
++	if (!(bgmac->feature_flags & BGMAC_FEAT_NO_CLR_MIB)) {
+ 		for (i = 0; i < BGMAC_NUM_MIB_TX_REGS; i++)
+ 			bgmac->mib_tx_regs[i] =
+ 				bgmac_read(bgmac,
+@@ -827,7 +833,7 @@ static void bgmac_clear_mib(struct bgmac
+ {
+ 	int i;
+ 
+-	if (bgmac->core->id.id == BCMA_CORE_4706_MAC_GBIT)
++	if (bgmac->feature_flags & BGMAC_FEAT_NO_CLR_MIB)
+ 		return;
+ 
+ 	bgmac_set(bgmac, BGMAC_DEV_CTL, BGMAC_DC_MROR);
+@@ -870,9 +876,8 @@ static void bgmac_mac_speed(struct bgmac
+ static void bgmac_miiconfig(struct bgmac *bgmac)
+ {
+ 	struct bcma_device *core = bgmac->core;
+-	u8 imode;
+ 
+-	if (bgmac_is_bcm4707_family(bgmac)) {
++	if (bgmac->feature_flags & BGMAC_FEAT_FORCE_SPEED_2500) {
+ 		bcma_awrite32(core, BCMA_IOCTL,
+ 			      bcma_aread32(core, BCMA_IOCTL) | 0x40 |
+ 			      BGMAC_BCMA_IOCTL_SW_CLKEN);
+@@ -880,6 +885,8 @@ static void bgmac_miiconfig(struct bgmac
+ 		bgmac->mac_duplex = DUPLEX_FULL;
+ 		bgmac_mac_speed(bgmac);
+ 	} else {
++		u8 imode;
++
+ 		imode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) &
+ 			BGMAC_DS_MM_MASK) >> BGMAC_DS_MM_SHIFT;
+ 		if (imode == 0 || imode == 1) {
+@@ -894,9 +901,7 @@ static void bgmac_miiconfig(struct bgmac
+ static void bgmac_chip_reset(struct bgmac *bgmac)
+ {
+ 	struct bcma_device *core = bgmac->core;
+-	struct bcma_bus *bus = core->bus;
+-	struct bcma_chipinfo *ci = &bus->chipinfo;
+-	u32 flags;
++	u32 cmdcfg_sr;
+ 	u32 iost;
+ 	int i;
+ 
+@@ -919,15 +924,12 @@ static void bgmac_chip_reset(struct bgma
+ 	}
+ 
+ 	iost = bcma_aread32(core, BCMA_IOST);
+-	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg == BCMA_PKG_ID_BCM47186) ||
+-	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg == 10) ||
+-	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg == BCMA_PKG_ID_BCM47188))
++	if (bgmac->feature_flags & BGMAC_FEAT_IOST_ATTACHED)
+ 		iost &= ~BGMAC_BCMA_IOST_ATTACHED;
+ 
+ 	/* 3GMAC: for BCM4707 & BCM47094, only do core reset at bgmac_probe() */
+-	if (ci->id != BCMA_CHIP_ID_BCM4707 &&
+-	    ci->id != BCMA_CHIP_ID_BCM47094) {
+-		flags = 0;
++	if (!(bgmac->feature_flags & BGMAC_FEAT_NO_RESET)) {
++		u32 flags = 0;
+ 		if (iost & BGMAC_BCMA_IOST_ATTACHED) {
+ 			flags = BGMAC_BCMA_IOCTL_SW_CLKEN;
+ 			if (!bgmac->has_robosw)
+@@ -937,7 +939,7 @@ static void bgmac_chip_reset(struct bgma
+ 	}
+ 
+ 	/* Request Misc PLL for corerev > 2 */
+-	if (core->id.rev > 2 && !bgmac_is_bcm4707_family(bgmac)) {
++	if (bgmac->feature_flags & BGMAC_FEAT_MISC_PLL_REQ) {
+ 		bgmac_set(bgmac, BCMA_CLKCTLST,
+ 			  BGMAC_BCMA_CLKCTLST_MISC_PLL_REQ);
+ 		bgmac_wait_value(bgmac->core, BCMA_CLKCTLST,
+@@ -946,9 +948,7 @@ static void bgmac_chip_reset(struct bgma
+ 				 1000);
+ 	}
+ 
+-	if (ci->id == BCMA_CHIP_ID_BCM5357 ||
+-	    ci->id == BCMA_CHIP_ID_BCM4749 ||
+-	    ci->id == BCMA_CHIP_ID_BCM53572) {
++	if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_PHY) {
+ 		struct bcma_drv_cc *cc = &bgmac->core->bus->drv_cc;
+ 		u8 et_swtype = 0;
+ 		u8 sw_type = BGMAC_CHIPCTL_1_SW_TYPE_EPHY |
+@@ -962,11 +962,9 @@ static void bgmac_chip_reset(struct bgma
+ 			et_swtype &= 0x0f;
+ 			et_swtype <<= 4;
+ 			sw_type = et_swtype;
+-		} else if (ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg == BCMA_PKG_ID_BCM5358) {
++		} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_EPHYRMII) {
+ 			sw_type = BGMAC_CHIPCTL_1_SW_TYPE_EPHYRMII;
+-		} else if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg == BCMA_PKG_ID_BCM47186) ||
+-			   (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg == 10) ||
+-			   (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg == BCMA_PKG_ID_BCM47188)) {
++		} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_RGMII) {
+ 			sw_type = BGMAC_CHIPCTL_1_IF_TYPE_RGMII |
+ 				  BGMAC_CHIPCTL_1_SW_TYPE_RGMII;
+ 		}
+@@ -986,6 +984,11 @@ static void bgmac_chip_reset(struct bgma
+ 	 * BGMAC_CMDCFG is read _after_ putting chip in a reset. So it has to
+ 	 * be keps until taking MAC out of the reset.
+ 	 */
++	if (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV4;
++	else
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV0;
++
+ 	bgmac_cmdcfg_maskset(bgmac,
+ 			     ~(BGMAC_CMDCFG_TE |
+ 			       BGMAC_CMDCFG_RE |
+@@ -1003,13 +1006,13 @@ static void bgmac_chip_reset(struct bgma
+ 			     BGMAC_CMDCFG_PROM |
+ 			     BGMAC_CMDCFG_NLC |
+ 			     BGMAC_CMDCFG_CFE |
+-			     BGMAC_CMDCFG_SR(core->id.rev),
++			     cmdcfg_sr,
+ 			     false);
+ 	bgmac->mac_speed = SPEED_UNKNOWN;
+ 	bgmac->mac_duplex = DUPLEX_UNKNOWN;
+ 
+ 	bgmac_clear_mib(bgmac);
+-	if (core->id.id == BCMA_CORE_4706_MAC_GBIT)
++	if (bgmac->feature_flags & BGMAC_FEAT_CMN_PHY_CTL)
+ 		bcma_maskset32(bgmac->cmn, BCMA_GMAC_CMN_PHY_CTL, ~0,
+ 			       BCMA_GMAC_CMN_PC_MTE);
+ 	else
+@@ -1035,46 +1038,48 @@ static void bgmac_chip_intrs_off(struct
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/gmac_enable */
+ static void bgmac_enable(struct bgmac *bgmac)
+ {
+-	struct bcma_chipinfo *ci = &bgmac->core->bus->chipinfo;
++	u32 cmdcfg_sr;
+ 	u32 cmdcfg;
+ 	u32 mode;
+-	u32 rxq_ctl;
+-	u32 fl_ctl;
+-	u16 bp_clk;
+-	u8 mdp;
++
++	if (bgmac->feature_flags & BGMAC_FEAT_CMDCFG_SR_REV4)
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV4;
++	else
++		cmdcfg_sr = BGMAC_CMDCFG_SR_REV0;
+ 
+ 	cmdcfg = bgmac_read(bgmac, BGMAC_CMDCFG);
+ 	bgmac_cmdcfg_maskset(bgmac, ~(BGMAC_CMDCFG_TE | BGMAC_CMDCFG_RE),
+-			     BGMAC_CMDCFG_SR(bgmac->core->id.rev), true);
++			     cmdcfg_sr, true);
+ 	udelay(2);
+ 	cmdcfg |= BGMAC_CMDCFG_TE | BGMAC_CMDCFG_RE;
+ 	bgmac_write(bgmac, BGMAC_CMDCFG, cmdcfg);
+ 
+ 	mode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) & BGMAC_DS_MM_MASK) >>
+ 		BGMAC_DS_MM_SHIFT;
+-	if (ci->id != BCMA_CHIP_ID_BCM47162 || mode != 0)
++	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST || mode != 0)
+ 		bgmac_set(bgmac, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
+-	if (ci->id == BCMA_CHIP_ID_BCM47162 && mode == 2)
++	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST && mode == 2)
+ 		bcma_chipco_chipctl_maskset(&bgmac->core->bus->drv_cc, 1, ~0,
+ 					    BGMAC_CHIPCTL_1_RXC_DLL_BYPASS);
+ 
+-	switch (ci->id) {
+-	case BCMA_CHIP_ID_BCM5357:
+-	case BCMA_CHIP_ID_BCM4749:
+-	case BCMA_CHIP_ID_BCM53572:
+-	case BCMA_CHIP_ID_BCM4716:
+-	case BCMA_CHIP_ID_BCM47162:
+-		fl_ctl = 0x03cb04cb;
+-		if (ci->id == BCMA_CHIP_ID_BCM5357 ||
+-		    ci->id == BCMA_CHIP_ID_BCM4749 ||
+-		    ci->id == BCMA_CHIP_ID_BCM53572)
++	if (bgmac->feature_flags & (BGMAC_FEAT_FLW_CTRL1 |
++				    BGMAC_FEAT_FLW_CTRL2)) {
++		u32 fl_ctl;
++
++		if (bgmac->feature_flags & BGMAC_FEAT_FLW_CTRL1)
+ 			fl_ctl = 0x2300e1;
++		else
++			fl_ctl = 0x03cb04cb;
++
+ 		bgmac_write(bgmac, BGMAC_FLOW_CTL_THRESH, fl_ctl);
+ 		bgmac_write(bgmac, BGMAC_PAUSE_CTL, 0x27fff);
+-		break;
+ 	}
+ 
+-	if (!bgmac_is_bcm4707_family(bgmac)) {
++	if (bgmac->feature_flags & BGMAC_FEAT_SET_RXQ_CLK) {
++		u32 rxq_ctl;
++		u16 bp_clk;
++		u8 mdp;
++
+ 		rxq_ctl = bgmac_read(bgmac, BGMAC_RXQ_CTL);
+ 		rxq_ctl &= ~BGMAC_RXQ_CTL_MDP_MASK;
+ 		bp_clk = bcma_pmu_get_bus_clock(&bgmac->core->bus->drv_cc) /
+@@ -1606,6 +1611,74 @@ static int bgmac_probe(struct bcma_devic
+ 	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
+ 		dev_warn(bgmac->dev, "Support for ADMtek ethernet switch not implemented\n");
+ 
++	/* Feature Flags */
++	switch (core->bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM5357:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47186) {
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++		}
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM5358)
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_EPHYRMII;
++		break;
++	case BCMA_CHIP_ID_BCM53572:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47188) {
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++		}
++		break;
++	case BCMA_CHIP_ID_BCM4749:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == 10) {
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++		}
++		break;
++	case BCMA_CHIP_ID_BCM4716:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		/* fallthrough */
++	case BCMA_CHIP_ID_BCM47162:
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		break;
++	/* bcm4707_family */
++	case BCMA_CHIP_ID_BCM4707:
++	case BCMA_CHIP_ID_BCM47094:
++	case BCMA_CHIP_ID_BCM53018:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
++		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
++		break;
++	default:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++	}
++
++	if (!bgmac_is_bcm4707_family(bgmac) && core->id.rev > 2)
++		bgmac->feature_flags |= BGMAC_FEAT_MISC_PLL_REQ;
++
++	if (core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		bgmac->feature_flags |= BGMAC_FEAT_CMN_PHY_CTL;
++		bgmac->feature_flags |= BGMAC_FEAT_NO_CLR_MIB;
++	}
++
++	if (core->id.rev >= 4) {
++		bgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;
++		bgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;
++		bgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;
++	}
++
+ 	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
+ 
+ 	if (!bgmac_is_bcm4707_family(bgmac)) {
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -190,7 +190,6 @@
+ #define  BGMAC_CMDCFG_HD_SHIFT			10
+ #define  BGMAC_CMDCFG_SR_REV0			0x00000800	/* Set to reset mode, for core rev 0-3 */
+ #define  BGMAC_CMDCFG_SR_REV4			0x00002000	/* Set to reset mode, for core rev >= 4 */
+-#define  BGMAC_CMDCFG_SR(rev)  ((rev >= 4) ? BGMAC_CMDCFG_SR_REV4 : BGMAC_CMDCFG_SR_REV0)
+ #define  BGMAC_CMDCFG_ML			0x00008000	/* Set to activate mac loopback mode */
+ #define  BGMAC_CMDCFG_AE			0x00400000
+ #define  BGMAC_CMDCFG_CFE			0x00800000
+@@ -376,6 +375,24 @@
+ 
+ #define ETHER_MAX_LEN   1518
+ 
++/* Feature Flags */
++#define BGMAC_FEAT_TX_MASK_SETUP	BIT(0)
++#define BGMAC_FEAT_RX_MASK_SETUP	BIT(1)
++#define BGMAC_FEAT_IOST_ATTACHED	BIT(2)
++#define BGMAC_FEAT_NO_RESET		BIT(3)
++#define BGMAC_FEAT_MISC_PLL_REQ		BIT(4)
++#define BGMAC_FEAT_SW_TYPE_PHY		BIT(5)
++#define BGMAC_FEAT_SW_TYPE_EPHYRMII	BIT(6)
++#define BGMAC_FEAT_SW_TYPE_RGMII	BIT(7)
++#define BGMAC_FEAT_CMN_PHY_CTL		BIT(8)
++#define BGMAC_FEAT_FLW_CTRL1		BIT(9)
++#define BGMAC_FEAT_FLW_CTRL2		BIT(10)
++#define BGMAC_FEAT_SET_RXQ_CLK		BIT(11)
++#define BGMAC_FEAT_CLKCTLST		BIT(12)
++#define BGMAC_FEAT_NO_CLR_MIB		BIT(13)
++#define BGMAC_FEAT_FORCE_SPEED_2500	BIT(14)
++#define BGMAC_FEAT_CMDCFG_SR_REV4	BIT(15)
++
+ struct bgmac_slot_info {
+ 	union {
+ 		struct sk_buff *skb;
+@@ -430,6 +447,8 @@ struct bgmac {
+ 
+ 	struct device *dev;
+ 	struct device *dma_dev;
++	u32 feature_flags;
++
+ 	struct net_device *net_dev;
+ 	struct napi_struct napi;
+ 	struct mii_bus *mii_bus;
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0005-net-ethernet-bgmac-Add-platform-device-support.patch b/target/linux/generic/pending-4.4/071-v4.8-0005-net-ethernet-bgmac-Add-platform-device-support.patch
new file mode 100644
index 0000000000..5755184949
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0005-net-ethernet-bgmac-Add-platform-device-support.patch
@@ -0,0 +1,1260 @@
+From f6a95a24957aec5bb488c3f978c4ed508177998f Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Thu, 7 Jul 2016 19:08:57 -0400
+Subject: [PATCH 5/5] net: ethernet: bgmac: Add platform device support
+
+The bcma portion of the driver has been split off into a bcma specific
+driver.  This has been mirrored for the platform driver.  The last
+references to the bcma core struct have been changed into a generic
+function call.  These function calls are wrappers to either the original
+bcma code or new platform functions that access the same areas via MMIO.
+This necessitated adding function pointers for both platform and bcma to
+hide which backend is being used from the generic bgmac code.
+
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Tested-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/Kconfig           |  23 +-
+ drivers/net/ethernet/broadcom/Makefile          |   4 +-
+ drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c |   2 +
+ drivers/net/ethernet/broadcom/bgmac-bcma.c      | 315 +++++++++++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac-platform.c  | 189 ++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac.c           | 329 ++++--------------------
+ drivers/net/ethernet/broadcom/bgmac.h           |  73 +++++-
+ 7 files changed, 650 insertions(+), 285 deletions(-)
+ create mode 100644 drivers/net/ethernet/broadcom/bgmac-bcma.c
+ create mode 100644 drivers/net/ethernet/broadcom/bgmac-platform.c
+
+--- a/drivers/net/ethernet/broadcom/Kconfig
++++ b/drivers/net/ethernet/broadcom/Kconfig
+@@ -150,10 +150,18 @@ config BNX2X_VXLAN
+ 	  Virtual eXtensible Local Area Network (VXLAN) in the driver.
+ 
+ config BGMAC
+-	tristate "BCMA bus GBit core support"
++	tristate
++	help
++	  This enables the integrated ethernet controller support for many
++	  Broadcom (mostly iProc) SoCs. An appropriate bus interface driver
++	  needs to be enabled to select this.
++
++config BGMAC_BCMA
++	tristate "Broadcom iProc GBit BCMA support"
+ 	depends on BCMA && BCMA_HOST_SOC
+ 	depends on HAS_DMA
+ 	depends on BCM47XX || ARCH_BCM_5301X || COMPILE_TEST
++	select BGMAC
+ 	select PHYLIB
+ 	select FIXED_PHY
+ 	---help---
+@@ -162,6 +170,19 @@ config BGMAC
+ 	  In case of using this driver on BCM4706 it's also requires to enable
+ 	  BCMA_DRIVER_GMAC_CMN to make it work.
+ 
++config BGMAC_PLATFORM
++	tristate "Broadcom iProc GBit platform support"
++	depends on HAS_DMA
++	depends on ARCH_BCM_IPROC || COMPILE_TEST
++	depends on OF
++	select BGMAC
++	select PHYLIB
++	select FIXED_PHY
++	default ARCH_BCM_IPROC
++	---help---
++	  Say Y here if you want to use the Broadcom iProc Gigabit Ethernet
++	  controller through the generic platform interface
++
+ config SYSTEMPORT
+ 	tristate "Broadcom SYSTEMPORT internal MAC support"
+ 	depends on OF
+--- a/drivers/net/ethernet/broadcom/Makefile
++++ b/drivers/net/ethernet/broadcom/Makefile
+@@ -10,6 +10,8 @@ obj-$(CONFIG_CNIC) += cnic.o
+ obj-$(CONFIG_BNX2X) += bnx2x/
+ obj-$(CONFIG_SB1250_MAC) += sb1250-mac.o
+ obj-$(CONFIG_TIGON3) += tg3.o
+-obj-$(CONFIG_BGMAC) += bgmac.o bgmac-bcma-mdio.o
++obj-$(CONFIG_BGMAC) += bgmac.o
++obj-$(CONFIG_BGMAC_BCMA) += bgmac-bcma.o bgmac-bcma-mdio.o
++obj-$(CONFIG_BGMAC_PLATFORM) += bgmac-platform.o
+ obj-$(CONFIG_SYSTEMPORT) += bcmsysport.o
+ obj-$(CONFIG_BNXT) += bnxt/
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
+@@ -255,6 +255,7 @@ err:
+ 	kfree(bcma_mdio);
+ 	return ERR_PTR(err);
+ }
++EXPORT_SYMBOL_GPL(bcma_mdio_mii_register);
+ 
+ void bcma_mdio_mii_unregister(struct mii_bus *mii_bus)
+ {
+@@ -270,6 +271,7 @@ void bcma_mdio_mii_unregister(struct mii
+ 	mdiobus_free(mii_bus);
+ 	kfree(bcma_mdio);
+ }
++EXPORT_SYMBOL_GPL(bcma_mdio_mii_unregister);
+ 
+ MODULE_AUTHOR("Rafa Miecki");
+ MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -0,0 +1,315 @@
++/*
++ * Driver for (BCM4706)? GBit MAC core on BCMA bus.
++ *
++ * Copyright (C) 2012 Rafa Miecki <zajec5@gmail.com>
++ *
++ * Licensed under the GNU/GPL. See COPYING for details.
++ */
++
++#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
++
++#include <linux/bcma/bcma.h>
++#include <linux/brcmphy.h>
++#include <linux/etherdevice.h>
++#include "bgmac.h"
++
++static inline bool bgmac_is_bcm4707_family(struct bcma_device *core)
++{
++	switch (core->bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM4707:
++	case BCMA_CHIP_ID_BCM47094:
++	case BCMA_CHIP_ID_BCM53018:
++		return true;
++	default:
++		return false;
++	}
++}
++
++/**************************************************
++ * BCMA bus ops
++ **************************************************/
++
++static u32 bcma_bgmac_read(struct bgmac *bgmac, u16 offset)
++{
++	return bcma_read32(bgmac->bcma.core, offset);
++}
++
++static void bcma_bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)
++{
++	bcma_write32(bgmac->bcma.core, offset, value);
++}
++
++static u32 bcma_bgmac_idm_read(struct bgmac *bgmac, u16 offset)
++{
++	return bcma_aread32(bgmac->bcma.core, offset);
++}
++
++static void bcma_bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)
++{
++	return bcma_awrite32(bgmac->bcma.core, offset, value);
++}
++
++static bool bcma_bgmac_clk_enabled(struct bgmac *bgmac)
++{
++	return bcma_core_is_enabled(bgmac->bcma.core);
++}
++
++static void bcma_bgmac_clk_enable(struct bgmac *bgmac, u32 flags)
++{
++	bcma_core_enable(bgmac->bcma.core, flags);
++}
++
++static void bcma_bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,
++				       u32 mask, u32 set)
++{
++	struct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;
++
++	bcma_chipco_chipctl_maskset(cc, offset, mask, set);
++}
++
++static u32 bcma_bgmac_get_bus_clock(struct bgmac *bgmac)
++{
++	struct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;
++
++	return bcma_pmu_get_bus_clock(cc);
++}
++
++static void bcma_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset, u32 mask,
++				     u32 set)
++{
++	bcma_maskset32(bgmac->bcma.cmn, offset, mask, set);
++}
++
++static const struct bcma_device_id bgmac_bcma_tbl[] = {
++	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_4706_MAC_GBIT,
++		  BCMA_ANY_REV, BCMA_ANY_CLASS),
++	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_MAC_GBIT, BCMA_ANY_REV,
++		  BCMA_ANY_CLASS),
++	{},
++};
++MODULE_DEVICE_TABLE(bcma, bgmac_bcma_tbl);
++
++/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipattach */
++static int bgmac_probe(struct bcma_device *core)
++{
++	struct ssb_sprom *sprom = &core->bus->sprom;
++	struct mii_bus *mii_bus;
++	struct bgmac *bgmac;
++	u8 *mac;
++	int err;
++
++	bgmac = kzalloc(sizeof(*bgmac), GFP_KERNEL);
++	if (!bgmac)
++		return -ENOMEM;
++
++	bgmac->bcma.core = core;
++	bgmac->dev = &core->dev;
++	bgmac->dma_dev = core->dma_dev;
++	bgmac->irq = core->irq;
++
++	bcma_set_drvdata(core, bgmac);
++
++	switch (core->core_unit) {
++	case 0:
++		mac = sprom->et0mac;
++		break;
++	case 1:
++		mac = sprom->et1mac;
++		break;
++	case 2:
++		mac = sprom->et2mac;
++		break;
++	default:
++		dev_err(bgmac->dev, "Unsupported core_unit %d\n",
++			core->core_unit);
++		err = -ENOTSUPP;
++		goto err;
++	}
++
++	ether_addr_copy(bgmac->mac_addr, mac);
++
++	/* On BCM4706 we need common core to access PHY */
++	if (core->id.id == BCMA_CORE_4706_MAC_GBIT &&
++	    !core->bus->drv_gmac_cmn.core) {
++		dev_err(bgmac->dev, "GMAC CMN core not found (required for BCM4706)\n");
++		err = -ENODEV;
++		goto err;
++	}
++	bgmac->bcma.cmn = core->bus->drv_gmac_cmn.core;
++
++	switch (core->core_unit) {
++	case 0:
++		bgmac->phyaddr = sprom->et0phyaddr;
++		break;
++	case 1:
++		bgmac->phyaddr = sprom->et1phyaddr;
++		break;
++	case 2:
++		bgmac->phyaddr = sprom->et2phyaddr;
++		break;
++	}
++	bgmac->phyaddr &= BGMAC_PHY_MASK;
++	if (bgmac->phyaddr == BGMAC_PHY_MASK) {
++		dev_err(bgmac->dev, "No PHY found\n");
++		err = -ENODEV;
++		goto err;
++	}
++	dev_info(bgmac->dev, "Found PHY addr: %d%s\n", bgmac->phyaddr,
++		 bgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");
++
++	if (!bgmac_is_bcm4707_family(core)) {
++		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
++		if (!IS_ERR(mii_bus)) {
++			err = PTR_ERR(mii_bus);
++			goto err;
++		}
++
++		bgmac->mii_bus = mii_bus;
++	}
++
++	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
++		dev_err(bgmac->dev, "PCI setup not implemented\n");
++		err = -ENOTSUPP;
++		goto err1;
++	}
++
++	bgmac->has_robosw = !!(core->bus->sprom.boardflags_lo &
++			       BGMAC_BFL_ENETROBO);
++	if (bgmac->has_robosw)
++		dev_warn(bgmac->dev, "Support for Roboswitch not implemented\n");
++
++	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
++		dev_warn(bgmac->dev, "Support for ADMtek ethernet switch not implemented\n");
++
++	/* Feature Flags */
++	switch (core->bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM5357:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47186) {
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++		}
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM5358)
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_EPHYRMII;
++		break;
++	case BCMA_CHIP_ID_BCM53572:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47188) {
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++		}
++		break;
++	case BCMA_CHIP_ID_BCM4749:
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
++		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
++		if (core->bus->chipinfo.pkg == 10) {
++			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++		}
++		break;
++	case BCMA_CHIP_ID_BCM4716:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		/* fallthrough */
++	case BCMA_CHIP_ID_BCM47162:
++		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		break;
++	/* bcm4707_family */
++	case BCMA_CHIP_ID_BCM4707:
++	case BCMA_CHIP_ID_BCM47094:
++	case BCMA_CHIP_ID_BCM53018:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
++		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
++		break;
++	default:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++	}
++
++	if (!bgmac_is_bcm4707_family(core) && core->id.rev > 2)
++		bgmac->feature_flags |= BGMAC_FEAT_MISC_PLL_REQ;
++
++	if (core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		bgmac->feature_flags |= BGMAC_FEAT_CMN_PHY_CTL;
++		bgmac->feature_flags |= BGMAC_FEAT_NO_CLR_MIB;
++	}
++
++	if (core->id.rev >= 4) {
++		bgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;
++		bgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;
++		bgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;
++	}
++
++	bgmac->read = bcma_bgmac_read;
++	bgmac->write = bcma_bgmac_write;
++	bgmac->idm_read = bcma_bgmac_idm_read;
++	bgmac->idm_write = bcma_bgmac_idm_write;
++	bgmac->clk_enabled = bcma_bgmac_clk_enabled;
++	bgmac->clk_enable = bcma_bgmac_clk_enable;
++	bgmac->cco_ctl_maskset = bcma_bgmac_cco_ctl_maskset;
++	bgmac->get_bus_clock = bcma_bgmac_get_bus_clock;
++	bgmac->cmn_maskset32 = bcma_bgmac_cmn_maskset32;
++
++	err = bgmac_enet_probe(bgmac);
++	if (err)
++		goto err1;
++
++	return 0;
++
++err1:
++	bcma_mdio_mii_unregister(bgmac->mii_bus);
++err:
++	kfree(bgmac);
++	bcma_set_drvdata(core, NULL);
++
++	return err;
++}
++
++static void bgmac_remove(struct bcma_device *core)
++{
++	struct bgmac *bgmac = bcma_get_drvdata(core);
++
++	bcma_mdio_mii_unregister(bgmac->mii_bus);
++	bgmac_enet_remove(bgmac);
++	bcma_set_drvdata(core, NULL);
++	kfree(bgmac);
++}
++
++static struct bcma_driver bgmac_bcma_driver = {
++	.name		= KBUILD_MODNAME,
++	.id_table	= bgmac_bcma_tbl,
++	.probe		= bgmac_probe,
++	.remove		= bgmac_remove,
++};
++
++static int __init bgmac_init(void)
++{
++	int err;
++
++	err = bcma_driver_register(&bgmac_bcma_driver);
++	if (err)
++		return err;
++	pr_info("Broadcom 47xx GBit MAC driver loaded\n");
++
++	return 0;
++}
++
++static void __exit bgmac_exit(void)
++{
++	bcma_driver_unregister(&bgmac_bcma_driver);
++}
++
++module_init(bgmac_init)
++module_exit(bgmac_exit)
++
++MODULE_AUTHOR("Rafa Miecki");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
+@@ -0,0 +1,189 @@
++/*
++ * Copyright (C) 2016 Broadcom
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation version 2.
++ *
++ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
++ * kind, whether express or implied; without even the implied warranty
++ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
++
++#include <linux/bcma/bcma.h>
++#include <linux/etherdevice.h>
++#include <linux/of_address.h>
++#include <linux/of_net.h>
++#include "bgmac.h"
++
++static u32 platform_bgmac_read(struct bgmac *bgmac, u16 offset)
++{
++	return readl(bgmac->plat.base + offset);
++}
++
++static void platform_bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)
++{
++	writel(value, bgmac->plat.base + offset);
++}
++
++static u32 platform_bgmac_idm_read(struct bgmac *bgmac, u16 offset)
++{
++	return readl(bgmac->plat.idm_base + offset);
++}
++
++static void platform_bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)
++{
++	return writel(value, bgmac->plat.idm_base + offset);
++}
++
++static bool platform_bgmac_clk_enabled(struct bgmac *bgmac)
++{
++	if ((bgmac_idm_read(bgmac, BCMA_IOCTL) &
++	     (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC)) != BCMA_IOCTL_CLK)
++		return false;
++	if (bgmac_idm_read(bgmac, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
++		return false;
++	return true;
++}
++
++static void platform_bgmac_clk_enable(struct bgmac *bgmac, u32 flags)
++{
++	bgmac_idm_write(bgmac, BCMA_IOCTL,
++			(BCMA_IOCTL_CLK | BCMA_IOCTL_FGC | flags));
++	bgmac_idm_read(bgmac, BCMA_IOCTL);
++
++	bgmac_idm_write(bgmac, BCMA_RESET_CTL, 0);
++	bgmac_idm_read(bgmac, BCMA_RESET_CTL);
++	udelay(1);
++
++	bgmac_idm_write(bgmac, BCMA_IOCTL, (BCMA_IOCTL_CLK | flags));
++	bgmac_idm_read(bgmac, BCMA_IOCTL);
++	udelay(1);
++}
++
++static void platform_bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,
++					   u32 mask, u32 set)
++{
++	/* This shouldn't be encountered */
++	WARN_ON(1);
++}
++
++static u32 platform_bgmac_get_bus_clock(struct bgmac *bgmac)
++{
++	/* This shouldn't be encountered */
++	WARN_ON(1);
++
++	return 0;
++}
++
++static void platform_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset,
++					 u32 mask, u32 set)
++{
++	/* This shouldn't be encountered */
++	WARN_ON(1);
++}
++
++static int bgmac_probe(struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node;
++	struct bgmac *bgmac;
++	struct resource *regs;
++	const u8 *mac_addr;
++
++	bgmac = devm_kzalloc(&pdev->dev, sizeof(*bgmac), GFP_KERNEL);
++	if (!bgmac)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, bgmac);
++
++	/* Set the features of the 4707 family */
++	bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++	bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
++	bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
++	bgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;
++	bgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;
++	bgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;
++
++	bgmac->dev = &pdev->dev;
++	bgmac->dma_dev = &pdev->dev;
++
++	mac_addr = of_get_mac_address(np);
++	if (mac_addr)
++		ether_addr_copy(bgmac->mac_addr, mac_addr);
++	else
++		dev_warn(&pdev->dev, "MAC address not present in device tree\n");
++
++	bgmac->irq = platform_get_irq(pdev, 0);
++	if (bgmac->irq < 0) {
++		dev_err(&pdev->dev, "Unable to obtain IRQ\n");
++		return bgmac->irq;
++	}
++
++	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "amac_base");
++	if (!regs) {
++		dev_err(&pdev->dev, "Unable to obtain base resource\n");
++		return -EINVAL;
++	}
++
++	bgmac->plat.base = devm_ioremap_resource(&pdev->dev, regs);
++	if (IS_ERR(bgmac->plat.base)) {
++		dev_err(&pdev->dev, "Unable to map base resource\n");
++		return PTR_ERR(bgmac->plat.base);
++	}
++
++	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "idm_base");
++	if (!regs) {
++		dev_err(&pdev->dev, "Unable to obtain idm resource\n");
++		return -EINVAL;
++	}
++
++	bgmac->plat.idm_base = devm_ioremap_resource(&pdev->dev, regs);
++	if (!bgmac->plat.idm_base) {
++		dev_err(&pdev->dev, "Unable to map idm resource\n");
++		return PTR_ERR(bgmac->plat.idm_base);
++	}
++
++	bgmac->read = platform_bgmac_read;
++	bgmac->write = platform_bgmac_write;
++	bgmac->idm_read = platform_bgmac_idm_read;
++	bgmac->idm_write = platform_bgmac_idm_write;
++	bgmac->clk_enabled = platform_bgmac_clk_enabled;
++	bgmac->clk_enable = platform_bgmac_clk_enable;
++	bgmac->cco_ctl_maskset = platform_bgmac_cco_ctl_maskset;
++	bgmac->get_bus_clock = platform_bgmac_get_bus_clock;
++	bgmac->cmn_maskset32 = platform_bgmac_cmn_maskset32;
++
++	return bgmac_enet_probe(bgmac);
++}
++
++static int bgmac_remove(struct platform_device *pdev)
++{
++	struct bgmac *bgmac = platform_get_drvdata(pdev);
++
++	bgmac_enet_remove(bgmac);
++
++	return 0;
++}
++
++static const struct of_device_id bgmac_of_enet_match[] = {
++	{.compatible = "brcm,amac",},
++	{.compatible = "brcm,nsp-amac",},
++	{},
++};
++
++MODULE_DEVICE_TABLE(of, bgmac_of_enet_match);
++
++static struct platform_driver bgmac_enet_driver = {
++	.driver = {
++		.name  = "bgmac-enet",
++		.of_match_table = bgmac_of_enet_match,
++	},
++	.probe = bgmac_probe,
++	.remove = bgmac_remove,
++};
++
++module_platform_driver(bgmac_enet_driver);
++MODULE_LICENSE("GPL");
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -6,51 +6,27 @@
+  * Licensed under the GNU/GPL. See COPYING for details.
+  */
+ 
+-#include "bgmac.h"
+ 
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/delay.h>
++#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
++
++#include <linux/bcma/bcma.h>
+ #include <linux/etherdevice.h>
+-#include <linux/mii.h>
+-#include <linux/phy.h>
+-#include <linux/phy_fixed.h>
+-#include <linux/interrupt.h>
+-#include <linux/dma-mapping.h>
+ #include <linux/bcm47xx_nvram.h>
++#include "bgmac.h"
+ 
+-static const struct bcma_device_id bgmac_bcma_tbl[] = {
+-	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_4706_MAC_GBIT, BCMA_ANY_REV, BCMA_ANY_CLASS),
+-	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_MAC_GBIT, BCMA_ANY_REV, BCMA_ANY_CLASS),
+-	{},
+-};
+-MODULE_DEVICE_TABLE(bcma, bgmac_bcma_tbl);
+-
+-static inline bool bgmac_is_bcm4707_family(struct bgmac *bgmac)
+-{
+-	switch (bgmac->core->bus->chipinfo.id) {
+-	case BCMA_CHIP_ID_BCM4707:
+-	case BCMA_CHIP_ID_BCM47094:
+-	case BCMA_CHIP_ID_BCM53018:
+-		return true;
+-	default:
+-		return false;
+-	}
+-}
+-
+-static bool bgmac_wait_value(struct bcma_device *core, u16 reg, u32 mask,
++static bool bgmac_wait_value(struct bgmac *bgmac, u16 reg, u32 mask,
+ 			     u32 value, int timeout)
+ {
+ 	u32 val;
+ 	int i;
+ 
+ 	for (i = 0; i < timeout / 10; i++) {
+-		val = bcma_read32(core, reg);
++		val = bgmac_read(bgmac, reg);
+ 		if ((val & mask) == value)
+ 			return true;
+ 		udelay(10);
+ 	}
+-	dev_err(&core->dev, "Timeout waiting for reg 0x%X\n", reg);
++	dev_err(bgmac->dev, "Timeout waiting for reg 0x%X\n", reg);
+ 	return false;
+ }
+ 
+@@ -89,7 +65,7 @@ static void bgmac_dma_tx_reset(struct bg
+ 
+ 	/* Remove SUSPEND bit */
+ 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_TX_CTL, 0);
+-	if (!bgmac_wait_value(bgmac->core,
++	if (!bgmac_wait_value(bgmac,
+ 			      ring->mmio_base + BGMAC_DMA_TX_STATUS,
+ 			      BGMAC_DMA_TX_STAT, BGMAC_DMA_TX_STAT_DISABLED,
+ 			      10000)) {
+@@ -317,7 +293,7 @@ static void bgmac_dma_rx_reset(struct bg
+ 		return;
+ 
+ 	bgmac_write(bgmac, ring->mmio_base + BGMAC_DMA_RX_CTL, 0);
+-	if (!bgmac_wait_value(bgmac->core,
++	if (!bgmac_wait_value(bgmac,
+ 			      ring->mmio_base + BGMAC_DMA_RX_STATUS,
+ 			      BGMAC_DMA_RX_STAT, BGMAC_DMA_RX_STAT_DISABLED,
+ 			      10000))
+@@ -643,7 +619,7 @@ static int bgmac_dma_alloc(struct bgmac
+ 	BUILD_BUG_ON(BGMAC_MAX_TX_RINGS > ARRAY_SIZE(ring_base));
+ 	BUILD_BUG_ON(BGMAC_MAX_RX_RINGS > ARRAY_SIZE(ring_base));
+ 
+-	if (!(bcma_aread32(bgmac->core, BCMA_IOST) & BCMA_IOST_DMA64)) {
++	if (!(bgmac_idm_read(bgmac, BCMA_IOST) & BCMA_IOST_DMA64)) {
+ 		dev_err(bgmac->dev, "Core does not report 64-bit DMA\n");
+ 		return -ENOTSUPP;
+ 	}
+@@ -875,12 +851,10 @@ static void bgmac_mac_speed(struct bgmac
+ 
+ static void bgmac_miiconfig(struct bgmac *bgmac)
+ {
+-	struct bcma_device *core = bgmac->core;
+-
+ 	if (bgmac->feature_flags & BGMAC_FEAT_FORCE_SPEED_2500) {
+-		bcma_awrite32(core, BCMA_IOCTL,
+-			      bcma_aread32(core, BCMA_IOCTL) | 0x40 |
+-			      BGMAC_BCMA_IOCTL_SW_CLKEN);
++		bgmac_idm_write(bgmac, BCMA_IOCTL,
++				bgmac_idm_read(bgmac, BCMA_IOCTL) | 0x40 |
++				BGMAC_BCMA_IOCTL_SW_CLKEN);
+ 		bgmac->mac_speed = SPEED_2500;
+ 		bgmac->mac_duplex = DUPLEX_FULL;
+ 		bgmac_mac_speed(bgmac);
+@@ -900,12 +874,11 @@ static void bgmac_miiconfig(struct bgmac
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipreset */
+ static void bgmac_chip_reset(struct bgmac *bgmac)
+ {
+-	struct bcma_device *core = bgmac->core;
+ 	u32 cmdcfg_sr;
+ 	u32 iost;
+ 	int i;
+ 
+-	if (bcma_core_is_enabled(core)) {
++	if (bgmac_clk_enabled(bgmac)) {
+ 		if (!bgmac->stats_grabbed) {
+ 			/* bgmac_chip_stats_update(bgmac); */
+ 			bgmac->stats_grabbed = true;
+@@ -923,7 +896,7 @@ static void bgmac_chip_reset(struct bgma
+ 		/* TODO: Clear software multicast filter list */
+ 	}
+ 
+-	iost = bcma_aread32(core, BCMA_IOST);
++	iost = bgmac_idm_read(bgmac, BCMA_IOST);
+ 	if (bgmac->feature_flags & BGMAC_FEAT_IOST_ATTACHED)
+ 		iost &= ~BGMAC_BCMA_IOST_ATTACHED;
+ 
+@@ -935,21 +908,20 @@ static void bgmac_chip_reset(struct bgma
+ 			if (!bgmac->has_robosw)
+ 				flags |= BGMAC_BCMA_IOCTL_SW_RESET;
+ 		}
+-		bcma_core_enable(core, flags);
++		bgmac_clk_enable(bgmac, flags);
+ 	}
+ 
+ 	/* Request Misc PLL for corerev > 2 */
+ 	if (bgmac->feature_flags & BGMAC_FEAT_MISC_PLL_REQ) {
+ 		bgmac_set(bgmac, BCMA_CLKCTLST,
+ 			  BGMAC_BCMA_CLKCTLST_MISC_PLL_REQ);
+-		bgmac_wait_value(bgmac->core, BCMA_CLKCTLST,
++		bgmac_wait_value(bgmac, BCMA_CLKCTLST,
+ 				 BGMAC_BCMA_CLKCTLST_MISC_PLL_ST,
+ 				 BGMAC_BCMA_CLKCTLST_MISC_PLL_ST,
+ 				 1000);
+ 	}
+ 
+ 	if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_PHY) {
+-		struct bcma_drv_cc *cc = &bgmac->core->bus->drv_cc;
+ 		u8 et_swtype = 0;
+ 		u8 sw_type = BGMAC_CHIPCTL_1_SW_TYPE_EPHY |
+ 			     BGMAC_CHIPCTL_1_IF_TYPE_MII;
+@@ -968,16 +940,15 @@ static void bgmac_chip_reset(struct bgma
+ 			sw_type = BGMAC_CHIPCTL_1_IF_TYPE_RGMII |
+ 				  BGMAC_CHIPCTL_1_SW_TYPE_RGMII;
+ 		}
+-		bcma_chipco_chipctl_maskset(cc, 1,
+-					    ~(BGMAC_CHIPCTL_1_IF_TYPE_MASK |
+-					      BGMAC_CHIPCTL_1_SW_TYPE_MASK),
+-					    sw_type);
++		bgmac_cco_ctl_maskset(bgmac, 1, ~(BGMAC_CHIPCTL_1_IF_TYPE_MASK |
++						  BGMAC_CHIPCTL_1_SW_TYPE_MASK),
++				      sw_type);
+ 	}
+ 
+ 	if (iost & BGMAC_BCMA_IOST_ATTACHED && !bgmac->has_robosw)
+-		bcma_awrite32(core, BCMA_IOCTL,
+-			      bcma_aread32(core, BCMA_IOCTL) &
+-			      ~BGMAC_BCMA_IOCTL_SW_RESET);
++		bgmac_idm_write(bgmac, BCMA_IOCTL,
++				bgmac_idm_read(bgmac, BCMA_IOCTL) &
++				~BGMAC_BCMA_IOCTL_SW_RESET);
+ 
+ 	/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/gmac_reset
+ 	 * Specs don't say about using BGMAC_CMDCFG_SR, but in this routine
+@@ -1013,8 +984,8 @@ static void bgmac_chip_reset(struct bgma
+ 
+ 	bgmac_clear_mib(bgmac);
+ 	if (bgmac->feature_flags & BGMAC_FEAT_CMN_PHY_CTL)
+-		bcma_maskset32(bgmac->cmn, BCMA_GMAC_CMN_PHY_CTL, ~0,
+-			       BCMA_GMAC_CMN_PC_MTE);
++		bgmac_cmn_maskset32(bgmac, BCMA_GMAC_CMN_PHY_CTL, ~0,
++				    BCMA_GMAC_CMN_PC_MTE);
+ 	else
+ 		bgmac_set(bgmac, BGMAC_PHY_CNTL, BGMAC_PC_MTE);
+ 	bgmac_miiconfig(bgmac);
+@@ -1059,8 +1030,8 @@ static void bgmac_enable(struct bgmac *b
+ 	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST || mode != 0)
+ 		bgmac_set(bgmac, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
+ 	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST && mode == 2)
+-		bcma_chipco_chipctl_maskset(&bgmac->core->bus->drv_cc, 1, ~0,
+-					    BGMAC_CHIPCTL_1_RXC_DLL_BYPASS);
++		bgmac_cco_ctl_maskset(bgmac, 1, ~0,
++				      BGMAC_CHIPCTL_1_RXC_DLL_BYPASS);
+ 
+ 	if (bgmac->feature_flags & (BGMAC_FEAT_FLW_CTRL1 |
+ 				    BGMAC_FEAT_FLW_CTRL2)) {
+@@ -1082,8 +1053,7 @@ static void bgmac_enable(struct bgmac *b
+ 
+ 		rxq_ctl = bgmac_read(bgmac, BGMAC_RXQ_CTL);
+ 		rxq_ctl &= ~BGMAC_RXQ_CTL_MDP_MASK;
+-		bp_clk = bcma_pmu_get_bus_clock(&bgmac->core->bus->drv_cc) /
+-				1000000;
++		bp_clk = bgmac_get_bus_clock(bgmac) / 1000000;
+ 		mdp = (bp_clk * 128 / 1000) - 3;
+ 		rxq_ctl |= (mdp << BGMAC_RXQ_CTL_MDP_SHIFT);
+ 		bgmac_write(bgmac, BGMAC_RXQ_CTL, rxq_ctl);
+@@ -1178,7 +1148,7 @@ static int bgmac_open(struct net_device
+ 	/* Specs say about reclaiming rings here, but we do that in DMA init */
+ 	bgmac_chip_init(bgmac);
+ 
+-	err = request_irq(bgmac->core->irq, bgmac_interrupt, IRQF_SHARED,
++	err = request_irq(bgmac->irq, bgmac_interrupt, IRQF_SHARED,
+ 			  KBUILD_MODNAME, net_dev);
+ 	if (err < 0) {
+ 		dev_err(bgmac->dev, "IRQ request error: %d!\n", err);
+@@ -1204,7 +1174,7 @@ static int bgmac_stop(struct net_device
+ 
+ 	napi_disable(&bgmac->napi);
+ 	bgmac_chip_intrs_off(bgmac);
+-	free_irq(bgmac->core->irq, net_dev);
++	free_irq(bgmac->irq, net_dev);
+ 
+ 	bgmac_chip_reset(bgmac);
+ 	bgmac_dma_cleanup(bgmac);
+@@ -1399,7 +1369,7 @@ static void bgmac_get_drvinfo(struct net
+ 			      struct ethtool_drvinfo *info)
+ {
+ 	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
+-	strlcpy(info->bus_info, "BCMA", sizeof(info->bus_info));
++	strlcpy(info->bus_info, "AXI", sizeof(info->bus_info));
+ }
+ 
+ static const struct ethtool_ops bgmac_ethtool_ops = {
+@@ -1483,116 +1453,41 @@ static int bgmac_phy_connect(struct bgma
+ 	return 0;
+ }
+ 
+-static int bgmac_probe(struct bcma_device *core)
++int bgmac_enet_probe(struct bgmac *info)
+ {
+ 	struct net_device *net_dev;
+ 	struct bgmac *bgmac;
+-	struct ssb_sprom *sprom = &core->bus->sprom;
+-	u8 *mac;
+ 	int err;
+ 
+-	switch (core->core_unit) {
+-	case 0:
+-		mac = sprom->et0mac;
+-		break;
+-	case 1:
+-		mac = sprom->et1mac;
+-		break;
+-	case 2:
+-		mac = sprom->et2mac;
+-		break;
+-	default:
+-		dev_err(&core->dev, "Unsupported core_unit %d\n",
+-			core->core_unit);
+-		return -ENOTSUPP;
+-	}
+-
+-	if (!is_valid_ether_addr(mac)) {
+-		dev_err(&core->dev, "Invalid MAC addr: %pM\n", mac);
+-		eth_random_addr(mac);
+-		dev_warn(&core->dev, "Using random MAC: %pM\n", mac);
+-	}
+-
+-	/* This (reset &) enable is not preset in specs or reference driver but
+-	 * Broadcom does it in arch PCI code when enabling fake PCI device.
+-	 */
+-	bcma_core_enable(core, 0);
+-
+ 	/* Allocation and references */
+ 	net_dev = alloc_etherdev(sizeof(*bgmac));
+ 	if (!net_dev)
+ 		return -ENOMEM;
++
+ 	net_dev->netdev_ops = &bgmac_netdev_ops;
+-	net_dev->irq = core->irq;
+ 	net_dev->ethtool_ops = &bgmac_ethtool_ops;
+ 	bgmac = netdev_priv(net_dev);
+-	bgmac->dev = &core->dev;
+-	bgmac->dma_dev = core->dma_dev;
++	memcpy(bgmac, info, sizeof(*bgmac));
+ 	bgmac->net_dev = net_dev;
+-	bgmac->core = core;
+-	bcma_set_drvdata(core, bgmac);
+-	SET_NETDEV_DEV(net_dev, &core->dev);
+-
+-	/* Defaults */
+-	memcpy(bgmac->net_dev->dev_addr, mac, ETH_ALEN);
+-
+-	/* On BCM4706 we need common core to access PHY */
+-	if (core->id.id == BCMA_CORE_4706_MAC_GBIT &&
+-	    !core->bus->drv_gmac_cmn.core) {
+-		dev_err(bgmac->dev, "GMAC CMN core not found (required for BCM4706)\n");
+-		err = -ENODEV;
+-		goto err_netdev_free;
+-	}
+-	bgmac->cmn = core->bus->drv_gmac_cmn.core;
++	net_dev->irq = bgmac->irq;
++	SET_NETDEV_DEV(net_dev, bgmac->dev);
+ 
+-	switch (core->core_unit) {
+-	case 0:
+-		bgmac->phyaddr = sprom->et0phyaddr;
+-		break;
+-	case 1:
+-		bgmac->phyaddr = sprom->et1phyaddr;
+-		break;
+-	case 2:
+-		bgmac->phyaddr = sprom->et2phyaddr;
+-		break;
++	if (!is_valid_ether_addr(bgmac->mac_addr)) {
++		dev_err(bgmac->dev, "Invalid MAC addr: %pM\n",
++			bgmac->mac_addr);
++		eth_random_addr(bgmac->mac_addr);
++		dev_warn(bgmac->dev, "Using random MAC: %pM\n",
++			 bgmac->mac_addr);
+ 	}
+-	bgmac->phyaddr &= BGMAC_PHY_MASK;
+-	if (bgmac->phyaddr == BGMAC_PHY_MASK) {
+-		dev_err(bgmac->dev, "No PHY found\n");
+-		err = -ENODEV;
+-		goto err_netdev_free;
+-	}
+-	dev_info(bgmac->dev, "Found PHY addr: %d%s\n", bgmac->phyaddr,
+-		 bgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");
++	ether_addr_copy(net_dev->dev_addr, bgmac->mac_addr);
+ 
+-	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
+-		dev_err(bgmac->dev, "PCI setup not implemented\n");
+-		err = -ENOTSUPP;
+-		goto err_netdev_free;
+-	}
++	/* This (reset &) enable is not preset in specs or reference driver but
++	 * Broadcom does it in arch PCI code when enabling fake PCI device.
++	 */
++	bgmac_clk_enable(bgmac, 0);
+ 
+ 	bgmac_chip_reset(bgmac);
+ 
+-	/* For Northstar, we have to take all GMAC core out of reset */
+-	if (bgmac_is_bcm4707_family(bgmac)) {
+-		struct bcma_device *ns_core;
+-		int ns_gmac;
+-
+-		/* Northstar has 4 GMAC cores */
+-		for (ns_gmac = 0; ns_gmac < 4; ns_gmac++) {
+-			/* As Northstar requirement, we have to reset all GMACs
+-			 * before accessing one. bgmac_chip_reset() call
+-			 * bcma_core_enable() for this core. Then the other
+-			 * three GMACs didn't reset.  We do it here.
+-			 */
+-			ns_core = bcma_find_core_unit(core->bus,
+-						      BCMA_CORE_MAC_GBIT,
+-						      ns_gmac);
+-			if (ns_core && !bcma_core_is_enabled(ns_core))
+-				bcma_core_enable(ns_core, 0);
+-		}
+-	}
+-
+ 	err = bgmac_dma_alloc(bgmac);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Unable to alloc memory for DMA\n");
+@@ -1603,103 +1498,15 @@ static int bgmac_probe(struct bcma_devic
+ 	if (bcm47xx_nvram_getenv("et0_no_txint", NULL, 0) == 0)
+ 		bgmac->int_mask &= ~BGMAC_IS_TX_MASK;
+ 
+-	bgmac->has_robosw = !!(core->bus->sprom.boardflags_lo &
+-			       BGMAC_BFL_ENETROBO);
+-	if (bgmac->has_robosw)
+-		dev_warn(bgmac->dev, "Support for Roboswitch not implemented\n");
+-
+-	if (core->bus->sprom.boardflags_lo & BGMAC_BFL_ENETADM)
+-		dev_warn(bgmac->dev, "Support for ADMtek ethernet switch not implemented\n");
+-
+-	/* Feature Flags */
+-	switch (core->bus->chipinfo.id) {
+-	case BCMA_CHIP_ID_BCM5357:
+-		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
+-		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
+-		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47186) {
+-			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
+-			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
+-		}
+-		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM5358)
+-			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_EPHYRMII;
+-		break;
+-	case BCMA_CHIP_ID_BCM53572:
+-		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
+-		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
+-		if (core->bus->chipinfo.pkg == BCMA_PKG_ID_BCM47188) {
+-			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
+-			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
+-		}
+-		break;
+-	case BCMA_CHIP_ID_BCM4749:
+-		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL1;
+-		bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_PHY;
+-		if (core->bus->chipinfo.pkg == 10) {
+-			bgmac->feature_flags |= BGMAC_FEAT_SW_TYPE_RGMII;
+-			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
+-		}
+-		break;
+-	case BCMA_CHIP_ID_BCM4716:
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		/* fallthrough */
+-	case BCMA_CHIP_ID_BCM47162:
+-		bgmac->feature_flags |= BGMAC_FEAT_FLW_CTRL2;
+-		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+-		break;
+-	/* bcm4707_family */
+-	case BCMA_CHIP_ID_BCM4707:
+-	case BCMA_CHIP_ID_BCM47094:
+-	case BCMA_CHIP_ID_BCM53018:
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
+-		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
+-		break;
+-	default:
+-		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+-		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+-	}
+-
+-	if (!bgmac_is_bcm4707_family(bgmac) && core->id.rev > 2)
+-		bgmac->feature_flags |= BGMAC_FEAT_MISC_PLL_REQ;
+-
+-	if (core->id.id == BCMA_CORE_4706_MAC_GBIT) {
+-		bgmac->feature_flags |= BGMAC_FEAT_CMN_PHY_CTL;
+-		bgmac->feature_flags |= BGMAC_FEAT_NO_CLR_MIB;
+-	}
+-
+-	if (core->id.rev >= 4) {
+-		bgmac->feature_flags |= BGMAC_FEAT_CMDCFG_SR_REV4;
+-		bgmac->feature_flags |= BGMAC_FEAT_TX_MASK_SETUP;
+-		bgmac->feature_flags |= BGMAC_FEAT_RX_MASK_SETUP;
+-	}
+-
+ 	netif_napi_add(net_dev, &bgmac->napi, bgmac_poll, BGMAC_WEIGHT);
+ 
+-	if (!bgmac_is_bcm4707_family(bgmac)) {
+-		struct mii_bus *mii_bus;
+-
+-		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
+-		if (!IS_ERR(mii_bus)) {
+-			err = PTR_ERR(mii_bus);
+-			goto err_dma_free;
+-		}
+-
+-		bgmac->mii_bus = mii_bus;
+-	}
+-
+ 	if (!bgmac->mii_bus)
+ 		err = bgmac_phy_connect_direct(bgmac);
+ 	else
+ 		err = bgmac_phy_connect(bgmac);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Cannot connect to phy\n");
+-		goto err_mii_unregister;
++		goto err_dma_free;
+ 	}
+ 
+ 	net_dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+@@ -1718,56 +1525,24 @@ static int bgmac_probe(struct bcma_devic
+ 
+ err_phy_disconnect:
+ 	phy_disconnect(net_dev->phydev);
+-err_mii_unregister:
+-	bcma_mdio_mii_unregister(bgmac->mii_bus);
+ err_dma_free:
+ 	bgmac_dma_free(bgmac);
+ err_netdev_free:
+-	bcma_set_drvdata(core, NULL);
+ 	free_netdev(net_dev);
+ 
+ 	return err;
+ }
++EXPORT_SYMBOL_GPL(bgmac_enet_probe);
+ 
+-static void bgmac_remove(struct bcma_device *core)
++void bgmac_enet_remove(struct bgmac *bgmac)
+ {
+-	struct bgmac *bgmac = bcma_get_drvdata(core);
+-
+ 	unregister_netdev(bgmac->net_dev);
+ 	phy_disconnect(bgmac->net_dev->phydev);
+-	bcma_mdio_mii_unregister(bgmac->mii_bus);
+ 	netif_napi_del(&bgmac->napi);
+ 	bgmac_dma_free(bgmac);
+-	bcma_set_drvdata(core, NULL);
+ 	free_netdev(bgmac->net_dev);
+ }
+-
+-static struct bcma_driver bgmac_bcma_driver = {
+-	.name		= KBUILD_MODNAME,
+-	.id_table	= bgmac_bcma_tbl,
+-	.probe		= bgmac_probe,
+-	.remove		= bgmac_remove,
+-};
+-
+-static int __init bgmac_init(void)
+-{
+-	int err;
+-
+-	err = bcma_driver_register(&bgmac_bcma_driver);
+-	if (err)
+-		return err;
+-	pr_info("Broadcom 47xx GBit MAC driver loaded\n");
+-
+-	return 0;
+-}
+-
+-static void __exit bgmac_exit(void)
+-{
+-	bcma_driver_unregister(&bgmac_bcma_driver);
+-}
+-
+-module_init(bgmac_init)
+-module_exit(bgmac_exit)
++EXPORT_SYMBOL_GPL(bgmac_enet_remove);
+ 
+ MODULE_AUTHOR("Rafa Miecki");
+ MODULE_LICENSE("GPL");
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -1,8 +1,6 @@
+ #ifndef _BGMAC_H
+ #define _BGMAC_H
+ 
+-#include <linux/bcma/bcma.h>
+-#include <linux/brcmphy.h>
+ #include <linux/netdevice.h>
+ 
+ #define BGMAC_DEV_CTL				0x000
+@@ -442,11 +440,21 @@ struct bgmac_rx_header {
+ };
+ 
+ struct bgmac {
+-	struct bcma_device *core;
+-	struct bcma_device *cmn; /* Reference to CMN core for BCM4706 */
++	union {
++		struct {
++			void *base;
++			void *idm_base;
++		} plat;
++		struct {
++			struct bcma_device *core;
++			/* Reference to CMN core for BCM4706 */
++			struct bcma_device *cmn;
++		} bcma;
++	};
+ 
+ 	struct device *dev;
+ 	struct device *dma_dev;
++	unsigned char mac_addr[ETH_ALEN];
+ 	u32 feature_flags;
+ 
+ 	struct net_device *net_dev;
+@@ -463,6 +471,7 @@ struct bgmac {
+ 	u32 mib_rx_regs[BGMAC_NUM_MIB_RX_REGS];
+ 
+ 	/* Int */
++	int irq;
+ 	u32 int_mask;
+ 
+ 	/* Current MAC state */
+@@ -473,19 +482,71 @@ struct bgmac {
+ 	bool has_robosw;
+ 
+ 	bool loopback;
++
++	u32 (*read)(struct bgmac *bgmac, u16 offset);
++	void (*write)(struct bgmac *bgmac, u16 offset, u32 value);
++	u32 (*idm_read)(struct bgmac *bgmac, u16 offset);
++	void (*idm_write)(struct bgmac *bgmac, u16 offset, u32 value);
++	bool (*clk_enabled)(struct bgmac *bgmac);
++	void (*clk_enable)(struct bgmac *bgmac, u32 flags);
++	void (*cco_ctl_maskset)(struct bgmac *bgmac, u32 offset, u32 mask,
++				u32 set);
++	u32 (*get_bus_clock)(struct bgmac *bgmac);
++	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
++			      u32 set);
+ };
+ 
++int bgmac_enet_probe(struct bgmac *info);
++void bgmac_enet_remove(struct bgmac *bgmac);
++
+ struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
+ void bcma_mdio_mii_unregister(struct mii_bus *mii_bus);
+ 
+ static inline u32 bgmac_read(struct bgmac *bgmac, u16 offset)
+ {
+-	return bcma_read32(bgmac->core, offset);
++	return bgmac->read(bgmac, offset);
+ }
+ 
+ static inline void bgmac_write(struct bgmac *bgmac, u16 offset, u32 value)
+ {
+-	bcma_write32(bgmac->core, offset, value);
++	bgmac->write(bgmac, offset, value);
++}
++
++static inline u32 bgmac_idm_read(struct bgmac *bgmac, u16 offset)
++{
++	return bgmac->idm_read(bgmac, offset);
++}
++
++static inline void bgmac_idm_write(struct bgmac *bgmac, u16 offset, u32 value)
++{
++	bgmac->idm_write(bgmac, offset, value);
++}
++
++static inline bool bgmac_clk_enabled(struct bgmac *bgmac)
++{
++	return bgmac->clk_enabled(bgmac);
++}
++
++static inline void bgmac_clk_enable(struct bgmac *bgmac, u32 flags)
++{
++	bgmac->clk_enable(bgmac, flags);
++}
++
++static inline void bgmac_cco_ctl_maskset(struct bgmac *bgmac, u32 offset,
++					 u32 mask, u32 set)
++{
++	bgmac->cco_ctl_maskset(bgmac, offset, mask, set);
++}
++
++static inline u32 bgmac_get_bus_clock(struct bgmac *bgmac)
++{
++	return bgmac->get_bus_clock(bgmac);
++}
++
++static inline void bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset,
++				       u32 mask, u32 set)
++{
++	bgmac->cmn_maskset32(bgmac, offset, mask, set);
+ }
+ 
+ static inline void bgmac_maskset(struct bgmac *bgmac, u16 offset, u32 mask,
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0006-net-ethernet-bgmac-Fix-return-value-check-in-bgmac_p.patch b/target/linux/generic/pending-4.4/071-v4.8-0006-net-ethernet-bgmac-Fix-return-value-check-in-bgmac_p.patch
new file mode 100644
index 0000000000..e0431c1235
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0006-net-ethernet-bgmac-Fix-return-value-check-in-bgmac_p.patch
@@ -0,0 +1,26 @@
+From 12c2e32f14da857b58af281b029d4549d24c3292 Mon Sep 17 00:00:00 2001
+From: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
+Date: Tue, 12 Jul 2016 00:17:28 +0000
+Subject: [PATCH] net: ethernet: bgmac: Fix return value check in bgmac_probe()
+
+In case of error, the function devm_ioremap_resource() returns ERR_PTR()
+and never returns NULL. The NULL test in the return value check should be
+replaced with IS_ERR().
+
+Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-platform.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
++++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
+@@ -141,7 +141,7 @@ static int bgmac_probe(struct platform_d
+ 	}
+ 
+ 	bgmac->plat.idm_base = devm_ioremap_resource(&pdev->dev, regs);
+-	if (!bgmac->plat.idm_base) {
++	if (IS_ERR(bgmac->plat.idm_base)) {
+ 		dev_err(&pdev->dev, "Unable to map idm resource\n");
+ 		return PTR_ERR(bgmac->plat.idm_base);
+ 	}
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0007-net-ethernet-bgmac-Remove-redundant-dev_err-call-in-.patch b/target/linux/generic/pending-4.4/071-v4.8-0007-net-ethernet-bgmac-Remove-redundant-dev_err-call-in-.patch
new file mode 100644
index 0000000000..479094830e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0007-net-ethernet-bgmac-Remove-redundant-dev_err-call-in-.patch
@@ -0,0 +1,42 @@
+From ce3a380dddd0cb16cb3d8d947b69657d7646c121 Mon Sep 17 00:00:00 2001
+From: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
+Date: Wed, 13 Jul 2016 12:46:57 +0000
+Subject: [PATCH] net: ethernet: bgmac: Remove redundant dev_err call in
+ bgmac_probe()
+
+There is a error message within devm_ioremap_resource
+already, so remove the dev_err call to avoid redundant
+error message.
+
+Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-platform.c | 8 ++------
+ 1 file changed, 2 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
++++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
+@@ -129,10 +129,8 @@ static int bgmac_probe(struct platform_d
+ 	}
+ 
+ 	bgmac->plat.base = devm_ioremap_resource(&pdev->dev, regs);
+-	if (IS_ERR(bgmac->plat.base)) {
+-		dev_err(&pdev->dev, "Unable to map base resource\n");
++	if (IS_ERR(bgmac->plat.base))
+ 		return PTR_ERR(bgmac->plat.base);
+-	}
+ 
+ 	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "idm_base");
+ 	if (!regs) {
+@@ -141,10 +139,8 @@ static int bgmac_probe(struct platform_d
+ 	}
+ 
+ 	bgmac->plat.idm_base = devm_ioremap_resource(&pdev->dev, regs);
+-	if (IS_ERR(bgmac->plat.idm_base)) {
+-		dev_err(&pdev->dev, "Unable to map idm resource\n");
++	if (IS_ERR(bgmac->plat.idm_base))
+ 		return PTR_ERR(bgmac->plat.idm_base);
+-	}
+ 
+ 	bgmac->read = platform_bgmac_read;
+ 	bgmac->write = platform_bgmac_write;
diff --git a/target/linux/generic/pending-4.4/071-v4.8-0009-net-bgmac-fix-reversed-check-for-MII-registration-er.patch b/target/linux/generic/pending-4.4/071-v4.8-0009-net-bgmac-fix-reversed-check-for-MII-registration-er.patch
new file mode 100644
index 0000000000..945546d6df
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.8-0009-net-bgmac-fix-reversed-check-for-MII-registration-er.patch
@@ -0,0 +1,28 @@
+From b9f63ae7ba2de2ba19137c5757c0607ce40f3ed5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 17 Aug 2016 15:37:14 +0200
+Subject: [PATCH] net: bgmac: fix reversed check for MII registration error
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It was failing on successful registration returning meaningless errors.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Fixes: 55954f3bfdac ("net: ethernet: bgmac: move BCMA MDIO Phy code into a separate file")
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -159,7 +159,7 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	if (!bgmac_is_bcm4707_family(core)) {
+ 		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
+-		if (!IS_ERR(mii_bus)) {
++		if (IS_ERR(mii_bus)) {
+ 			err = PTR_ERR(mii_bus);
+ 			goto err;
+ 		}
diff --git a/target/linux/generic/pending-4.4/071-v4.9-0001-net-bgmac-support-Ethernet-core-on-BCM53573-SoCs.patch b/target/linux/generic/pending-4.4/071-v4.9-0001-net-bgmac-support-Ethernet-core-on-BCM53573-SoCs.patch
new file mode 100644
index 0000000000..82d3fe4d6d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.9-0001-net-bgmac-support-Ethernet-core-on-BCM53573-SoCs.patch
@@ -0,0 +1,161 @@
+From 1cb94db3d1bfe0075bde78fb2989f17e0a8a3936 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 17 Aug 2016 23:00:30 +0200
+Subject: [PATCH] net: bgmac: support Ethernet core on BCM53573 SoCs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+BCM53573 is a new series of Broadcom's SoCs. It's based on ARM and can
+be found in two packages (versions): BCM53573 and BCM47189. It shares
+some code with the Northstar family, but also requires some new quirks.
+
+First of all there can be up to 2 Ethernet cores on this SoC. If that is
+the case, they are connected to two different switch ports allowing some
+more complex/optimized setups. It seems the second unit doesn't come
+fully configured and requires some IRQ quirk.
+
+Other than that only the first core is connected to the PHY. For the
+second one we have to register fixed PHY (similarly to the Northstar),
+otherwise generic PHY driver would get some invalid info.
+
+This has been successfully tested on Tenda AC9 (BCM47189B0).
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma.c | 19 ++++++++++++++++++-
+ drivers/net/ethernet/broadcom/bgmac.c      | 25 +++++++++++++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac.h      | 19 +++++++++++++++++++
+ include/linux/bcma/bcma.h                  |  3 +++
+ include/linux/bcma/bcma_regs.h             |  1 +
+ 5 files changed, 66 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -92,6 +92,7 @@ MODULE_DEVICE_TABLE(bcma, bgmac_bcma_tbl
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipattach */
+ static int bgmac_probe(struct bcma_device *core)
+ {
++	struct bcma_chipinfo *ci = &core->bus->chipinfo;
+ 	struct ssb_sprom *sprom = &core->bus->sprom;
+ 	struct mii_bus *mii_bus;
+ 	struct bgmac *bgmac;
+@@ -157,7 +158,8 @@ static int bgmac_probe(struct bcma_devic
+ 	dev_info(bgmac->dev, "Found PHY addr: %d%s\n", bgmac->phyaddr,
+ 		 bgmac->phyaddr == BGMAC_PHY_NOREGS ? " (NOREGS)" : "");
+ 
+-	if (!bgmac_is_bcm4707_family(core)) {
++	if (!bgmac_is_bcm4707_family(core) &&
++	    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {
+ 		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
+ 		if (IS_ERR(mii_bus)) {
+ 			err = PTR_ERR(mii_bus);
+@@ -230,6 +232,21 @@ static int bgmac_probe(struct bcma_devic
+ 		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
+ 		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
+ 		break;
++	case BCMA_CHIP_ID_BCM53573:
++		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
++		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
++		if (ci->pkg == BCMA_PKG_ID_BCM47189)
++			bgmac->feature_flags |= BGMAC_FEAT_IOST_ATTACHED;
++		if (core->core_unit == 0) {
++			bgmac->feature_flags |= BGMAC_FEAT_CC4_IF_SW_TYPE;
++			if (ci->pkg == BCMA_PKG_ID_BCM47189)
++				bgmac->feature_flags |=
++					BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII;
++		} else if (core->core_unit == 1) {
++			bgmac->feature_flags |= BGMAC_FEAT_IRQ_ID_OOB_6;
++			bgmac->feature_flags |= BGMAC_FEAT_CC7_IF_TYPE_RGMII;
++		}
++		break;
+ 	default:
+ 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+ 		bgmac->feature_flags |= BGMAC_FEAT_SET_RXQ_CLK;
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -943,6 +943,27 @@ static void bgmac_chip_reset(struct bgma
+ 		bgmac_cco_ctl_maskset(bgmac, 1, ~(BGMAC_CHIPCTL_1_IF_TYPE_MASK |
+ 						  BGMAC_CHIPCTL_1_SW_TYPE_MASK),
+ 				      sw_type);
++	} else if (bgmac->feature_flags & BGMAC_FEAT_CC4_IF_SW_TYPE) {
++		u32 sw_type = BGMAC_CHIPCTL_4_IF_TYPE_MII |
++			      BGMAC_CHIPCTL_4_SW_TYPE_EPHY;
++		u8 et_swtype = 0;
++		char buf[4];
++
++		if (bcm47xx_nvram_getenv("et_swtype", buf, sizeof(buf)) > 0) {
++			if (kstrtou8(buf, 0, &et_swtype))
++				dev_err(bgmac->dev, "Failed to parse et_swtype (%s)\n",
++					buf);
++			sw_type = (et_swtype & 0x0f) << 12;
++		} else if (bgmac->feature_flags & BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII) {
++			sw_type = BGMAC_CHIPCTL_4_IF_TYPE_RGMII |
++				  BGMAC_CHIPCTL_4_SW_TYPE_RGMII;
++		}
++		bgmac_cco_ctl_maskset(bgmac, 4, ~(BGMAC_CHIPCTL_4_IF_TYPE_MASK |
++						  BGMAC_CHIPCTL_4_SW_TYPE_MASK),
++				      sw_type);
++	} else if (bgmac->feature_flags & BGMAC_FEAT_CC7_IF_TYPE_RGMII) {
++		bgmac_cco_ctl_maskset(bgmac, 7, ~BGMAC_CHIPCTL_7_IF_TYPE_MASK,
++				      BGMAC_CHIPCTL_7_IF_TYPE_RGMII);
+ 	}
+ 
+ 	if (iost & BGMAC_BCMA_IOST_ATTACHED && !bgmac->has_robosw)
+@@ -1486,6 +1507,10 @@ int bgmac_enet_probe(struct bgmac *info)
+ 	 */
+ 	bgmac_clk_enable(bgmac, 0);
+ 
++	/* This seems to be fixing IRQ by assigning OOB #6 to the core */
++	if (bgmac->feature_flags & BGMAC_FEAT_IRQ_ID_OOB_6)
++		bgmac_idm_write(bgmac, BCMA_OOB_SEL_OUT_A30, 0x86);
++
+ 	bgmac_chip_reset(bgmac);
+ 
+ 	err = bgmac_dma_alloc(bgmac);
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -369,6 +369,21 @@
+ #define BGMAC_CHIPCTL_1_SW_TYPE_RGMII		0x000000C0
+ #define BGMAC_CHIPCTL_1_RXC_DLL_BYPASS		0x00010000
+ 
++#define BGMAC_CHIPCTL_4_IF_TYPE_MASK		0x00003000
++#define BGMAC_CHIPCTL_4_IF_TYPE_RMII		0x00000000
++#define BGMAC_CHIPCTL_4_IF_TYPE_MII		0x00001000
++#define BGMAC_CHIPCTL_4_IF_TYPE_RGMII		0x00002000
++#define BGMAC_CHIPCTL_4_SW_TYPE_MASK		0x0000C000
++#define BGMAC_CHIPCTL_4_SW_TYPE_EPHY		0x00000000
++#define BGMAC_CHIPCTL_4_SW_TYPE_EPHYMII		0x00004000
++#define BGMAC_CHIPCTL_4_SW_TYPE_EPHYRMII	0x00008000
++#define BGMAC_CHIPCTL_4_SW_TYPE_RGMII		0x0000C000
++
++#define BGMAC_CHIPCTL_7_IF_TYPE_MASK		0x000000C0
++#define BGMAC_CHIPCTL_7_IF_TYPE_RMII		0x00000000
++#define BGMAC_CHIPCTL_7_IF_TYPE_MII		0x00000040
++#define BGMAC_CHIPCTL_7_IF_TYPE_RGMII		0x00000080
++
+ #define BGMAC_WEIGHT	64
+ 
+ #define ETHER_MAX_LEN   1518
+@@ -390,6 +405,10 @@
+ #define BGMAC_FEAT_NO_CLR_MIB		BIT(13)
+ #define BGMAC_FEAT_FORCE_SPEED_2500	BIT(14)
+ #define BGMAC_FEAT_CMDCFG_SR_REV4	BIT(15)
++#define BGMAC_FEAT_IRQ_ID_OOB_6		BIT(16)
++#define BGMAC_FEAT_CC4_IF_SW_TYPE	BIT(17)
++#define BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII	BIT(18)
++#define BGMAC_FEAT_CC7_IF_TYPE_RGMII	BIT(19)
+ 
+ struct bgmac_slot_info {
+ 	union {
+--- a/include/linux/bcma/bcma_regs.h
++++ b/include/linux/bcma/bcma_regs.h
+@@ -23,6 +23,7 @@
+ #define  BCMA_CLKCTLST_4328A0_HAVEALP	0x00020000 /* 4328a0 has reversed bits */
+ 
+ /* Agent registers (common for every core) */
++#define BCMA_OOB_SEL_OUT_A30		0x0100
+ #define BCMA_IOCTL			0x0408 /* IO control */
+ #define  BCMA_IOCTL_CLK			0x0001
+ #define  BCMA_IOCTL_FGC			0x0002
diff --git a/target/linux/generic/pending-4.4/071-v4.9-0002-net-bgmac-make-it-clear-when-setting-interface-type-.patch b/target/linux/generic/pending-4.4/071-v4.9-0002-net-bgmac-make-it-clear-when-setting-interface-type-.patch
new file mode 100644
index 0000000000..272ec5c3f3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.9-0002-net-bgmac-make-it-clear-when-setting-interface-type-.patch
@@ -0,0 +1,31 @@
+From e2d8f646c79f26e094bfaf9b21be614d1e148a67 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 17 Aug 2016 23:11:52 +0200
+Subject: [PATCH] net: bgmac: make it clear when setting interface type to RMII
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It doesn't really change anything as BGMAC_CHIPCTL_1_IF_TYPE_RMII is
+equal to 0. It make code a bit clener, so far when reading it one could
+think we forgot to set a proper mode. It also keeps this mode code in
+sync with other ones.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -935,7 +935,8 @@ static void bgmac_chip_reset(struct bgma
+ 			et_swtype <<= 4;
+ 			sw_type = et_swtype;
+ 		} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_EPHYRMII) {
+-			sw_type = BGMAC_CHIPCTL_1_SW_TYPE_EPHYRMII;
++			sw_type = BGMAC_CHIPCTL_1_IF_TYPE_RMII |
++				  BGMAC_CHIPCTL_1_SW_TYPE_EPHYRMII;
+ 		} else if (bgmac->feature_flags & BGMAC_FEAT_SW_TYPE_RGMII) {
+ 			sw_type = BGMAC_CHIPCTL_1_IF_TYPE_RGMII |
+ 				  BGMAC_CHIPCTL_1_SW_TYPE_RGMII;
diff --git a/target/linux/generic/pending-4.4/071-v4.9-0003-net-bgmac-Fix-errant-feature-flag-check.patch b/target/linux/generic/pending-4.4/071-v4.9-0003-net-bgmac-Fix-errant-feature-flag-check.patch
new file mode 100644
index 0000000000..830d8ccde4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.9-0003-net-bgmac-Fix-errant-feature-flag-check.patch
@@ -0,0 +1,33 @@
+From 4af1474e6198b10fee7bb20e81f7e033ad1b586c Mon Sep 17 00:00:00 2001
+From: Jon Mason <jon.mason@broadcom.com>
+Date: Wed, 5 Oct 2016 15:36:49 -0400
+Subject: [PATCH] net: bgmac: Fix errant feature flag check
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+During the conversion to the feature flags, a check against
+ci->id != BCMA_CHIP_ID_BCM47162
+became
+bgmac->feature_flags & BGMAC_FEAT_CLKCTLS
+instead of
+!(bgmac->feature_flags & BGMAC_FEAT_CLKCTLS)
+
+Reported-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1049,7 +1049,7 @@ static void bgmac_enable(struct bgmac *b
+ 
+ 	mode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) & BGMAC_DS_MM_MASK) >>
+ 		BGMAC_DS_MM_SHIFT;
+-	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST || mode != 0)
++	if (!(bgmac->feature_flags & BGMAC_FEAT_CLKCTLST) || mode != 0)
+ 		bgmac_set(bgmac, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
+ 	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST && mode == 2)
+ 		bgmac_cco_ctl_maskset(bgmac, 1, ~0,
diff --git a/target/linux/generic/pending-4.4/071-v4.9-0004-net-bgmac-fix-spelling-mistake-connecton-connection.patch b/target/linux/generic/pending-4.4/071-v4.9-0004-net-bgmac-fix-spelling-mistake-connecton-connection.patch
new file mode 100644
index 0000000000..5721abcf95
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.9-0004-net-bgmac-fix-spelling-mistake-connecton-connection.patch
@@ -0,0 +1,25 @@
+From c121f72a66c5f92fbe2fc53baa274eef39875cec Mon Sep 17 00:00:00 2001
+From: Colin Ian King <colin.king@canonical.com>
+Date: Mon, 24 Oct 2016 23:46:18 +0100
+Subject: [PATCH] net: bgmac: fix spelling mistake: "connecton" -> "connection"
+
+trivial fix to spelling mistake in dev_err message
+
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+Acked-by: Jon Mason <jon.mason@broadcom.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1468,7 +1468,7 @@ static int bgmac_phy_connect(struct bgma
+ 	phy_dev = phy_connect(bgmac->net_dev, bus_id, &bgmac_adjust_link,
+ 			      PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phy_dev)) {
+-		dev_err(bgmac->dev, "PHY connecton failed\n");
++		dev_err(bgmac->dev, "PHY connection failed\n");
+ 		return PTR_ERR(phy_dev);
+ 	}
+ 
diff --git a/target/linux/generic/pending-4.4/071-v4.9-0005-net-bgmac-fix-reversed-checks-for-clock-control-flag.patch b/target/linux/generic/pending-4.4/071-v4.9-0005-net-bgmac-fix-reversed-checks-for-clock-control-flag.patch
new file mode 100644
index 0000000000..e9bf06c870
--- /dev/null
+++ b/target/linux/generic/pending-4.4/071-v4.9-0005-net-bgmac-fix-reversed-checks-for-clock-control-flag.patch
@@ -0,0 +1,35 @@
+From cdb26d3387f0cdf7b2a2eea581385173547ef21f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 7 Nov 2016 13:53:27 +0100
+Subject: [PATCH] net: bgmac: fix reversed checks for clock control flag
+
+This fixes regression introduced by patch adding feature flags. It was
+already reported and patch followed (it got accepted) but it appears it
+was incorrect. Instead of fixing reversed condition it broke a good one.
+
+This patch was verified to actually fix SoC hanges caused by bgmac on
+BCM47186B0.
+
+Fixes: db791eb2970b ("net: ethernet: bgmac: convert to feature flags")
+Fixes: 4af1474e6198 ("net: bgmac: Fix errant feature flag check")
+Cc: Jon Mason <jon.mason@broadcom.com>
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1049,9 +1049,9 @@ static void bgmac_enable(struct bgmac *b
+ 
+ 	mode = (bgmac_read(bgmac, BGMAC_DEV_STATUS) & BGMAC_DS_MM_MASK) >>
+ 		BGMAC_DS_MM_SHIFT;
+-	if (!(bgmac->feature_flags & BGMAC_FEAT_CLKCTLST) || mode != 0)
++	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST || mode != 0)
+ 		bgmac_set(bgmac, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
+-	if (bgmac->feature_flags & BGMAC_FEAT_CLKCTLST && mode == 2)
++	if (!(bgmac->feature_flags & BGMAC_FEAT_CLKCTLST) && mode == 2)
+ 		bgmac_cco_ctl_maskset(bgmac, 1, ~0,
+ 				      BGMAC_CHIPCTL_1_RXC_DLL_BYPASS);
+ 
diff --git a/target/linux/generic/pending-4.4/072-net-add-devm-version-of-alloc_etherdev_mqs-function.patch b/target/linux/generic/pending-4.4/072-net-add-devm-version-of-alloc_etherdev_mqs-function.patch
new file mode 100644
index 0000000000..be03cca9ee
--- /dev/null
+++ b/target/linux/generic/pending-4.4/072-net-add-devm-version-of-alloc_etherdev_mqs-function.patch
@@ -0,0 +1,70 @@
+From 40be0dda0725886b623d67868db3219a2e74683b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Sat, 28 Jan 2017 15:15:42 +0100
+Subject: [PATCH] net: add devm version of alloc_etherdev_mqs function
+
+This patch adds devm_alloc_etherdev_mqs function and devm_alloc_etherdev
+macro. These can be used for simpler netdev allocation without having to
+care about calling free_netdev.
+
+Thanks to this change drivers, their error paths and removal paths may
+get simpler by a bit.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/etherdevice.h |  5 +++++
+ net/ethernet/eth.c          | 28 ++++++++++++++++++++++++++++
+ 2 files changed, 33 insertions(+)
+
+--- a/include/linux/etherdevice.h
++++ b/include/linux/etherdevice.h
+@@ -51,6 +51,11 @@ struct net_device *alloc_etherdev_mqs(in
+ #define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)
+ #define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeof_priv, count, count)
+ 
++struct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,
++					   unsigned int txqs,
++					   unsigned int rxqs);
++#define devm_alloc_etherdev(dev, sizeof_priv) devm_alloc_etherdev_mqs(dev, sizeof_priv, 1, 1)
++
+ struct sk_buff **eth_gro_receive(struct sk_buff **head,
+ 				 struct sk_buff *skb);
+ int eth_gro_complete(struct sk_buff *skb, int nhoff);
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -388,6 +388,34 @@ struct net_device *alloc_etherdev_mqs(in
+ }
+ EXPORT_SYMBOL(alloc_etherdev_mqs);
+ 
++static void devm_free_netdev(struct device *dev, void *res)
++{
++	free_netdev(*(struct net_device **)res);
++}
++
++struct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,
++					   unsigned int txqs, unsigned int rxqs)
++{
++	struct net_device **dr;
++	struct net_device *netdev;
++
++	dr = devres_alloc(devm_free_netdev, sizeof(*dr), GFP_KERNEL);
++	if (!dr)
++		return NULL;
++
++	netdev = alloc_etherdev_mqs(sizeof_priv, txqs, rxqs);
++	if (!netdev) {
++		devres_free(dr);
++		return NULL;
++	}
++
++	*dr = netdev;
++	devres_add(dev, dr);
++
++	return netdev;
++}
++EXPORT_SYMBOL(devm_alloc_etherdev_mqs);
++
+ ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)
+ {
+ 	return scnprintf(buf, PAGE_SIZE, "%*phC\n", len, addr);
diff --git a/target/linux/generic/pending-4.4/073-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch b/target/linux/generic/pending-4.4/073-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch
new file mode 100644
index 0000000000..544a074a78
--- /dev/null
+++ b/target/linux/generic/pending-4.4/073-v4.10-0001-net-bgmac-allocate-struct-bgmac-just-once-don-t-copy.patch
@@ -0,0 +1,139 @@
+From 34a5102c3235c470a6c77fba16cb971964d9c136 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 31 Jan 2017 19:37:54 +0100
+Subject: [PATCH 1/3] net: bgmac: allocate struct bgmac just once & don't copy
+ it
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+So far were were allocating struct bgmac in 3 places: platform code,
+bcma code and shared bgmac_enet_probe function. The reason for this was
+bgmac_enet_probe:
+1) Requiring early-filled struct bgmac
+2) Calling alloc_etherdev on its own in order to use netdev_priv later
+
+This solution got few drawbacks:
+1) Was duplicating allocating code
+2) Required copying early-filled struct
+3) Resulted in platform/bcma code having access only to unused struct
+
+Solve this situation by simply extracting some probe code into the new
+bgmac_alloc function.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma.c     |  4 +---
+ drivers/net/ethernet/broadcom/bgmac-platform.c |  2 +-
+ drivers/net/ethernet/broadcom/bgmac.c          | 25 +++++++++++++++++--------
+ drivers/net/ethernet/broadcom/bgmac.h          |  3 ++-
+ 4 files changed, 21 insertions(+), 13 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -99,12 +99,11 @@ static int bgmac_probe(struct bcma_devic
+ 	u8 *mac;
+ 	int err;
+ 
+-	bgmac = kzalloc(sizeof(*bgmac), GFP_KERNEL);
++	bgmac = bgmac_alloc(&core->dev);
+ 	if (!bgmac)
+ 		return -ENOMEM;
+ 
+ 	bgmac->bcma.core = core;
+-	bgmac->dev = &core->dev;
+ 	bgmac->dma_dev = core->dma_dev;
+ 	bgmac->irq = core->irq;
+ 
+@@ -285,7 +284,6 @@ static int bgmac_probe(struct bcma_devic
+ err1:
+ 	bcma_mdio_mii_unregister(bgmac->mii_bus);
+ err:
+-	kfree(bgmac);
+ 	bcma_set_drvdata(core, NULL);
+ 
+ 	return err;
+--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
++++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
+@@ -93,7 +93,7 @@ static int bgmac_probe(struct platform_d
+ 	struct resource *regs;
+ 	const u8 *mac_addr;
+ 
+-	bgmac = devm_kzalloc(&pdev->dev, sizeof(*bgmac), GFP_KERNEL);
++	bgmac = bgmac_alloc(&pdev->dev);
+ 	if (!bgmac)
+ 		return -ENOMEM;
+ 
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -1475,22 +1475,32 @@ static int bgmac_phy_connect(struct bgma
+ 	return 0;
+ }
+ 
+-int bgmac_enet_probe(struct bgmac *info)
++struct bgmac *bgmac_alloc(struct device *dev)
+ {
+ 	struct net_device *net_dev;
+ 	struct bgmac *bgmac;
+-	int err;
+ 
+ 	/* Allocation and references */
+-	net_dev = alloc_etherdev(sizeof(*bgmac));
++	net_dev = devm_alloc_etherdev(dev, sizeof(*bgmac));
+ 	if (!net_dev)
+-		return -ENOMEM;
++		return NULL;
+ 
+ 	net_dev->netdev_ops = &bgmac_netdev_ops;
+ 	net_dev->ethtool_ops = &bgmac_ethtool_ops;
++
+ 	bgmac = netdev_priv(net_dev);
+-	memcpy(bgmac, info, sizeof(*bgmac));
++	bgmac->dev = dev;
+ 	bgmac->net_dev = net_dev;
++
++	return bgmac;
++}
++EXPORT_SYMBOL_GPL(bgmac_alloc);
++
++int bgmac_enet_probe(struct bgmac *bgmac)
++{
++	struct net_device *net_dev = bgmac->net_dev;
++	int err;
++
+ 	net_dev->irq = bgmac->irq;
+ 	SET_NETDEV_DEV(net_dev, bgmac->dev);
+ 
+@@ -1517,7 +1527,7 @@ int bgmac_enet_probe(struct bgmac *info)
+ 	err = bgmac_dma_alloc(bgmac);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Unable to alloc memory for DMA\n");
+-		goto err_netdev_free;
++		goto err_out;
+ 	}
+ 
+ 	bgmac->int_mask = BGMAC_IS_ERRMASK | BGMAC_IS_RX | BGMAC_IS_TX_MASK;
+@@ -1553,8 +1563,7 @@ err_phy_disconnect:
+ 	phy_disconnect(net_dev->phydev);
+ err_dma_free:
+ 	bgmac_dma_free(bgmac);
+-err_netdev_free:
+-	free_netdev(net_dev);
++err_out:
+ 
+ 	return err;
+ }
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -515,7 +515,8 @@ struct bgmac {
+ 			      u32 set);
+ };
+ 
+-int bgmac_enet_probe(struct bgmac *info);
++struct bgmac *bgmac_alloc(struct device *dev);
++int bgmac_enet_probe(struct bgmac *bgmac);
+ void bgmac_enet_remove(struct bgmac *bgmac);
+ 
+ struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
diff --git a/target/linux/generic/pending-4.4/073-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch b/target/linux/generic/pending-4.4/073-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch
new file mode 100644
index 0000000000..8848f619ea
--- /dev/null
+++ b/target/linux/generic/pending-4.4/073-v4.10-0002-net-bgmac-drop-struct-bcma_mdio-we-don-t-need-anymor.patch
@@ -0,0 +1,274 @@
+From aa8863e5d49417094b9457a0d53e8505e95a1863 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 31 Jan 2017 19:37:55 +0100
+Subject: [PATCH 2/3] net: bgmac: drop struct bcma_mdio we don't need anymore
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Adding struct bcma_mdio was a workaround for bcma code not having access
+to the struct bgmac used in the core code. Now we don't duplicate this
+struct we can just use it internally in bcma code.
+
+This simplifies code & allows access to all bgmac driver details from
+all places in bcma code.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c | 98 ++++++++++---------------
+ drivers/net/ethernet/broadcom/bgmac-bcma.c      |  2 +-
+ drivers/net/ethernet/broadcom/bgmac.h           |  2 +-
+ 3 files changed, 42 insertions(+), 60 deletions(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
+@@ -12,11 +12,6 @@
+ #include <linux/brcmphy.h>
+ #include "bgmac.h"
+ 
+-struct bcma_mdio {
+-	struct bcma_device *core;
+-	u8 phyaddr;
+-};
+-
+ static bool bcma_mdio_wait_value(struct bcma_device *core, u16 reg, u32 mask,
+ 				 u32 value, int timeout)
+ {
+@@ -37,7 +32,7 @@ static bool bcma_mdio_wait_value(struct
+  * PHY ops
+  **************************************************/
+ 
+-static u16 bcma_mdio_phy_read(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg)
++static u16 bcma_mdio_phy_read(struct bgmac *bgmac, u8 phyaddr, u8 reg)
+ {
+ 	struct bcma_device *core;
+ 	u16 phy_access_addr;
+@@ -56,12 +51,12 @@ static u16 bcma_mdio_phy_read(struct bcm
+ 	BUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);
+ 	BUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);
+ 
+-	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
+-		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
++	if (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		core = bgmac->bcma.core->bus->drv_gmac_cmn.core;
+ 		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
+ 		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
+ 	} else {
+-		core = bcma_mdio->core;
++		core = bgmac->bcma.core;
+ 		phy_access_addr = BGMAC_PHY_ACCESS;
+ 		phy_ctl_addr = BGMAC_PHY_CNTL;
+ 	}
+@@ -87,7 +82,7 @@ static u16 bcma_mdio_phy_read(struct bcm
+ }
+ 
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphywr */
+-static int bcma_mdio_phy_write(struct bcma_mdio *bcma_mdio, u8 phyaddr, u8 reg,
++static int bcma_mdio_phy_write(struct bgmac *bgmac, u8 phyaddr, u8 reg,
+ 			       u16 value)
+ {
+ 	struct bcma_device *core;
+@@ -95,12 +90,12 @@ static int bcma_mdio_phy_write(struct bc
+ 	u16 phy_ctl_addr;
+ 	u32 tmp;
+ 
+-	if (bcma_mdio->core->id.id == BCMA_CORE_4706_MAC_GBIT) {
+-		core = bcma_mdio->core->bus->drv_gmac_cmn.core;
++	if (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {
++		core = bgmac->bcma.core->bus->drv_gmac_cmn.core;
+ 		phy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;
+ 		phy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;
+ 	} else {
+-		core = bcma_mdio->core;
++		core = bgmac->bcma.core;
+ 		phy_access_addr = BGMAC_PHY_ACCESS;
+ 		phy_ctl_addr = BGMAC_PHY_CNTL;
+ 	}
+@@ -110,8 +105,8 @@ static int bcma_mdio_phy_write(struct bc
+ 	tmp |= phyaddr;
+ 	bcma_write32(core, phy_ctl_addr, tmp);
+ 
+-	bcma_write32(bcma_mdio->core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
+-	if (bcma_read32(bcma_mdio->core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
++	bcma_write32(bgmac->bcma.core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);
++	if (bcma_read32(bgmac->bcma.core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)
+ 		dev_warn(&core->dev, "Error setting MDIO int\n");
+ 
+ 	tmp = BGMAC_PA_START;
+@@ -132,39 +127,39 @@ static int bcma_mdio_phy_write(struct bc
+ }
+ 
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyinit */
+-static void bcma_mdio_phy_init(struct bcma_mdio *bcma_mdio)
++static void bcma_mdio_phy_init(struct bgmac *bgmac)
+ {
+-	struct bcma_chipinfo *ci = &bcma_mdio->core->bus->chipinfo;
++	struct bcma_chipinfo *ci = &bgmac->bcma.core->bus->chipinfo;
+ 	u8 i;
+ 
+ 	if (ci->id == BCMA_CHIP_ID_BCM5356) {
+ 		for (i = 0; i < 5; i++) {
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x008b);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x15, 0x0100);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x12, 0x2aaa);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);
++			bcma_mdio_phy_write(bgmac, i, 0x15, 0x0100);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
+ 		}
+ 	}
+ 	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
+ 	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
+ 	    (ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {
+-		struct bcma_drv_cc *cc = &bcma_mdio->core->bus->drv_cc;
++		struct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;
+ 
+ 		bcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);
+ 		bcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);
+ 		for (i = 0; i < 5; i++) {
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5284);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x0010);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000f);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x5296);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x1073);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9073);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x16, 0x52b6);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x17, 0x9273);
+-			bcma_mdio_phy_write(bcma_mdio, i, 0x1f, 0x000b);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bgmac, i, 0x16, 0x5284);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
++			bcma_mdio_phy_write(bgmac, i, 0x17, 0x0010);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);
++			bcma_mdio_phy_write(bgmac, i, 0x16, 0x5296);
++			bcma_mdio_phy_write(bgmac, i, 0x17, 0x1073);
++			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9073);
++			bcma_mdio_phy_write(bgmac, i, 0x16, 0x52b6);
++			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);
++			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
+ 		}
+ 	}
+ }
+@@ -172,17 +167,17 @@ static void bcma_mdio_phy_init(struct bc
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
+ static int bcma_mdio_phy_reset(struct mii_bus *bus)
+ {
+-	struct bcma_mdio *bcma_mdio = bus->priv;
+-	u8 phyaddr = bcma_mdio->phyaddr;
++	struct bgmac *bgmac = bus->priv;
++	u8 phyaddr = bgmac->phyaddr;
+ 
+-	if (bcma_mdio->phyaddr == BGMAC_PHY_NOREGS)
++	if (phyaddr == BGMAC_PHY_NOREGS)
+ 		return 0;
+ 
+-	bcma_mdio_phy_write(bcma_mdio, phyaddr, MII_BMCR, BMCR_RESET);
++	bcma_mdio_phy_write(bgmac, phyaddr, MII_BMCR, BMCR_RESET);
+ 	udelay(100);
+-	if (bcma_mdio_phy_read(bcma_mdio, phyaddr, MII_BMCR) & BMCR_RESET)
+-		dev_err(&bcma_mdio->core->dev, "PHY reset failed\n");
+-	bcma_mdio_phy_init(bcma_mdio);
++	if (bcma_mdio_phy_read(bgmac, phyaddr, MII_BMCR) & BMCR_RESET)
++		dev_err(bgmac->dev, "PHY reset failed\n");
++	bcma_mdio_phy_init(bgmac);
+ 
+ 	return 0;
+ }
+@@ -202,16 +197,12 @@ static int bcma_mdio_mii_write(struct mi
+ 	return bcma_mdio_phy_write(bus->priv, mii_id, regnum, value);
+ }
+ 
+-struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr)
++struct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac)
+ {
+-	struct bcma_mdio *bcma_mdio;
++	struct bcma_device *core = bgmac->bcma.core;
+ 	struct mii_bus *mii_bus;
+ 	int i, err;
+ 
+-	bcma_mdio = kzalloc(sizeof(*bcma_mdio), GFP_KERNEL);
+-	if (!bcma_mdio)
+-		return ERR_PTR(-ENOMEM);
+-
+ 	mii_bus = mdiobus_alloc();
+ 	if (!mii_bus) {
+ 		err = -ENOMEM;
+@@ -221,12 +212,12 @@ struct mii_bus *bcma_mdio_mii_register(s
+ 	mii_bus->name = "bcma_mdio mii bus";
+ 	sprintf(mii_bus->id, "%s-%d-%d", "bcma_mdio", core->bus->num,
+ 		core->core_unit);
+-	mii_bus->priv = bcma_mdio;
++	mii_bus->priv = bgmac;
+ 	mii_bus->read = bcma_mdio_mii_read;
+ 	mii_bus->write = bcma_mdio_mii_write;
+ 	mii_bus->reset = bcma_mdio_phy_reset;
+ 	mii_bus->parent = &core->dev;
+-	mii_bus->phy_mask = ~(1 << phyaddr);
++	mii_bus->phy_mask = ~(1 << bgmac->phyaddr);
+  
+ 	mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+ 	if (!mii_bus->irq) {
+@@ -236,9 +227,6 @@ struct mii_bus *bcma_mdio_mii_register(s
+ 	for (i = 0; i < PHY_MAX_ADDR; i++)
+ 		mii_bus->irq[i] = PHY_POLL;
+ 
+-	bcma_mdio->core = core;
+-	bcma_mdio->phyaddr = phyaddr;
+-
+ 	err = mdiobus_register(mii_bus);
+ 	if (err) {
+ 		dev_err(&core->dev, "Registration of mii bus failed\n");
+@@ -252,24 +240,18 @@ err_free_irq:
+ err_free_bus:
+ 	mdiobus_free(mii_bus);
+ err:
+-	kfree(bcma_mdio);
+ 	return ERR_PTR(err);
+ }
+ EXPORT_SYMBOL_GPL(bcma_mdio_mii_register);
+ 
+ void bcma_mdio_mii_unregister(struct mii_bus *mii_bus)
+ {
+-	struct bcma_mdio *bcma_mdio;
+-
+ 	if (!mii_bus)
+ 		return;
+ 
+-	bcma_mdio = mii_bus->priv;
+-
+ 	mdiobus_unregister(mii_bus);
+ 	kfree(mii_bus->irq);
+ 	mdiobus_free(mii_bus);
+-	kfree(bcma_mdio);
+ }
+ EXPORT_SYMBOL_GPL(bcma_mdio_mii_unregister);
+ 
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -159,7 +159,7 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	if (!bgmac_is_bcm4707_family(core) &&
+ 	    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {
+-		mii_bus = bcma_mdio_mii_register(core, bgmac->phyaddr);
++		mii_bus = bcma_mdio_mii_register(bgmac);
+ 		if (IS_ERR(mii_bus)) {
+ 			err = PTR_ERR(mii_bus);
+ 			goto err;
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -519,7 +519,7 @@ struct bgmac *bgmac_alloc(struct device
+ int bgmac_enet_probe(struct bgmac *bgmac);
+ void bgmac_enet_remove(struct bgmac *bgmac);
+ 
+-struct mii_bus *bcma_mdio_mii_register(struct bcma_device *core, u8 phyaddr);
++struct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac);
+ void bcma_mdio_mii_unregister(struct mii_bus *mii_bus);
+ 
+ static inline u32 bgmac_read(struct bgmac *bgmac, u16 offset)
diff --git a/target/linux/generic/pending-4.4/073-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch b/target/linux/generic/pending-4.4/073-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch
new file mode 100644
index 0000000000..d1be3e3f4c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/073-v4.10-0003-net-bgmac-use-PHY-subsystem-for-initializing-PHY.patch
@@ -0,0 +1,53 @@
+From 8e6f31baba7e2c13ab7e954fe6179420a7545a8b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 31 Jan 2017 19:37:56 +0100
+Subject: [PATCH 3/3] net: bgmac: use PHY subsystem for initializing PHY
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for using bgmac with PHYs supported by standalone PHY
+drivers. Having any PHY initialization in bgmac is hacky and shouldn't
+be extended but rather removed if anyone has hardware to test it.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma-mdio.c
+@@ -132,6 +132,10 @@ static void bcma_mdio_phy_init(struct bg
+ 	struct bcma_chipinfo *ci = &bgmac->bcma.core->bus->chipinfo;
+ 	u8 i;
+ 
++	/* For some legacy hardware we do chipset-based PHY initialization here
++	 * without even detecting PHY ID. It's hacky and should be cleaned as
++	 * soon as someone can test it.
++	 */
+ 	if (ci->id == BCMA_CHIP_ID_BCM5356) {
+ 		for (i = 0; i < 5; i++) {
+ 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);
+@@ -140,6 +144,7 @@ static void bcma_mdio_phy_init(struct bg
+ 			bcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);
+ 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
+ 		}
++		return;
+ 	}
+ 	if ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||
+ 	    (ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||
+@@ -161,7 +166,12 @@ static void bcma_mdio_phy_init(struct bg
+ 			bcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);
+ 			bcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);
+ 		}
++		return;
+ 	}
++
++	/* For all other hw do initialization using PHY subsystem. */
++	if (bgmac->net_dev && bgmac->net_dev->phydev)
++		phy_init_hw(bgmac->net_dev->phydev);
+ }
+ 
+ /* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */
diff --git a/target/linux/generic/pending-4.4/073-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch b/target/linux/generic/pending-4.4/073-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch
new file mode 100644
index 0000000000..27cd660b5c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/073-v4.15-0001-net-bgmac-enable-master-mode-for-BCM54210E-and-B5021.patch
@@ -0,0 +1,50 @@
+From 12acd136913ccdf394eeb2bc8686ff5505368119 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 12 Oct 2017 10:21:26 +0200
+Subject: [PATCH] net: bgmac: enable master mode for BCM54210E and B50212E PHYs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+There are 4 very similar PHYs:
+0x600d84a1: BCM54210E (rev B0)
+0x600d84a2: BCM54210E (rev B1)
+0x600d84a5: B50212E (rev B0)
+0x600d84a6: B50212E (rev B1)
+that need setting master mode manually. It's because they run in slave
+mode by default with Automatic Slave/Master configuration disabled which
+can lead to unreliable connection with massive ping loss.
+
+So far it was reported for a board with BCM47189 SoC and B50212E B1 PHY
+connected to the bgmac supported ethernet device. Telling PHY driver to
+setup PHY properly solves this issue.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -159,13 +159,19 @@ static int bgmac_probe(struct bcma_devic
+ 
+ 	if (!bgmac_is_bcm4707_family(core) &&
+ 	    !(ci->id == BCMA_CHIP_ID_BCM53573 && core->core_unit == 1)) {
++		struct phy_device *phydev;
++
+ 		mii_bus = bcma_mdio_mii_register(bgmac);
+ 		if (IS_ERR(mii_bus)) {
+ 			err = PTR_ERR(mii_bus);
+ 			goto err;
+ 		}
+-
+ 		bgmac->mii_bus = mii_bus;
++
++		phydev = bgmac->mii_bus->phy_map[bgmac->phyaddr];
++		if (ci->id == BCMA_CHIP_ID_BCM53573 && phydev &&
++		    (phydev->drv->phy_id & phydev->drv->phy_id_mask) == PHY_ID_BCM54210E)
++			phydev->dev_flags |= PHY_BRCM_EN_MASTER_MODE;
+ 	}
+ 
+ 	if (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {
diff --git a/target/linux/generic/pending-4.4/074-NET-PHY-adds-driver-for-lantiq-PHY11G.patch b/target/linux/generic/pending-4.4/074-NET-PHY-adds-driver-for-lantiq-PHY11G.patch
new file mode 100644
index 0000000000..e24099ef45
--- /dev/null
+++ b/target/linux/generic/pending-4.4/074-NET-PHY-adds-driver-for-lantiq-PHY11G.patch
@@ -0,0 +1,537 @@
+From 0a63ab263725c427051a8bbaa0732b749627da27 Mon Sep 17 00:00:00 2001
+From: John Crispin <blogic@openwrt.org>
+Date: Thu, 7 Aug 2014 18:15:36 +0200
+Subject: [PATCH 23/36] NET: PHY: adds driver for lantiq PHY11G
+
+Signed-off-by: John Crispin <blogic@openwrt.org>
+---
+ drivers/net/phy/Kconfig  |    5 +
+ drivers/net/phy/Makefile |    1 +
+ drivers/net/phy/lantiq.c |  231 ++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 237 insertions(+)
+ create mode 100644 drivers/net/phy/lantiq.c
+
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -156,6 +156,11 @@ config MICROCHIP_PHY
+ 	help
+ 	  Supports the LAN88XX PHYs.
+ 
++config LANTIQ_PHY
++	tristate "Driver for Lantiq PHYs"
++	---help---
++	  Supports the 11G and 22F PHYs.
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -30,6 +30,7 @@ obj-$(CONFIG_DP83848_PHY)	+= dp83848.o
+ obj-$(CONFIG_DP83867_PHY)	+= dp83867.o
+ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
++obj-$(CONFIG_LANTIQ_PHY)        += lantiq.o
+ obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
+ obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
+ obj-$(CONFIG_AT803X_PHY)	+= at803x.o
+--- /dev/null
++++ b/drivers/net/phy/lantiq.c
+@@ -0,0 +1,278 @@
++/*
++ *   This program is free software; you can redistribute it and/or modify
++ *   it under the terms of the GNU General Public License as published by
++ *   the Free Software Foundation; either version 2 of the License, or
++ *   (at your option) any later version.
++ *
++ *   This program is distributed in the hope that it will be useful,
++ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *   GNU General Public License for more details.
++ *
++ *   You should have received a copy of the GNU General Public License
++ *   along with this program; if not, write to the Free Software
++ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
++ *
++ *   Copyright (C) 2012 Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
++ */
++
++#include <linux/module.h>
++#include <linux/phy.h>
++#include <linux/of.h>
++
++#define MII_MMDCTRL		0x0d
++#define MII_MMDDATA		0x0e
++
++#define MII_VR9_11G_IMASK	0x19	/* interrupt mask */
++#define MII_VR9_11G_ISTAT	0x1a	/* interrupt status */
++
++#define INT_VR9_11G_WOL		BIT(15)	/* Wake-On-LAN */
++#define INT_VR9_11G_ANE		BIT(11)	/* Auto-Neg error */
++#define INT_VR9_11G_ANC		BIT(10)	/* Auto-Neg complete */
++#define INT_VR9_11G_ADSC	BIT(5)	/* Link auto-downspeed detect */
++#define INT_VR9_11G_DXMC	BIT(2)	/* Duplex mode change */
++#define INT_VR9_11G_LSPC	BIT(1)	/* Link speed change */
++#define INT_VR9_11G_LSTC	BIT(0)	/* Link state change */
++#define INT_VR9_11G_MASK	(INT_VR9_11G_LSTC | INT_VR9_11G_ADSC)
++
++#define ADVERTISED_MPD		BIT(10)	/* Multi-port device */
++
++#define MMD_DEVAD		0x1f
++#define MMD_ACTYPE_SHIFT	14
++#define MMD_ACTYPE_ADDRESS	(0 << MMD_ACTYPE_SHIFT)
++#define MMD_ACTYPE_DATA		(1 << MMD_ACTYPE_SHIFT)
++#define MMD_ACTYPE_DATA_PI	(2 << MMD_ACTYPE_SHIFT)
++#define MMD_ACTYPE_DATA_PIWR	(3 << MMD_ACTYPE_SHIFT)
++
++static __maybe_unused int vr9_gphy_mmd_read(struct phy_device *phydev,
++						u16 regnum)
++{
++	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_ADDRESS | MMD_DEVAD);
++	phy_write(phydev, MII_MMDDATA, regnum);
++	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_DATA | MMD_DEVAD);
++
++	return phy_read(phydev, MII_MMDDATA);
++}
++
++static __maybe_unused int vr9_gphy_mmd_write(struct phy_device *phydev,
++						u16 regnum, u16 val)
++{
++	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_ADDRESS | MMD_DEVAD);
++	phy_write(phydev, MII_MMDDATA, regnum);
++	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_DATA | MMD_DEVAD);
++	phy_write(phydev, MII_MMDDATA, val);
++
++	return 0;
++}
++
++#if IS_ENABLED(CONFIG_OF_MDIO)
++static int vr9_gphy_of_reg_init(struct phy_device *phydev)
++{
++	u32 tmp;
++
++	/* store the led values if one was passed by the devicetree */
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,ledch", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e0, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,ledcl", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e1, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led0h", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e2, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led0l", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e3, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led1h", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e4, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led1l", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e5, tmp);
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led2h", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e6, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led2l", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e7, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led3h", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e8, tmp);
++
++	if (!of_property_read_u32(phydev->dev.of_node, "lantiq,led3l", &tmp))
++		vr9_gphy_mmd_write(phydev, 0x1e9, tmp);
++
++	return 0;
++}
++#else
++static int vr9_gphy_of_reg_init(struct phy_device *phydev)
++{
++	return 0;
++}
++#endif /* CONFIG_OF_MDIO */
++
++static int vr9_gphy_config_init(struct phy_device *phydev)
++{
++	int err;
++
++	dev_dbg(&phydev->dev, "%s\n", __func__);
++
++	/* Mask all interrupts */
++	err = phy_write(phydev, MII_VR9_11G_IMASK, 0);
++	if (err)
++		return err;
++
++	/* Clear all pending interrupts */
++	phy_read(phydev, MII_VR9_11G_ISTAT);
++
++	vr9_gphy_mmd_write(phydev, 0x1e0, 0xc0);
++	vr9_gphy_mmd_write(phydev, 0x1e1, 0x00);
++	vr9_gphy_mmd_write(phydev, 0x1e2, 0x70);
++	vr9_gphy_mmd_write(phydev, 0x1e3, 0x03);
++	vr9_gphy_mmd_write(phydev, 0x1e4, 0x70);
++	vr9_gphy_mmd_write(phydev, 0x1e5, 0x03);
++	vr9_gphy_mmd_write(phydev, 0x1e6, 0x70);
++	vr9_gphy_mmd_write(phydev, 0x1e7, 0x03);
++	vr9_gphy_mmd_write(phydev, 0x1e8, 0x70);
++	vr9_gphy_mmd_write(phydev, 0x1e9, 0x03);
++
++	vr9_gphy_of_reg_init(phydev);
++
++	return 0;
++}
++
++static int vr9_gphy_config_aneg(struct phy_device *phydev)
++{
++	int reg, err;
++
++	/* Advertise as multi-port device */
++	reg = phy_read(phydev, MII_CTRL1000);
++	reg |= ADVERTISED_MPD;
++	err = phy_write(phydev, MII_CTRL1000, reg);
++	if (err)
++		return err;
++
++	return genphy_config_aneg(phydev);
++}
++
++static int vr9_gphy_ack_interrupt(struct phy_device *phydev)
++{
++	int reg;
++
++	/*
++	 * Possible IRQ numbers:
++	 * - IM3_IRL18 for GPHY0
++	 * - IM3_IRL17 for GPHY1
++	 *
++	 * Due to a silicon bug IRQ lines are not really independent from
++	 * each other. Sometimes the two lines are driven at the same time
++	 * if only one GPHY core raises the interrupt.
++	 */
++
++	reg = phy_read(phydev, MII_VR9_11G_ISTAT);
++
++	return (reg < 0) ? reg : 0;
++}
++
++static int vr9_gphy_did_interrupt(struct phy_device *phydev)
++{
++	int reg;
++
++	reg = phy_read(phydev, MII_VR9_11G_ISTAT);
++
++	return reg > 0;
++}
++
++static int vr9_gphy_config_intr(struct phy_device *phydev)
++{
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
++		err = phy_write(phydev, MII_VR9_11G_IMASK, INT_VR9_11G_MASK);
++	else
++		err = phy_write(phydev, MII_VR9_11G_IMASK, 0);
++
++	return err;
++}
++
++static struct phy_driver lantiq_phy[] = {
++	{
++		.phy_id		= 0xd565a400,
++		.phy_id_mask	= 0xfffffff8,
++		.name		= "Lantiq XWAY PEF7071",
++		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
++		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
++		.config_init	= vr9_gphy_config_init,
++		.config_aneg	= vr9_gphy_config_aneg,
++		.read_status	= genphy_read_status,
++		.ack_interrupt	= vr9_gphy_ack_interrupt,
++		.did_interrupt	= vr9_gphy_did_interrupt,
++		.config_intr	= vr9_gphy_config_intr,
++		.driver		= { .owner = THIS_MODULE },
++	}, {
++		.phy_id		= 0x030260D0,
++		.phy_id_mask	= 0xfffffff0,
++		.name		= "Lantiq XWAY VR9 GPHY 11G v1.3",
++		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
++		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
++		.config_init	= vr9_gphy_config_init,
++		.config_aneg	= vr9_gphy_config_aneg,
++		.read_status	= genphy_read_status,
++		.ack_interrupt	= vr9_gphy_ack_interrupt,
++		.did_interrupt	= vr9_gphy_did_interrupt,
++		.config_intr	= vr9_gphy_config_intr,
++		.driver		= { .owner = THIS_MODULE },
++	}, {
++		.phy_id		= 0xd565a408,
++		.phy_id_mask	= 0xfffffff8,
++		.name		= "Lantiq XWAY VR9 GPHY 11G v1.4",
++		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
++		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
++		.config_init	= vr9_gphy_config_init,
++		.config_aneg	= vr9_gphy_config_aneg,
++		.read_status	= genphy_read_status,
++		.ack_interrupt	= vr9_gphy_ack_interrupt,
++		.did_interrupt	= vr9_gphy_did_interrupt,
++		.config_intr	= vr9_gphy_config_intr,
++		.driver		= { .owner = THIS_MODULE },
++	}, {
++		.phy_id		= 0xd565a418,
++		.phy_id_mask	= 0xfffffff8,
++		.name		= "Lantiq XWAY XRX PHY22F v1.4",
++		.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
++		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
++		.config_init	= vr9_gphy_config_init,
++		.config_aneg	= vr9_gphy_config_aneg,
++		.read_status	= genphy_read_status,
++		.ack_interrupt	= vr9_gphy_ack_interrupt,
++		.did_interrupt	= vr9_gphy_did_interrupt,
++		.config_intr	= vr9_gphy_config_intr,
++		.driver		= { .owner = THIS_MODULE },
++	},
++};
++
++static int __init ltq_phy_init(void)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(lantiq_phy); i++) {
++		int err = phy_driver_register(&lantiq_phy[i]);
++		if (err)
++			pr_err("lantiq_phy: failed to load %s\n", lantiq_phy[i].name);
++	}
++
++	return 0;
++}
++
++static void __exit ltq_phy_exit(void)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(lantiq_phy); i++)
++		phy_driver_unregister(&lantiq_phy[i]);
++}
++
++module_init(ltq_phy_init);
++module_exit(ltq_phy_exit);
++
++MODULE_DESCRIPTION("Lantiq PHY drivers");
++MODULE_AUTHOR("Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/Documentation/devicetree/bindings/phy/phy-lanitq.txt
+@@ -0,0 +1,216 @@
++Lanitq PHY binding
++============================================
++
++This devicetree binding controls the lantiq ethernet phys led functionality.
++
++Example:
++	mdio@0 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "lantiq,xrx200-mdio";
++			phy5: ethernet-phy@5 {
++			reg = <0x1>;
++			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
++		};
++		phy11: ethernet-phy@11 {
++			reg = <0x11>;
++			compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
++			lantiq,led2h = <0x00>;
++			lantiq,led2l = <0x03>;
++		};
++		phy12: ethernet-phy@12 {
++			reg = <0x12>;
++			compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
++			lantiq,led1h = <0x00>;
++			lantiq,led1l = <0x03>;
++		};
++		phy13: ethernet-phy@13 {
++			reg = <0x13>;
++			compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
++			lantiq,led2h = <0x00>;
++			lantiq,led2l = <0x03>;
++		};
++		phy14: ethernet-phy@14 {
++			reg = <0x14>;
++			compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
++			lantiq,led1h = <0x00>;
++			lantiq,led1l = <0x03>;
++		};
++	};
++
++Register Description
++============================================
++
++LEDCH:
++
++Name	Hardware Reset Value
++LEDCH	0x00C5
++
++| 15 |    |    |    |    |    |    |  8 |
++=========================================
++|		RES			|
++=========================================
++
++|  7 |    |    |    |    |    |    |  0 |
++=========================================
++|   FBF   |   SBF   |RES |     NACS     |
++=========================================
++
++Field	Bits	Type	Description
++FBF	7:6	RW	Fast Blink Frequency
++			---
++			0x0 (00b) F02HZ 2 Hz blinking frequency
++			0x1 (01b) F04HZ 4 Hz blinking frequency
++			0x2 (10b) F08HZ 8 Hz blinking frequency
++			0x3 (11b) F16HZ 16 Hz blinking frequency
++
++SBF	5:4	RW	Slow Blink Frequency
++			---
++			0x0 (00b) F02HZ 2 Hz blinking frequency
++			0x1 (01b) F04HZ 4 Hz blinking frequency
++			0x2 (10b) F08HZ 8 Hz blinking frequency
++			0x3 (11b) F16HZ 16 Hz blinking frequency
++
++NACS	2:0	RW	Inverse of Scan Function
++			---
++			0x0 (000b) NONE No Function
++			0x1 (001b) LINK Complex function enabled when link is up
++			0x2 (010b) PDOWN Complex function enabled when device is powered-down
++			0x3 (011b) EEE Complex function enabled when device is in EEE mode
++			0x4 (100b) ANEG Complex function enabled when auto-negotiation is running
++			0x5 (101b) ABIST Complex function enabled when analog self-test is running
++			0x6 (110b) CDIAG Complex function enabled when cable diagnostics are running
++			0x7 (111b) TEST Complex function enabled when test mode is running
++
++LEDCL:
++
++Name	Hardware Reset Value
++LEDCL	0x0067
++
++| 15 |    |    |    |    |    |    |  8 |
++=========================================
++|		RES			|
++=========================================
++
++|  7 |    |    |    |    |    |    |  0 |
++=========================================
++|RES |     SCAN     |RES |    CBLINK    |
++=========================================
++
++Field	Bits	Type	Description
++SCAN	6:4	RW	Complex Scan Configuration
++			---
++			000 B NONE No Function
++			001 B LINK Complex function enabled when link is up
++			010 B PDOWN Complex function enabled when device is powered-down
++			011 B EEE Complex function enabled when device is in EEE mode
++			100 B ANEG Complex function enabled when auto-negotiation is running
++			101 B ABIST Complex function enabled when analog self-test is running
++			110 B CDIAG Complex function enabled when cable diagnostics are running
++			111 B TEST Complex function enabled when test mode is running
++
++CBLINK	2:0	RW	Complex Blinking Configuration
++			---
++			000 B NONE No Function
++			001 B LINK Complex function enabled when link is up
++			010 B PDOWN Complex function enabled when device is powered-down
++			011 B EEE Complex function enabled when device is in EEE mode
++			100 B ANEG Complex function enabled when auto-negotiation is running
++			101 B ABIST Complex function enabled when analog self-test is running
++			110 B CDIAG Complex function enabled when cable diagnostics are running
++			111 B TEST Complex function enabled when test mode is running
++
++LEDxH:
++
++Name	Hardware Reset Value
++LED0H	0x0070
++LED1H	0x0020
++LED2H	0x0040
++LED3H	0x0040
++
++| 15 |    |    |    |    |    |    |  8 |
++=========================================
++|		RES			|
++=========================================
++
++|  7 |    |    |    |    |    |    |  0 |
++=========================================
++|        CON        |       BLINKF      |
++=========================================
++
++Field	Bits	Type	Description
++CON	7:4	RW	Constant On Configuration
++			---
++			0x0 (0000b) NONE LED does not light up constantly
++			0x1 (0001b) LINK10 LED is on when link is 10 Mbit/s
++			0x2 (0010b) LINK100 LED is on when link is 100 Mbit/s
++			0x3 (0011b) LINK10X LED is on when link is 10/100 Mbit/s
++			0x4 (0100b) LINK1000 LED is on when link is 1000 Mbit/s
++			0x5 (0101b) LINK10_0 LED is on when link is 10/1000 Mbit/s
++			0x6 (0110b) LINK100X LED is on when link is 100/1000 Mbit/s
++			0x7 (0111b) LINK10XX LED is on when link is 10/100/1000 Mbit/s
++			0x8 (1000b) PDOWN LED is on when device is powered-down
++			0x9 (1001b) EEE LED is on when device is in EEE mode
++			0xA (1010b) ANEG LED is on when auto-negotiation is running
++			0xB (1011b) ABIST LED is on when analog self-test is running
++			0xC (1100b) CDIAG LED is on when cable diagnostics are running
++
++BLINKF	3:0	RW	Fast Blinking Configuration
++			---
++			0x0 (0000b) NONE No Blinking
++			0x1 (0001b) LINK10 Blink when link is 10 Mbit/s
++			0x2 (0010b) LINK100 Blink when link is 100 Mbit/s
++			0x3 (0011b) LINK10X Blink when link is 10/100 Mbit/s
++			0x4 (0100b) LINK1000 Blink when link is 1000 Mbit/s
++			0x5 (0101b) LINK10_0 Blink when link is 10/1000 Mbit/s
++			0x6 (0110b) LINK100X Blink when link is 100/1000 Mbit/s
++			0x7 (0111b) LINK10XX Blink when link is 10/100/1000 Mbit/s
++			0x8 (1000b) PDOWN Blink when device is powered-down
++			0x9 (1001b) EEE Blink when device is in EEE mode
++			0xA (1010b) ANEG Blink when auto-negotiation is running
++			0xB (1011b) ABIST Blink when analog self-test is running
++			0xC (1100b) CDIAG Blink when cable diagnostics are running
++
++LEDxL:
++
++Name	Hardware Reset Value
++LED0L	0x0003
++LED1L	0x0000
++LED2L	0x0000
++LED3L	0x0020
++
++| 15 |    |    |    |    |    |    |  8 |
++=========================================
++|		RES			|
++=========================================
++
++|  7 |    |    |    |    |    |    |  0 |
++=========================================
++|      BLINKS       |       PULSE       |
++=========================================
++
++Field	Bits	Type	Description
++BLINKS	7:4	RW	Slow Blinkin Configuration
++			---
++			0x0 (0000b) NONE No Blinking
++			0x1 (0001b) LINK10 Blink when link is 10 Mbit/s
++			0x2 (0010b) LINK100 Blink when link is 100 Mbit/s
++			0x3 (0011b) LINK10X Blink when link is 10/100 Mbit/s
++			0x4 (0100b) LINK1000 Blink when link is 1000 Mbit/s
++			0x5 (0101b) LINK10_0 Blink when link is 10/1000 Mbit/s
++			0x6 (0110b) LINK100X Blink when link is 100/1000 Mbit/s
++			0x7 (0111b) LINK10XX Blink when link is 10/100/1000 Mbit/s
++			0x8 (1000b) PDOWN Blink when device is powered-down
++			0x9 (1001b) EEE Blink when device is in EEE mode
++			0xA (1010b) ANEG Blink when auto-negotiation is running
++			0xB (1011b) ABIST Blink when analog self-test is running
++			0xC (1100b) CDIAG Blink when cable diagnostics are runningning
++
++PULSE	3:0	RW	Pulsing Configuration
++			The pulse field is a mask field by which certain events can be combined
++			---
++			0x0 (0000b) NONE No pulsing
++			0x1 (0001b) TXACT Transmit activity
++			0x2 (0010b) RXACT Receive activity
++			0x4 (0100b) COL Collision
++			0x8 (1000b) RES Reserved
diff --git a/target/linux/generic/pending-4.4/078-0001-net-phy-update-Broadcom-drivers-to-v4.5.patch b/target/linux/generic/pending-4.4/078-0001-net-phy-update-Broadcom-drivers-to-v4.5.patch
new file mode 100644
index 0000000000..222d126f69
--- /dev/null
+++ b/target/linux/generic/pending-4.4/078-0001-net-phy-update-Broadcom-drivers-to-v4.5.patch
@@ -0,0 +1,125 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH 1/4] net: phy: update Broadcom drivers to v4.5
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+
+--- a/drivers/net/phy/bcm7xxx.c
++++ b/drivers/net/phy/bcm7xxx.c
+@@ -250,10 +250,6 @@ static int bcm7xxx_config_init(struct ph
+ 	phy_write(phydev, MII_BCM7XXX_AUX_MODE, MII_BCM7XX_64CLK_MDIO);
+ 	phy_read(phydev, MII_BCM7XXX_AUX_MODE);
+ 
+-	/* Workaround only required for 100Mbits/sec capable PHYs */
+-	if (phydev->supported & PHY_GBIT_FEATURES)
+-		return 0;
+-
+ 	/* set shadow mode 2 */
+ 	ret = phy_set_clr_bits(phydev, MII_BCM7XXX_TEST,
+ 			MII_BCM7XXX_SHD_MODE_2, MII_BCM7XXX_SHD_MODE_2);
+@@ -270,7 +266,7 @@ static int bcm7xxx_config_init(struct ph
+ 	phy_write(phydev, MII_BCM7XXX_100TX_FALSE_CAR, 0x7555);
+ 
+ 	/* reset shadow mode 2 */
+-	ret = phy_set_clr_bits(phydev, MII_BCM7XXX_TEST, MII_BCM7XXX_SHD_MODE_2, 0);
++	ret = phy_set_clr_bits(phydev, MII_BCM7XXX_TEST, 0, MII_BCM7XXX_SHD_MODE_2);
+ 	if (ret < 0)
+ 		return ret;
+ 
+@@ -307,11 +303,6 @@ static int bcm7xxx_suspend(struct phy_de
+ 	return 0;
+ }
+ 
+-static int bcm7xxx_dummy_config_init(struct phy_device *phydev)
+-{
+-	return 0;
+-}
+-
+ #define BCM7XXX_28NM_GPHY(_oui, _name)					\
+ {									\
+ 	.phy_id		= (_oui),					\
+@@ -338,7 +329,7 @@ static struct phy_driver bcm7xxx_driver[
+ 	.phy_id         = PHY_ID_BCM7425,
+ 	.phy_id_mask    = 0xfffffff0,
+ 	.name           = "Broadcom BCM7425",
+-	.features       = PHY_GBIT_FEATURES |
++	.features       = PHY_BASIC_FEATURES |
+ 			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+ 	.flags          = PHY_IS_INTERNAL,
+ 	.config_init    = bcm7xxx_config_init,
+@@ -351,7 +342,7 @@ static struct phy_driver bcm7xxx_driver[
+ 	.phy_id         = PHY_ID_BCM7429,
+ 	.phy_id_mask    = 0xfffffff0,
+ 	.name           = "Broadcom BCM7429",
+-	.features       = PHY_GBIT_FEATURES |
++	.features       = PHY_BASIC_FEATURES |
+ 			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+ 	.flags          = PHY_IS_INTERNAL,
+ 	.config_init    = bcm7xxx_config_init,
+@@ -361,31 +352,18 @@ static struct phy_driver bcm7xxx_driver[
+ 	.resume         = bcm7xxx_config_init,
+ 	.driver         = { .owner = THIS_MODULE },
+ }, {
+-	.phy_id		= PHY_BCM_OUI_4,
+-	.phy_id_mask	= 0xffff0000,
+-	.name		= "Broadcom BCM7XXX 40nm",
+-	.features	= PHY_GBIT_FEATURES |
+-			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+-	.flags		= PHY_IS_INTERNAL,
+-	.config_init	= bcm7xxx_config_init,
+-	.config_aneg	= genphy_config_aneg,
+-	.read_status	= genphy_read_status,
+-	.suspend	= bcm7xxx_suspend,
+-	.resume		= bcm7xxx_config_init,
+-	.driver		= { .owner = THIS_MODULE },
+-}, {
+-	.phy_id		= PHY_BCM_OUI_5,
+-	.phy_id_mask	= 0xffffff00,
+-	.name		= "Broadcom BCM7XXX 65nm",
+-	.features	= PHY_BASIC_FEATURES |
++	.phy_id         = PHY_ID_BCM7435,
++	.phy_id_mask    = 0xfffffff0,
++	.name           = "Broadcom BCM7435",
++	.features       = PHY_BASIC_FEATURES |
+ 			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+-	.flags		= PHY_IS_INTERNAL,
+-	.config_init	= bcm7xxx_dummy_config_init,
+-	.config_aneg	= genphy_config_aneg,
+-	.read_status	= genphy_read_status,
+-	.suspend	= bcm7xxx_suspend,
+-	.resume		= bcm7xxx_config_init,
+-	.driver		= { .owner = THIS_MODULE },
++	.flags          = PHY_IS_INTERNAL,
++	.config_init    = bcm7xxx_config_init,
++	.config_aneg    = genphy_config_aneg,
++	.read_status    = genphy_read_status,
++	.suspend        = bcm7xxx_suspend,
++	.resume         = bcm7xxx_config_init,
++	.driver         = { .owner = THIS_MODULE },
+ } };
+ 
+ static struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
+@@ -395,9 +373,8 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_BCM7425, 0xfffffff0, },
+ 	{ PHY_ID_BCM7429, 0xfffffff0, },
+ 	{ PHY_ID_BCM7439, 0xfffffff0, },
++	{ PHY_ID_BCM7435, 0xfffffff0, },
+ 	{ PHY_ID_BCM7445, 0xfffffff0, },
+-	{ PHY_BCM_OUI_4, 0xffff0000 },
+-	{ PHY_BCM_OUI_5, 0xffffff00 },
+ 	{ }
+ };
+ 
+--- a/include/linux/brcmphy.h
++++ b/include/linux/brcmphy.h
+@@ -26,6 +26,7 @@
+ #define PHY_ID_BCM7366			0x600d8490
+ #define PHY_ID_BCM7425			0x600d86b0
+ #define PHY_ID_BCM7429			0x600d8730
++#define PHY_ID_BCM7435			0x600d8750
+ #define PHY_ID_BCM7439			0x600d8480
+ #define PHY_ID_BCM7439_2		0xae025080
+ #define PHY_ID_BCM7445			0x600d8510
diff --git a/target/linux/generic/pending-4.4/078-0002-net-phy-update-Broadcom-drivers-to-v4.6.patch b/target/linux/generic/pending-4.4/078-0002-net-phy-update-Broadcom-drivers-to-v4.6.patch
new file mode 100644
index 0000000000..4be229b8fa
--- /dev/null
+++ b/target/linux/generic/pending-4.4/078-0002-net-phy-update-Broadcom-drivers-to-v4.6.patch
@@ -0,0 +1,123 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH 2/4] net: phy: update Broadcom drivers to v4.6
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+
+--- a/drivers/net/phy/bcm7xxx.c
++++ b/drivers/net/phy/bcm7xxx.c
+@@ -24,7 +24,7 @@
+ #define MII_BCM7XXX_100TX_FALSE_CAR	0x13
+ #define MII_BCM7XXX_100TX_DISC		0x14
+ #define MII_BCM7XXX_AUX_MODE		0x1d
+-#define  MII_BCM7XX_64CLK_MDIO		BIT(12)
++#define  MII_BCM7XXX_64CLK_MDIO		BIT(12)
+ #define MII_BCM7XXX_TEST		0x1f
+ #define  MII_BCM7XXX_SHD_MODE_2		BIT(2)
+ 
+@@ -247,7 +247,7 @@ static int bcm7xxx_config_init(struct ph
+ 	int ret;
+ 
+ 	/* Enable 64 clock MDIO */
+-	phy_write(phydev, MII_BCM7XXX_AUX_MODE, MII_BCM7XX_64CLK_MDIO);
++	phy_write(phydev, MII_BCM7XXX_AUX_MODE, MII_BCM7XXX_64CLK_MDIO);
+ 	phy_read(phydev, MII_BCM7XXX_AUX_MODE);
+ 
+ 	/* set shadow mode 2 */
+@@ -318,6 +318,22 @@ static int bcm7xxx_suspend(struct phy_de
+ 	.driver		= { .owner = THIS_MODULE },			\
+ }
+ 
++#define BCM7XXX_40NM_EPHY(_oui, _name)					\
++{									\
++	.phy_id         = (_oui),					\
++	.phy_id_mask    = 0xfffffff0,					\
++	.name           = _name,					\
++	.features       = PHY_BASIC_FEATURES |				\
++			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,	\
++	.flags          = PHY_IS_INTERNAL,				\
++	.config_init    = bcm7xxx_config_init,				\
++	.config_aneg    = genphy_config_aneg,				\
++	.read_status    = genphy_read_status,				\
++	.suspend        = bcm7xxx_suspend,				\
++	.resume         = bcm7xxx_config_init,				\
++	.driver		= { .owner = THIS_MODULE },			\
++}
++
+ static struct phy_driver bcm7xxx_driver[] = {
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7250, "Broadcom BCM7250"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7364, "Broadcom BCM7364"),
+@@ -325,51 +341,19 @@ static struct phy_driver bcm7xxx_driver[
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7439, "Broadcom BCM7439"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7439_2, "Broadcom BCM7439 (2)"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7445, "Broadcom BCM7445"),
+-{
+-	.phy_id         = PHY_ID_BCM7425,
+-	.phy_id_mask    = 0xfffffff0,
+-	.name           = "Broadcom BCM7425",
+-	.features       = PHY_BASIC_FEATURES |
+-			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+-	.flags          = PHY_IS_INTERNAL,
+-	.config_init    = bcm7xxx_config_init,
+-	.config_aneg    = genphy_config_aneg,
+-	.read_status    = genphy_read_status,
+-	.suspend        = bcm7xxx_suspend,
+-	.resume         = bcm7xxx_config_init,
+-	.driver         = { .owner = THIS_MODULE },
+-}, {
+-	.phy_id         = PHY_ID_BCM7429,
+-	.phy_id_mask    = 0xfffffff0,
+-	.name           = "Broadcom BCM7429",
+-	.features       = PHY_BASIC_FEATURES |
+-			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+-	.flags          = PHY_IS_INTERNAL,
+-	.config_init    = bcm7xxx_config_init,
+-	.config_aneg    = genphy_config_aneg,
+-	.read_status    = genphy_read_status,
+-	.suspend        = bcm7xxx_suspend,
+-	.resume         = bcm7xxx_config_init,
+-	.driver         = { .owner = THIS_MODULE },
+-}, {
+-	.phy_id         = PHY_ID_BCM7435,
+-	.phy_id_mask    = 0xfffffff0,
+-	.name           = "Broadcom BCM7435",
+-	.features       = PHY_BASIC_FEATURES |
+-			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+-	.flags          = PHY_IS_INTERNAL,
+-	.config_init    = bcm7xxx_config_init,
+-	.config_aneg    = genphy_config_aneg,
+-	.read_status    = genphy_read_status,
+-	.suspend        = bcm7xxx_suspend,
+-	.resume         = bcm7xxx_config_init,
+-	.driver         = { .owner = THIS_MODULE },
+-} };
++	BCM7XXX_40NM_EPHY(PHY_ID_BCM7346, "Broadcom BCM7346"),
++	BCM7XXX_40NM_EPHY(PHY_ID_BCM7362, "Broadcom BCM7362"),
++	BCM7XXX_40NM_EPHY(PHY_ID_BCM7425, "Broadcom BCM7425"),
++	BCM7XXX_40NM_EPHY(PHY_ID_BCM7429, "Broadcom BCM7429"),
++	BCM7XXX_40NM_EPHY(PHY_ID_BCM7435, "Broadcom BCM7435"),
++};
+ 
+ static struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
+ 	{ PHY_ID_BCM7250, 0xfffffff0, },
+ 	{ PHY_ID_BCM7364, 0xfffffff0, },
+ 	{ PHY_ID_BCM7366, 0xfffffff0, },
++	{ PHY_ID_BCM7346, 0xfffffff0, },
++	{ PHY_ID_BCM7362, 0xfffffff0, },
+ 	{ PHY_ID_BCM7425, 0xfffffff0, },
+ 	{ PHY_ID_BCM7429, 0xfffffff0, },
+ 	{ PHY_ID_BCM7439, 0xfffffff0, },
+--- a/include/linux/brcmphy.h
++++ b/include/linux/brcmphy.h
+@@ -24,6 +24,8 @@
+ #define PHY_ID_BCM7250			0xae025280
+ #define PHY_ID_BCM7364			0xae025260
+ #define PHY_ID_BCM7366			0x600d8490
++#define PHY_ID_BCM7346			0x600d8650
++#define PHY_ID_BCM7362			0x600d84b0
+ #define PHY_ID_BCM7425			0x600d86b0
+ #define PHY_ID_BCM7429			0x600d8730
+ #define PHY_ID_BCM7435			0x600d8750
diff --git a/target/linux/generic/pending-4.4/078-0003-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch b/target/linux/generic/pending-4.4/078-0003-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
new file mode 100644
index 0000000000..1d943d605b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/078-0003-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
@@ -0,0 +1,315 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH] net: phy: cherry-pick Broadcom drivers updates from v4.10
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This includes following upstream commits:
+5519da874ad0 net: phy: broadcom: Move bcm54xx_auxctl_{read, write} to common library
+b14995ac2527 net: phy: broadcom: Add BCM54810 PHY entry
+5b4e29005123 net: phy: broadcom: add bcm54xx_auxctl_read
+d92ead16be40 net: phy: broadcom: Add support for BCM54612E
+3cf25904fe46 net: phy: broadcom: Update Auxiliary Control Register macros
+
+Other commits were skipped as they depend on other changes like
+ETHTOOL_PHY_DOWNSHIFT & DOWNSHIFT_DEV_DISABLE and new APIs like
+get_sset_count.
+
+One exception was picking new regs from commit d06f78c4232d ("net: phy:
+broadcom: Add support code for downshift/Wirespeed").
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -77,7 +77,7 @@ config BROADCOM_PHY
+ 	select BCM_NET_PHYLIB
+ 	---help---
+ 	  Currently supports the BCM5411, BCM5421, BCM5461, BCM54616S, BCM5464,
+-	  BCM5481 and BCM5482 PHYs.
++	  BCM5481, BCM54810 and BCM5482 PHYs.
+ 
+ config BCM_CYGNUS_PHY
+ 	tristate "Drivers for Broadcom Cygnus SoC internal PHY"
+--- a/drivers/net/phy/bcm-phy-lib.c
++++ b/drivers/net/phy/bcm-phy-lib.c
+@@ -50,6 +50,23 @@ int bcm_phy_read_exp(struct phy_device *
+ }
+ EXPORT_SYMBOL_GPL(bcm_phy_read_exp);
+ 
++int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum)
++{
++	/* The register must be written to both the Shadow Register Select and
++	 * the Shadow Read Register Selector
++	 */
++	phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum |
++		  regnum << MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT);
++	return phy_read(phydev, MII_BCM54XX_AUX_CTL);
++}
++EXPORT_SYMBOL_GPL(bcm54xx_auxctl_read);
++
++int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
++{
++	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
++}
++EXPORT_SYMBOL(bcm54xx_auxctl_write);
++
+ int bcm_phy_write_misc(struct phy_device *phydev,
+ 		       u16 reg, u16 chl, u16 val)
+ {
+--- a/drivers/net/phy/bcm-phy-lib.h
++++ b/drivers/net/phy/bcm-phy-lib.h
+@@ -19,6 +19,9 @@
+ int bcm_phy_write_exp(struct phy_device *phydev, u16 reg, u16 val);
+ int bcm_phy_read_exp(struct phy_device *phydev, u16 reg);
+ 
++int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val);
++int bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum);
++
+ int bcm_phy_write_misc(struct phy_device *phydev,
+ 		       u16 reg, u16 chl, u16 value);
+ int bcm_phy_read_misc(struct phy_device *phydev,
+--- a/drivers/net/phy/broadcom.c
++++ b/drivers/net/phy/broadcom.c
+@@ -18,7 +18,7 @@
+ #include <linux/module.h>
+ #include <linux/phy.h>
+ #include <linux/brcmphy.h>
+-
++#include <linux/of.h>
+ 
+ #define BRCM_PHY_MODEL(phydev) \
+ 	((phydev)->drv->phy_id & (phydev)->drv->phy_id_mask)
+@@ -30,9 +30,32 @@ MODULE_DESCRIPTION("Broadcom PHY driver"
+ MODULE_AUTHOR("Maciej W. Rozycki");
+ MODULE_LICENSE("GPL");
+ 
+-static int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
++static int bcm54810_config(struct phy_device *phydev)
+ {
+-	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
++	int rc, val;
++
++	val = bcm_phy_read_exp(phydev, BCM54810_EXP_BROADREACH_LRE_MISC_CTL);
++	val &= ~BCM54810_EXP_BROADREACH_LRE_MISC_CTL_EN;
++	rc = bcm_phy_write_exp(phydev, BCM54810_EXP_BROADREACH_LRE_MISC_CTL,
++			       val);
++	if (rc < 0)
++		return rc;
++
++	val = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
++	val &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
++	val |= MII_BCM54XX_AUXCTL_MISC_WREN;
++	rc = bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
++				  val);
++	if (rc < 0)
++		return rc;
++
++	val = bcm_phy_read_shadow(phydev, BCM54810_SHD_CLK_CTL);
++	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
++	rc = bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
++	if (rc < 0)
++		return rc;
++
++	return 0;
+ }
+ 
+ /* Needs SMDSP clock enabled via bcm54xx_phydsp_config() */
+@@ -207,6 +230,12 @@ static int bcm54xx_config_init(struct ph
+ 	    (phydev->dev_flags & PHY_BRCM_AUTO_PWRDWN_ENABLE))
+ 		bcm54xx_adjust_rxrefclk(phydev);
+ 
++	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
++		err = bcm54810_config(phydev);
++		if (err)
++			return err;
++	}
++
+ 	bcm54xx_phydsp_config(phydev);
+ 
+ 	return 0;
+@@ -304,6 +333,7 @@ static int bcm5482_read_status(struct ph
+ 
+ static int bcm5481_config_aneg(struct phy_device *phydev)
+ {
++	struct device_node *np = phydev->dev.of_node;
+ 	int ret;
+ 
+ 	/* Aneg firsly. */
+@@ -334,6 +364,49 @@ static int bcm5481_config_aneg(struct ph
+ 		phy_write(phydev, 0x18, reg);
+ 	}
+ 
++	if (of_property_read_bool(np, "enet-phy-lane-swap")) {
++		/* Lane Swap - Undocumented register...magic! */
++		ret = bcm_phy_write_exp(phydev, MII_BCM54XX_EXP_SEL_ER + 0x9,
++					0x11B);
++		if (ret < 0)
++			return ret;
++	}
++
++	return ret;
++}
++
++static int bcm54612e_config_aneg(struct phy_device *phydev)
++{
++	int ret;
++
++	/* First, auto-negotiate. */
++	ret = genphy_config_aneg(phydev);
++
++	/* Clear TX internal delay unless requested. */
++	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
++	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
++		/* Disable TXD to GTXCLK clock delay (default set) */
++		/* Bit 9 is the only field in shadow register 00011 */
++		bcm_phy_write_shadow(phydev, 0x03, 0);
++	}
++
++	/* Clear RX internal delay unless requested. */
++	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
++	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
++		u16 reg;
++
++		/* Errata: reads require filling in the write selector field */
++		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
++				     MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC);
++		reg = phy_read(phydev, MII_BCM54XX_AUX_CTL);
++		/* Disable RXD to RXC delay (default set) */
++		reg &= ~MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW;
++		/* Clear shadow selector field */
++		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
++		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
++				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
++	}
++
+ 	return ret;
+ }
+ 
+@@ -488,6 +561,18 @@ static struct phy_driver broadcom_driver
+ 	.config_intr	= bcm_phy_config_intr,
+ 	.driver		= { .owner = THIS_MODULE },
+ }, {
++	.phy_id		= PHY_ID_BCM54612E,
++	.phy_id_mask	= 0xfffffff0,
++	.name		= "Broadcom BCM54612E",
++	.features	= PHY_GBIT_FEATURES |
++			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
++	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
++	.config_init	= bcm54xx_config_init,
++	.config_aneg	= bcm54612e_config_aneg,
++	.read_status	= genphy_read_status,
++	.ack_interrupt	= bcm_phy_ack_intr,
++	.config_intr	= bcm_phy_config_intr,
++}, {
+ 	.phy_id		= PHY_ID_BCM54616S,
+ 	.phy_id_mask	= 0xfffffff0,
+ 	.name		= "Broadcom BCM54616S",
+@@ -527,6 +612,18 @@ static struct phy_driver broadcom_driver
+ 	.config_intr	= bcm_phy_config_intr,
+ 	.driver		= { .owner = THIS_MODULE },
+ }, {
++	.phy_id         = PHY_ID_BCM54810,
++	.phy_id_mask    = 0xfffffff0,
++	.name           = "Broadcom BCM54810",
++	.features       = PHY_GBIT_FEATURES |
++			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
++	.flags          = PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
++	.config_init    = bcm54xx_config_init,
++	.config_aneg    = bcm5481_config_aneg,
++	.read_status    = genphy_read_status,
++	.ack_interrupt  = bcm_phy_ack_intr,
++	.config_intr    = bcm_phy_config_intr,
++}, {
+ 	.phy_id		= PHY_ID_BCM5482,
+ 	.phy_id_mask	= 0xfffffff0,
+ 	.name		= "Broadcom BCM5482",
+@@ -612,9 +709,11 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_BCM5411, 0xfffffff0 },
+ 	{ PHY_ID_BCM5421, 0xfffffff0 },
+ 	{ PHY_ID_BCM5461, 0xfffffff0 },
++	{ PHY_ID_BCM54612E, 0xfffffff0 },
+ 	{ PHY_ID_BCM54616S, 0xfffffff0 },
+ 	{ PHY_ID_BCM5464, 0xfffffff0 },
+ 	{ PHY_ID_BCM5481, 0xfffffff0 },
++	{ PHY_ID_BCM54810, 0xfffffff0 },
+ 	{ PHY_ID_BCM5482, 0xfffffff0 },
+ 	{ PHY_ID_BCM50610, 0xfffffff0 },
+ 	{ PHY_ID_BCM50610M, 0xfffffff0 },
+--- a/include/linux/brcmphy.h
++++ b/include/linux/brcmphy.h
+@@ -13,11 +13,13 @@
+ #define PHY_ID_BCM5241			0x0143bc30
+ #define PHY_ID_BCMAC131			0x0143bc70
+ #define PHY_ID_BCM5481			0x0143bca0
++#define PHY_ID_BCM54810			0x03625d00
+ #define PHY_ID_BCM5482			0x0143bcb0
+ #define PHY_ID_BCM5411			0x00206070
+ #define PHY_ID_BCM5421			0x002060e0
+ #define PHY_ID_BCM5464			0x002060b0
+ #define PHY_ID_BCM5461			0x002060c0
++#define PHY_ID_BCM54612E		0x03625e60
+ #define PHY_ID_BCM54616S		0x03625d10
+ #define PHY_ID_BCM57780			0x03625d90
+ 
+@@ -55,6 +57,7 @@
+ #define PHY_BRCM_EXT_IBND_TX_ENABLE	0x00002000
+ #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
+ #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
++
+ /* Broadcom BCM7xxx specific workarounds */
+ #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
+ #define PHY_BRCM_7XXX_PATCH(x)		((x) & 0xff)
+@@ -105,11 +108,14 @@
+ #define MII_BCM54XX_AUXCTL_ACTL_SMDSP_ENA	0x0800
+ 
+ #define MII_BCM54XX_AUXCTL_MISC_WREN	0x8000
++#define MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW	0x0100
+ #define MII_BCM54XX_AUXCTL_MISC_FORCE_AMDIX	0x0200
+ #define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
+ #define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
++#define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
++#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN	(1 << 8)
+ 
+-#define MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL	0x0000
++#define MII_BCM54XX_AUXCTL_SHDWSEL_MASK	0x0007
+ 
+ /*
+  * Broadcom LED source encodings.  These are used in BCM5461, BCM5481,
+@@ -124,6 +130,7 @@
+ #define BCM_LED_SRC_INTR	0x6
+ #define BCM_LED_SRC_QUALITY	0x7
+ #define BCM_LED_SRC_RCVLED	0x8
++#define BCM_LED_SRC_WIRESPEED	0x9
+ #define BCM_LED_SRC_MULTICOLOR1	0xa
+ #define BCM_LED_SRC_OPENSHORT	0xb
+ #define BCM_LED_SRC_OFF		0xe	/* Tied high */
+@@ -135,6 +142,14 @@
+  * Shadow values go into bits [14:10] of register 0x1c to select a shadow
+  * register to access.
+  */
++
++/* 00100: Reserved control register 2 */
++#define BCM54XX_SHD_SCR2		0x04
++#define  BCM54XX_SHD_SCR2_WSPD_RTRY_DIS	0x100
++#define  BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_SHIFT	2
++#define  BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_OFFSET	2
++#define  BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_MASK	0x7
++
+ /* 00101: Spare Control Register 3 */
+ #define BCM54XX_SHD_SCR3		0x05
+ #define  BCM54XX_SHD_SCR3_DEF_CLK125	0x0001
+@@ -189,6 +204,12 @@
+ #define BCM5482_SSD_SGMII_SLAVE_EN	0x0002	/* Slave mode enable */
+ #define BCM5482_SSD_SGMII_SLAVE_AD	0x0001	/* Slave auto-detection */
+ 
++/* BCM54810 Registers */
++#define BCM54810_EXP_BROADREACH_LRE_MISC_CTL	(MII_BCM54XX_EXP_SEL_ER + 0x90)
++#define BCM54810_EXP_BROADREACH_LRE_MISC_CTL_EN	(1 << 0)
++#define BCM54810_SHD_CLK_CTL			0x3
++#define BCM54810_SHD_CLK_CTL_GTXCLK_EN		(1 << 9)
++
+ 
+ /*****************************************************************************/
+ /* Fast Ethernet Transceiver definitions. */
diff --git a/target/linux/generic/pending-4.4/078-0004-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch b/target/linux/generic/pending-4.4/078-0004-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
new file mode 100644
index 0000000000..269c4e7247
--- /dev/null
+++ b/target/linux/generic/pending-4.4/078-0004-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
@@ -0,0 +1,283 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH] net: phy: cherry-pick Broadcom drivers updates from v4.11
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This includes following upstream commits:
+62e13097c46c net: phy: broadcom: rehook BCM54612E specific init
+0fc9ae107669 net: phy: broadcom: add support for BCM54210E
+5e7bfa6cb0a9 net: phy: bcm-phy-lib: clean up remaining AUXCTL register defines
+8293c7bcdef1 net: phy: broadcom: drop duplicated define for RGMII SKEW delay
+85b4685da52f net: phy: broadcom: use auxctl reading helper in BCM54612E code
+039a7b8592ab net: phy: bcm7xxx: Implement EGPHY workaround for 7278
+582d0ac397ca net: phy: bcm7xxx: Add entry for BCM7278
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+
+--- a/drivers/net/phy/bcm7xxx.c
++++ b/drivers/net/phy/bcm7xxx.c
+@@ -163,12 +163,43 @@ static int bcm7xxx_28nm_e0_plus_afe_conf
+ 	return 0;
+ }
+ 
++static int bcm7xxx_28nm_a0_patch_afe_config_init(struct phy_device *phydev)
++{
++	/* +1 RC_CAL codes for RL centering for both LT and HT conditions */
++	bcm_phy_write_misc(phydev, AFE_RXCONFIG_2, 0xd003);
++
++	/* Cut master bias current by 2% to compensate for RC_CAL offset */
++	bcm_phy_write_misc(phydev, DSP_TAP10, 0x791b);
++
++	/* Improve hybrid leakage */
++	bcm_phy_write_misc(phydev, AFE_HPF_TRIM_OTHERS, 0x10e3);
++
++	/* Change rx_on_tune 8 to 0xf */
++	bcm_phy_write_misc(phydev, 0x21, 0x2, 0x87f6);
++
++	/* Change 100Tx EEE bandwidth */
++	bcm_phy_write_misc(phydev, 0x22, 0x2, 0x017d);
++
++	/* Enable ffe zero detection for Vitesse interoperability */
++	bcm_phy_write_misc(phydev, 0x26, 0x2, 0x0015);
++
++	r_rc_cal_reset(phydev);
++
++	return 0;
++}
++
+ static int bcm7xxx_28nm_config_init(struct phy_device *phydev)
+ {
+ 	u8 rev = PHY_BRCM_7XXX_REV(phydev->dev_flags);
+ 	u8 patch = PHY_BRCM_7XXX_PATCH(phydev->dev_flags);
+ 	int ret = 0;
+ 
++	/* Newer devices have moved the revision information back into a
++	 * standard location in MII_PHYS_ID[23]
++	 */
++	if (rev == 0)
++		rev = phydev->phy_id & ~phydev->drv->phy_id_mask;
++
+ 	pr_info_once("%s: %s PHY revision: 0x%02x, patch: %d\n",
+ 		     dev_name(&phydev->dev), phydev->drv->name, rev, patch);
+ 
+@@ -192,6 +223,9 @@ static int bcm7xxx_28nm_config_init(stru
+ 	case 0x10:
+ 		ret = bcm7xxx_28nm_e0_plus_afe_config_init(phydev);
+ 		break;
++	case 0x01:
++		ret = bcm7xxx_28nm_a0_patch_afe_config_init(phydev);
++		break;
+ 	default:
+ 		break;
+ 	}
+@@ -336,6 +370,7 @@ static int bcm7xxx_suspend(struct phy_de
+ 
+ static struct phy_driver bcm7xxx_driver[] = {
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7250, "Broadcom BCM7250"),
++	BCM7XXX_28NM_GPHY(PHY_ID_BCM7278, "Broadcom BCM7278"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7364, "Broadcom BCM7364"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7366, "Broadcom BCM7366"),
+ 	BCM7XXX_28NM_GPHY(PHY_ID_BCM7439, "Broadcom BCM7439"),
+@@ -350,6 +385,7 @@ static struct phy_driver bcm7xxx_driver[
+ 
+ static struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
+ 	{ PHY_ID_BCM7250, 0xfffffff0, },
++	{ PHY_ID_BCM7278, 0xfffffff0, },
+ 	{ PHY_ID_BCM7364, 0xfffffff0, },
+ 	{ PHY_ID_BCM7366, 0xfffffff0, },
+ 	{ PHY_ID_BCM7346, 0xfffffff0, },
+--- a/drivers/net/phy/broadcom.c
++++ b/drivers/net/phy/broadcom.c
+@@ -30,6 +30,50 @@ MODULE_DESCRIPTION("Broadcom PHY driver"
+ MODULE_AUTHOR("Maciej W. Rozycki");
+ MODULE_LICENSE("GPL");
+ 
++static int bcm54210e_config_init(struct phy_device *phydev)
++{
++	int val;
++
++	val = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
++	val &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
++	val |= MII_BCM54XX_AUXCTL_MISC_WREN;
++	bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC, val);
++
++	val = bcm_phy_read_shadow(phydev, BCM54810_SHD_CLK_CTL);
++	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
++	bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
++
++	return 0;
++}
++
++static int bcm54612e_config_init(struct phy_device *phydev)
++{
++	/* Clear TX internal delay unless requested. */
++	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
++	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
++		/* Disable TXD to GTXCLK clock delay (default set) */
++		/* Bit 9 is the only field in shadow register 00011 */
++		bcm_phy_write_shadow(phydev, 0x03, 0);
++	}
++
++	/* Clear RX internal delay unless requested. */
++	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
++	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
++		u16 reg;
++
++		reg = bcm54xx_auxctl_read(phydev,
++					  MII_BCM54XX_AUXCTL_SHDWSEL_MISC);
++		/* Disable RXD to RXC delay (default set) */
++		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN;
++		/* Clear shadow selector field */
++		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
++		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
++				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
++	}
++
++	return 0;
++}
++
+ static int bcm54810_config(struct phy_device *phydev)
+ {
+ 	int rc, val;
+@@ -230,7 +274,15 @@ static int bcm54xx_config_init(struct ph
+ 	    (phydev->dev_flags & PHY_BRCM_AUTO_PWRDWN_ENABLE))
+ 		bcm54xx_adjust_rxrefclk(phydev);
+ 
+-	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
++	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54210E) {
++		err = bcm54210e_config_init(phydev);
++		if (err)
++			return err;
++	} else if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54612E) {
++		err = bcm54612e_config_init(phydev);
++		if (err)
++			return err;
++	} else if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54810) {
+ 		err = bcm54810_config(phydev);
+ 		if (err)
+ 			return err;
+@@ -375,41 +427,6 @@ static int bcm5481_config_aneg(struct ph
+ 	return ret;
+ }
+ 
+-static int bcm54612e_config_aneg(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	/* First, auto-negotiate. */
+-	ret = genphy_config_aneg(phydev);
+-
+-	/* Clear TX internal delay unless requested. */
+-	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
+-	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)) {
+-		/* Disable TXD to GTXCLK clock delay (default set) */
+-		/* Bit 9 is the only field in shadow register 00011 */
+-		bcm_phy_write_shadow(phydev, 0x03, 0);
+-	}
+-
+-	/* Clear RX internal delay unless requested. */
+-	if ((phydev->interface != PHY_INTERFACE_MODE_RGMII_ID) &&
+-	    (phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)) {
+-		u16 reg;
+-
+-		/* Errata: reads require filling in the write selector field */
+-		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
+-				     MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC);
+-		reg = phy_read(phydev, MII_BCM54XX_AUX_CTL);
+-		/* Disable RXD to RXC delay (default set) */
+-		reg &= ~MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW;
+-		/* Clear shadow selector field */
+-		reg &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MASK;
+-		bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC,
+-				     MII_BCM54XX_AUXCTL_MISC_WREN | reg);
+-	}
+-
+-	return ret;
+-}
+-
+ static int brcm_phy_setbits(struct phy_device *phydev, int reg, int set)
+ {
+ 	int val;
+@@ -548,6 +565,19 @@ static struct phy_driver broadcom_driver
+ 	.config_intr	= bcm_phy_config_intr,
+ 	.driver		= { .owner = THIS_MODULE },
+ }, {
++	.phy_id		= PHY_ID_BCM54210E,
++	.phy_id_mask	= 0xfffffff0,
++	.name		= "Broadcom BCM54210E",
++	.features	= PHY_GBIT_FEATURES |
++			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
++	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
++	.config_init	= bcm54xx_config_init,
++	.config_aneg	= genphy_config_aneg,
++	.read_status	= genphy_read_status,
++	.ack_interrupt	= bcm_phy_ack_intr,
++	.config_intr	= bcm_phy_config_intr,
++	.driver		= { .owner = THIS_MODULE },
++}, {
+ 	.phy_id		= PHY_ID_BCM5461,
+ 	.phy_id_mask	= 0xfffffff0,
+ 	.name		= "Broadcom BCM5461",
+@@ -568,7 +598,7 @@ static struct phy_driver broadcom_driver
+ 			  SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+ 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+ 	.config_init	= bcm54xx_config_init,
+-	.config_aneg	= bcm54612e_config_aneg,
++	.config_aneg	= genphy_config_aneg,
+ 	.read_status	= genphy_read_status,
+ 	.ack_interrupt	= bcm_phy_ack_intr,
+ 	.config_intr	= bcm_phy_config_intr,
+@@ -708,6 +738,7 @@ module_phy_driver(broadcom_drivers);
+ static struct mdio_device_id __maybe_unused broadcom_tbl[] = {
+ 	{ PHY_ID_BCM5411, 0xfffffff0 },
+ 	{ PHY_ID_BCM5421, 0xfffffff0 },
++	{ PHY_ID_BCM54210E, 0xfffffff0 },
+ 	{ PHY_ID_BCM5461, 0xfffffff0 },
+ 	{ PHY_ID_BCM54612E, 0xfffffff0 },
+ 	{ PHY_ID_BCM54616S, 0xfffffff0 },
+--- a/include/linux/brcmphy.h
++++ b/include/linux/brcmphy.h
+@@ -17,6 +17,7 @@
+ #define PHY_ID_BCM5482			0x0143bcb0
+ #define PHY_ID_BCM5411			0x00206070
+ #define PHY_ID_BCM5421			0x002060e0
++#define PHY_ID_BCM54210E		0x600d84a0
+ #define PHY_ID_BCM5464			0x002060b0
+ #define PHY_ID_BCM5461			0x002060c0
+ #define PHY_ID_BCM54612E		0x03625e60
+@@ -24,6 +25,7 @@
+ #define PHY_ID_BCM57780			0x03625d90
+ 
+ #define PHY_ID_BCM7250			0xae025280
++#define PHY_ID_BCM7278			0xae0251a0
+ #define PHY_ID_BCM7364			0xae025260
+ #define PHY_ID_BCM7366			0x600d8490
+ #define PHY_ID_BCM7346			0x600d8650
+@@ -103,18 +105,17 @@
+ /*
+  * AUXILIARY CONTROL SHADOW ACCESS REGISTERS.  (PHY REG 0x18)
+  */
+-#define MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL	0x0000
++#define MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL	0x00
+ #define MII_BCM54XX_AUXCTL_ACTL_TX_6DB		0x0400
+ #define MII_BCM54XX_AUXCTL_ACTL_SMDSP_ENA	0x0800
+ 
+-#define MII_BCM54XX_AUXCTL_MISC_WREN	0x8000
+-#define MII_BCM54XX_AUXCTL_MISC_RXD_RXC_SKEW	0x0100
+-#define MII_BCM54XX_AUXCTL_MISC_FORCE_AMDIX	0x0200
+-#define MII_BCM54XX_AUXCTL_MISC_RDSEL_MISC	0x7000
+-#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC	0x0007
+-#define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
+-#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN	(1 << 8)
++#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC			0x07
++#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_WIRESPEED_EN	0x0010
++#define MII_BCM54XX_AUXCTL_SHDWSEL_MISC_RGMII_SKEW_EN	0x0100
++#define MII_BCM54XX_AUXCTL_MISC_FORCE_AMDIX		0x0200
++#define MII_BCM54XX_AUXCTL_MISC_WREN			0x8000
+ 
++#define MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT	12
+ #define MII_BCM54XX_AUXCTL_SHDWSEL_MASK	0x0007
+ 
+ /*
diff --git a/target/linux/generic/pending-4.4/078-0006-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch b/target/linux/generic/pending-4.4/078-0006-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
new file mode 100644
index 0000000000..c39995da7b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/078-0006-net-phy-cherry-pick-Broadcom-drivers-updates-from-v4.patch
@@ -0,0 +1,37 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH] net: phy: cherry-pick Broadcom drivers updates from v4.15
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This includes following upstream commits:
+2355a6546a05 net: phy: broadcom: support new device flag for setting master mode
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+
+--- a/drivers/net/phy/broadcom.c
++++ b/drivers/net/phy/broadcom.c
+@@ -43,6 +43,12 @@ static int bcm54210e_config_init(struct
+ 	val &= ~BCM54810_SHD_CLK_CTL_GTXCLK_EN;
+ 	bcm_phy_write_shadow(phydev, BCM54810_SHD_CLK_CTL, val);
+ 
++	if (phydev->dev_flags & PHY_BRCM_EN_MASTER_MODE) {
++		val = phy_read(phydev, MII_CTRL1000);
++		val |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;
++		phy_write(phydev, MII_CTRL1000, val);
++	}
++
+ 	return 0;
+ }
+ 
+--- a/include/linux/brcmphy.h
++++ b/include/linux/brcmphy.h
+@@ -59,6 +59,7 @@
+ #define PHY_BRCM_EXT_IBND_TX_ENABLE	0x00002000
+ #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
+ #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
++#define PHY_BRCM_EN_MASTER_MODE		0x00010000
+ 
+ /* Broadcom BCM7xxx specific workarounds */
+ #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
diff --git a/target/linux/generic/pending-4.4/080-spi-introduce-accelerated-read-support-for-spi-flash.patch b/target/linux/generic/pending-4.4/080-spi-introduce-accelerated-read-support-for-spi-flash.patch
new file mode 100644
index 0000000000..5e116b0bbf
--- /dev/null
+++ b/target/linux/generic/pending-4.4/080-spi-introduce-accelerated-read-support-for-spi-flash.patch
@@ -0,0 +1,179 @@
+From 556351f14e74db4cd3ddde386457edce7bf0b27f Mon Sep 17 00:00:00 2001
+From: Vignesh R <vigneshr@ti.com>
+Date: Fri, 11 Dec 2015 09:39:56 +0530
+Subject: [PATCH] spi: introduce accelerated read support for spi flash devices
+
+In addition to providing direct access to SPI bus, some spi controller
+hardwares (like ti-qspi) provide special port (like memory mapped port)
+that are optimized to improve SPI flash read performance.
+This means the controller can automatically send the SPI signals
+required to read data from the SPI flash device.
+For this, SPI controller needs to know flash specific information like
+read command to use, dummy bytes and address width.
+
+Introduce spi_flash_read() interface to support accelerated read
+over SPI flash devices. SPI master drivers can implement this callback to
+support interfaces such as memory mapped read etc. m25p80 flash driver
+and other flash drivers can call this make use of such interfaces. The
+interface should only be used with SPI flashes and cannot be used with
+other SPI devices.
+
+Signed-off-by: Vignesh R <vigneshr@ti.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+
+--- a/drivers/spi/spi.c
++++ b/drivers/spi/spi.c
+@@ -1135,6 +1135,7 @@ static void __spi_pump_messages(struct s
+ 		}
+ 	}
+ 
++	mutex_lock(&master->bus_lock_mutex);
+ 	trace_spi_message_start(master->cur_msg);
+ 
+ 	if (master->prepare_message) {
+@@ -1144,6 +1145,7 @@ static void __spi_pump_messages(struct s
+ 				"failed to prepare message: %d\n", ret);
+ 			master->cur_msg->status = ret;
+ 			spi_finalize_current_message(master);
++			mutex_unlock(&master->bus_lock_mutex);
+ 			return;
+ 		}
+ 		master->cur_msg_prepared = true;
+@@ -1153,6 +1155,7 @@ static void __spi_pump_messages(struct s
+ 	if (ret) {
+ 		master->cur_msg->status = ret;
+ 		spi_finalize_current_message(master);
++		mutex_unlock(&master->bus_lock_mutex);
+ 		return;
+ 	}
+ 
+@@ -1160,8 +1163,10 @@ static void __spi_pump_messages(struct s
+ 	if (ret) {
+ 		dev_err(&master->dev,
+ 			"failed to transfer one message from queue\n");
++		mutex_unlock(&master->bus_lock_mutex);
+ 		return;
+ 	}
++	mutex_unlock(&master->bus_lock_mutex);
+ }
+ 
+ /**
+@@ -2329,6 +2334,46 @@ int spi_async_locked(struct spi_device *
+ EXPORT_SYMBOL_GPL(spi_async_locked);
+ 
+ 
++int spi_flash_read(struct spi_device *spi,
++		   struct spi_flash_read_message *msg)
++
++{
++	struct spi_master *master = spi->master;
++	int ret;
++
++	if ((msg->opcode_nbits == SPI_NBITS_DUAL ||
++	     msg->addr_nbits == SPI_NBITS_DUAL) &&
++	    !(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
++		return -EINVAL;
++	if ((msg->opcode_nbits == SPI_NBITS_QUAD ||
++	     msg->addr_nbits == SPI_NBITS_QUAD) &&
++	    !(spi->mode & SPI_TX_QUAD))
++		return -EINVAL;
++	if (msg->data_nbits == SPI_NBITS_DUAL &&
++	    !(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
++		return -EINVAL;
++	if (msg->data_nbits == SPI_NBITS_QUAD &&
++	    !(spi->mode &  SPI_RX_QUAD))
++		return -EINVAL;
++
++	if (master->auto_runtime_pm) {
++		ret = pm_runtime_get_sync(master->dev.parent);
++		if (ret < 0) {
++			dev_err(&master->dev, "Failed to power device: %d\n",
++				ret);
++			return ret;
++		}
++	}
++	mutex_lock(&master->bus_lock_mutex);
++	ret = master->spi_flash_read(spi, msg);
++	mutex_unlock(&master->bus_lock_mutex);
++	if (master->auto_runtime_pm)
++		pm_runtime_put(master->dev.parent);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(spi_flash_read);
++
+ /*-------------------------------------------------------------------------*/
+ 
+ /* Utility methods for SPI master protocol drivers, layered on
+--- a/include/linux/spi/spi.h
++++ b/include/linux/spi/spi.h
+@@ -25,6 +25,7 @@
+ struct dma_chan;
+ struct spi_master;
+ struct spi_transfer;
++struct spi_flash_read_message;
+ 
+ /*
+  * INTERFACES between SPI master-side drivers and SPI infrastructure.
+@@ -361,6 +362,8 @@ static inline void spi_unregister_driver
+  * @handle_err: the subsystem calls the driver to handle an error that occurs
+  *		in the generic implementation of transfer_one_message().
+  * @unprepare_message: undo any work done by prepare_message().
++ * @spi_flash_read: to support spi-controller hardwares that provide
++ *                  accelerated interface to read from flash devices.
+  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
+  *	number. Any individual value may be -ENOENT for CS lines that
+  *	are not GPIOs (driven by the SPI controller itself).
+@@ -507,6 +510,8 @@ struct spi_master {
+ 			       struct spi_message *message);
+ 	int (*unprepare_message)(struct spi_master *master,
+ 				 struct spi_message *message);
++	int (*spi_flash_read)(struct  spi_device *spi,
++			      struct spi_flash_read_message *msg);
+ 
+ 	/*
+ 	 * These hooks are for drivers that use a generic implementation
+@@ -999,6 +1004,42 @@ static inline ssize_t spi_w8r16be(struct
+ 	return be16_to_cpu(result);
+ }
+ 
++/**
++ * struct spi_flash_read_message - flash specific information for
++ * spi-masters that provide accelerated flash read interfaces
++ * @buf: buffer to read data
++ * @from: offset within the flash from where data is to be read
++ * @len: length of data to be read
++ * @retlen: actual length of data read
++ * @read_opcode: read_opcode to be used to communicate with flash
++ * @addr_width: number of address bytes
++ * @dummy_bytes: number of dummy bytes
++ * @opcode_nbits: number of lines to send opcode
++ * @addr_nbits: number of lines to send address
++ * @data_nbits: number of lines for data
++ */
++struct spi_flash_read_message {
++	void *buf;
++	loff_t from;
++	size_t len;
++	size_t retlen;
++	u8 read_opcode;
++	u8 addr_width;
++	u8 dummy_bytes;
++	u8 opcode_nbits;
++	u8 addr_nbits;
++	u8 data_nbits;
++};
++
++/* SPI core interface for flash read support */
++static inline bool spi_flash_read_supported(struct spi_device *spi)
++{
++	return spi->master->spi_flash_read ? true : false;
++}
++
++int spi_flash_read(struct spi_device *spi,
++		   struct spi_flash_read_message *msg);
++
+ /*---------------------------------------------------------------------------*/
+ 
+ /*
diff --git a/target/linux/generic/pending-4.4/081-spi-bcm53xx-add-spi_flash_read-callback-for-MMIO-bas.patch b/target/linux/generic/pending-4.4/081-spi-bcm53xx-add-spi_flash_read-callback-for-MMIO-bas.patch
new file mode 100644
index 0000000000..730f41e4a5
--- /dev/null
+++ b/target/linux/generic/pending-4.4/081-spi-bcm53xx-add-spi_flash_read-callback-for-MMIO-bas.patch
@@ -0,0 +1,157 @@
+From a7b221d8f0d75511c5f959584712a5dd35f88a86 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Mon, 18 Apr 2016 14:39:30 +0200
+Subject: [PATCH] spi: bcm53xx: add spi_flash_read callback for MMIO-based
+ reads
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This implements more efficient reads of SPI-attached flash content.
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+
+--- a/drivers/spi/spi-bcm53xx.c
++++ b/drivers/spi/spi-bcm53xx.c
+@@ -10,6 +10,7 @@
+ #include "spi-bcm53xx.h"
+ 
+ #define BCM53XXSPI_MAX_SPI_BAUD	13500000	/* 216 MHz? */
++#define BCM53XXSPI_FLASH_WINDOW	SZ_32M
+ 
+ /* The longest observed required wait was 19 ms */
+ #define BCM53XXSPI_SPE_TIMEOUT_MS	80
+@@ -17,8 +18,10 @@
+ struct bcm53xxspi {
+ 	struct bcma_device *core;
+ 	struct spi_master *master;
++	void __iomem *mmio_base;
+ 
+ 	size_t read_offset;
++	bool bspi;				/* Boot SPI mode with memory mapping */
+ };
+ 
+ static inline u32 bcm53xxspi_read(struct bcm53xxspi *b53spi, u16 offset)
+@@ -32,6 +35,50 @@ static inline void bcm53xxspi_write(stru
+ 	bcma_write32(b53spi->core, offset, value);
+ }
+ 
++static void bcm53xxspi_disable_bspi(struct bcm53xxspi *b53spi)
++{
++	struct device *dev = &b53spi->core->dev;
++	unsigned long deadline;
++	u32 tmp;
++
++	if (!b53spi->bspi)
++		return;
++
++	tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL);
++	if (tmp & 0x1)
++		return;
++
++	deadline = jiffies + usecs_to_jiffies(200);
++	do {
++		tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_BUSY_STATUS);
++		if (!(tmp & 0x1)) {
++			bcm53xxspi_write(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL,
++					 0x1);
++			ndelay(200);
++			b53spi->bspi = false;
++			return;
++		}
++		udelay(1);
++	} while (!time_after_eq(jiffies, deadline));
++
++	dev_warn(dev, "Timeout disabling BSPI\n");
++}
++
++static void bcm53xxspi_enable_bspi(struct bcm53xxspi *b53spi)
++{
++	u32 tmp;
++
++	if (b53spi->bspi)
++		return;
++
++	tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL);
++	if (!(tmp & 0x1))
++		return;
++
++	bcm53xxspi_write(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL, 0x0);
++	b53spi->bspi = true;
++}
++
+ static inline unsigned int bcm53xxspi_calc_timeout(size_t len)
+ {
+ 	/* Do some magic calculation based on length and buad. Add 10% and 1. */
+@@ -176,6 +223,8 @@ static int bcm53xxspi_transfer_one(struc
+ 	u8 *buf;
+ 	size_t left;
+ 
++	bcm53xxspi_disable_bspi(b53spi);
++
+ 	if (t->tx_buf) {
+ 		buf = (u8 *)t->tx_buf;
+ 		left = t->len;
+@@ -206,6 +255,22 @@ static int bcm53xxspi_transfer_one(struc
+ 	return 0;
+ }
+ 
++static int bcm53xxspi_flash_read(struct spi_device *spi,
++				 struct spi_flash_read_message *msg)
++{
++	struct bcm53xxspi *b53spi = spi_master_get_devdata(spi->master);
++	int ret = 0;
++
++	if (msg->from + msg->len > BCM53XXSPI_FLASH_WINDOW)
++		return -EINVAL;
++
++	bcm53xxspi_enable_bspi(b53spi);
++	memcpy_fromio(msg->buf, b53spi->mmio_base + msg->from, msg->len);
++	msg->retlen = msg->len;
++
++	return ret;
++}
++
+ /**************************************************
+  * BCMA
+  **************************************************/
+@@ -222,6 +287,7 @@ MODULE_DEVICE_TABLE(bcma, bcm53xxspi_bcm
+ 
+ static int bcm53xxspi_bcma_probe(struct bcma_device *core)
+ {
++	struct device *dev = &core->dev;
+ 	struct bcm53xxspi *b53spi;
+ 	struct spi_master *master;
+ 	int err;
+@@ -231,7 +297,7 @@ static int bcm53xxspi_bcma_probe(struct
+ 		return -ENOTSUPP;
+ 	}
+ 
+-	master = spi_alloc_master(&core->dev, sizeof(*b53spi));
++	master = spi_alloc_master(dev, sizeof(*b53spi));
+ 	if (!master)
+ 		return -ENOMEM;
+ 
+@@ -239,11 +305,19 @@ static int bcm53xxspi_bcma_probe(struct
+ 	b53spi->master = master;
+ 	b53spi->core = core;
+ 
++	if (core->addr_s[0])
++		b53spi->mmio_base = devm_ioremap(dev, core->addr_s[0],
++						 BCM53XXSPI_FLASH_WINDOW);
++	b53spi->bspi = true;
++	bcm53xxspi_disable_bspi(b53spi);
++
+ 	master->transfer_one = bcm53xxspi_transfer_one;
++	if (b53spi->mmio_base)
++		master->spi_flash_read = bcm53xxspi_flash_read;
+ 
+ 	bcma_set_drvdata(core, b53spi);
+ 
+-	err = devm_spi_register_master(&core->dev, master);
++	err = devm_spi_register_master(dev, master);
+ 	if (err) {
+ 		spi_master_put(master);
+ 		bcma_set_drvdata(core, NULL);
diff --git a/target/linux/generic/pending-4.4/082-0001-USB-core-let-USB-device-know-device-node.patch b/target/linux/generic/pending-4.4/082-0001-USB-core-let-USB-device-know-device-node.patch
new file mode 100644
index 0000000000..901cdf7e83
--- /dev/null
+++ b/target/linux/generic/pending-4.4/082-0001-USB-core-let-USB-device-know-device-node.patch
@@ -0,0 +1,179 @@
+From 69bec725985324e79b1c47ea287815ac4ddb0521 Mon Sep 17 00:00:00 2001
+From: Peter Chen <peter.chen@freescale.com>
+Date: Fri, 19 Feb 2016 17:26:15 +0800
+Subject: [PATCH] USB: core: let USB device know device node
+
+Although most of USB devices are hot-plug's, there are still some devices
+are hard wired on the board, eg, for HSIC and SSIC interface USB devices.
+If these kinds of USB devices are multiple functions, and they can supply
+other interfaces like i2c, gpios for other devices, we may need to
+describe these at device tree.
+
+In this commit, it uses "reg" in dts as physical port number to match
+the phyiscal port number decided by USB core, if they are the same,
+then the device node is for the device we are creating for USB core.
+
+Signed-off-by: Peter Chen <peter.chen@freescale.com>
+Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
+Acked-by: Alan Stern <stern@rowland.harvard.edu>
+Acked-by: Rob Herring <robh@kernel.org>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ .../devicetree/bindings/usb/usb-device.txt         | 28 +++++++++++++
+ drivers/usb/core/Makefile                          |  2 +-
+ drivers/usb/core/of.c                              | 47 ++++++++++++++++++++++
+ drivers/usb/core/usb.c                             | 10 +++++
+ include/linux/usb/of.h                             |  7 ++++
+ 5 files changed, 93 insertions(+), 1 deletion(-)
+ create mode 100644 Documentation/devicetree/bindings/usb/usb-device.txt
+ create mode 100644 drivers/usb/core/of.c
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/usb/usb-device.txt
+@@ -0,0 +1,28 @@
++Generic USB Device Properties
++
++Usually, we only use device tree for hard wired USB device.
++The reference binding doc is from:
++http://www.firmware.org/1275/bindings/usb/usb-1_0.ps
++
++Required properties:
++- compatible: usbVID,PID. The textual representation of VID, PID shall
++  be in lower case hexadecimal with leading zeroes suppressed. The
++  other compatible strings from the above standard binding could also
++  be used, but a device adhering to this binding may leave out all except
++  for usbVID,PID.
++- reg: the port number which this device is connecting to, the range
++  is 1-31.
++
++Example:
++
++&usb1 {
++	status = "okay";
++
++	#address-cells = <1>;
++	#size-cells = <0>;
++
++	hub: genesys@1 {
++		compatible = "usb5e3,608";
++		reg = <1>;
++	};
++}
+--- a/drivers/usb/core/Makefile
++++ b/drivers/usb/core/Makefile
+@@ -5,7 +5,7 @@
+ usbcore-y := usb.o hub.o hcd.o urb.o message.o driver.o
+ usbcore-y += config.o file.o buffer.o sysfs.o endpoint.o
+ usbcore-y += devio.o notify.o generic.o quirks.o devices.o
+-usbcore-y += port.o
++usbcore-y += port.o of.o
+ 
+ usbcore-$(CONFIG_PCI)		+= hcd-pci.o
+ usbcore-$(CONFIG_ACPI)		+= usb-acpi.o
+--- /dev/null
++++ b/drivers/usb/core/of.c
+@@ -0,0 +1,47 @@
++/*
++ * of.c		The helpers for hcd device tree support
++ *
++ * Copyright (C) 2016 Freescale Semiconductor, Inc.
++ * Author: Peter Chen <peter.chen@freescale.com>
++ *
++ * This program is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2  of
++ * the License as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/of.h>
++
++/**
++ * usb_of_get_child_node - Find the device node match port number
++ * @parent: the parent device node
++ * @portnum: the port number which device is connecting
++ *
++ * Find the node from device tree according to its port number.
++ *
++ * Return: On success, a pointer to the device node, %NULL on failure.
++ */
++struct device_node *usb_of_get_child_node(struct device_node *parent,
++					int portnum)
++{
++	struct device_node *node;
++	u32 port;
++
++	for_each_child_of_node(parent, node) {
++		if (!of_property_read_u32(node, "reg", &port)) {
++			if (port == portnum)
++				return node;
++		}
++	}
++
++	return NULL;
++}
++EXPORT_SYMBOL_GPL(usb_of_get_child_node);
++
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -36,6 +36,7 @@
+ #include <linux/mutex.h>
+ #include <linux/workqueue.h>
+ #include <linux/debugfs.h>
++#include <linux/usb/of.h>
+ 
+ #include <asm/io.h>
+ #include <linux/scatterlist.h>
+@@ -469,6 +470,7 @@ struct usb_device *usb_alloc_dev(struct
+ 		dev->route = 0;
+ 
+ 		dev->dev.parent = bus->controller;
++		dev->dev.of_node = bus->controller->of_node;
+ 		dev_set_name(&dev->dev, "usb%d", bus->busnum);
+ 		root_hub = 1;
+ 	} else {
+@@ -493,6 +495,14 @@ struct usb_device *usb_alloc_dev(struct
+ 		dev->dev.parent = &parent->dev;
+ 		dev_set_name(&dev->dev, "%d-%s", bus->busnum, dev->devpath);
+ 
++		if (!parent->parent) {
++			/* device under root hub's port */
++			port1 = usb_hcd_find_raw_port_number(usb_hcd,
++				port1);
++		}
++		dev->dev.of_node = usb_of_get_child_node(parent->dev.of_node,
++				port1);
++
+ 		/* hub driver sets up TT records */
+ 	}
+ 
+--- a/include/linux/usb/of.h
++++ b/include/linux/usb/of.h
+@@ -15,6 +15,8 @@
+ bool of_usb_host_tpl_support(struct device_node *np);
+ int of_usb_update_otg_caps(struct device_node *np,
+ 			struct usb_otg_caps *otg_caps);
++struct device_node *usb_of_get_child_node(struct device_node *parent,
++			int portnum);
+ #else
+ static inline bool of_usb_host_tpl_support(struct device_node *np)
+ {
+@@ -25,6 +27,11 @@ static inline int of_usb_update_otg_caps
+ {
+ 	return 0;
+ }
++static inline struct device_node *usb_of_get_child_node
++		(struct device_node *parent, int portnum)
++{
++	return NULL;
++}
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_USB_SUPPORT)
diff --git a/target/linux/generic/pending-4.4/082-0002-usb-core-usb_alloc_dev-fix-setting-of-portnum.patch b/target/linux/generic/pending-4.4/082-0002-usb-core-usb_alloc_dev-fix-setting-of-portnum.patch
new file mode 100644
index 0000000000..15cf4cae56
--- /dev/null
+++ b/target/linux/generic/pending-4.4/082-0002-usb-core-usb_alloc_dev-fix-setting-of-portnum.patch
@@ -0,0 +1,108 @@
+From 7222c832254a75dcd67d683df75753d4a4e125bb Mon Sep 17 00:00:00 2001
+From: Nicolai Stange <nicstange@gmail.com>
+Date: Thu, 17 Mar 2016 23:53:02 +0100
+Subject: [PATCH] usb/core: usb_alloc_dev(): fix setting of ->portnum
+
+With commit 69bec7259853 ("USB: core: let USB device know device node"),
+the port1 argument of usb_alloc_dev() gets overwritten as follows:
+
+  ... usb_alloc_dev(..., unsigned port1)
+  {
+    ...
+    if (!parent->parent) {
+      port1 = usb_hcd_find_raw_port_number(..., port1);
+    }
+    ...
+  }
+
+Later on, this now overwritten port1 gets assigned to ->portnum:
+
+  dev->portnum = port1;
+
+However, since xhci_find_raw_port_number() isn't idempotent, the
+aforementioned commit causes a number of KASAN splats like the following:
+
+  BUG: KASAN: slab-out-of-bounds in xhci_find_raw_port_number+0x98/0x170
+                                       at addr ffff8801d9311670
+  Read of size 8 by task kworker/2:1/87
+  [...]
+  Workqueue: usb_hub_wq hub_event
+   0000000000000188 000000005814b877 ffff8800cba17588 ffffffff8191447e
+   0000000041b58ab3 ffffffff82a03209 ffffffff819143a2 ffffffff82a252f4
+   ffff8801d93115e0 0000000000000188 ffff8801d9311628 ffff8800cba17588
+  Call Trace:
+   [<ffffffff8191447e>] dump_stack+0xdc/0x15e
+   [<ffffffff819143a2>] ? _atomic_dec_and_lock+0xa2/0xa2
+   [<ffffffff814e2cd1>] ? print_section+0x61/0xb0
+   [<ffffffff814e4939>] print_trailer+0x179/0x2c0
+   [<ffffffff814f0d84>] object_err+0x34/0x40
+   [<ffffffff814f4388>] kasan_report_error+0x2f8/0x8b0
+   [<ffffffff814eb91e>] ? __slab_alloc+0x5e/0x90
+   [<ffffffff812178c0>] ? __lock_is_held+0x90/0x130
+   [<ffffffff814f5091>] kasan_report+0x71/0xa0
+   [<ffffffff814ec082>] ? kmem_cache_alloc_trace+0x212/0x560
+   [<ffffffff81d99468>] ? xhci_find_raw_port_number+0x98/0x170
+   [<ffffffff814f33d4>] __asan_load8+0x64/0x70
+   [<ffffffff81d99468>] xhci_find_raw_port_number+0x98/0x170
+   [<ffffffff81db0105>] xhci_setup_addressable_virt_dev+0x235/0xa10
+   [<ffffffff81d9ea51>] xhci_setup_device+0x3c1/0x1430
+   [<ffffffff8121cddd>] ? trace_hardirqs_on+0xd/0x10
+   [<ffffffff81d9fac0>] ? xhci_setup_device+0x1430/0x1430
+   [<ffffffff81d9fad3>] xhci_address_device+0x13/0x20
+   [<ffffffff81d2081a>] hub_port_init+0x55a/0x1550
+   [<ffffffff81d28705>] hub_event+0xef5/0x24d0
+   [<ffffffff81d27810>] ? hub_port_debounce+0x2f0/0x2f0
+   [<ffffffff8195e1ee>] ? debug_object_deactivate+0x1be/0x270
+   [<ffffffff81210203>] ? print_rt_rq+0x53/0x2d0
+   [<ffffffff8121657d>] ? trace_hardirqs_off+0xd/0x10
+   [<ffffffff8226acfb>] ? _raw_spin_unlock_irqrestore+0x5b/0x60
+   [<ffffffff81250000>] ? irq_domain_set_hwirq_and_chip+0x30/0xb0
+   [<ffffffff81256339>] ? debug_lockdep_rcu_enabled+0x39/0x40
+   [<ffffffff812178c0>] ? __lock_is_held+0x90/0x130
+   [<ffffffff81196877>] process_one_work+0x567/0xec0
+  [...]
+
+Afterwards, xhci reports some functional errors:
+
+  xhci_hcd 0000:00:14.0: ERROR: unexpected setup address command completion
+                                code 0x11.
+  xhci_hcd 0000:00:14.0: ERROR: unexpected setup address command completion
+                                code 0x11.
+  usb 4-3: device not accepting address 2, error -22
+
+Fix this by not overwriting the port1 argument in usb_alloc_dev(), but
+storing the raw port number as required by OF in an additional variable,
+raw_port.
+
+Fixes: 69bec7259853 ("USB: core: let USB device know device node")
+Signed-off-by: Nicolai Stange <nicstange@gmail.com>
+Acked-by: Alan Stern <stern@rowland.harvard.edu>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/usb.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -423,6 +423,7 @@ struct usb_device *usb_alloc_dev(struct
+ 	struct usb_device *dev;
+ 	struct usb_hcd *usb_hcd = bus_to_hcd(bus);
+ 	unsigned root_hub = 0;
++	unsigned raw_port = port1;
+ 
+ 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+ 	if (!dev)
+@@ -497,11 +498,11 @@ struct usb_device *usb_alloc_dev(struct
+ 
+ 		if (!parent->parent) {
+ 			/* device under root hub's port */
+-			port1 = usb_hcd_find_raw_port_number(usb_hcd,
++			raw_port = usb_hcd_find_raw_port_number(usb_hcd,
+ 				port1);
+ 		}
+ 		dev->dev.of_node = usb_of_get_child_node(parent->dev.of_node,
+-				port1);
++				raw_port);
+ 
+ 		/* hub driver sets up TT records */
+ 	}
diff --git a/target/linux/generic/pending-4.4/083-0001-clk-Add-devm_-clk_hw_-register-unregister-APIs.patch b/target/linux/generic/pending-4.4/083-0001-clk-Add-devm_-clk_hw_-register-unregister-APIs.patch
new file mode 100644
index 0000000000..0408353138
--- /dev/null
+++ b/target/linux/generic/pending-4.4/083-0001-clk-Add-devm_-clk_hw_-register-unregister-APIs.patch
@@ -0,0 +1,182 @@
+From 4143804c4fdef40358c654d1fb2271a1a0f1fedf Mon Sep 17 00:00:00 2001
+From: Stephen Boyd <sboyd@codeaurora.org>
+Date: Fri, 5 Feb 2016 17:02:52 -0800
+Subject: [PATCH] clk: Add {devm_}clk_hw_{register,unregister}() APIs
+
+We've largely split the clk consumer and provider APIs along
+struct clk and struct clk_hw, but clk_register() still returns a
+struct clk pointer for each struct clk_hw that's registered.
+Eventually we'd like to only allocate struct clks when there's a
+user, because struct clk is per-user now, so clk_register() needs
+to change.
+
+Let's add new APIs to register struct clk_hws, but this time
+we'll hide the struct clk from the caller by returning an int
+error code. Also add an unregistration API that takes the clk_hw
+structure that was passed to the registration API. This way
+provider drivers never have to deal with a struct clk pointer
+unless they're using the clk consumer APIs.
+
+Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
+---
+ Documentation/driver-model/devres.txt |  1 +
+ drivers/clk/clk.c                     | 86 +++++++++++++++++++++++++++++++++++
+ include/linux/clk-provider.h          |  6 +++
+ 3 files changed, 93 insertions(+)
+
+--- a/Documentation/driver-model/devres.txt
++++ b/Documentation/driver-model/devres.txt
+@@ -236,6 +236,7 @@ certainly invest a bit more effort into
+ CLOCK
+   devm_clk_get()
+   devm_clk_put()
++  devm_clk_hw_register()
+ 
+ DMA
+   dmam_alloc_coherent()
+--- a/drivers/clk/clk.c
++++ b/drivers/clk/clk.c
+@@ -2595,6 +2595,22 @@ fail_out:
+ }
+ EXPORT_SYMBOL_GPL(clk_register);
+ 
++/**
++ * clk_hw_register - register a clk_hw and return an error code
++ * @dev: device that is registering this clock
++ * @hw: link to hardware-specific clock data
++ *
++ * clk_hw_register is the primary interface for populating the clock tree with
++ * new clock nodes. It returns an integer equal to zero indicating success or
++ * less than zero indicating failure. Drivers must test for an error code after
++ * calling clk_hw_register().
++ */
++int clk_hw_register(struct device *dev, struct clk_hw *hw)
++{
++	return PTR_ERR_OR_ZERO(clk_register(dev, hw));
++}
++EXPORT_SYMBOL_GPL(clk_hw_register);
++
+ /* Free memory allocated for a clock. */
+ static void __clk_release(struct kref *ref)
+ {
+@@ -2696,11 +2712,26 @@ void clk_unregister(struct clk *clk)
+ }
+ EXPORT_SYMBOL_GPL(clk_unregister);
+ 
++/**
++ * clk_hw_unregister - unregister a currently registered clk_hw
++ * @hw: hardware-specific clock data to unregister
++ */
++void clk_hw_unregister(struct clk_hw *hw)
++{
++	clk_unregister(hw->clk);
++}
++EXPORT_SYMBOL_GPL(clk_hw_unregister);
++
+ static void devm_clk_release(struct device *dev, void *res)
+ {
+ 	clk_unregister(*(struct clk **)res);
+ }
+ 
++static void devm_clk_hw_release(struct device *dev, void *res)
++{
++	clk_hw_unregister(*(struct clk_hw **)res);
++}
++
+ /**
+  * devm_clk_register - resource managed clk_register()
+  * @dev: device that is registering this clock
+@@ -2731,6 +2762,36 @@ struct clk *devm_clk_register(struct dev
+ }
+ EXPORT_SYMBOL_GPL(devm_clk_register);
+ 
++/**
++ * devm_clk_hw_register - resource managed clk_hw_register()
++ * @dev: device that is registering this clock
++ * @hw: link to hardware-specific clock data
++ *
++ * Managed clk_hw_register(). Clocks returned from this function are
++ * automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()
++ * for more information.
++ */
++int devm_clk_hw_register(struct device *dev, struct clk_hw *hw)
++{
++	struct clk_hw **hwp;
++	int ret;
++
++	hwp = devres_alloc(devm_clk_hw_release, sizeof(*hwp), GFP_KERNEL);
++	if (!hwp)
++		return -ENOMEM;
++
++	ret = clk_hw_register(dev, hw);
++	if (!ret) {
++		*hwp = hw;
++		devres_add(dev, hwp);
++	} else {
++		devres_free(hwp);
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(devm_clk_hw_register);
++
+ static int devm_clk_match(struct device *dev, void *res, void *data)
+ {
+ 	struct clk *c = res;
+@@ -2739,6 +2800,15 @@ static int devm_clk_match(struct device
+ 	return c == data;
+ }
+ 
++static int devm_clk_hw_match(struct device *dev, void *res, void *data)
++{
++	struct clk_hw *hw = res;
++
++	if (WARN_ON(!hw))
++		return 0;
++	return hw == data;
++}
++
+ /**
+  * devm_clk_unregister - resource managed clk_unregister()
+  * @clk: clock to unregister
+@@ -2753,6 +2823,22 @@ void devm_clk_unregister(struct device *
+ }
+ EXPORT_SYMBOL_GPL(devm_clk_unregister);
+ 
++/**
++ * devm_clk_hw_unregister - resource managed clk_hw_unregister()
++ * @dev: device that is unregistering the hardware-specific clock data
++ * @hw: link to hardware-specific clock data
++ *
++ * Unregister a clk_hw registered with devm_clk_hw_register(). Normally
++ * this function will not need to be called and the resource management
++ * code will ensure that the resource is freed.
++ */
++void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw)
++{
++	WARN_ON(devres_release(dev, devm_clk_hw_release, devm_clk_hw_match,
++				hw));
++}
++EXPORT_SYMBOL_GPL(devm_clk_hw_unregister);
++
+ /*
+  * clkdev helpers
+  */
+--- a/include/linux/clk-provider.h
++++ b/include/linux/clk-provider.h
+@@ -639,9 +639,15 @@ void of_gpio_mux_clk_setup(struct device
+ struct clk *clk_register(struct device *dev, struct clk_hw *hw);
+ struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw);
+ 
++int __must_check clk_hw_register(struct device *dev, struct clk_hw *hw);
++int __must_check devm_clk_hw_register(struct device *dev, struct clk_hw *hw);
++
+ void clk_unregister(struct clk *clk);
+ void devm_clk_unregister(struct device *dev, struct clk *clk);
+ 
++void clk_hw_unregister(struct clk_hw *hw);
++void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw);
++
+ /* helper functions */
+ const char *__clk_get_name(const struct clk *clk);
+ const char *clk_hw_get_name(const struct clk_hw *hw);
diff --git a/target/linux/generic/pending-4.4/083-0002-clk-Add-clk_hw-OF-clk-providers.patch b/target/linux/generic/pending-4.4/083-0002-clk-Add-clk_hw-OF-clk-providers.patch
new file mode 100644
index 0000000000..0bcb5bb805
--- /dev/null
+++ b/target/linux/generic/pending-4.4/083-0002-clk-Add-clk_hw-OF-clk-providers.patch
@@ -0,0 +1,234 @@
+From 0861e5b8cf80038e91942f1005c8dfce79d18c38 Mon Sep 17 00:00:00 2001
+From: Stephen Boyd <sboyd@codeaurora.org>
+Date: Fri, 5 Feb 2016 17:38:26 -0800
+Subject: [PATCH] clk: Add clk_hw OF clk providers
+
+Now that we have a clk registration API that doesn't return
+struct clks, we need to have some way to hand out struct clks via
+the clk_get() APIs that doesn't involve associating struct clk
+pointers with an OF node. Currently we ask the OF provider to
+give us a struct clk pointer for some clkspec, turn that struct
+clk into a struct clk_hw and then allocate a new struct clk to
+return to the caller.
+
+Let's add a clk_hw based OF provider hook that returns a struct
+clk_hw directly, so that we skip the intermediate step of
+converting from struct clk to struct clk_hw. Eventually when
+we've converted all OF clk providers to struct clk_hw based APIs
+we can remove the struct clk based ones.
+
+It should also be noted that we change the onecell provider to
+have a flex array instead of a pointer for the array of clk_hw
+pointers. This allows providers to allocate one structure of the
+correct length in one step instead of two.
+
+Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
+---
+ drivers/clk/clk.c            | 85 +++++++++++++++++++++++++++++++++++++++++---
+ include/linux/clk-provider.h | 30 ++++++++++++++++
+ 2 files changed, 111 insertions(+), 4 deletions(-)
+
+--- a/drivers/clk/clk.c
++++ b/drivers/clk/clk.c
+@@ -3001,6 +3001,7 @@ struct of_clk_provider {
+ 
+ 	struct device_node *node;
+ 	struct clk *(*get)(struct of_phandle_args *clkspec, void *data);
++	struct clk_hw *(*get_hw)(struct of_phandle_args *clkspec, void *data);
+ 	void *data;
+ };
+ 
+@@ -3017,6 +3018,12 @@ struct clk *of_clk_src_simple_get(struct
+ }
+ EXPORT_SYMBOL_GPL(of_clk_src_simple_get);
+ 
++struct clk_hw *of_clk_hw_simple_get(struct of_phandle_args *clkspec, void *data)
++{
++	return data;
++}
++EXPORT_SYMBOL_GPL(of_clk_hw_simple_get);
++
+ struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data)
+ {
+ 	struct clk_onecell_data *clk_data = data;
+@@ -3031,6 +3038,21 @@ struct clk *of_clk_src_onecell_get(struc
+ }
+ EXPORT_SYMBOL_GPL(of_clk_src_onecell_get);
+ 
++struct clk_hw *
++of_clk_hw_onecell_get(struct of_phandle_args *clkspec, void *data)
++{
++	struct clk_hw_onecell_data *hw_data = data;
++	unsigned int idx = clkspec->args[0];
++
++	if (idx >= hw_data->num) {
++		pr_err("%s: invalid index %u\n", __func__, idx);
++		return ERR_PTR(-EINVAL);
++	}
++
++	return hw_data->hws[idx];
++}
++EXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);
++
+ /**
+  * of_clk_add_provider() - Register a clock provider for a node
+  * @np: Device node pointer associated with clock provider
+@@ -3067,6 +3089,41 @@ int of_clk_add_provider(struct device_no
+ EXPORT_SYMBOL_GPL(of_clk_add_provider);
+ 
+ /**
++ * of_clk_add_hw_provider() - Register a clock provider for a node
++ * @np: Device node pointer associated with clock provider
++ * @get: callback for decoding clk_hw
++ * @data: context pointer for @get callback.
++ */
++int of_clk_add_hw_provider(struct device_node *np,
++			   struct clk_hw *(*get)(struct of_phandle_args *clkspec,
++						 void *data),
++			   void *data)
++{
++	struct of_clk_provider *cp;
++	int ret;
++
++	cp = kzalloc(sizeof(*cp), GFP_KERNEL);
++	if (!cp)
++		return -ENOMEM;
++
++	cp->node = of_node_get(np);
++	cp->data = data;
++	cp->get_hw = get;
++
++	mutex_lock(&of_clk_mutex);
++	list_add(&cp->link, &of_clk_providers);
++	mutex_unlock(&of_clk_mutex);
++	pr_debug("Added clk_hw provider from %s\n", np->full_name);
++
++	ret = of_clk_set_defaults(np, true);
++	if (ret < 0)
++		of_clk_del_provider(np);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(of_clk_add_hw_provider);
++
++/**
+  * of_clk_del_provider() - Remove a previously registered clock provider
+  * @np: Device node pointer associated with clock provider
+  */
+@@ -3087,11 +3144,32 @@ void of_clk_del_provider(struct device_n
+ }
+ EXPORT_SYMBOL_GPL(of_clk_del_provider);
+ 
++static struct clk_hw *
++__of_clk_get_hw_from_provider(struct of_clk_provider *provider,
++			      struct of_phandle_args *clkspec)
++{
++	struct clk *clk;
++	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
++
++	if (provider->get_hw) {
++		hw = provider->get_hw(clkspec, provider->data);
++	} else if (provider->get) {
++		clk = provider->get(clkspec, provider->data);
++		if (!IS_ERR(clk))
++			hw = __clk_get_hw(clk);
++		else
++			hw = ERR_CAST(clk);
++	}
++
++	return hw;
++}
++
+ struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,
+ 				       const char *dev_id, const char *con_id)
+ {
+ 	struct of_clk_provider *provider;
+ 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
++	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);
+ 
+ 	if (!clkspec)
+ 		return ERR_PTR(-EINVAL);
+@@ -3100,10 +3178,9 @@ struct clk *__of_clk_get_from_provider(s
+ 	mutex_lock(&of_clk_mutex);
+ 	list_for_each_entry(provider, &of_clk_providers, link) {
+ 		if (provider->node == clkspec->np)
+-			clk = provider->get(clkspec, provider->data);
+-		if (!IS_ERR(clk)) {
+-			clk = __clk_create_clk(__clk_get_hw(clk), dev_id,
+-					       con_id);
++			hw = __of_clk_get_hw_from_provider(provider, clkspec);
++		if (!IS_ERR(hw)) {
++			clk = __clk_create_clk(hw, dev_id, con_id);
+ 
+ 			if (!IS_ERR(clk) && !__clk_get(clk)) {
+ 				__clk_free_clk(clk);
+--- a/include/linux/clk-provider.h
++++ b/include/linux/clk-provider.h
+@@ -693,6 +693,11 @@ struct clk_onecell_data {
+ 	unsigned int clk_num;
+ };
+ 
++struct clk_hw_onecell_data {
++	size_t num;
++	struct clk_hw *hws[];
++};
++
+ extern struct of_device_id __clk_of_table;
+ 
+ #define CLK_OF_DECLARE(name, compat, fn) OF_DECLARE_1(clk, name, compat, fn)
+@@ -702,10 +707,19 @@ int of_clk_add_provider(struct device_no
+ 			struct clk *(*clk_src_get)(struct of_phandle_args *args,
+ 						   void *data),
+ 			void *data);
++int of_clk_add_hw_provider(struct device_node *np,
++			   struct clk_hw *(*get)(struct of_phandle_args *clkspec,
++						 void *data),
++			   void *data);
+ void of_clk_del_provider(struct device_node *np);
+ struct clk *of_clk_src_simple_get(struct of_phandle_args *clkspec,
+ 				  void *data);
++
++struct clk_hw *of_clk_hw_simple_get(struct of_phandle_args *clkspec,
++				    void *data);
+ struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data);
++struct clk_hw *of_clk_hw_onecell_get(struct of_phandle_args *clkspec,
++				     void *data);
+ int of_clk_get_parent_count(struct device_node *np);
+ int of_clk_parent_fill(struct device_node *np, const char **parents,
+ 		       unsigned int size);
+@@ -722,6 +736,13 @@ static inline int of_clk_add_provider(st
+ {
+ 	return 0;
+ }
++static inline int of_clk_add_hw_provider(struct device_node *np,
++			struct clk_hw *(*get)(struct of_phandle_args *clkspec,
++					      void *data),
++			void *data)
++{
++	return 0;
++}
+ #define of_clk_del_provider(np) \
+ 	{ while (0); }
+ static inline struct clk *of_clk_src_simple_get(
+@@ -729,11 +750,21 @@ static inline struct clk *of_clk_src_sim
+ {
+ 	return ERR_PTR(-ENOENT);
+ }
++static inline struct clk_hw *
++of_clk_hw_simple_get(struct of_phandle_args *clkspec, void *data)
++{
++	return ERR_PTR(-ENOENT);
++}
+ static inline struct clk *of_clk_src_onecell_get(
+ 	struct of_phandle_args *clkspec, void *data)
+ {
+ 	return ERR_PTR(-ENOENT);
+ }
++static inline struct clk_hw *
++of_clk_hw_onecell_get(struct of_phandle_args *clkspec, void *data)
++{
++	return ERR_PTR(-ENOENT);
++}
+ static inline int of_clk_get_parent_count(struct device_node *np)
+ {
+ 	return 0;
diff --git a/target/linux/generic/pending-4.4/084-0001-usb-core-Introduce-a-USB-port-LED-trigger.patch b/target/linux/generic/pending-4.4/084-0001-usb-core-Introduce-a-USB-port-LED-trigger.patch
new file mode 100644
index 0000000000..68039f67bb
--- /dev/null
+++ b/target/linux/generic/pending-4.4/084-0001-usb-core-Introduce-a-USB-port-LED-trigger.patch
@@ -0,0 +1,465 @@
+From 0f247626cbbfa2010d2b86fdee652605e084e248 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 16 Sep 2016 16:13:48 +0200
+Subject: [PATCH] usb: core: Introduce a USB port LED trigger
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This commit adds a new trigger responsible for turning on LED when USB
+device gets connected to the selected USB port. This can can useful for
+various home routers that have USB port(s) and a proper LED telling user
+a device is connected.
+
+The trigger gets its documentation file but basically it just requires
+enabling it and selecting USB ports (e.g. echo 1 > ports/usb1-1).
+
+There was a long discussion on design of this driver. Its current state
+is a result of picking them most adjustable solution as others couldn't
+handle all cases.
+
+1) It wasn't possible for the driver to register separated trigger for
+   each USB port. Some physical USB ports are handled by more than one
+   controller and so by more than one USB port. E.g. USB 2.0 physical
+   port may be handled by OHCI's port and EHCI's port.
+   It's also not possible to assign more than 1 trigger to a single LED
+   and implementing such feature would be tricky due to syncing triggers
+   and sysfs conflicts with old triggers.
+
+2) Another idea was to register trigger per USB hub. This wouldn't allow
+   handling devices with multiple USB LEDs and controllers (hubs)
+   controlling more than 1 physical port. It's common for hubs to have
+   few ports and each may have its own LED.
+
+This final trigger is highly flexible. It allows selecting any USB ports
+for any LED. It was also modified (comparing to the initial version) to
+allow choosing ports rather than having user /guess/ proper names. It
+was successfully tested on SmartRG SR400ac which has 3 USB LEDs,
+2 physical ports and 3 controllers.
+
+It was noted USB subsystem already has usb-gadget and usb-host triggers
+but they are pretty trivial ones. They indicate activity only and can't
+have ports specified.
+
+In future it may be good idea to consider adding activity support to
+usbport as well. This should allow switching to this more generic driver
+and maybe marking old ones as obsolete.
+This can be implemented with another sysfs file for setting mode. The
+default mode wouldn't change so there won't be ABI breakage and so such
+feature can be safely implemented later.
+
+There was also an idea of supporting other devices (PCI, SDIO, etc.) but
+as this driver already contains some USB specific code (and will get
+more) these should be probably separated drivers (triggers).
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ .../ABI/testing/sysfs-class-led-trigger-usbport    |  12 +
+ Documentation/leds/ledtrig-usbport.txt             |  41 +++
+ drivers/usb/core/Kconfig                           |   8 +
+ drivers/usb/core/Makefile                          |   2 +
+ drivers/usb/core/ledtrig-usbport.c                 | 314 +++++++++++++++++++++
+ 5 files changed, 377 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-class-led-trigger-usbport
+ create mode 100644 Documentation/leds/ledtrig-usbport.txt
+ create mode 100644 drivers/usb/core/ledtrig-usbport.c
+
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-class-led-trigger-usbport
+@@ -0,0 +1,12 @@
++What:		/sys/class/leds/<led>/ports/<port>
++Date:		September 2016
++KernelVersion:	4.9
++Contact:	linux-leds@vger.kernel.org
++		linux-usb@vger.kernel.org
++Description:
++		Every dir entry represents a single USB port that can be
++		selected for the USB port trigger. Selecting ports makes trigger
++		observing them for any connected devices and lighting on LED if
++		there are any.
++		Echoing "1" value selects USB port. Echoing "0" unselects it.
++		Current state can be also read.
+--- /dev/null
++++ b/Documentation/leds/ledtrig-usbport.txt
+@@ -0,0 +1,41 @@
++USB port LED trigger
++====================
++
++This LED trigger can be used for signalling to the user a presence of USB device
++in a given port. It simply turns on LED when device appears and turns it off
++when it disappears.
++
++It requires selecting USB ports that should be observed. All available ones are
++listed as separated entries in a "ports" subdirectory. Selecting is handled by
++echoing "1" to a chosen port.
++
++Please note that this trigger allows selecting multiple USB ports for a single
++LED. This can be useful in two cases:
++
++1) Device with single USB LED and few physical ports
++
++In such a case LED will be turned on as long as there is at least one connected
++USB device.
++
++2) Device with a physical port handled by few controllers
++
++Some devices may have one controller per PHY standard. E.g. USB 3.0 physical
++port may be handled by ohci-platform, ehci-platform and xhci-hcd. If there is
++only one LED user will most likely want to assign ports from all 3 hubs.
++
++
++This trigger can be activated from user space on led class devices as shown
++below:
++
++  echo usbport > trigger
++
++This adds sysfs attributes to the LED that are documented in:
++Documentation/ABI/testing/sysfs-class-led-trigger-usbport
++
++Example use-case:
++
++  echo usbport > trigger
++  echo 1 > ports/usb1-port1
++  echo 1 > ports/usb2-port1
++  cat ports/usb1-port1
++  echo 0 > ports/usb1-port1
+--- a/drivers/usb/core/Kconfig
++++ b/drivers/usb/core/Kconfig
+@@ -103,3 +103,11 @@ config USB_ULPI_BUS
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called ulpi.
++
++config USB_LEDS_TRIGGER_USBPORT
++	tristate "USB port LED trigger"
++	depends on USB && LEDS_TRIGGERS
++	help
++	  This driver allows LEDs to be controlled by USB events. Enabling this
++	  trigger allows specifying list of USB ports that should turn on LED
++	  when some USB device gets connected.
+--- a/drivers/usb/core/Makefile
++++ b/drivers/usb/core/Makefile
+@@ -11,3 +11,5 @@ usbcore-$(CONFIG_PCI)		+= hcd-pci.o
+ usbcore-$(CONFIG_ACPI)		+= usb-acpi.o
+ 
+ obj-$(CONFIG_USB)		+= usbcore.o
++
++obj-$(CONFIG_USB_LEDS_TRIGGER_USBPORT)	+= ledtrig-usbport.o
+--- /dev/null
++++ b/drivers/usb/core/ledtrig-usbport.c
+@@ -0,0 +1,314 @@
++/*
++ * USB port LED trigger
++ *
++ * Copyright (C) 2016 Rafa Miecki <rafal@milecki.pl>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/device.h>
++#include <linux/leds.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/usb.h>
++
++struct usbport_trig_data {
++	struct led_classdev *led_cdev;
++	struct list_head ports;
++	struct notifier_block nb;
++	int count; /* Amount of connected matching devices */
++};
++
++struct usbport_trig_port {
++	struct usbport_trig_data *data;
++	struct usb_device *hub;
++	int portnum;
++	char *port_name;
++	bool observed;
++	struct device_attribute attr;
++	struct list_head list;
++};
++
++/***************************************
++ * Helpers
++ ***************************************/
++
++/**
++ * usbport_trig_usb_dev_observed - Check if dev is connected to observed port
++ */
++static bool usbport_trig_usb_dev_observed(struct usbport_trig_data *usbport_data,
++					  struct usb_device *usb_dev)
++{
++	struct usbport_trig_port *port;
++
++	if (!usb_dev->parent)
++		return false;
++
++	list_for_each_entry(port, &usbport_data->ports, list) {
++		if (usb_dev->parent == port->hub &&
++		    usb_dev->portnum == port->portnum)
++			return port->observed;
++	}
++
++	return false;
++}
++
++static int usbport_trig_usb_dev_check(struct usb_device *usb_dev, void *data)
++{
++	struct usbport_trig_data *usbport_data = data;
++
++	if (usbport_trig_usb_dev_observed(usbport_data, usb_dev))
++		usbport_data->count++;
++
++	return 0;
++}
++
++/**
++ * usbport_trig_update_count - Recalculate amount of connected matching devices
++ */
++static void usbport_trig_update_count(struct usbport_trig_data *usbport_data)
++{
++	struct led_classdev *led_cdev = usbport_data->led_cdev;
++
++	usbport_data->count = 0;
++	usb_for_each_dev(usbport_data, usbport_trig_usb_dev_check);
++	led_cdev->brightness_set(led_cdev,
++				 usbport_data->count ? LED_FULL : LED_OFF);
++}
++
++/***************************************
++ * Device attr
++ ***************************************/
++
++static ssize_t usbport_trig_port_show(struct device *dev,
++				      struct device_attribute *attr, char *buf)
++{
++	struct usbport_trig_port *port = container_of(attr,
++						      struct usbport_trig_port,
++						      attr);
++
++	return sprintf(buf, "%d\n", port->observed) + 1;
++}
++
++static ssize_t usbport_trig_port_store(struct device *dev,
++				       struct device_attribute *attr,
++				       const char *buf, size_t size)
++{
++	struct usbport_trig_port *port = container_of(attr,
++						      struct usbport_trig_port,
++						      attr);
++
++	if (!strcmp(buf, "0") || !strcmp(buf, "0\n"))
++		port->observed = 0;
++	else if (!strcmp(buf, "1") || !strcmp(buf, "1\n"))
++		port->observed = 1;
++	else
++		return -EINVAL;
++
++	usbport_trig_update_count(port->data);
++
++	return size;
++}
++
++static struct attribute *ports_attrs[] = {
++	NULL,
++};
++static const struct attribute_group ports_group = {
++	.name = "ports",
++	.attrs = ports_attrs,
++};
++
++/***************************************
++ * Adding & removing ports
++ ***************************************/
++
++static int usbport_trig_add_port(struct usbport_trig_data *usbport_data,
++				 struct usb_device *usb_dev,
++				 const char *hub_name, int portnum)
++{
++	struct led_classdev *led_cdev = usbport_data->led_cdev;
++	struct usbport_trig_port *port;
++	size_t len;
++	int err;
++
++	port = kzalloc(sizeof(*port), GFP_KERNEL);
++	if (!port) {
++		err = -ENOMEM;
++		goto err_out;
++	}
++
++	port->data = usbport_data;
++	port->hub = usb_dev;
++	port->portnum = portnum;
++
++	len = strlen(hub_name) + 8;
++	port->port_name = kzalloc(len, GFP_KERNEL);
++	if (!port->port_name) {
++		err = -ENOMEM;
++		goto err_free_port;
++	}
++	snprintf(port->port_name, len, "%s-port%d", hub_name, portnum);
++
++	port->attr.attr.name = port->port_name;
++	port->attr.attr.mode = S_IRUSR | S_IWUSR;
++	port->attr.show = usbport_trig_port_show;
++	port->attr.store = usbport_trig_port_store;
++
++	err = sysfs_add_file_to_group(&led_cdev->dev->kobj, &port->attr.attr,
++				      ports_group.name);
++	if (err)
++		goto err_free_port_name;
++
++	list_add_tail(&port->list, &usbport_data->ports);
++
++	return 0;
++
++err_free_port_name:
++	kfree(port->port_name);
++err_free_port:
++	kfree(port);
++err_out:
++	return err;
++}
++
++static int usbport_trig_add_usb_dev_ports(struct usb_device *usb_dev,
++					  void *data)
++{
++	struct usbport_trig_data *usbport_data = data;
++	int i;
++
++	for (i = 1; i <= usb_dev->maxchild; i++)
++		usbport_trig_add_port(usbport_data, usb_dev,
++				      dev_name(&usb_dev->dev), i);
++
++	return 0;
++}
++
++static void usbport_trig_remove_port(struct usbport_trig_data *usbport_data,
++				     struct usbport_trig_port *port)
++{
++	struct led_classdev *led_cdev = usbport_data->led_cdev;
++
++	list_del(&port->list);
++	sysfs_remove_file_from_group(&led_cdev->dev->kobj, &port->attr.attr,
++				     ports_group.name);
++	kfree(port->port_name);
++	kfree(port);
++}
++
++static void usbport_trig_remove_usb_dev_ports(struct usbport_trig_data *usbport_data,
++					      struct usb_device *usb_dev)
++{
++	struct usbport_trig_port *port, *tmp;
++
++	list_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {
++		if (port->hub == usb_dev)
++			usbport_trig_remove_port(usbport_data, port);
++	}
++}
++
++/***************************************
++ * Init, exit, etc.
++ ***************************************/
++
++static int usbport_trig_notify(struct notifier_block *nb, unsigned long action,
++			       void *data)
++{
++	struct usbport_trig_data *usbport_data =
++		container_of(nb, struct usbport_trig_data, nb);
++	struct led_classdev *led_cdev = usbport_data->led_cdev;
++	struct usb_device *usb_dev = data;
++	bool observed;
++
++	observed = usbport_trig_usb_dev_observed(usbport_data, usb_dev);
++
++	switch (action) {
++	case USB_DEVICE_ADD:
++		usbport_trig_add_usb_dev_ports(usb_dev, usbport_data);
++		if (observed && usbport_data->count++ == 0)
++			led_cdev->brightness_set(led_cdev, LED_FULL);
++		return NOTIFY_OK;
++	case USB_DEVICE_REMOVE:
++		usbport_trig_remove_usb_dev_ports(usbport_data, usb_dev);
++		if (observed && --usbport_data->count == 0)
++			led_cdev->brightness_set(led_cdev, LED_OFF);
++		return NOTIFY_OK;
++	}
++
++	return NOTIFY_DONE;
++}
++
++static void usbport_trig_activate(struct led_classdev *led_cdev)
++{
++	struct usbport_trig_data *usbport_data;
++	int err;
++
++	usbport_data = kzalloc(sizeof(*usbport_data), GFP_KERNEL);
++	if (!usbport_data)
++		return;
++	usbport_data->led_cdev = led_cdev;
++
++	/* List of ports */
++	INIT_LIST_HEAD(&usbport_data->ports);
++	err = sysfs_create_group(&led_cdev->dev->kobj, &ports_group);
++	if (err)
++		goto err_free;
++	usb_for_each_dev(usbport_data, usbport_trig_add_usb_dev_ports);
++
++	/* Notifications */
++	usbport_data->nb.notifier_call = usbport_trig_notify,
++	led_cdev->trigger_data = usbport_data;
++	usb_register_notify(&usbport_data->nb);
++
++	led_cdev->activated = true;
++	return;
++
++err_free:
++	kfree(usbport_data);
++}
++
++static void usbport_trig_deactivate(struct led_classdev *led_cdev)
++{
++	struct usbport_trig_data *usbport_data = led_cdev->trigger_data;
++	struct usbport_trig_port *port, *tmp;
++
++	if (!led_cdev->activated)
++		return;
++
++	list_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {
++		usbport_trig_remove_port(usbport_data, port);
++	}
++
++	usb_unregister_notify(&usbport_data->nb);
++
++	sysfs_remove_group(&led_cdev->dev->kobj, &ports_group);
++
++	kfree(usbport_data);
++
++	led_cdev->activated = false;
++}
++
++static struct led_trigger usbport_led_trigger = {
++	.name     = "usbport",
++	.activate = usbport_trig_activate,
++	.deactivate = usbport_trig_deactivate,
++};
++
++static int __init usbport_trig_init(void)
++{
++	return led_trigger_register(&usbport_led_trigger);
++}
++
++static void __exit usbport_trig_exit(void)
++{
++	led_trigger_unregister(&usbport_led_trigger);
++}
++
++module_init(usbport_trig_init);
++module_exit(usbport_trig_exit);
++
++MODULE_AUTHOR("Rafa Miecki <rafal@milecki.pl>");
++MODULE_DESCRIPTION("USB port trigger");
++MODULE_LICENSE("GPL v2");
diff --git a/target/linux/generic/pending-4.4/084-0002-usb-core-usbport-Use-proper-LED-API-to-fix-potential.patch b/target/linux/generic/pending-4.4/084-0002-usb-core-usbport-Use-proper-LED-API-to-fix-potential.patch
new file mode 100644
index 0000000000..ec41a2dc21
--- /dev/null
+++ b/target/linux/generic/pending-4.4/084-0002-usb-core-usbport-Use-proper-LED-API-to-fix-potential.patch
@@ -0,0 +1,70 @@
+From 89778ba335e302a450932ce5b703c1ee6216e949 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 6 Dec 2016 00:39:33 +0100
+Subject: [PATCH] usb: core: usbport: Use proper LED API to fix potential crash
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Calling brightness_set manually isn't safe as some LED drivers don't
+implement this callback. The best idea is to just use a proper helper
+which will fallback to the brightness_set_blocking callback if needed.
+
+This fixes:
+[ 1461.761528] Unable to handle kernel NULL pointer dereference at virtual address 00000000
+(...)
+[ 1462.117049] Backtrace:
+[ 1462.119521] [<bf228164>] (usbport_trig_port_store [ledtrig_usbport]) from [<c023f758>] (dev_attr_store+0x20/0x2c)
+[ 1462.129826]  r7:dcabc7c0 r6:dee0ff80 r5:00000002 r4:bf228164
+[ 1462.135511] [<c023f738>] (dev_attr_store) from [<c0169310>] (sysfs_kf_write+0x48/0x4c)
+[ 1462.143459]  r5:00000002 r4:c023f738
+[ 1462.147049] [<c01692c8>] (sysfs_kf_write) from [<c0168ab8>] (kernfs_fop_write+0xf8/0x1f8)
+[ 1462.155258]  r5:00000002 r4:df4a1000
+[ 1462.158850] [<c01689c0>] (kernfs_fop_write) from [<c0100c78>] (__vfs_write+0x34/0x120)
+[ 1462.166800]  r10:00000000 r9:dee0e000 r8:c000fc24 r7:00000002 r6:dee0ff80 r5:c01689c0
+[ 1462.174660]  r4:df727a80
+[ 1462.177204] [<c0100c44>] (__vfs_write) from [<c0101ae4>] (vfs_write+0xac/0x170)
+[ 1462.184543]  r9:dee0e000 r8:c000fc24 r7:dee0ff80 r6:b6f092d0 r5:df727a80 r4:00000002
+[ 1462.192319] [<c0101a38>] (vfs_write) from [<c01028dc>] (SyS_write+0x4c/0xa8)
+[ 1462.199396]  r9:dee0e000 r8:c000fc24 r7:00000002 r6:b6f092d0 r5:df727a80 r4:df727a80
+[ 1462.207174] [<c0102890>] (SyS_write) from [<c000fa60>] (ret_fast_syscall+0x0/0x3c)
+[ 1462.214774]  r7:00000004 r6:ffffffff r5:00000000 r4:00000000
+[ 1462.220456] Code: bad PC value
+[ 1462.223560] ---[ end trace 676638a3a12c7a56 ]---
+
+Reported-by: Ralph Sennhauser <ralph.sennhauser@gmail.com>
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Fixes: 0f247626cbb ("usb: core: Introduce a USB port LED trigger")
+Cc: stable@vger.kernel.org # 4.9+
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/ledtrig-usbport.c | 7 +++----
+ 1 file changed, 3 insertions(+), 4 deletions(-)
+
+--- a/drivers/usb/core/ledtrig-usbport.c
++++ b/drivers/usb/core/ledtrig-usbport.c
+@@ -74,8 +74,7 @@ static void usbport_trig_update_count(st
+ 
+ 	usbport_data->count = 0;
+ 	usb_for_each_dev(usbport_data, usbport_trig_usb_dev_check);
+-	led_cdev->brightness_set(led_cdev,
+-				 usbport_data->count ? LED_FULL : LED_OFF);
++	led_set_brightness(led_cdev, usbport_data->count ? LED_FULL : LED_OFF);
+ }
+ 
+ /***************************************
+@@ -228,12 +227,12 @@ static int usbport_trig_notify(struct no
+ 	case USB_DEVICE_ADD:
+ 		usbport_trig_add_usb_dev_ports(usb_dev, usbport_data);
+ 		if (observed && usbport_data->count++ == 0)
+-			led_cdev->brightness_set(led_cdev, LED_FULL);
++			led_set_brightness(led_cdev, LED_FULL);
+ 		return NOTIFY_OK;
+ 	case USB_DEVICE_REMOVE:
+ 		usbport_trig_remove_usb_dev_ports(usbport_data, usb_dev);
+ 		if (observed && --usbport_data->count == 0)
+-			led_cdev->brightness_set(led_cdev, LED_OFF);
++			led_set_brightness(led_cdev, LED_OFF);
+ 		return NOTIFY_OK;
+ 	}
+ 
diff --git a/target/linux/generic/pending-4.4/084-0003-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch b/target/linux/generic/pending-4.4/084-0003-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch
new file mode 100644
index 0000000000..65d17c8a9e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/084-0003-usb-core-read-USB-ports-from-DT-in-the-usbport-LED-t.patch
@@ -0,0 +1,106 @@
+From 4f04c210d031667e503d6538a72345a36f3b5d71 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 8 Jun 2017 18:08:32 +0200
+Subject: [PATCH] usb: core: read USB ports from DT in the usbport LED trigger
+ driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This uses DT info to read relation description of LEDs and USB ports. If
+DT has properly described LEDs, trigger will know when to turn them on.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/usb/core/ledtrig-usbport.c | 56 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 56 insertions(+)
+
+--- a/drivers/usb/core/ledtrig-usbport.c
++++ b/drivers/usb/core/ledtrig-usbport.c
+@@ -11,8 +11,10 @@
+ #include <linux/device.h>
+ #include <linux/leds.h>
+ #include <linux/module.h>
++#include <linux/of.h>
+ #include <linux/slab.h>
+ #include <linux/usb.h>
++#include <linux/usb/of.h>
+ 
+ struct usbport_trig_data {
+ 	struct led_classdev *led_cdev;
+@@ -123,6 +125,57 @@ static const struct attribute_group port
+  * Adding & removing ports
+  ***************************************/
+ 
++/**
++ * usbport_trig_port_observed - Check if port should be observed
++ */
++static bool usbport_trig_port_observed(struct usbport_trig_data *usbport_data,
++				       struct usb_device *usb_dev, int port1)
++{
++	struct device *dev = usbport_data->led_cdev->dev;
++	struct device_node *led_np = dev->of_node;
++	struct of_phandle_args args;
++	struct device_node *port_np;
++	int count, i;
++
++	if (!led_np)
++		return false;
++
++	/* Get node of port being added */
++	port_np = usb_of_get_child_node(usb_dev->dev.of_node, port1);
++	if (!port_np)
++		return false;
++
++	/* Amount of trigger sources for this LED */
++	count = of_count_phandle_with_args(led_np, "trigger-sources",
++					   "#trigger-source-cells");
++	if (count < 0) {
++		dev_warn(dev, "Failed to get trigger sources for %s\n",
++			 led_np->full_name);
++		return false;
++	}
++
++	/* Check list of sources for this specific port */
++	for (i = 0; i < count; i++) {
++		int err;
++
++		err = of_parse_phandle_with_args(led_np, "trigger-sources",
++						 "#trigger-source-cells", i,
++						 &args);
++		if (err) {
++			dev_err(dev, "Failed to get trigger source phandle at index %d: %d\n",
++				i, err);
++			continue;
++		}
++
++		of_node_put(args.np);
++
++		if (args.np == port_np)
++			return true;
++	}
++
++	return false;
++}
++
+ static int usbport_trig_add_port(struct usbport_trig_data *usbport_data,
+ 				 struct usb_device *usb_dev,
+ 				 const char *hub_name, int portnum)
+@@ -141,6 +194,8 @@ static int usbport_trig_add_port(struct
+ 	port->data = usbport_data;
+ 	port->hub = usb_dev;
+ 	port->portnum = portnum;
++	port->observed = usbport_trig_port_observed(usbport_data, usb_dev,
++						    portnum);
+ 
+ 	len = strlen(hub_name) + 8;
+ 	port->port_name = kzalloc(len, GFP_KERNEL);
+@@ -255,6 +310,7 @@ static void usbport_trig_activate(struct
+ 	if (err)
+ 		goto err_free;
+ 	usb_for_each_dev(usbport_data, usbport_trig_add_usb_dev_ports);
++	usbport_trig_update_count(usbport_data);
+ 
+ 	/* Notifications */
+ 	usbport_data->nb.notifier_call = usbport_trig_notify,
diff --git a/target/linux/generic/pending-4.4/085-0001-leds-leds-gpio-Set-of_node-for-created-LED-devices.patch b/target/linux/generic/pending-4.4/085-0001-leds-leds-gpio-Set-of_node-for-created-LED-devices.patch
new file mode 100644
index 0000000000..f60b1fc16b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/085-0001-leds-leds-gpio-Set-of_node-for-created-LED-devices.patch
@@ -0,0 +1,53 @@
+From bff23714bc36a1322d0f14519022df0d1a4b21f3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Fri, 8 Jul 2016 14:53:38 +0200
+Subject: [PATCH] leds: leds-gpio: Set of_node for created LED devices
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+When working with Device Tree we iterate over children of "gpio-leds"
+compatible node and create LED device for each of them. We take care of
+all common DT properties (label, default trigger, state, etc.), however
+some triggers may want to support more of them.
+
+It could be useful for timer trigger to support setting delay on/off
+values with Device Tree property. Or for transient trigger to support
+e.g. duration property.
+
+We obviously should handle such properties in triggers, not in generic
+code. To let trigger drivers read properties from DT node we need to set
+of_node to point the relevant node. This change allows using all kind of
+of helpers in e.g. "activate" callbacks.
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
+---
+ drivers/leds/leds-gpio.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+--- a/drivers/leds/leds-gpio.c
++++ b/drivers/leds/leds-gpio.c
+@@ -182,6 +182,7 @@ static struct gpio_leds_priv *gpio_leds_
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	device_for_each_child_node(dev, child) {
++		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
+ 		struct gpio_led led = {};
+ 		const char *state = NULL;
+ 
+@@ -220,12 +221,12 @@ static struct gpio_leds_priv *gpio_leds_
+ 		if (fwnode_property_present(child, "retain-state-suspended"))
+ 			led.retain_state_suspended = 1;
+ 
+-		ret = create_gpio_led(&led, &priv->leds[priv->num_leds],
+-				      dev, NULL);
++		ret = create_gpio_led(&led, led_dat, dev, NULL);
+ 		if (ret < 0) {
+ 			fwnode_handle_put(child);
+ 			goto err;
+ 		}
++		led_dat->cdev.dev->of_node = np;
+ 		priv->num_leds++;
+ 	}
+ 
diff --git a/target/linux/generic/pending-4.4/085-0002-leds-gpio-introduce-gpio_blink_set_t.patch b/target/linux/generic/pending-4.4/085-0002-leds-gpio-introduce-gpio_blink_set_t.patch
new file mode 100644
index 0000000000..670d4ba91f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/085-0002-leds-gpio-introduce-gpio_blink_set_t.patch
@@ -0,0 +1,61 @@
+From 68620e594c250ba8c43a78e77f5296cb9952582e Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 14 Sep 2016 20:54:12 +0200
+Subject: [PATCH] leds: gpio: introduce gpio_blink_set_t
+
+Introduce a typedef gpio_blink_set_t to improve readability of the code.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
+---
+ drivers/leds/leds-gpio.c | 6 ++----
+ include/linux/leds.h     | 9 ++++++---
+ 2 files changed, 8 insertions(+), 7 deletions(-)
+
+--- a/drivers/leds/leds-gpio.c
++++ b/drivers/leds/leds-gpio.c
+@@ -29,8 +29,7 @@ struct gpio_led_data {
+ 	u8 new_level;
+ 	u8 can_sleep;
+ 	u8 blinking;
+-	int (*platform_gpio_blink_set)(struct gpio_desc *desc, int state,
+-			unsigned long *delay_on, unsigned long *delay_off);
++	gpio_blink_set_t platform_gpio_blink_set;
+ };
+ 
+ static void gpio_led_work(struct work_struct *work)
+@@ -88,8 +87,7 @@ static int gpio_blink_set(struct led_cla
+ 
+ static int create_gpio_led(const struct gpio_led *template,
+ 	struct gpio_led_data *led_dat, struct device *parent,
+-	int (*blink_set)(struct gpio_desc *, int, unsigned long *,
+-			 unsigned long *))
++	gpio_blink_set_t blink_set)
+ {
+ 	int ret, state;
+ 
+--- a/include/linux/leds.h
++++ b/include/linux/leds.h
+@@ -330,6 +330,11 @@ struct led_platform_data {
+ 	struct led_info	*leds;
+ };
+ 
++struct gpio_desc;
++typedef int (*gpio_blink_set_t)(struct gpio_desc *desc, int state,
++				unsigned long *delay_on,
++				unsigned long *delay_off);
++
+ /* For the leds-gpio driver */
+ struct gpio_led {
+ 	const char *name;
+@@ -352,9 +357,7 @@ struct gpio_led_platform_data {
+ #define GPIO_LED_NO_BLINK_LOW	0	/* No blink GPIO state low */
+ #define GPIO_LED_NO_BLINK_HIGH	1	/* No blink GPIO state high */
+ #define GPIO_LED_BLINK		2	/* Please, blink */
+-	int		(*gpio_blink_set)(struct gpio_desc *desc, int state,
+-					unsigned long *delay_on,
+-					unsigned long *delay_off);
++	gpio_blink_set_t	gpio_blink_set;
+ };
+ 
+ struct platform_device *gpio_led_register_device(
diff --git a/target/linux/generic/pending-4.4/085-0003-leds-gpio-switch-to-managed-version-of-led_classdev_.patch b/target/linux/generic/pending-4.4/085-0003-leds-gpio-switch-to-managed-version-of-led_classdev_.patch
new file mode 100644
index 0000000000..7aa865aa83
--- /dev/null
+++ b/target/linux/generic/pending-4.4/085-0003-leds-gpio-switch-to-managed-version-of-led_classdev_.patch
@@ -0,0 +1,75 @@
+From bc2c0dd85a0a31505ca2f92bef891ddac9126725 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 14 Sep 2016 20:55:27 +0200
+Subject: [PATCH] leds: gpio: switch to managed version of
+ led_classdev_register
+
+Using the managed version of led_classdev_register allows to
+significantly simplify the code.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
+---
+ drivers/leds/leds-gpio.c | 23 ++---------------------
+ 1 file changed, 2 insertions(+), 21 deletions(-)
+
+--- a/drivers/leds/leds-gpio.c
++++ b/drivers/leds/leds-gpio.c
+@@ -143,7 +143,7 @@ static int create_gpio_led(const struct
+ 
+ 	INIT_WORK(&led_dat->work, gpio_led_work);
+ 
+-	return led_classdev_register(parent, &led_dat->cdev);
++	return devm_led_classdev_register(parent, &led_dat->cdev);
+ }
+ 
+ static void delete_gpio_led(struct gpio_led_data *led)
+@@ -231,8 +231,6 @@ static struct gpio_leds_priv *gpio_leds_
+ 	return priv;
+ 
+ err:
+-	for (count = priv->num_leds - 1; count >= 0; count--)
+-		delete_gpio_led(&priv->leds[count]);
+ 	return ERR_PTR(ret);
+ }
+ 
+@@ -261,12 +259,8 @@ static int gpio_led_probe(struct platfor
+ 			ret = create_gpio_led(&pdata->leds[i],
+ 					      &priv->leds[i],
+ 					      &pdev->dev, pdata->gpio_blink_set);
+-			if (ret < 0) {
+-				/* On failure: unwind the led creations */
+-				for (i = i - 1; i >= 0; i--)
+-					delete_gpio_led(&priv->leds[i]);
++			if (ret < 0)
+ 				return ret;
+-			}
+ 		}
+ 	} else {
+ 		priv = gpio_leds_create(pdev);
+@@ -279,17 +273,6 @@ static int gpio_led_probe(struct platfor
+ 	return 0;
+ }
+ 
+-static int gpio_led_remove(struct platform_device *pdev)
+-{
+-	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
+-	int i;
+-
+-	for (i = 0; i < priv->num_leds; i++)
+-		delete_gpio_led(&priv->leds[i]);
+-
+-	return 0;
+-}
+-
+ static void gpio_led_shutdown(struct platform_device *pdev)
+ {
+ 	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
+@@ -304,7 +287,6 @@ static void gpio_led_shutdown(struct pla
+ 
+ static struct platform_driver gpio_led_driver = {
+ 	.probe		= gpio_led_probe,
+-	.remove		= gpio_led_remove,
+ 	.shutdown	= gpio_led_shutdown,
+ 	.driver		= {
+ 		.name	= "leds-gpio",
diff --git a/target/linux/generic/pending-4.4/085-0004-leds-core-add-OF-variants-of-LED-registering-functio.patch b/target/linux/generic/pending-4.4/085-0004-leds-core-add-OF-variants-of-LED-registering-functio.patch
new file mode 100644
index 0000000000..e02984041a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/085-0004-leds-core-add-OF-variants-of-LED-registering-functio.patch
@@ -0,0 +1,120 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 6 Mar 2017 06:19:44 +0100
+Subject: [PATCH] leds: core: add OF variants of LED registering functions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+These new functions allow passing an additional device_node argument
+that will be internally set for created LED device. Thanks to this LED
+core code and triggers will be able to access DT node for reading extra
+info.
+
+The easiest solution for achieving this was reworking old functions to
+more generic ones & adding simple defines for API compatibility.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Pavel Machek <pavel@ucw.cz>
+Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
+---
+ drivers/leds/led-class.c | 26 ++++++++++++++++----------
+ include/linux/leds.h     | 14 ++++++++++----
+ 2 files changed, 26 insertions(+), 14 deletions(-)
+
+--- a/drivers/leds/led-class.c
++++ b/drivers/leds/led-class.c
+@@ -181,11 +181,14 @@ static int led_classdev_next_name(const
+ }
+ 
+ /**
+- * led_classdev_register - register a new object of led_classdev class.
+- * @parent: The device to register.
++ * of_led_classdev_register - register a new object of led_classdev class.
++ *
++ * @parent: parent of LED device
+  * @led_cdev: the led_classdev structure for this device.
++ * @np: DT node describing this LED
+  */
+-int led_classdev_register(struct device *parent, struct led_classdev *led_cdev)
++int of_led_classdev_register(struct device *parent, struct device_node *np,
++			    struct led_classdev *led_cdev)
+ {
+ 	char name[64];
+ 	int ret;
+@@ -198,6 +201,7 @@ int led_classdev_register(struct device
+ 				led_cdev, led_cdev->groups, "%s", name);
+ 	if (IS_ERR(led_cdev->dev))
+ 		return PTR_ERR(led_cdev->dev);
++	led_cdev->dev->of_node = np;
+ 
+ 	if (ret)
+ 		dev_warn(parent, "Led %s renamed to %s due to name collision",
+@@ -230,7 +234,7 @@ int led_classdev_register(struct device
+ 
+ 	return 0;
+ }
+-EXPORT_SYMBOL_GPL(led_classdev_register);
++EXPORT_SYMBOL_GPL(of_led_classdev_register);
+ 
+ /**
+  * led_classdev_unregister - unregisters a object of led_properties class.
+@@ -269,12 +273,14 @@ static void devm_led_classdev_release(st
+ }
+ 
+ /**
+- * devm_led_classdev_register - resource managed led_classdev_register()
+- * @parent: The device to register.
++ * devm_of_led_classdev_register - resource managed led_classdev_register()
++ *
++ * @parent: parent of LED device
+  * @led_cdev: the led_classdev structure for this device.
+  */
+-int devm_led_classdev_register(struct device *parent,
+-			       struct led_classdev *led_cdev)
++int devm_of_led_classdev_register(struct device *parent,
++				  struct device_node *np,
++				  struct led_classdev *led_cdev)
+ {
+ 	struct led_classdev **dr;
+ 	int rc;
+@@ -283,7 +289,7 @@ int devm_led_classdev_register(struct de
+ 	if (!dr)
+ 		return -ENOMEM;
+ 
+-	rc = led_classdev_register(parent, led_cdev);
++	rc = of_led_classdev_register(parent, np, led_cdev);
+ 	if (rc) {
+ 		devres_free(dr);
+ 		return rc;
+@@ -294,7 +300,7 @@ int devm_led_classdev_register(struct de
+ 
+ 	return 0;
+ }
+-EXPORT_SYMBOL_GPL(devm_led_classdev_register);
++EXPORT_SYMBOL_GPL(devm_of_led_classdev_register);
+ 
+ static int devm_led_classdev_match(struct device *dev, void *res, void *data)
+ {
+--- a/include/linux/leds.h
++++ b/include/linux/leds.h
+@@ -103,10 +103,16 @@ struct led_classdev {
+ 	struct mutex		led_access;
+ };
+ 
+-extern int led_classdev_register(struct device *parent,
+-				 struct led_classdev *led_cdev);
+-extern int devm_led_classdev_register(struct device *parent,
+-				      struct led_classdev *led_cdev);
++extern int of_led_classdev_register(struct device *parent,
++				    struct device_node *np,
++				    struct led_classdev *led_cdev);
++#define led_classdev_register(parent, led_cdev)				\
++	of_led_classdev_register(parent, NULL, led_cdev)
++extern int devm_of_led_classdev_register(struct device *parent,
++					 struct device_node *np,
++					 struct led_classdev *led_cdev);
++#define devm_led_classdev_register(parent, led_cdev)			\
++	devm_of_led_classdev_register(parent, NULL, led_cdev)
+ extern void led_classdev_unregister(struct led_classdev *led_cdev);
+ extern void devm_led_classdev_unregister(struct device *parent,
+ 					 struct led_classdev *led_cdev);
diff --git a/target/linux/generic/pending-4.4/085-0005-leds-gpio-use-OF-variant-of-LED-registering-function.patch b/target/linux/generic/pending-4.4/085-0005-leds-gpio-use-OF-variant-of-LED-registering-function.patch
new file mode 100644
index 0000000000..159fae84f4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/085-0005-leds-gpio-use-OF-variant-of-LED-registering-function.patch
@@ -0,0 +1,60 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 6 Mar 2017 06:19:45 +0100
+Subject: [PATCH] leds: gpio: use OF variant of LED registering function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+In leds-gpio we support LEDs specified in DT so we should use
+(devm_)of_led_classdev_register. This allows passing DT node as argument
+for use by the LED subsystem.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Acked-by: Pavel Machek <pavel@ucw.cz>
+Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
+---
+ drivers/leds/leds-gpio.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/leds/leds-gpio.c
++++ b/drivers/leds/leds-gpio.c
+@@ -87,7 +87,7 @@ static int gpio_blink_set(struct led_cla
+ 
+ static int create_gpio_led(const struct gpio_led *template,
+ 	struct gpio_led_data *led_dat, struct device *parent,
+-	gpio_blink_set_t blink_set)
++	struct device_node *np, gpio_blink_set_t blink_set)
+ {
+ 	int ret, state;
+ 
+@@ -143,7 +143,7 @@ static int create_gpio_led(const struct
+ 
+ 	INIT_WORK(&led_dat->work, gpio_led_work);
+ 
+-	return devm_led_classdev_register(parent, &led_dat->cdev);
++	return devm_of_led_classdev_register(parent, np, &led_dat->cdev);
+ }
+ 
+ static void delete_gpio_led(struct gpio_led_data *led)
+@@ -219,7 +219,7 @@ static struct gpio_leds_priv *gpio_leds_
+ 		if (fwnode_property_present(child, "retain-state-suspended"))
+ 			led.retain_state_suspended = 1;
+ 
+-		ret = create_gpio_led(&led, led_dat, dev, NULL);
++		ret = create_gpio_led(&led, led_dat, dev, np, NULL);
+ 		if (ret < 0) {
+ 			fwnode_handle_put(child);
+ 			goto err;
+@@ -256,9 +256,9 @@ static int gpio_led_probe(struct platfor
+ 
+ 		priv->num_leds = pdata->num_leds;
+ 		for (i = 0; i < priv->num_leds; i++) {
+-			ret = create_gpio_led(&pdata->leds[i],
+-					      &priv->leds[i],
+-					      &pdev->dev, pdata->gpio_blink_set);
++			ret = create_gpio_led(&pdata->leds[i], &priv->leds[i],
++					      &pdev->dev, NULL,
++					      pdata->gpio_blink_set);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
diff --git a/target/linux/generic/pending-4.4/086-0001-thermal-of-thermal-Add-devm-version-of-thermal_zone_.patch b/target/linux/generic/pending-4.4/086-0001-thermal-of-thermal-Add-devm-version-of-thermal_zone_.patch
new file mode 100644
index 0000000000..b551bac69d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/086-0001-thermal-of-thermal-Add-devm-version-of-thermal_zone_.patch
@@ -0,0 +1,143 @@
+From e498b4984db82b4ba3ceea7dba813222a31e9c2e Mon Sep 17 00:00:00 2001
+From: Laxman Dewangan <ldewangan@nvidia.com>
+Date: Wed, 9 Mar 2016 18:40:06 +0530
+Subject: [PATCH] thermal: of-thermal: Add devm version of
+ thermal_zone_of_sensor_register
+
+Add resource managed version of thermal_zone_of_sensor_register() and
+thermal_zone_of_sensor_unregister().
+
+This helps in reducing the code size in error path, remove of
+driver remove callbacks and making proper sequence for deallocations.
+
+Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
+Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
+---
+ drivers/thermal/of-thermal.c | 81 ++++++++++++++++++++++++++++++++++++++++++++
+ include/linux/thermal.h      | 18 ++++++++++
+ 2 files changed, 99 insertions(+)
+
+--- a/drivers/thermal/of-thermal.c
++++ b/drivers/thermal/of-thermal.c
+@@ -559,6 +559,87 @@ void thermal_zone_of_sensor_unregister(s
+ }
+ EXPORT_SYMBOL_GPL(thermal_zone_of_sensor_unregister);
+ 
++static void devm_thermal_zone_of_sensor_release(struct device *dev, void *res)
++{
++	thermal_zone_of_sensor_unregister(dev,
++					  *(struct thermal_zone_device **)res);
++}
++
++static int devm_thermal_zone_of_sensor_match(struct device *dev, void *res,
++					     void *data)
++{
++	struct thermal_zone_device **r = res;
++
++	if (WARN_ON(!r || !*r))
++		return 0;
++
++	return *r == data;
++}
++
++/**
++ * devm_thermal_zone_of_sensor_register - Resource managed version of
++ *				thermal_zone_of_sensor_register()
++ * @dev: a valid struct device pointer of a sensor device. Must contain
++ *       a valid .of_node, for the sensor node.
++ * @sensor_id: a sensor identifier, in case the sensor IP has more
++ *	       than one sensors
++ * @data: a private pointer (owned by the caller) that will be passed
++ *	  back, when a temperature reading is needed.
++ * @ops: struct thermal_zone_of_device_ops *. Must contain at least .get_temp.
++ *
++ * Refer thermal_zone_of_sensor_register() for more details.
++ *
++ * Return: On success returns a valid struct thermal_zone_device,
++ * otherwise, it returns a corresponding ERR_PTR(). Caller must
++ * check the return value with help of IS_ERR() helper.
++ * Registered hermal_zone_device device will automatically be
++ * released when device is unbounded.
++ */
++struct thermal_zone_device *devm_thermal_zone_of_sensor_register(
++	struct device *dev, int sensor_id,
++	void *data, const struct thermal_zone_of_device_ops *ops)
++{
++	struct thermal_zone_device **ptr, *tzd;
++
++	ptr = devres_alloc(devm_thermal_zone_of_sensor_release, sizeof(*ptr),
++			   GFP_KERNEL);
++	if (!ptr)
++		return ERR_PTR(-ENOMEM);
++
++	tzd = thermal_zone_of_sensor_register(dev, sensor_id, data, ops);
++	if (IS_ERR(tzd)) {
++		devres_free(ptr);
++		return tzd;
++	}
++
++	*ptr = tzd;
++	devres_add(dev, ptr);
++
++	return tzd;
++}
++EXPORT_SYMBOL_GPL(devm_thermal_zone_of_sensor_register);
++
++/**
++ * devm_thermal_zone_of_sensor_unregister - Resource managed version of
++ *				thermal_zone_of_sensor_unregister().
++ * @dev: Device for which which resource was allocated.
++ * @tzd: a pointer to struct thermal_zone_device where the sensor is registered.
++ *
++ * This function removes the sensor callbacks and private data from the
++ * thermal zone device registered with devm_thermal_zone_of_sensor_register()
++ * API. It will also silent the zone by remove the .get_temp() and .get_trend()
++ * thermal zone device callbacks.
++ * Normally this function will not need to be called and the resource
++ * management code will ensure that the resource is freed.
++ */
++void devm_thermal_zone_of_sensor_unregister(struct device *dev,
++					    struct thermal_zone_device *tzd)
++{
++	WARN_ON(devres_release(dev, devm_thermal_zone_of_sensor_release,
++			       devm_thermal_zone_of_sensor_match, tzd));
++}
++EXPORT_SYMBOL_GPL(devm_thermal_zone_of_sensor_unregister);
++
+ /***   functions parsing device tree nodes   ***/
+ 
+ /**
+--- a/include/linux/thermal.h
++++ b/include/linux/thermal.h
+@@ -364,6 +364,11 @@ thermal_zone_of_sensor_register(struct d
+ 				const struct thermal_zone_of_device_ops *ops);
+ void thermal_zone_of_sensor_unregister(struct device *dev,
+ 				       struct thermal_zone_device *tz);
++struct thermal_zone_device *devm_thermal_zone_of_sensor_register(
++		struct device *dev, int id, void *data,
++		const struct thermal_zone_of_device_ops *ops);
++void devm_thermal_zone_of_sensor_unregister(struct device *dev,
++					    struct thermal_zone_device *tz);
+ #else
+ static inline struct thermal_zone_device *
+ thermal_zone_of_sensor_register(struct device *dev, int id, void *data,
+@@ -378,6 +383,19 @@ void thermal_zone_of_sensor_unregister(s
+ {
+ }
+ 
++static inline struct thermal_zone_device *devm_thermal_zone_of_sensor_register(
++		struct device *dev, int id, void *data,
++		const struct thermal_zone_of_device_ops *ops)
++{
++	return ERR_PTR(-ENODEV);
++}
++
++static inline
++void devm_thermal_zone_of_sensor_unregister(struct device *dev,
++					    struct thermal_zone_device *tz)
++{
++}
++
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_THERMAL)
diff --git a/target/linux/generic/pending-4.4/086-0002-thermal-core-export-apis-to-get-slope-and-offset.patch b/target/linux/generic/pending-4.4/086-0002-thermal-core-export-apis-to-get-slope-and-offset.patch
new file mode 100644
index 0000000000..3fbe5f521a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/086-0002-thermal-core-export-apis-to-get-slope-and-offset.patch
@@ -0,0 +1,101 @@
+From 4a7069a32c99a81950de035535b0a064dcceaeba Mon Sep 17 00:00:00 2001
+From: Rajendra Nayak <rnayak@codeaurora.org>
+Date: Thu, 5 May 2016 14:21:42 +0530
+Subject: [PATCH] thermal: core: export apis to get slope and offset
+
+Add apis for platform thermal drivers to query for slope and offset
+attributes, which might be needed for temperature calculations.
+
+Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
+Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
+Signed-off-by: Zhang Rui <rui.zhang@intel.com>
+---
+ Documentation/thermal/sysfs-api.txt | 12 ++++++++++++
+ drivers/thermal/thermal_core.c      | 30 ++++++++++++++++++++++++++++++
+ include/linux/thermal.h             |  8 ++++++++
+ 3 files changed, 50 insertions(+)
+
+--- a/Documentation/thermal/sysfs-api.txt
++++ b/Documentation/thermal/sysfs-api.txt
+@@ -72,6 +72,18 @@ temperature) and throttle appropriate de
+     It deletes the corresponding entry form /sys/class/thermal folder and
+     unbind all the thermal cooling devices it uses.
+ 
++1.1.7 int thermal_zone_get_slope(struct thermal_zone_device *tz)
++
++	This interface is used to read the slope attribute value
++	for the thermal zone device, which might be useful for platform
++	drivers for temperature calculations.
++
++1.1.8 int thermal_zone_get_offset(struct thermal_zone_device *tz)
++
++	This interface is used to read the offset attribute value
++	for the thermal zone device, which might be useful for platform
++	drivers for temperature calculations.
++
+ 1.2 thermal cooling device interface
+ 1.2.1 struct thermal_cooling_device *thermal_cooling_device_register(char *name,
+ 		void *devdata, struct thermal_cooling_device_ops *)
+--- a/drivers/thermal/thermal_core.c
++++ b/drivers/thermal/thermal_core.c
+@@ -2061,6 +2061,36 @@ exit:
+ }
+ EXPORT_SYMBOL_GPL(thermal_zone_get_zone_by_name);
+ 
++/**
++ * thermal_zone_get_slope - return the slope attribute of the thermal zone
++ * @tz: thermal zone device with the slope attribute
++ *
++ * Return: If the thermal zone device has a slope attribute, return it, else
++ * return 1.
++ */
++int thermal_zone_get_slope(struct thermal_zone_device *tz)
++{
++	if (tz && tz->tzp)
++		return tz->tzp->slope;
++	return 1;
++}
++EXPORT_SYMBOL_GPL(thermal_zone_get_slope);
++
++/**
++ * thermal_zone_get_offset - return the offset attribute of the thermal zone
++ * @tz: thermal zone device with the offset attribute
++ *
++ * Return: If the thermal zone device has a offset attribute, return it, else
++ * return 0.
++ */
++int thermal_zone_get_offset(struct thermal_zone_device *tz)
++{
++	if (tz && tz->tzp)
++		return tz->tzp->offset;
++	return 0;
++}
++EXPORT_SYMBOL_GPL(thermal_zone_get_offset);
++
+ #ifdef CONFIG_NET
+ static const struct genl_multicast_group thermal_event_mcgrps[] = {
+ 	{ .name = THERMAL_GENL_MCAST_GROUP_NAME, },
+--- a/include/linux/thermal.h
++++ b/include/linux/thermal.h
+@@ -432,6 +432,8 @@ thermal_of_cooling_device_register(struc
+ void thermal_cooling_device_unregister(struct thermal_cooling_device *);
+ struct thermal_zone_device *thermal_zone_get_zone_by_name(const char *name);
+ int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp);
++int thermal_zone_get_slope(struct thermal_zone_device *tz);
++int thermal_zone_get_offset(struct thermal_zone_device *tz);
+ 
+ int get_tz_trend(struct thermal_zone_device *, int);
+ struct thermal_instance *get_thermal_instance(struct thermal_zone_device *,
+@@ -489,6 +491,12 @@ static inline struct thermal_zone_device
+ static inline int thermal_zone_get_temp(
+ 		struct thermal_zone_device *tz, int *temp)
+ { return -ENODEV; }
++static inline int thermal_zone_get_slope(
++		struct thermal_zone_device *tz)
++{ return -ENODEV; }
++static inline int thermal_zone_get_offset(
++		struct thermal_zone_device *tz)
++{ return -ENODEV; }
+ static inline int get_tz_trend(struct thermal_zone_device *tz, int trip)
+ { return -ENODEV; }
+ static inline struct thermal_instance *
diff --git a/target/linux/generic/pending-4.4/086-0003-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch b/target/linux/generic/pending-4.4/086-0003-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch
new file mode 100644
index 0000000000..d606804de6
--- /dev/null
+++ b/target/linux/generic/pending-4.4/086-0003-thermal-bcm2835-add-thermal-driver-for-bcm2835-SoC.patch
@@ -0,0 +1,365 @@
+From bcb7dd9ef206f7d646ed8dac6fe7772083714253 Mon Sep 17 00:00:00 2001
+From: Stefan Wahren <stefan.wahren@i2se.com>
+Date: Fri, 31 Mar 2017 20:03:06 +0000
+Subject: [PATCH] thermal: bcm2835: add thermal driver for bcm2835 SoC
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add basic thermal driver for bcm2835 SoC.
+
+This driver currently make sure that tsense HW block is set up
+correctly.
+
+Tested-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
+Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
+Acked-by: Eric Anholt <eric@anholt.net>
+Acked-by: Eduardo Valentin <edubezval@gmail.com>
+Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
+---
+ drivers/thermal/Kconfig           |   8 +
+ drivers/thermal/Makefile          |   1 +
+ drivers/thermal/bcm2835_thermal.c | 314 ++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 323 insertions(+)
+ create mode 100644 drivers/thermal/bcm2835_thermal.c
+
+--- a/drivers/thermal/Kconfig
++++ b/drivers/thermal/Kconfig
+@@ -391,4 +391,12 @@ config QCOM_SPMI_TEMP_ALARM
+ 	  real time die temperature if an ADC is present or an estimate of the
+ 	  temperature based upon the over temperature stage value.
+ 
++config BCM2835_THERMAL
++	tristate "Thermal sensors on bcm2835 SoC"
++	depends on ARCH_BCM2835 || COMPILE_TEST
++	depends on HAS_IOMEM
++	depends on THERMAL_OF
++	help
++	  Support for thermal sensors on Broadcom bcm2835 SoCs.
++
+ endif
+--- a/drivers/thermal/Makefile
++++ b/drivers/thermal/Makefile
+@@ -48,3 +48,4 @@ obj-$(CONFIG_INTEL_PCH_THERMAL)	+= intel
+ obj-$(CONFIG_ST_THERMAL)	+= st/
+ obj-$(CONFIG_TEGRA_SOCTHERM)	+= tegra_soctherm.o
+ obj-$(CONFIG_HISI_THERMAL)     += hisi_thermal.o
++obj-$(CONFIG_BCM2835_THERMAL) += bcm2835_thermal.o
+--- /dev/null
++++ b/drivers/thermal/bcm2835_thermal.c
+@@ -0,0 +1,314 @@
++/*
++ * Driver for Broadcom BCM2835 SoC temperature sensor
++ *
++ * Copyright (C) 2016 Martin Sperl
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/clk.h>
++#include <linux/debugfs.h>
++#include <linux/device.h>
++#include <linux/err.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/thermal.h>
++
++#define BCM2835_TS_TSENSCTL			0x00
++#define BCM2835_TS_TSENSSTAT			0x04
++
++#define BCM2835_TS_TSENSCTL_PRWDW		BIT(0)
++#define BCM2835_TS_TSENSCTL_RSTB		BIT(1)
++
++/*
++ * bandgap reference voltage in 6 mV increments
++ * 000b = 1178 mV, 001b = 1184 mV, ... 111b = 1220 mV
++ */
++#define BCM2835_TS_TSENSCTL_CTRL_BITS		3
++#define BCM2835_TS_TSENSCTL_CTRL_SHIFT		2
++#define BCM2835_TS_TSENSCTL_CTRL_MASK		    \
++	GENMASK(BCM2835_TS_TSENSCTL_CTRL_BITS +     \
++		BCM2835_TS_TSENSCTL_CTRL_SHIFT - 1, \
++		BCM2835_TS_TSENSCTL_CTRL_SHIFT)
++#define BCM2835_TS_TSENSCTL_CTRL_DEFAULT	1
++#define BCM2835_TS_TSENSCTL_EN_INT		BIT(5)
++#define BCM2835_TS_TSENSCTL_DIRECT		BIT(6)
++#define BCM2835_TS_TSENSCTL_CLR_INT		BIT(7)
++#define BCM2835_TS_TSENSCTL_THOLD_SHIFT		8
++#define BCM2835_TS_TSENSCTL_THOLD_BITS		10
++#define BCM2835_TS_TSENSCTL_THOLD_MASK		     \
++	GENMASK(BCM2835_TS_TSENSCTL_THOLD_BITS +     \
++		BCM2835_TS_TSENSCTL_THOLD_SHIFT - 1, \
++		BCM2835_TS_TSENSCTL_THOLD_SHIFT)
++/*
++ * time how long the block to be asserted in reset
++ * which based on a clock counter (TSENS clock assumed)
++ */
++#define BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT	18
++#define BCM2835_TS_TSENSCTL_RSTDELAY_BITS	8
++#define BCM2835_TS_TSENSCTL_REGULEN		BIT(26)
++
++#define BCM2835_TS_TSENSSTAT_DATA_BITS		10
++#define BCM2835_TS_TSENSSTAT_DATA_SHIFT		0
++#define BCM2835_TS_TSENSSTAT_DATA_MASK		     \
++	GENMASK(BCM2835_TS_TSENSSTAT_DATA_BITS +     \
++		BCM2835_TS_TSENSSTAT_DATA_SHIFT - 1, \
++		BCM2835_TS_TSENSSTAT_DATA_SHIFT)
++#define BCM2835_TS_TSENSSTAT_VALID		BIT(10)
++#define BCM2835_TS_TSENSSTAT_INTERRUPT		BIT(11)
++
++struct bcm2835_thermal_data {
++	struct thermal_zone_device *tz;
++	void __iomem *regs;
++	struct clk *clk;
++	struct dentry *debugfsdir;
++};
++
++static int bcm2835_thermal_adc2temp(u32 adc, int offset, int slope)
++{
++	return offset + slope * adc;
++}
++
++static int bcm2835_thermal_temp2adc(int temp, int offset, int slope)
++{
++	temp -= offset;
++	temp /= slope;
++
++	if (temp < 0)
++		temp = 0;
++	if (temp >= BIT(BCM2835_TS_TSENSSTAT_DATA_BITS))
++		temp = BIT(BCM2835_TS_TSENSSTAT_DATA_BITS) - 1;
++
++	return temp;
++}
++
++static int bcm2835_thermal_get_temp(void *d, int *temp)
++{
++	struct bcm2835_thermal_data *data = d;
++	u32 val = readl(data->regs + BCM2835_TS_TSENSSTAT);
++
++	if (!(val & BCM2835_TS_TSENSSTAT_VALID))
++		return -EIO;
++
++	val &= BCM2835_TS_TSENSSTAT_DATA_MASK;
++
++	*temp = bcm2835_thermal_adc2temp(
++		val,
++		thermal_zone_get_offset(data->tz),
++		thermal_zone_get_slope(data->tz));
++
++	return 0;
++}
++
++static const struct debugfs_reg32 bcm2835_thermal_regs[] = {
++	{
++		.name = "ctl",
++		.offset = 0
++	},
++	{
++		.name = "stat",
++		.offset = 4
++	}
++};
++
++static void bcm2835_thermal_debugfs(struct platform_device *pdev)
++{
++	struct thermal_zone_device *tz = platform_get_drvdata(pdev);
++	struct bcm2835_thermal_data *data = tz->devdata;
++	struct debugfs_regset32 *regset;
++
++	data->debugfsdir = debugfs_create_dir("bcm2835_thermal", NULL);
++	if (!data->debugfsdir)
++		return;
++
++	regset = devm_kzalloc(&pdev->dev, sizeof(*regset), GFP_KERNEL);
++	if (!regset)
++		return;
++
++	regset->regs = bcm2835_thermal_regs;
++	regset->nregs = ARRAY_SIZE(bcm2835_thermal_regs);
++	regset->base = data->regs;
++
++	debugfs_create_regset32("regset", 0444, data->debugfsdir, regset);
++}
++
++static struct thermal_zone_of_device_ops bcm2835_thermal_ops = {
++	.get_temp = bcm2835_thermal_get_temp,
++};
++
++/*
++ * Note: as per Raspberry Foundation FAQ
++ * (https://www.raspberrypi.org/help/faqs/#performanceOperatingTemperature)
++ * the recommended temperature range for the SoC -40C to +85C
++ * so the trip limit is set to 80C.
++ * this applies to all the BCM283X SoC
++ */
++
++static const struct of_device_id bcm2835_thermal_of_match_table[] = {
++	{
++		.compatible = "brcm,bcm2835-thermal",
++	},
++	{
++		.compatible = "brcm,bcm2836-thermal",
++	},
++	{
++		.compatible = "brcm,bcm2837-thermal",
++	},
++	{},
++};
++MODULE_DEVICE_TABLE(of, bcm2835_thermal_of_match_table);
++
++static int bcm2835_thermal_probe(struct platform_device *pdev)
++{
++	const struct of_device_id *match;
++	struct thermal_zone_device *tz;
++	struct bcm2835_thermal_data *data;
++	struct resource *res;
++	int err = 0;
++	u32 val;
++	unsigned long rate;
++
++	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	match = of_match_device(bcm2835_thermal_of_match_table,
++				&pdev->dev);
++	if (!match)
++		return -EINVAL;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs)) {
++		err = PTR_ERR(data->regs);
++		dev_err(&pdev->dev, "Could not get registers: %d\n", err);
++		return err;
++	}
++
++	data->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(data->clk)) {
++		err = PTR_ERR(data->clk);
++		if (err != -EPROBE_DEFER)
++			dev_err(&pdev->dev, "Could not get clk: %d\n", err);
++		return err;
++	}
++
++	err = clk_prepare_enable(data->clk);
++	if (err)
++		return err;
++
++	rate = clk_get_rate(data->clk);
++	if ((rate < 1920000) || (rate > 5000000))
++		dev_warn(&pdev->dev,
++			 "Clock %pCn running at %pCr Hz is outside of the recommended range: 1.92 to 5MHz\n",
++			 data->clk, data->clk);
++
++	/* register of thermal sensor and get info from DT */
++	tz = thermal_zone_of_sensor_register(&pdev->dev, 0, data,
++					     &bcm2835_thermal_ops);
++	if (IS_ERR(tz)) {
++		err = PTR_ERR(tz);
++		dev_err(&pdev->dev,
++			"Failed to register the thermal device: %d\n",
++			err);
++		goto err_clk;
++	}
++
++	/*
++	 * right now the FW does set up the HW-block, so we are not
++	 * touching the configuration registers.
++	 * But if the HW is not enabled, then set it up
++	 * using "sane" values used by the firmware right now.
++	 */
++	val = readl(data->regs + BCM2835_TS_TSENSCTL);
++	if (!(val & BCM2835_TS_TSENSCTL_RSTB)) {
++		int trip_temp, offset, slope;
++
++		slope = thermal_zone_get_slope(tz);
++		offset = thermal_zone_get_offset(tz);
++		/*
++		 * For now we deal only with critical, otherwise
++		 * would need to iterate
++		 */
++		err = tz->ops->get_trip_temp(tz, 0, &trip_temp);
++		if (err < 0) {
++			err = PTR_ERR(tz);
++			dev_err(&pdev->dev,
++				"Not able to read trip_temp: %d\n",
++				err);
++			goto err_tz;
++		}
++
++		/* set bandgap reference voltage and enable voltage regulator */
++		val = (BCM2835_TS_TSENSCTL_CTRL_DEFAULT <<
++		       BCM2835_TS_TSENSCTL_CTRL_SHIFT) |
++		      BCM2835_TS_TSENSCTL_REGULEN;
++
++		/* use the recommended reset duration */
++		val |= (0xFE << BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT);
++
++		/*  trip_adc value from info */
++		val |= bcm2835_thermal_temp2adc(trip_temp,
++						offset,
++						slope)
++			<< BCM2835_TS_TSENSCTL_THOLD_SHIFT;
++
++		/* write the value back to the register as 2 steps */
++		writel(val, data->regs + BCM2835_TS_TSENSCTL);
++		val |= BCM2835_TS_TSENSCTL_RSTB;
++		writel(val, data->regs + BCM2835_TS_TSENSCTL);
++	}
++
++	data->tz = tz;
++
++	platform_set_drvdata(pdev, tz);
++
++	bcm2835_thermal_debugfs(pdev);
++
++	return 0;
++err_tz:
++	thermal_zone_of_sensor_unregister(&pdev->dev, tz);
++err_clk:
++	clk_disable_unprepare(data->clk);
++
++	return err;
++}
++
++static int bcm2835_thermal_remove(struct platform_device *pdev)
++{
++	struct thermal_zone_device *tz = platform_get_drvdata(pdev);
++	struct bcm2835_thermal_data *data = tz->devdata;
++
++	debugfs_remove_recursive(data->debugfsdir);
++	thermal_zone_of_sensor_unregister(&pdev->dev, tz);
++	clk_disable_unprepare(data->clk);
++
++	return 0;
++}
++
++static struct platform_driver bcm2835_thermal_driver = {
++	.probe = bcm2835_thermal_probe,
++	.remove = bcm2835_thermal_remove,
++	.driver = {
++		.name = "bcm2835_thermal",
++		.of_match_table = bcm2835_thermal_of_match_table,
++	},
++};
++module_platform_driver(bcm2835_thermal_driver);
++
++MODULE_AUTHOR("Martin Sperl");
++MODULE_DESCRIPTION("Thermal driver for bcm2835 chip");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-4.4/086-0004-thermal-broadcom-add-Northstar-thermal-driver.patch b/target/linux/generic/pending-4.4/086-0004-thermal-broadcom-add-Northstar-thermal-driver.patch
new file mode 100644
index 0000000000..182109632f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/086-0004-thermal-broadcom-add-Northstar-thermal-driver.patch
@@ -0,0 +1,173 @@
+From a94cb7eeecc4104a6874339f90c5d0647359c102 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 3 Apr 2017 17:48:29 +0200
+Subject: [PATCH] thermal: broadcom: add Northstar thermal driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Northstar is a SoC family commonly used in home routers. This commit
+adds a driver for checking CPU temperature. As Northstar Plus seems to
+also have this IP block this new symbol gets ARCH_BCM_IPROC dependency.
+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+Signed-off-by: Jon Mason <jon.mason@broadcom.com>
+Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
+---
+ drivers/thermal/Kconfig               |   5 ++
+ drivers/thermal/Makefile              |   1 +
+ drivers/thermal/broadcom/Kconfig      |   8 +++
+ drivers/thermal/broadcom/Makefile     |   1 +
+ drivers/thermal/broadcom/ns-thermal.c | 105 ++++++++++++++++++++++++++++++++++
+ 5 files changed, 120 insertions(+)
+ create mode 100644 drivers/thermal/broadcom/Kconfig
+ create mode 100644 drivers/thermal/broadcom/Makefile
+ create mode 100644 drivers/thermal/broadcom/ns-thermal.c
+
+--- a/drivers/thermal/Kconfig
++++ b/drivers/thermal/Kconfig
+@@ -365,6 +365,11 @@ config INTEL_PCH_THERMAL
+ 	  Thermal reporting device will provide temperature reading,
+ 	  programmable trip points and other information.
+ 
++menu "Broadcom thermal drivers"
++depends on ARCH_BCM || COMPILE_TEST
++source "drivers/thermal/broadcom/Kconfig"
++endmenu
++
+ menu "Texas Instruments thermal drivers"
+ depends on ARCH_HAS_BANDGAP || COMPILE_TEST
+ source "drivers/thermal/ti-soc-thermal/Kconfig"
+--- a/drivers/thermal/Makefile
++++ b/drivers/thermal/Makefile
+@@ -26,6 +26,7 @@ thermal_sys-$(CONFIG_CLOCK_THERMAL)	+= c
+ thermal_sys-$(CONFIG_DEVFREQ_THERMAL) += devfreq_cooling.o
+ 
+ # platform thermal drivers
++obj-y				+= broadcom/
+ obj-$(CONFIG_QCOM_SPMI_TEMP_ALARM)	+= qcom-spmi-temp-alarm.o
+ obj-$(CONFIG_SPEAR_THERMAL)	+= spear_thermal.o
+ obj-$(CONFIG_ROCKCHIP_THERMAL)	+= rockchip_thermal.o
+--- /dev/null
++++ b/drivers/thermal/broadcom/Kconfig
+@@ -0,0 +1,8 @@
++config BCM_NS_THERMAL
++	tristate "Northstar thermal driver"
++	depends on ARCH_BCM_IPROC || COMPILE_TEST
++	help
++	  Northstar is a family of SoCs that includes e.g. BCM4708, BCM47081,
++	  BCM4709 and BCM47094. It contains DMU (Device Management Unit) block
++	  with a thermal sensor that allows checking CPU temperature. This
++	  driver provides support for it.
+--- /dev/null
++++ b/drivers/thermal/broadcom/Makefile
+@@ -0,0 +1 @@
++obj-$(CONFIG_BCM_NS_THERMAL)		+= ns-thermal.o
+--- /dev/null
++++ b/drivers/thermal/broadcom/ns-thermal.c
+@@ -0,0 +1,105 @@
++/*
++ * Copyright (C) 2017 Rafa Miecki <rafal@milecki.pl>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/of_address.h>
++#include <linux/platform_device.h>
++#include <linux/thermal.h>
++
++#define PVTMON_CONTROL0					0x00
++#define PVTMON_CONTROL0_SEL_MASK			0x0000000e
++#define PVTMON_CONTROL0_SEL_TEMP_MONITOR		0x00000000
++#define PVTMON_CONTROL0_SEL_TEST_MODE			0x0000000e
++#define PVTMON_STATUS					0x08
++
++struct ns_thermal {
++	struct thermal_zone_device *tz;
++	void __iomem *pvtmon;
++};
++
++static int ns_thermal_get_temp(void *data, int *temp)
++{
++	struct ns_thermal *ns_thermal = data;
++	int offset = thermal_zone_get_offset(ns_thermal->tz);
++	int slope = thermal_zone_get_slope(ns_thermal->tz);
++	u32 val;
++
++	val = readl(ns_thermal->pvtmon + PVTMON_CONTROL0);
++	if ((val & PVTMON_CONTROL0_SEL_MASK) != PVTMON_CONTROL0_SEL_TEMP_MONITOR) {
++		/* Clear current mode selection */
++		val &= ~PVTMON_CONTROL0_SEL_MASK;
++
++		/* Set temp monitor mode (it's the default actually) */
++		val |= PVTMON_CONTROL0_SEL_TEMP_MONITOR;
++
++		writel(val, ns_thermal->pvtmon + PVTMON_CONTROL0);
++	}
++
++	val = readl(ns_thermal->pvtmon + PVTMON_STATUS);
++	*temp = slope * val + offset;
++
++	return 0;
++}
++
++static const struct thermal_zone_of_device_ops ns_thermal_ops = {
++	.get_temp = ns_thermal_get_temp,
++};
++
++static int ns_thermal_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct ns_thermal *ns_thermal;
++
++	ns_thermal = devm_kzalloc(dev, sizeof(*ns_thermal), GFP_KERNEL);
++	if (!ns_thermal)
++		return -ENOMEM;
++
++	ns_thermal->pvtmon = of_iomap(dev_of_node(dev), 0);
++	if (WARN_ON(!ns_thermal->pvtmon))
++		return -ENOENT;
++
++	ns_thermal->tz = devm_thermal_zone_of_sensor_register(dev, 0,
++							      ns_thermal,
++							      &ns_thermal_ops);
++	if (IS_ERR(ns_thermal->tz)) {
++		iounmap(ns_thermal->pvtmon);
++		return PTR_ERR(ns_thermal->tz);
++	}
++
++	platform_set_drvdata(pdev, ns_thermal);
++
++	return 0;
++}
++
++static int ns_thermal_remove(struct platform_device *pdev)
++{
++	struct ns_thermal *ns_thermal = platform_get_drvdata(pdev);
++
++	iounmap(ns_thermal->pvtmon);
++
++	return 0;
++}
++
++static const struct of_device_id ns_thermal_of_match[] = {
++	{ .compatible = "brcm,ns-thermal", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, ns_thermal_of_match);
++
++static struct platform_driver ns_thermal_driver = {
++	.probe		= ns_thermal_probe,
++	.remove		= ns_thermal_remove,
++	.driver = {
++		.name = "ns-thermal",
++		.of_match_table = ns_thermal_of_match,
++	},
++};
++module_platform_driver(ns_thermal_driver);
++
++MODULE_DESCRIPTION("Northstar thermal driver");
++MODULE_LICENSE("GPL v2");
diff --git a/target/linux/generic/pending-4.4/086-0005-thermal-broadcom-fix-compilation-of-Northstar-driver.patch b/target/linux/generic/pending-4.4/086-0005-thermal-broadcom-fix-compilation-of-Northstar-driver.patch
new file mode 100644
index 0000000000..62bfffefbe
--- /dev/null
+++ b/target/linux/generic/pending-4.4/086-0005-thermal-broadcom-fix-compilation-of-Northstar-driver.patch
@@ -0,0 +1,19 @@
+From d44264c8735f79da3253520024841311c555ca31 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 14 Apr 2017 22:25:12 +0200
+Subject: [PATCH] thermal: broadcom: fix compilation of Northstar driver
+
+---
+ drivers/thermal/broadcom/ns-thermal.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/thermal/broadcom/ns-thermal.c
++++ b/drivers/thermal/broadcom/ns-thermal.c
+@@ -6,6 +6,7 @@
+  * published by the Free Software Foundation.
+  */
+ 
++#include <asm/io.h>
+ #include <linux/module.h>
+ #include <linux/of_address.h>
+ #include <linux/platform_device.h>
diff --git a/target/linux/generic/pending-4.4/087-regmap-make-LZO-cache-optional.patch b/target/linux/generic/pending-4.4/087-regmap-make-LZO-cache-optional.patch
new file mode 100644
index 0000000000..c26994ee35
--- /dev/null
+++ b/target/linux/generic/pending-4.4/087-regmap-make-LZO-cache-optional.patch
@@ -0,0 +1,69 @@
+From de88e9b0354c2e3ff8eae3f97afe43a34f5ed239 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jonas.gorski@gmail.com>
+Date: Sat, 13 May 2017 13:03:21 +0200
+Subject: [PATCH] regmap: make LZO cache optional
+
+Commit 2cbbb579bcbe3 ("regmap: Add the LZO cache support") added support
+for LZO compression in regcache, but there were never any users added
+afterwards. Since LZO support itself has its own size, it currently is
+rather a deoptimization.
+
+So make it optional by introducing a symbol that can be selected by
+drivers wanting to make use of it.
+
+Saves e.g. ~46 kB on MIPS (size of LZO support + regcache LZO code).
+
+Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
+---
+I tried using google to find any users (even out-of-tree ones), but at
+best I found a single driver submission that was switched to RBTREE in
+subsequent resubmissions (MFD_SMSC).
+
+One could maybe also just drop the code because of no users for 5 years,
+but that would be up to the maintainer(s) to decide.
+
+ drivers/base/regmap/Kconfig    | 5 ++++-
+ drivers/base/regmap/Makefile   | 3 ++-
+ drivers/base/regmap/regcache.c | 2 ++
+ 3 files changed, 8 insertions(+), 2 deletions(-)
+
+--- a/drivers/base/regmap/Kconfig
++++ b/drivers/base/regmap/Kconfig
+@@ -4,9 +4,12 @@
+ 
+ config REGMAP
+ 	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ)
++	select IRQ_DOMAIN if REGMAP_IRQ
++	bool
++
++config REGCACHE_COMPRESSED
+ 	select LZO_COMPRESS
+ 	select LZO_DECOMPRESS
+-	select IRQ_DOMAIN if REGMAP_IRQ
+ 	bool
+ 
+ config REGMAP_AC97
+--- a/drivers/base/regmap/Makefile
++++ b/drivers/base/regmap/Makefile
+@@ -2,7 +2,8 @@
+ CFLAGS_regmap.o := -I$(src)
+ 
+ obj-$(CONFIG_REGMAP) += regmap.o regcache.o
+-obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-lzo.o regcache-flat.o
++obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
++obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
+ obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
+ obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
+ obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
+--- a/drivers/base/regmap/regcache.c
++++ b/drivers/base/regmap/regcache.c
+@@ -21,7 +21,9 @@
+ 
+ static const struct regcache_ops *cache_types[] = {
+ 	&regcache_rbtree_ops,
++#if IS_ENABLED(CONFIG_REGCACHE_COMPRESSED)
+ 	&regcache_lzo_ops,
++#endif
+ 	&regcache_flat_ops,
+ };
+ 
diff --git a/target/linux/generic/pending-4.4/090-MIPS-c-r4k-Use-IPI-calls-for-CM-indexed-cache-ops.patch b/target/linux/generic/pending-4.4/090-MIPS-c-r4k-Use-IPI-calls-for-CM-indexed-cache-ops.patch
new file mode 100644
index 0000000000..0c1c0a4509
--- /dev/null
+++ b/target/linux/generic/pending-4.4/090-MIPS-c-r4k-Use-IPI-calls-for-CM-indexed-cache-ops.patch
@@ -0,0 +1,317 @@
+From: James Hogan <james.hogan@imgtec.com>
+Date: Mon, 25 Jan 2016 21:30:00 +0000
+Subject: [PATCH] MIPS: c-r4k: Use IPI calls for CM indexed cache ops
+
+The Coherence Manager (CM) can propagate address-based ("hit") cache
+operations to other cores in the coherent system, alleviating software
+of the need to use IPI calls, however indexed cache operations are not
+propagated since doing so makes no sense for separate caches.
+
+r4k_on_each_cpu() previously had a special case for CONFIG_MIPS_MT_SMP,
+intended to avoid the IPIs when the only other CPUs in the system were
+other VPEs in the same core, and hence sharing the same caches. This was
+changed by commit cccf34e9411c ("MIPS: c-r4k: Fix cache flushing for MT
+cores") to apparently handle multi-core multi-VPE systems, but it
+focussed mainly on hit cache ops, so the IPI calls were still disabled
+entirely for CM systems.
+
+This doesn't normally cause problems, but tests can be written to hit
+these corner cases by using multiple threads, or changing task
+affinities to force the process to migrate cores. For example the
+failure of mprotect RW->RX to globally sync icaches (via
+flush_cache_range) can be detected by modifying and mprotecting a code
+page on one core, and migrating to a different core to execute from it.
+
+Most of the functions called by r4k_on_each_cpu() perform cache
+operations exclusively with a single addressing-type (virtual address vs
+indexed), so add a type argument and modify the callers to pass in
+R4K_USER (user virtual addressing), R4K_KERN (global kernel virtual
+addressing) or R4K_INDEX (index into cache).
+
+local_r4k_flush_icache_range() is split up, to allow it to be called
+from the rest of the kernel, or from r4k_flush_icache_range() where it
+will choose either indexed or hit cache operations based on the size of
+the range and the cache sizes.
+
+local_r4k_flush_kernel_vmap_range() is split into two functions, each of
+which uses cache operations with a single addressing-type, with
+r4k_flush_kernel_vmap_range() making the decision whether to use indexed
+cache ops or not.
+
+Signed-off-by: James Hogan <james.hogan@imgtec.com>
+Cc: Ralf Baechle <ralf@linux-mips.org>
+Cc: Paul Burton <paul.burton@imgtec.com>
+Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
+Cc: linux-mips@linux-mips.org
+---
+
+--- a/arch/mips/mm/c-r4k.c
++++ b/arch/mips/mm/c-r4k.c
+@@ -40,6 +40,50 @@
+ #include <asm/mips-cm.h>
+ 
+ /*
++ * Bits describing what cache ops an IPI callback function may perform.
++ *
++ * R4K_USER   -	Virtual user address based cache operations.
++ *		Ineffective on other CPUs.
++ * R4K_KERN   -	Virtual kernel address based cache operations (including kmap).
++ *		Effective on other CPUs.
++ * R4K_INDEX -	Index based cache operations.
++ *		Effective on other CPUs.
++ */
++
++#define R4K_USER	BIT(0)
++#define R4K_KERN	BIT(1)
++#define R4K_INDEX	BIT(2)
++
++#ifdef CONFIG_SMP
++/* The Coherence manager propagates address-based cache ops to other cores */
++#define r4k_hit_globalized	mips_cm_present()
++#define r4k_index_globalized	0
++#else
++/* If there's only 1 CPU, then all cache ops are globalized to that 1 CPU */
++#define r4k_hit_globalized	1
++#define r4k_index_globalized	1
++#endif
++
++/**
++ * r4k_op_needs_ipi() - Decide if a cache op needs to be done on every core.
++ * @type:	Type of cache operations (R4K_USER, R4K_KERN or R4K_INDEX).
++ *
++ * Returns:	1 if the cache operation @type should be done on every core in
++ *		the system.
++ *		0 if the cache operation @type is globalized and only needs to
++ *		be performed on a simple CPU.
++ */
++static inline bool r4k_op_needs_ipi(unsigned int type)
++{
++	/*
++	 * If hardware doesn't globalize the required cache ops we must use IPIs
++	 * to do so.
++	 */
++	return (type & R4K_KERN  && !r4k_hit_globalized) ||
++	       (type & R4K_INDEX && !r4k_index_globalized);
++}
++
++/*
+  * Special Variant of smp_call_function for use by cache functions:
+  *
+  *  o No return value
+@@ -48,19 +92,11 @@
+  *    primary cache.
+  *  o doesn't disable interrupts on the local CPU
+  */
+-static inline void r4k_on_each_cpu(void (*func) (void *info), void *info)
++static inline void r4k_on_each_cpu(unsigned int type,
++				   void (*func) (void *info), void *info)
+ {
+ 	preempt_disable();
+-
+-	/*
+-	 * The Coherent Manager propagates address-based cache ops to other
+-	 * cores but not index-based ops. However, r4k_on_each_cpu is used
+-	 * in both cases so there is no easy way to tell what kind of op is
+-	 * executed to the other cores. The best we can probably do is
+-	 * to restrict that call when a CM is not present because both
+-	 * CM-based SMP protocols (CMP & CPS) restrict index-based cache ops.
+-	 */
+-	if (!mips_cm_present())
++	if (r4k_op_needs_ipi(type))
+ 		smp_call_function_many(&cpu_foreign_map, func, info, 1);
+ 	func(info);
+ 	preempt_enable();
+@@ -456,7 +492,7 @@ static inline void local_r4k___flush_cac
+ 
+ static void r4k___flush_cache_all(void)
+ {
+-	r4k_on_each_cpu(local_r4k___flush_cache_all, NULL);
++	r4k_on_each_cpu(R4K_INDEX, local_r4k___flush_cache_all, NULL);
+ }
+ 
+ static inline int has_valid_asid(const struct mm_struct *mm)
+@@ -503,7 +539,7 @@ static void r4k_flush_cache_range(struct
+ 	int exec = vma->vm_flags & VM_EXEC;
+ 
+ 	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc))
+-		r4k_on_each_cpu(local_r4k_flush_cache_range, vma);
++		r4k_on_each_cpu(R4K_INDEX, local_r4k_flush_cache_range, vma);
+ }
+ 
+ static inline void local_r4k_flush_cache_mm(void * args)
+@@ -535,7 +571,7 @@ static void r4k_flush_cache_mm(struct mm
+ 	if (!cpu_has_dc_aliases)
+ 		return;
+ 
+-	r4k_on_each_cpu(local_r4k_flush_cache_mm, mm);
++	r4k_on_each_cpu(R4K_INDEX, local_r4k_flush_cache_mm, mm);
+ }
+ 
+ struct flush_cache_page_args {
+@@ -629,7 +665,7 @@ static void r4k_flush_cache_page(struct
+ 	args.addr = addr;
+ 	args.pfn = pfn;
+ 
+-	r4k_on_each_cpu(local_r4k_flush_cache_page, &args);
++	r4k_on_each_cpu(R4K_KERN, local_r4k_flush_cache_page, &args);
+ }
+ 
+ static inline void local_r4k_flush_data_cache_page(void * addr)
+@@ -642,18 +678,23 @@ static void r4k_flush_data_cache_page(un
+ 	if (in_atomic())
+ 		local_r4k_flush_data_cache_page((void *)addr);
+ 	else
+-		r4k_on_each_cpu(local_r4k_flush_data_cache_page, (void *) addr);
++		r4k_on_each_cpu(R4K_KERN, local_r4k_flush_data_cache_page,
++				(void *) addr);
+ }
+ 
+ struct flush_icache_range_args {
+ 	unsigned long start;
+ 	unsigned long end;
++	unsigned int type;
+ };
+ 
+-static inline void local_r4k_flush_icache_range(unsigned long start, unsigned long end)
++static inline void __local_r4k_flush_icache_range(unsigned long start,
++						  unsigned long end,
++						  unsigned int type)
+ {
+ 	if (!cpu_has_ic_fills_f_dc) {
+-		if (end - start >= dcache_size) {
++		if (type == R4K_INDEX ||
++		    (type & R4K_INDEX && end - start >= dcache_size)) {
+ 			r4k_blast_dcache();
+ 		} else {
+ 			R4600_HIT_CACHEOP_WAR_IMPL;
+@@ -661,7 +702,8 @@ static inline void local_r4k_flush_icach
+ 		}
+ 	}
+ 
+-	if (end - start > icache_size)
++	if (type == R4K_INDEX ||
++	    (type & R4K_INDEX && end - start > icache_size))
+ 		r4k_blast_icache();
+ 	else {
+ 		switch (boot_cpu_type()) {
+@@ -687,23 +729,59 @@ static inline void local_r4k_flush_icach
+ #endif
+ }
+ 
++static inline void local_r4k_flush_icache_range(unsigned long start,
++						unsigned long end)
++{
++	__local_r4k_flush_icache_range(start, end, R4K_KERN | R4K_INDEX);
++}
++
+ static inline void local_r4k_flush_icache_range_ipi(void *args)
+ {
+ 	struct flush_icache_range_args *fir_args = args;
+ 	unsigned long start = fir_args->start;
+ 	unsigned long end = fir_args->end;
++	unsigned int type = fir_args->type;
+ 
+-	local_r4k_flush_icache_range(start, end);
++	__local_r4k_flush_icache_range(start, end, type);
+ }
+ 
+ static void r4k_flush_icache_range(unsigned long start, unsigned long end)
+ {
+ 	struct flush_icache_range_args args;
++	unsigned long size, cache_size;
+ 
+ 	args.start = start;
+ 	args.end = end;
++	args.type = R4K_KERN | R4K_INDEX;
+ 
+-	r4k_on_each_cpu(local_r4k_flush_icache_range_ipi, &args);
++	if (in_atomic()) {
++		/*
++		 * We can't do blocking IPI calls from atomic context, so fall
++		 * back to pure address-based cache ops if they globalize.
++		 */
++		if (!r4k_index_globalized && r4k_hit_globalized) {
++			args.type &= ~R4K_INDEX;
++		} else {
++			/* Just do it locally instead. */
++			local_r4k_flush_icache_range(start, end);
++			instruction_hazard();
++			return;
++		}
++	} else if (!r4k_index_globalized && r4k_hit_globalized) {
++		/*
++		 * If address-based cache ops are globalized, then we may be
++		 * able to avoid the IPI for small flushes.
++		 */
++		size = start - end;
++		cache_size = icache_size;
++		if (!cpu_has_ic_fills_f_dc) {
++			size *= 2;
++			cache_size += dcache_size;
++		}
++		if (size <= cache_size)
++			args.type &= ~R4K_INDEX;
++	}
++	r4k_on_each_cpu(args.type, local_r4k_flush_icache_range_ipi, &args);
+ 	instruction_hazard();
+ }
+ 
+@@ -823,7 +901,12 @@ static void local_r4k_flush_cache_sigtra
+ 
+ static void r4k_flush_cache_sigtramp(unsigned long addr)
+ {
+-	r4k_on_each_cpu(local_r4k_flush_cache_sigtramp, (void *) addr);
++	/*
++	 * FIXME this is a bit broken when !r4k_hit_globalized, since the user
++	 * code probably won't be mapped on other CPUs, so if the process is
++	 * migrated, it could end up hitting stale icache lines.
++	 */
++	r4k_on_each_cpu(R4K_USER, local_r4k_flush_cache_sigtramp, (void *)addr);
+ }
+ 
+ static void r4k_flush_icache_all(void)
+@@ -837,6 +920,15 @@ struct flush_kernel_vmap_range_args {
+ 	int		size;
+ };
+ 
++static inline void local_r4k_flush_kernel_vmap_range_index(void *args)
++{
++	/*
++	 * Aliases only affect the primary caches so don't bother with
++	 * S-caches or T-caches.
++	 */
++	r4k_blast_dcache();
++}
++
+ static inline void local_r4k_flush_kernel_vmap_range(void *args)
+ {
+ 	struct flush_kernel_vmap_range_args *vmra = args;
+@@ -847,12 +939,8 @@ static inline void local_r4k_flush_kerne
+ 	 * Aliases only affect the primary caches so don't bother with
+ 	 * S-caches or T-caches.
+ 	 */
+-	if (cpu_has_safe_index_cacheops && size >= dcache_size)
+-		r4k_blast_dcache();
+-	else {
+-		R4600_HIT_CACHEOP_WAR_IMPL;
+-		blast_dcache_range(vaddr, vaddr + size);
+-	}
++	R4600_HIT_CACHEOP_WAR_IMPL;
++	blast_dcache_range(vaddr, vaddr + size);
+ }
+ 
+ static void r4k_flush_kernel_vmap_range(unsigned long vaddr, int size)
+@@ -862,7 +950,12 @@ static void r4k_flush_kernel_vmap_range(
+ 	args.vaddr = (unsigned long) vaddr;
+ 	args.size = size;
+ 
+-	r4k_on_each_cpu(local_r4k_flush_kernel_vmap_range, &args);
++	if (cpu_has_safe_index_cacheops && size >= dcache_size)
++		r4k_on_each_cpu(R4K_INDEX,
++				local_r4k_flush_kernel_vmap_range_index, NULL);
++	else
++		r4k_on_each_cpu(R4K_KERN, local_r4k_flush_kernel_vmap_range,
++				&args);
+ }
+ 
+ static inline void rm7k_erratum31(void)
diff --git a/target/linux/generic/pending-4.4/091-MIPS-c-r4k-Exclude-sibling-CPUs-in-SMP-calls.patch b/target/linux/generic/pending-4.4/091-MIPS-c-r4k-Exclude-sibling-CPUs-in-SMP-calls.patch
new file mode 100644
index 0000000000..8d5030c84b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/091-MIPS-c-r4k-Exclude-sibling-CPUs-in-SMP-calls.patch
@@ -0,0 +1,37 @@
+From: James Hogan <james.hogan@imgtec.com>
+Date: Thu, 3 Mar 2016 21:30:42 +0000
+Subject: [PATCH] MIPS: c-r4k: Exclude sibling CPUs in SMP calls
+
+When performing SMP calls to foreign cores, exclude sibling CPUs from
+the provided map, as we already handle the local core on the current
+CPU. This prevents an IPI call from for example core 0, VPE 1 to VPE 0
+on the same core.
+
+Signed-off-by: James Hogan <james.hogan@imgtec.com>
+Cc: Ralf Baechle <ralf@linux-mips.org>
+Cc: Paul Burton <paul.burton@imgtec.com>
+Cc: linux-mips@linux-mips.org
+---
+
+--- a/arch/mips/mm/c-r4k.c
++++ b/arch/mips/mm/c-r4k.c
+@@ -96,8 +96,17 @@ static inline void r4k_on_each_cpu(unsig
+ 				   void (*func) (void *info), void *info)
+ {
+ 	preempt_disable();
+-	if (r4k_op_needs_ipi(type))
+-		smp_call_function_many(&cpu_foreign_map, func, info, 1);
++	/* cpu_foreign_map and cpu_sibling_map[] undeclared when !CONFIG_SMP */
++#ifdef CONFIG_SMP
++	if (r4k_op_needs_ipi(type)) {
++		struct cpumask mask;
++
++		/* exclude sibling CPUs */
++		cpumask_andnot(&mask, &cpu_foreign_map,
++			       &cpu_sibling_map[smp_processor_id()]);
++		smp_call_function_many(&mask, func, info, 1);
++	}
++#endif
+ 	func(info);
+ 	preempt_enable();
+ }
diff --git a/target/linux/generic/pending-4.4/092-MIPS-ZBOOT-copy-appended-dtb-to-the-end-of-the-kerne.patch b/target/linux/generic/pending-4.4/092-MIPS-ZBOOT-copy-appended-dtb-to-the-end-of-the-kerne.patch
new file mode 100644
index 0000000000..78188dd298
--- /dev/null
+++ b/target/linux/generic/pending-4.4/092-MIPS-ZBOOT-copy-appended-dtb-to-the-end-of-the-kerne.patch
@@ -0,0 +1,132 @@
+From b8f54f2cde788623f41d11327688c75aed34092f Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Mon, 20 Jun 2016 11:27:36 +0200
+Subject: [PATCH 1/2] MIPS: ZBOOT: copy appended dtb to the end of the kernel
+
+Instead of rewriting the arguments, just move the appended dtb to where
+the decompressed kernel expects it. This eliminates the need for special
+casing vmlinuz.bin appended dtb files.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+Cc: Kevin Cernekee <cernekee@gmail.com>
+Cc: Florian Fainelli <f.fainelli@gmail.com>
+Cc: John Crispin <john@phrozen.org>
+Cc: Paul Burton <paul.burton@imgtec.com>
+Cc: James Hogan <james.hogan@imgtec.com>
+Cc: Alban Bedel <albeu@free.fr>
+Cc: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Cc: Antony Pavlov <antonynpavlov@gmail.com>
+Cc: linux-mips@linux-mips.org
+Patchwork: https://patchwork.linux-mips.org/patch/13698/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+ arch/mips/Kconfig                      | 22 ++--------------------
+ arch/mips/boot/compressed/decompress.c | 17 +++++++++++++++++
+ arch/mips/boot/compressed/head.S       | 16 ----------------
+ 3 files changed, 19 insertions(+), 36 deletions(-)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -2753,10 +2753,10 @@ choice
+ 		  the documented boot protocol using a device tree.
+ 
+ 	config MIPS_RAW_APPENDED_DTB
+-		bool "vmlinux.bin"
++		bool "vmlinux.bin or vmlinuz.bin"
+ 		help
+ 		  With this option, the boot code will look for a device tree binary
+-		  DTB) appended to raw vmlinux.bin (without decompressor).
++		  DTB) appended to raw vmlinux.bin or vmlinuz.bin.
+ 		  (e.g. cat vmlinux.bin <filename>.dtb > vmlinux_w_dtb).
+ 
+ 		  This is meant as a backward compatibility convenience for those
+@@ -2768,24 +2768,6 @@ choice
+ 		  look like a DTB header after a reboot if no actual DTB is appended
+ 		  to vmlinux.bin.  Do not leave this option active in a production kernel
+ 		  if you don't intend to always append a DTB.
+-
+-	config MIPS_ZBOOT_APPENDED_DTB
+-		bool "vmlinuz.bin"
+-		depends on SYS_SUPPORTS_ZBOOT
+-		help
+-		  With this option, the boot code will look for a device tree binary
+-		  DTB) appended to raw vmlinuz.bin (with decompressor).
+-		  (e.g. cat vmlinuz.bin <filename>.dtb > vmlinuz_w_dtb).
+-
+-		  This is meant as a backward compatibility convenience for those
+-		  systems with a bootloader that can't be upgraded to accommodate
+-		  the documented boot protocol using a device tree.
+-
+-		  Beware that there is very little in terms of protection against
+-		  this option being confused by leftover garbage in memory that might
+-		  look like a DTB header after a reboot if no actual DTB is appended
+-		  to vmlinuz.bin.  Do not leave this option active in a production kernel
+-		  if you don't intend to always append a DTB.
+ endchoice
+ 
+ choice
+--- a/arch/mips/boot/compressed/decompress.c
++++ b/arch/mips/boot/compressed/decompress.c
+@@ -14,6 +14,7 @@
+ #include <linux/types.h>
+ #include <linux/kernel.h>
+ #include <linux/string.h>
++#include <linux/libfdt.h>
+ 
+ #include <asm/addrspace.h>
+ 
+@@ -36,6 +37,8 @@ extern void puthex(unsigned long long va
+ #define puthex(val) do {} while (0)
+ #endif
+ 
++extern char __appended_dtb[];
++
+ void error(char *x)
+ {
+ 	puts("\n\n");
+@@ -114,6 +117,20 @@ void decompress_kernel(unsigned long boo
+ 	__decompress((char *)zimage_start, zimage_size, 0, 0,
+ 		   (void *)VMLINUX_LOAD_ADDRESS_ULL, 0, 0, error);
+ 
++	if (IS_ENABLED(CONFIG_MIPS_RAW_APPENDED_DTB) &&
++	    fdt_magic((void *)&__appended_dtb) == FDT_MAGIC) {
++		unsigned int image_size, dtb_size;
++
++		dtb_size = fdt_totalsize((void *)&__appended_dtb);
++
++		/* last four bytes is always image size in little endian */
++		image_size = le32_to_cpup((void *)&__image_end - 4);
++
++		/* copy dtb to where the booted kernel will expect it */
++		memcpy((void *)VMLINUX_LOAD_ADDRESS_ULL + image_size,
++		       __appended_dtb, dtb_size);
++	}
++
+ 	/* FIXME: should we flush cache here? */
+ 	puts("Now, booting the kernel...\n");
+ }
+--- a/arch/mips/boot/compressed/head.S
++++ b/arch/mips/boot/compressed/head.S
+@@ -25,22 +25,6 @@ start:
+ 	move	s2, a2
+ 	move	s3, a3
+ 
+-#ifdef CONFIG_MIPS_ZBOOT_APPENDED_DTB
+-	PTR_LA	t0, __appended_dtb
+-#ifdef CONFIG_CPU_BIG_ENDIAN
+-	li	t1, 0xd00dfeed
+-#else
+-	li	t1, 0xedfe0dd0
+-#endif
+-	lw	t2, (t0)
+-	bne	t1, t2, not_found
+-	 nop
+-
+-	move	s1, t0
+-	PTR_LI	s0, -2
+-not_found:
+-#endif
+-
+ 	/* Clear BSS */
+ 	PTR_LA	a0, _edata
+ 	PTR_LA	a2, _end
diff --git a/target/linux/generic/pending-4.4/093-MIPS-store-the-appended-dtb-address-in-a-variable.patch b/target/linux/generic/pending-4.4/093-MIPS-store-the-appended-dtb-address-in-a-variable.patch
new file mode 100644
index 0000000000..d868d210aa
--- /dev/null
+++ b/target/linux/generic/pending-4.4/093-MIPS-store-the-appended-dtb-address-in-a-variable.patch
@@ -0,0 +1,132 @@
+From 15f37e1588920e010f20b53f04af94e91b8ee714 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Mon, 20 Jun 2016 11:27:37 +0200
+Subject: [PATCH] MIPS: store the appended dtb address in a variable
+
+Instead of rewriting the arguments to match the UHI spec, store the
+address of a appended or UHI supplied dtb in fw_supplied_dtb.
+
+That way the original bootloader arugments are kept intact while still
+making the use of an appended dtb invisible for mach code.
+
+Mach code can still find out if it is an appended dtb by comparing
+fw_arg1 with fw_supplied_dtb.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+Cc: Kevin Cernekee <cernekee@gmail.com>
+Cc: Florian Fainelli <f.fainelli@gmail.com>
+Cc: John Crispin <john@phrozen.org>
+Cc: Paul Burton <paul.burton@imgtec.com>
+Cc: James Hogan <james.hogan@imgtec.com>
+Cc: Alban Bedel <albeu@free.fr>
+Cc: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Cc: Antony Pavlov <antonynpavlov@gmail.com>
+Cc: linux-mips@linux-mips.org
+Patchwork: https://patchwork.linux-mips.org/patch/13699/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+ arch/mips/ath79/setup.c          |  4 ++--
+ arch/mips/bmips/setup.c          |  4 ++--
+ arch/mips/include/asm/bootinfo.h |  4 ++++
+ arch/mips/kernel/head.S          | 21 ++++++++++++++-------
+ arch/mips/kernel/setup.c         |  4 ++++
+ arch/mips/lantiq/prom.c          |  4 ++--
+ arch/mips/pic32/pic32mzda/init.c |  4 ++--
+ 7 files changed, 30 insertions(+), 15 deletions(-)
+
+--- a/arch/mips/ath79/setup.c
++++ b/arch/mips/ath79/setup.c
+@@ -207,6 +207,8 @@ void __init plat_mem_setup(void)
+ 	fdt_start = fw_getenvl("fdt_start");
+ 	if (fdt_start)
+ 		__dt_setup_arch((void *)KSEG0ADDR(fdt_start));
++	else if (fw_passed_dtb)
++		__dt_setup_arch((void *)KSEG0ADDR(fw_passed_dtb));
+ #ifdef CONFIG_BUILTIN_DTB
+ 	else
+ 		__dt_setup_arch(__dtb_start);
+--- a/arch/mips/bmips/setup.c
++++ b/arch/mips/bmips/setup.c
+@@ -149,8 +149,8 @@ void __init plat_mem_setup(void)
+ 	/* intended to somewhat resemble ARM; see Documentation/arm/Booting */
+ 	if (fw_arg0 == 0 && fw_arg1 == 0xffffffff)
+ 		dtb = phys_to_virt(fw_arg2);
+-	else if (fw_arg0 == -2) /* UHI interface */
+-		dtb = (void *)fw_arg1;
++	else if (fw_passed_dtb) /* UHI interface */
++		dtb = (void *)fw_passed_dtb;
+ 	else if (__dtb_start != __dtb_end)
+ 		dtb = (void *)__dtb_start;
+ 	else
+--- a/arch/mips/include/asm/bootinfo.h
++++ b/arch/mips/include/asm/bootinfo.h
+@@ -127,6 +127,10 @@ extern char arcs_cmdline[COMMAND_LINE_SI
+  */
+ extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
+ 
++#ifdef CONFIG_USE_OF
++extern unsigned long fw_passed_dtb;
++#endif
++
+ /*
+  * Platform memory detection hook called by setup_arch
+  */
+--- a/arch/mips/kernel/head.S
++++ b/arch/mips/kernel/head.S
+@@ -94,21 +94,24 @@ NESTED(kernel_entry, 16, sp)			# kernel
+ 	jr	t0
+ 0:
+ 
++#ifdef CONFIG_USE_OF
+ #ifdef CONFIG_MIPS_RAW_APPENDED_DTB
+-	PTR_LA		t0, __appended_dtb
++	PTR_LA		t2, __appended_dtb
+ 
+ #ifdef CONFIG_CPU_BIG_ENDIAN
+ 	li		t1, 0xd00dfeed
+ #else
+ 	li		t1, 0xedfe0dd0
+ #endif
+-	lw		t2, (t0)
+-	bne		t1, t2, not_found
+-	 nop
+-
+-	move		a1, t0
+-	PTR_LI		a0, -2
+-not_found:
++	lw		t0, (t2)
++	beq		t0, t1, dtb_found
++#endif
++	li		t1, -2
++	beq		a0, t1, dtb_found
++	move		t2, a1
++
++	li		t2, 0
++dtb_found:
+ #endif
+ 	PTR_LA		t0, __bss_start		# clear .bss
+ 	LONG_S		zero, (t0)
+@@ -123,6 +126,10 @@ not_found:
+ 	LONG_S		a2, fw_arg2
+ 	LONG_S		a3, fw_arg3
+ 
++#ifdef CONFIG_USE_OF
++	LONG_S		t2, fw_passed_dtb
++#endif
++
+ 	MTC0		zero, CP0_CONTEXT	# clear context register
+ 	PTR_LA		$28, init_thread_union
+ 	/* Set the SP after an empty pt_regs.  */
+--- a/arch/mips/kernel/setup.c
++++ b/arch/mips/kernel/setup.c
+@@ -886,6 +886,10 @@ void __init setup_arch(char **cmdline_p)
+ unsigned long kernelsp[NR_CPUS];
+ unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
+ 
++#ifdef CONFIG_USE_OF
++unsigned long fw_passed_dtb;
++#endif
++
+ #ifdef CONFIG_DEBUG_FS
+ struct dentry *mips_debugfs_dir;
+ static int __init debugfs_mips(void)
diff --git a/target/linux/generic/pending-4.4/094-MIPS-c-r4k-Fix-size-calc-when-avoiding-IPIs-for-smal.patch b/target/linux/generic/pending-4.4/094-MIPS-c-r4k-Fix-size-calc-when-avoiding-IPIs-for-smal.patch
new file mode 100644
index 0000000000..733d9c77b3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/094-MIPS-c-r4k-Fix-size-calc-when-avoiding-IPIs-for-smal.patch
@@ -0,0 +1,38 @@
+From: Paul Burton <paul.burton@imgtec.com>
+Date: Mon, 5 Sep 2016 15:24:54 +0100
+Subject: [PATCH] MIPS: c-r4k: Fix size calc when avoiding IPIs for small
+ icache flushes
+
+Commit f70ddc07b637 ("MIPS: c-r4k: Avoid small flush_icache_range SMP
+calls") adds checks to force use of hit-type cache ops for small icache
+flushes where they are globalised & index-type cache ops aren't, in
+order to avoid the overhead of IPIs in those cases. However it
+calculated the size of the region being flushed incorrectly, subtracting
+the end address from the start address rather than the reverse. This
+would have led to an overflow with size wrapping round to some large
+value, and likely to the special case for avoiding IPIs not actually
+being hit.
+
+Signed-off-by: Paul Burton <paul.burton@imgtec.com>
+Cc: James Hogan <james.hogan@imgtec.com>
+Fixes: f70ddc07b637 ("MIPS: c-r4k: Avoid small flush_icache_range SMP calls")
+Reviewed-by: James Hogan <james.hogan@imgtec.com>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Cc: Huacai Chen <chenhc@lemote.com>
+Cc: linux-mips@linux-mips.org
+Cc: linux-kernel@vger.kernel.org
+Patchwork: https://patchwork.linux-mips.org/patch/14211/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+
+--- a/arch/mips/mm/c-r4k.c
++++ b/arch/mips/mm/c-r4k.c
+@@ -781,7 +781,7 @@ static void r4k_flush_icache_range(unsig
+ 		 * If address-based cache ops are globalized, then we may be
+ 		 * able to avoid the IPI for small flushes.
+ 		 */
+-		size = start - end;
++		size = end - start;
+ 		cache_size = icache_size;
+ 		if (!cpu_has_ic_fills_f_dc) {
+ 			size *= 2;
diff --git a/target/linux/generic/pending-4.4/096-arc-add-model-property-in-dts.patch b/target/linux/generic/pending-4.4/096-arc-add-model-property-in-dts.patch
new file mode 100644
index 0000000000..85019ed008
--- /dev/null
+++ b/target/linux/generic/pending-4.4/096-arc-add-model-property-in-dts.patch
@@ -0,0 +1,163 @@
+From f1e53ac0a99e3754465bd87ae1a6fdbfb8340d15 Mon Sep 17 00:00:00 2001
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Date: Mon, 15 Aug 2016 14:42:44 +0300
+Subject: [PATCH] arc: Add "model" properly in device tree description of all
+ boards
+
+As it was discussed quite some time ago (see
+https://lkml.org/lkml/2015/11/5/862) it's a good practice to add
+"model" property in .dts. Moreover as per ePAPR "model" property is
+required and should look like "manufacturer,model" so we do here.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+Cc: Vineet Gupta <vgupta@synopsys.com>
+Cc: Jonas Gorski <jonas.gorski@gmail.com>
+Cc: Arnd Bergmann <arnd@arndb.de>
+Cc: Rob Herring <robh@kernel.org>
+Cc: Christian Ruppert <christian.ruppert@alitech.com>
+---
+ arch/arc/boot/dts/abilis_tb100_dvk.dts | 1 +
+ arch/arc/boot/dts/abilis_tb101_dvk.dts | 1 +
+ arch/arc/boot/dts/axs101.dts           | 1 +
+ arch/arc/boot/dts/axs103.dts           | 1 +
+ arch/arc/boot/dts/axs103_idu.dts       | 1 +
+ arch/arc/boot/dts/nsim_700.dts         | 1 +
+ arch/arc/boot/dts/nsim_hs.dts          | 1 +
+ arch/arc/boot/dts/nsim_hs_idu.dts      | 1 +
+ arch/arc/boot/dts/nsimosci.dts         | 1 +
+ arch/arc/boot/dts/nsimosci_hs.dts      | 1 +
+ arch/arc/boot/dts/nsimosci_hs_idu.dts  | 1 +
+ arch/arc/boot/dts/vdk_hs38.dts         | 1 +
+ arch/arc/boot/dts/vdk_hs38_smp.dts     | 1 +
+ 13 files changed, 13 insertions(+)
+
+--- a/arch/arc/boot/dts/abilis_tb100_dvk.dts
++++ b/arch/arc/boot/dts/abilis_tb100_dvk.dts
+@@ -24,6 +24,7 @@
+ /include/ "abilis_tb100.dtsi"
+ 
+ / {
++	model = "abilis,tb100";
+ 	chosen {
+ 		bootargs = "earlycon=uart8250,mmio32,0xff100000,9600n8 console=ttyS0,9600n8";
+ 	};
+--- a/arch/arc/boot/dts/abilis_tb101_dvk.dts
++++ b/arch/arc/boot/dts/abilis_tb101_dvk.dts
+@@ -24,6 +24,7 @@
+ /include/ "abilis_tb101.dtsi"
+ 
+ / {
++	model = "abilis,tb101";
+ 	chosen {
+ 		bootargs = "earlycon=uart8250,mmio32,0xff100000,9600n8 console=ttyS0,9600n8";
+ 	};
+--- a/arch/arc/boot/dts/axs101.dts
++++ b/arch/arc/boot/dts/axs101.dts
+@@ -13,6 +13,7 @@
+ /include/ "axs10x_mb.dtsi"
+ 
+ / {
++	model = "snps,axs101";
+ 	compatible = "snps,axs101", "snps,arc-sdp";
+ 
+ 	chosen {
+--- a/arch/arc/boot/dts/axs103.dts
++++ b/arch/arc/boot/dts/axs103.dts
+@@ -16,6 +16,7 @@
+ /include/ "axs10x_mb.dtsi"
+ 
+ / {
++	model = "snps,axs103";
+ 	compatible = "snps,axs103", "snps,arc-sdp";
+ 
+ 	chosen {
+--- a/arch/arc/boot/dts/axs103_idu.dts
++++ b/arch/arc/boot/dts/axs103_idu.dts
+@@ -16,6 +16,7 @@
+ /include/ "axs10x_mb.dtsi"
+ 
+ / {
++	model = "snps,axs103-smp";
+ 	compatible = "snps,axs103", "snps,arc-sdp";
+ 
+ 	chosen {
+--- a/arch/arc/boot/dts/nsim_700.dts
++++ b/arch/arc/boot/dts/nsim_700.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsim";
+ 	compatible = "snps,nsim";
+ 	clock-frequency = <80000000>;	/* 80 MHZ */
+ 	#address-cells = <1>;
+--- a/arch/arc/boot/dts/nsim_hs.dts
++++ b/arch/arc/boot/dts/nsim_hs.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsim_hs";
+ 	compatible = "snps,nsim_hs";
+ 	#address-cells = <2>;
+ 	#size-cells = <2>;
+--- a/arch/arc/boot/dts/nsim_hs_idu.dts
++++ b/arch/arc/boot/dts/nsim_hs_idu.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsim_hs-smp";
+ 	compatible = "snps,nsim_hs";
+ 	interrupt-parent = <&core_intc>;
+ 
+--- a/arch/arc/boot/dts/nsimosci.dts
++++ b/arch/arc/boot/dts/nsimosci.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsimosci";
+ 	compatible = "snps,nsimosci";
+ 	clock-frequency = <20000000>;	/* 20 MHZ */
+ 	#address-cells = <1>;
+--- a/arch/arc/boot/dts/nsimosci_hs.dts
++++ b/arch/arc/boot/dts/nsimosci_hs.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsimosci_hs";
+ 	compatible = "snps,nsimosci_hs";
+ 	clock-frequency = <20000000>;	/* 20 MHZ */
+ 	#address-cells = <1>;
+--- a/arch/arc/boot/dts/nsimosci_hs_idu.dts
++++ b/arch/arc/boot/dts/nsimosci_hs_idu.dts
+@@ -10,6 +10,7 @@
+ /include/ "skeleton.dtsi"
+ 
+ / {
++	model = "snps,nsimosci_hs-smp";
+ 	compatible = "snps,nsimosci_hs";
+ 	clock-frequency = <5000000>;	/* 5 MHZ */
+ 	#address-cells = <1>;
+--- a/arch/arc/boot/dts/vdk_hs38.dts
++++ b/arch/arc/boot/dts/vdk_hs38.dts
+@@ -13,6 +13,7 @@
+ /include/ "vdk_axs10x_mb.dtsi"
+ 
+ / {
++	model = "snps,vdk_archs";
+ 	compatible = "snps,axs103";
+ 
+ 	chosen {
+--- a/arch/arc/boot/dts/vdk_hs38_smp.dts
++++ b/arch/arc/boot/dts/vdk_hs38_smp.dts
+@@ -13,6 +13,7 @@
+ /include/ "vdk_axs10x_mb.dtsi"
+ 
+ / {
++	model = "snps,vdk_archs-smp";
+ 	compatible = "snps,axs103";
+ 
+ 	chosen {
diff --git a/target/linux/generic/pending-4.4/097-MIPS-io.h-Define-ioremap_cache.patch b/target/linux/generic/pending-4.4/097-MIPS-io.h-Define-ioremap_cache.patch
new file mode 100644
index 0000000000..e048410e42
--- /dev/null
+++ b/target/linux/generic/pending-4.4/097-MIPS-io.h-Define-ioremap_cache.patch
@@ -0,0 +1,29 @@
+From a68f376844605399cbd28b662d5ed213639f46f7 Mon Sep 17 00:00:00 2001
+From: "Maciej W. Rozycki" <macro@imgtec.com>
+Date: Sat, 9 Jan 2016 02:05:31 +0000
+Subject: [PATCH] MIPS: io.h: Define `ioremap_cache'
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Maciej W. Rozycki <macro@imgtec.com>
+Cc: Brian Norris <computersforpeace@gmail.com>
+Cc: Rafa Miecki <zajec5@gmail.com>
+Cc: linux-mips@linux-mips.org
+Cc: linux-kernel@vger.kernel.org
+Patchwork: https://patchwork.linux-mips.org/patch/12040/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+ arch/mips/include/asm/io.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/mips/include/asm/io.h
++++ b/arch/mips/include/asm/io.h
+@@ -275,6 +275,7 @@ static inline void __iomem * __ioremap_m
+  */
+ #define ioremap_cachable(offset, size)					\
+ 	__ioremap_mode((offset), (size), _page_cachable_default)
++#define ioremap_cache ioremap_cachable
+ 
+ /*
+  * These two are MIPS specific ioremap variant.	 ioremap_cacheable_cow
diff --git a/target/linux/generic/pending-4.4/098-usb-dwc2-Remove-unnecessary-kfree.patch b/target/linux/generic/pending-4.4/098-usb-dwc2-Remove-unnecessary-kfree.patch
new file mode 100644
index 0000000000..3a27feac8f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/098-usb-dwc2-Remove-unnecessary-kfree.patch
@@ -0,0 +1,24 @@
+From cd4b1e34655d46950c065d9284b596cd8d7b28cd Mon Sep 17 00:00:00 2001
+From: John Youn <johnyoun@synopsys.com>
+Date: Thu, 3 Nov 2016 17:55:45 -0700
+Subject: [PATCH] usb: dwc2: Remove unnecessary kfree
+
+This shouldn't be freed by the HCD as it is owned by the core and
+allocated with devm_kzalloc.
+
+Signed-off-by: John Youn <johnyoun@synopsys.com>
+Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
+---
+ drivers/usb/dwc2/hcd.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/usb/dwc2/hcd.c
++++ b/drivers/usb/dwc2/hcd.c
+@@ -3160,7 +3160,6 @@ error3:
+ error2:
+ 	usb_put_hcd(hcd);
+ error1:
+-	kfree(hsotg->core_params);
+ 
+ #ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS
+ 	kfree(hsotg->last_frame_num_array);
diff --git a/target/linux/generic/pending-4.4/101-MIPS-fix-cache-flushing-for-highmem-pages.patch b/target/linux/generic/pending-4.4/101-MIPS-fix-cache-flushing-for-highmem-pages.patch
new file mode 100644
index 0000000000..e4ac2cd583
--- /dev/null
+++ b/target/linux/generic/pending-4.4/101-MIPS-fix-cache-flushing-for-highmem-pages.patch
@@ -0,0 +1,31 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 24 Jan 2016 01:03:51 +0100
+Subject: [PATCH] MIPS: fix cache flushing for highmem pages
+
+Most cache flush ops were no-op for highmem pages. This led to nasty
+segfaults and (in the case of page_address(page) == NULL) kernel
+crashes.
+
+Fix this by always flushing highmem pages using kmap/kunmap_atomic
+around the actual cache flush. This might be a bit inefficient, but at
+least it's stable.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/mm/cache.c
++++ b/arch/mips/mm/cache.c
+@@ -111,6 +111,13 @@ void __flush_anon_page(struct page *page
+ {
+ 	unsigned long addr = (unsigned long) page_address(page);
+ 
++	if (PageHighMem(page)) {
++		addr = (unsigned long)kmap_atomic(page);
++		flush_data_cache_page(addr);
++		__kunmap_atomic((void *)addr);
++		return;
++	}
++
+ 	if (pages_do_alias(addr, vmaddr)) {
+ 		if (page_mapped(page) && !Page_dcache_dirty(page)) {
+ 			void *kaddr;
diff --git a/target/linux/generic/pending-4.4/102-ehci_hcd_ignore_oc.patch b/target/linux/generic/pending-4.4/102-ehci_hcd_ignore_oc.patch
new file mode 100644
index 0000000000..71e3a74ad5
--- /dev/null
+++ b/target/linux/generic/pending-4.4/102-ehci_hcd_ignore_oc.patch
@@ -0,0 +1,82 @@
+From 1e311820ec3055e3f08e687de6564692a7cec675 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <florian@openwrt.org>
+Date: Mon, 28 Jan 2013 20:06:29 +0100
+Subject: [PATCH 11/12] USB: EHCI: add ignore_oc flag to disable overcurrent
+ checking
+
+This patch adds an ignore_oc flag which can be set by EHCI controller
+not supporting or wanting to disable overcurrent checking. The EHCI
+platform data in include/linux/usb/ehci_pdriver.h is also augmented to
+take advantage of this new flag.
+
+Signed-off-by: Florian Fainelli <florian@openwrt.org>
+---
+ drivers/usb/host/ehci-hcd.c      |    2 +-
+ drivers/usb/host/ehci-hub.c      |    4 ++--
+ drivers/usb/host/ehci-platform.c |    1 +
+ drivers/usb/host/ehci.h          |    1 +
+ include/linux/usb/ehci_pdriver.h |    1 +
+ 5 files changed, 6 insertions(+), 3 deletions(-)
+
+--- a/drivers/usb/host/ehci-hcd.c
++++ b/drivers/usb/host/ehci-hcd.c
+@@ -639,7 +639,7 @@ static int ehci_run (struct usb_hcd *hcd
+ 		"USB %x.%x started, EHCI %x.%02x%s\n",
+ 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
+ 		temp >> 8, temp & 0xff,
+-		ignore_oc ? ", overcurrent ignored" : "");
++		(ignore_oc || ehci->ignore_oc) ? ", overcurrent ignored" : "");
+ 
+ 	ehci_writel(ehci, INTR_MASK,
+ 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
+--- a/drivers/usb/host/ehci-hub.c
++++ b/drivers/usb/host/ehci-hub.c
+@@ -634,7 +634,7 @@ ehci_hub_status_data (struct usb_hcd *hc
+ 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
+ 	 * PORT_POWER; that's surprising, but maybe within-spec.
+ 	 */
+-	if (!ignore_oc)
++	if (!ignore_oc && !ehci->ignore_oc)
+ 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
+ 	else
+ 		mask = PORT_CSC | PORT_PEC;
+@@ -996,7 +996,7 @@ int ehci_hub_control(
+ 		if (temp & PORT_PEC)
+ 			status |= USB_PORT_STAT_C_ENABLE << 16;
+ 
+-		if ((temp & PORT_OCC) && !ignore_oc){
++		if ((temp & PORT_OCC) && (!ignore_oc && !ehci->ignore_oc)){
+ 			status |= USB_PORT_STAT_C_OVERCURRENT << 16;
+ 
+ 			/*
+--- a/drivers/usb/host/ehci-platform.c
++++ b/drivers/usb/host/ehci-platform.c
+@@ -254,6 +254,8 @@ static int ehci_platform_probe(struct pl
+ 		hcd->has_tt = 1;
+ 	if (pdata->reset_on_resume)
+ 		priv->reset_on_resume = true;
++	if (pdata->ignore_oc)
++		ehci->ignore_oc = 1;
+ 
+ #ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+ 	if (ehci->big_endian_mmio) {
+--- a/drivers/usb/host/ehci.h
++++ b/drivers/usb/host/ehci.h
+@@ -227,6 +227,7 @@ struct ehci_hcd {			/* one per controlle
+ 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
+ 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
+ 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
++	unsigned		ignore_oc:1;
+ 
+ 	/* required for usb32 quirk */
+ 	#define OHCI_CTRL_HCFS          (3 << 6)
+--- a/include/linux/usb/ehci_pdriver.h
++++ b/include/linux/usb/ehci_pdriver.h
+@@ -49,6 +49,7 @@ struct usb_ehci_pdata {
+ 	unsigned	no_io_watchdog:1;
+ 	unsigned	reset_on_resume:1;
+ 	unsigned	dma_mask_64:1;
++	unsigned	ignore_oc:1;
+ 
+ 	/* Turn on all power and clocks */
+ 	int (*power_on)(struct platform_device *pdev);
diff --git a/target/linux/generic/pending-4.4/103-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch b/target/linux/generic/pending-4.4/103-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch
new file mode 100644
index 0000000000..a53be2d15c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/103-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch
@@ -0,0 +1,86 @@
+From: Tobias Wolf <dev-NTEO@vplace.de>
+Date: Wed, 30 Nov 2016 09:16:41 +0100
+Subject: [PATCH] mm: Fix alloc_node_mem_map with ARCH_PFN_OFFSET
+ calculation
+
+Dear folks,
+
+An rt288x (ralink) based router (Belkin F5D8235 v1) does not boot with any
+kernel beyond version 4.3 resulting in:
+
+BUG: Bad page state in process swapper  pfn:086ac
+
+bisect resulted in:
+
+a1c34a3bf00af2cede839879502e12dc68491ad5 is the first bad commit
+commit a1c34a3bf00af2cede839879502e12dc68491ad5
+Author: Laura Abbott <laura@labbott.name>
+Date:   Thu Nov 5 18:48:46 2015 -0800
+
+    mm: Don't offset memmap for flatmem
+
+    Srinivas Kandagatla reported bad page messages when trying to remove the
+    bottom 2MB on an ARM based IFC6410 board
+
+      BUG: Bad page state in process swapper  pfn:fffa8
+      page:ef7fb500 count:0 mapcount:0 mapping:  (null) index:0x0
+      flags: 0x96640253(locked|error|dirty|active|arch_1|reclaim|mlocked)
+      page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
+      bad because of flags:
+      flags: 0x200041(locked|active|mlocked)
+      Modules linked in:
+      CPU: 0 PID: 0 Comm: swapper Not tainted 3.19.0-rc3-00007-g412f9ba-dirty
+#816
+      Hardware name: Qualcomm (Flattened Device Tree)
+        unwind_backtrace
+        show_stack
+        dump_stack
+        bad_page
+        free_pages_prepare
+        free_hot_cold_page
+        __free_pages
+        free_highmem_page
+        mem_init
+        start_kernel
+      Disabling lock debugging due to kernel taint
+    [...]
+:040000 040000 2de013c372345fd471cd58f0553c9b38b0ef1cc4
+0a8156f848733dfa21e16c196dfb6c0a76290709 M      mm
+
+This fix for ARM does not account ARCH_PFN_OFFSET for mem_map as later used by
+page_to_pfn anymore.
+
+The following output was generated with two hacked in printk statements:
+
+printk("before %p vs. %p or %p\n", mem_map, mem_map - offset, mem_map -
+(pgdat->node_start_pfn - ARCH_PFN_OFFSET));
+		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
+			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
+printk("after %p\n", mem_map);
+
+Output:
+
+[    0.000000] before 8861b280 vs. 8861b280 or 8851b280
+[    0.000000] after 8851b280
+
+As seen in the first line mem_map with subtraction of offset does not equal the
+mem_map after subtraction of ARCH_PFN_OFFSET.
+
+After adding the offset of ARCH_PFN_OFFSET as well to mem_map as the
+previously calculated offset is zero for the named platform it is able to boot
+4.4 and 4.9-rc7 again.
+
+Signed-off-by: Tobias Wolf <dev-NTEO@vplace.de>
+---
+
+--- a/mm/page_alloc.c
++++ b/mm/page_alloc.c
+@@ -5372,7 +5372,7 @@ static void __init_refok alloc_node_mem_
+ 		mem_map = NODE_DATA(0)->node_mem_map;
+ #if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)
+ 		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
+-			mem_map -= offset;
++			mem_map -= offset + (pgdat->node_start_pfn - ARCH_PFN_OFFSET);
+ #endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */
+ 	}
+ #endif
diff --git a/target/linux/generic/pending-4.4/105-add-linux-spidev-compatible.patch b/target/linux/generic/pending-4.4/105-add-linux-spidev-compatible.patch
new file mode 100644
index 0000000000..cae20a532a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/105-add-linux-spidev-compatible.patch
@@ -0,0 +1,15 @@
+Add the linux,spidev compatible in spidev
+Several device in ramips have this binding in the dts
+
+Signed-off-by: Giuseppe Lippolis <giu.lippolis@gmail.com>
+---
+--- a/drivers/spi/spidev.c
++++ b/drivers/spi/spidev.c
+@@ -695,6 +695,7 @@ static struct class *spidev_class;
+ static const struct of_device_id spidev_dt_ids[] = {
+ 	{ .compatible = "rohm,dh2228fv" },
+ 	{ .compatible = "lineartechnology,ltc2488" },
++	{ .compatible = "siliconlabs,si3210" },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/target/linux/generic/pending-4.4/106-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch b/target/linux/generic/pending-4.4/106-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch
new file mode 100644
index 0000000000..57c9475359
--- /dev/null
+++ b/target/linux/generic/pending-4.4/106-spi-use-gpio_set_value_cansleep-for-setting-chipsele.patch
@@ -0,0 +1,21 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 30 Dec 2016 14:53:45 +0100
+Subject: [PATCH] spi: use gpio_set_value_cansleep for setting chipselect GPIO
+
+Sleeping is safe inside spi_transfer_one_message, and some GPIO chips
+need to sleep for setting values
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/spi/spi.c
++++ b/drivers/spi/spi.c
+@@ -674,7 +674,7 @@ static void spi_set_cs(struct spi_device
+ 		enable = !enable;
+ 
+ 	if (gpio_is_valid(spi->cs_gpio))
+-		gpio_set_value(spi->cs_gpio, !enable);
++		gpio_set_value_cansleep(spi->cs_gpio, !enable);
+ 	else if (spi->master->set_cs)
+ 		spi->master->set_cs(spi, !enable);
+ }
diff --git a/target/linux/generic/pending-4.4/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch b/target/linux/generic/pending-4.4/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
new file mode 100644
index 0000000000..b7ff845343
--- /dev/null
+++ b/target/linux/generic/pending-4.4/110-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
@@ -0,0 +1,86 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 10 Apr 2015 13:35:29 +0200
+Subject: [PATCH] jffs2: use .rename2 and add RENAME_WHITEOUT support
+
+It is required for renames on overlayfs
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/fs/jffs2/dir.c
++++ b/fs/jffs2/dir.c
+@@ -35,7 +35,7 @@ static int jffs2_mkdir (struct inode *,s
+ static int jffs2_rmdir (struct inode *,struct dentry *);
+ static int jffs2_mknod (struct inode *,struct dentry *,umode_t,dev_t);
+ static int jffs2_rename (struct inode *, struct dentry *,
+-			 struct inode *, struct dentry *);
++			 struct inode *, struct dentry *, unsigned int);
+ 
+ const struct file_operations jffs2_dir_operations =
+ {
+@@ -57,7 +57,7 @@ const struct inode_operations jffs2_dir_
+ 	.mkdir =	jffs2_mkdir,
+ 	.rmdir =	jffs2_rmdir,
+ 	.mknod =	jffs2_mknod,
+-	.rename =	jffs2_rename,
++	.rename2 =	jffs2_rename,
+ 	.get_acl =	jffs2_get_acl,
+ 	.set_acl =	jffs2_set_acl,
+ 	.setattr =	jffs2_setattr,
+@@ -754,8 +754,27 @@ static int jffs2_mknod (struct inode *di
+ 	return ret;
+ }
+ 
++static int jffs2_whiteout(struct inode *old_dir, struct dentry *old_dentry)
++{
++	struct dentry *wh;
++	int err;
++
++	wh = d_alloc(old_dentry->d_parent, &old_dentry->d_name);
++	if (!wh)
++		return -ENOMEM;
++
++	err = jffs2_mknod(old_dir, wh, S_IFCHR | WHITEOUT_MODE,
++			  WHITEOUT_DEV);
++	if (err)
++		return err;
++
++	d_rehash(wh);
++	return 0;
++}
++
+ static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
+-			 struct inode *new_dir_i, struct dentry *new_dentry)
++			 struct inode *new_dir_i, struct dentry *new_dentry,
++			 unsigned int flags)
+ {
+ 	int ret;
+ 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
+@@ -763,6 +782,9 @@ static int jffs2_rename (struct inode *o
+ 	uint8_t type;
+ 	uint32_t now;
+ 
++	if (flags & ~RENAME_WHITEOUT)
++		return -EINVAL;
++
+ 	/* The VFS will check for us and prevent trying to rename a
+ 	 * file over a directory and vice versa, but if it's a directory,
+ 	 * the VFS can't check whether the victim is empty. The filesystem
+@@ -826,9 +848,14 @@ static int jffs2_rename (struct inode *o
+ 	if (d_is_dir(old_dentry) && !victim_f)
+ 		inc_nlink(new_dir_i);
+ 
+-	/* Unlink the original */
+-	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
+-			      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);
++	if (flags & RENAME_WHITEOUT)
++		/* Replace with whiteout */
++		ret = jffs2_whiteout(old_dir_i, old_dentry);
++	else
++		/* Unlink the original */
++		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
++				      old_dentry->d_name.name,
++				      old_dentry->d_name.len, NULL, now);
+ 
+ 	/* We don't touch inode->i_nlink */
+ 
diff --git a/target/linux/generic/pending-4.4/111-jffs2-add-RENAME_EXCHANGE-support.patch b/target/linux/generic/pending-4.4/111-jffs2-add-RENAME_EXCHANGE-support.patch
new file mode 100644
index 0000000000..37eb073df9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/111-jffs2-add-RENAME_EXCHANGE-support.patch
@@ -0,0 +1,81 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 25 Apr 2015 12:41:32 +0200
+Subject: [PATCH] jffs2: add RENAME_EXCHANGE support
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/fs/jffs2/dir.c
++++ b/fs/jffs2/dir.c
+@@ -779,18 +779,31 @@ static int jffs2_rename (struct inode *o
+ 	int ret;
+ 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
+ 	struct jffs2_inode_info *victim_f = NULL;
++	struct inode *fst_inode = d_inode(old_dentry);
++	struct inode *snd_inode = d_inode(new_dentry);
+ 	uint8_t type;
+ 	uint32_t now;
+ 
+-	if (flags & ~RENAME_WHITEOUT)
++	if (flags & ~(RENAME_WHITEOUT | RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
++	if ((flags & RENAME_EXCHANGE) && (old_dir_i != new_dir_i)) {
++		if (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {
++			inc_nlink(new_dir_i);
++			drop_nlink(old_dir_i);
++		}
++		else if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {
++			drop_nlink(new_dir_i);
++			inc_nlink(old_dir_i);
++		}
++	}
++
+ 	/* The VFS will check for us and prevent trying to rename a
+ 	 * file over a directory and vice versa, but if it's a directory,
+ 	 * the VFS can't check whether the victim is empty. The filesystem
+ 	 * needs to do that for itself.
+ 	 */
+-	if (d_really_is_positive(new_dentry)) {
++	if (d_really_is_positive(new_dentry) && !(flags & RENAME_EXCHANGE)) {
+ 		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
+ 		if (d_is_dir(new_dentry)) {
+ 			struct jffs2_full_dirent *fd;
+@@ -825,7 +838,7 @@ static int jffs2_rename (struct inode *o
+ 	if (ret)
+ 		return ret;
+ 
+-	if (victim_f) {
++	if (victim_f && !(flags & RENAME_EXCHANGE)) {
+ 		/* There was a victim. Kill it off nicely */
+ 		if (d_is_dir(new_dentry))
+ 			clear_nlink(d_inode(new_dentry));
+@@ -845,12 +858,18 @@ static int jffs2_rename (struct inode *o
+ 
+ 	/* If it was a directory we moved, and there was no victim,
+ 	   increase i_nlink on its new parent */
+-	if (d_is_dir(old_dentry) && !victim_f)
++	if (d_is_dir(old_dentry) && !victim_f && !(flags & RENAME_EXCHANGE))
+ 		inc_nlink(new_dir_i);
+ 
+ 	if (flags & RENAME_WHITEOUT)
+ 		/* Replace with whiteout */
+ 		ret = jffs2_whiteout(old_dir_i, old_dentry);
++	else if (flags & RENAME_EXCHANGE)
++		/* Replace the original */
++		ret = jffs2_do_link(c, JFFS2_INODE_INFO(old_dir_i),
++				    d_inode(new_dentry)->i_ino, type,
++				    old_dentry->d_name.name, old_dentry->d_name.len,
++				    now);
+ 	else
+ 		/* Unlink the original */
+ 		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
+@@ -882,7 +901,7 @@ static int jffs2_rename (struct inode *o
+ 		return ret;
+ 	}
+ 
+-	if (d_is_dir(old_dentry))
++	if (d_is_dir(old_dentry) && !(flags & RENAME_EXCHANGE))
+ 		drop_nlink(old_dir_i);
+ 
+ 	new_dir_i->i_mtime = new_dir_i->i_ctime = old_dir_i->i_mtime = old_dir_i->i_ctime = ITIME(now);
diff --git a/target/linux/generic/pending-4.4/120-bridge_allow_receiption_on_disabled_port.patch b/target/linux/generic/pending-4.4/120-bridge_allow_receiption_on_disabled_port.patch
new file mode 100644
index 0000000000..bba6074982
--- /dev/null
+++ b/target/linux/generic/pending-4.4/120-bridge_allow_receiption_on_disabled_port.patch
@@ -0,0 +1,54 @@
+From: Stephen Hemminger <stephen@networkplumber.org>
+Subject: bridge: allow receiption on disabled port
+
+When an ethernet device is enslaved to a bridge, and the bridge STP
+detects loss of carrier (or operational state down), then normally
+packet receiption is blocked.
+
+This breaks control applications like WPA which maybe expecting to
+receive packets to negotiate to bring link up. The bridge needs to
+block forwarding packets from these disabled ports, but there is no
+hard requirement to not allow local packet delivery.
+
+Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -218,11 +218,13 @@ EXPORT_SYMBOL_GPL(br_handle_frame_finish
+ static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
+-	u16 vid = 0;
++	if (p->state != BR_STATE_DISABLED) {
++		u16 vid = 0;
+ 
+-	/* check if vlan is allowed, to avoid spoofing */
+-	if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
+-		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
++		/* check if vlan is allowed, to avoid spoofing */
++		if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
++			br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
++	}
+ 	return 0;	 /* process further */
+ }
+ 
+@@ -297,6 +299,18 @@ rx_handler_result_t br_handle_frame(stru
+ 
+ forward:
+ 	switch (p->state) {
++	case BR_STATE_DISABLED:
++		if (ether_addr_equal(p->br->dev->dev_addr, dest))
++			skb->pkt_type = PACKET_HOST;
++
++		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, dev_net(skb->dev), NULL, skb, skb->dev, NULL,
++			br_handle_local_finish))
++			break;
++
++		BR_INPUT_SKB_CB(skb)->brdev = p->br->dev;
++		br_pass_frame_up(skb);
++		break;
++
+ 	case BR_STATE_FORWARDING:
+ 		rhook = rcu_dereference(br_should_route_hook);
+ 		if (rhook) {
diff --git a/target/linux/generic/pending-4.4/132-mips_inline_dma_ops.patch b/target/linux/generic/pending-4.4/132-mips_inline_dma_ops.patch
new file mode 100644
index 0000000000..143b0bb3ff
--- /dev/null
+++ b/target/linux/generic/pending-4.4/132-mips_inline_dma_ops.patch
@@ -0,0 +1,778 @@
+From 2c58080407554e1bac8fd50d23cb02420524caed Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 12 Aug 2013 12:50:22 +0200
+Subject: [PATCH] MIPS: partially inline dma ops
+
+Several DMA ops are no-op on many platforms, and the indirection through
+the mips_dma_map_ops function table is causing the compiler to emit
+unnecessary code.
+
+Inlining visibly improves network performance in my tests (on a 24Kc
+based system), and also slightly reduces code size of a few drivers.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/mips/Kconfig                   |   4 +
+ arch/mips/include/asm/dma-mapping.h | 360 +++++++++++++++++++++++++++++++++++-
+ arch/mips/mm/dma-default.c          | 163 ++--------------
+ 3 files changed, 373 insertions(+), 154 deletions(-)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1619,6 +1619,7 @@ config CPU_CAVIUM_OCTEON
+ 	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
+ 	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
+ 	select MIPS_L1_CACHE_SHIFT_7
++	select SYS_HAS_DMA_OPS
+ 	help
+ 	  The Cavium Octeon processor is a highly integrated chip containing
+ 	  many ethernet hardware widgets for networking tasks. The processor
+@@ -1914,6 +1915,9 @@ config MIPS_MALTA_PM
+ 	bool
+ 	default y
+ 
++config SYS_HAS_DMA_OPS
++	bool
++
+ #
+ # CPU may reorder R->R, R->W, W->R, W->W
+ # Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
+--- a/arch/mips/include/asm/dma-mapping.h
++++ b/arch/mips/include/asm/dma-mapping.h
+@@ -1,9 +1,16 @@
+ #ifndef _ASM_DMA_MAPPING_H
+ #define _ASM_DMA_MAPPING_H
+ 
++#include <linux/kmemcheck.h>
++#include <linux/bug.h>
+ #include <linux/scatterlist.h>
++#include <linux/dma-debug.h>
++#include <linux/dma-attrs.h>
++
+ #include <asm/dma-coherence.h>
+ #include <asm/cache.h>
++#include <asm/cpu-type.h>
++#include <asm-generic/dma-coherent.h>
+ 
+ #ifndef CONFIG_SGI_IP27 /* Kludge to fix 2.6.39 build for IP27 */
+ #include <dma-coherence.h>
+@@ -11,12 +18,53 @@
+ 
+ extern struct dma_map_ops *mips_dma_map_ops;
+ 
++void __dma_sync(struct page *page, unsigned long offset, size_t size,
++		enum dma_data_direction direction);
++void *mips_dma_alloc_coherent(struct device *dev, size_t size,
++			      dma_addr_t *dma_handle, gfp_t gfp,
++			      struct dma_attrs *attrs);
++void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
++			    dma_addr_t dma_handle, struct dma_attrs *attrs);
++
+ static inline struct dma_map_ops *get_dma_ops(struct device *dev)
+ {
++#ifdef CONFIG_SYS_HAS_DMA_OPS
+ 	if (dev && dev->archdata.dma_ops)
+ 		return dev->archdata.dma_ops;
+ 	else
+ 		return mips_dma_map_ops;
++#else
++	return NULL;
++#endif
++}
++
++/*
++ * The affected CPUs below in 'cpu_needs_post_dma_flush()' can
++ * speculatively fill random cachelines with stale data at any time,
++ * requiring an extra flush post-DMA.
++ *
++ * Warning on the terminology - Linux calls an uncached area coherent;
++ * MIPS terminology calls memory areas with hardware maintained coherency
++ * coherent.
++ *
++ * Note that the R14000 and R16000 should also be checked for in this
++ * condition.  However this function is only called on non-I/O-coherent
++ * systems and only the R10000 and R12000 are used in such systems, the
++ * SGI IP28 Indigo rsp. SGI IP32 aka O2.
++ */
++static inline int cpu_needs_post_dma_flush(struct device *dev)
++{
++	return !plat_device_is_coherent(dev) &&
++	       (boot_cpu_type() == CPU_R10000 ||
++		boot_cpu_type() == CPU_R12000 ||
++		boot_cpu_type() == CPU_BMIPS5000);
++}
++
++static inline struct page *dma_addr_to_page(struct device *dev,
++	dma_addr_t dma_addr)
++{
++	return pfn_to_page(
++		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
+ }
+ 
+ static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
+@@ -29,9 +77,399 @@ static inline bool dma_capable(struct de
+ 
+ static inline void dma_mark_clean(void *addr, size_t size) {}
+ 
+-#include <asm-generic/dma-mapping-common.h>
++static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
++					      size_t size,
++					      enum dma_data_direction dir,
++					      struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	unsigned long offset = (unsigned long)ptr & ~PAGE_MASK;
++	struct page *page = virt_to_page(ptr);
++	dma_addr_t addr;
++
++	kmemcheck_mark_initialized(ptr, size);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		addr = ops->map_page(dev, page, offset, size, dir, attrs);
++	} else {
++		if (!plat_device_is_coherent(dev))
++			__dma_sync(page, offset, size, dir);
++
++		addr = plat_map_dma_mem_page(dev, page) + offset;
++	}
++	debug_dma_map_page(dev, page, offset, size, dir, addr, true);
++	return addr;
++}
++
++static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
++					  size_t size,
++					  enum dma_data_direction dir,
++					  struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->unmap_page(dev, addr, size, dir, attrs);
++	} else {
++		if (cpu_needs_post_dma_flush(dev))
++			__dma_sync(dma_addr_to_page(dev, addr),
++				   addr & ~PAGE_MASK, size, dir);
++		plat_post_dma_flush(dev);
++		plat_unmap_dma_mem(dev, addr, size, dir);
++	}
++	debug_dma_unmap_page(dev, addr, size, dir, true);
++}
++
++/*
++ * dma_maps_sg_attrs returns 0 on error and > 0 on success.
++ * It should never return a value < 0.
++ */
++static inline int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
++				   int nents, enum dma_data_direction dir,
++				   struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	int i, ents;
++	struct scatterlist *s;
++
++	for_each_sg(sg, s, nents, i)
++		kmemcheck_mark_initialized(sg_virt(s), s->length);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ents = ops->map_sg(dev, sg, nents, dir, attrs);
++	} else {
++		for_each_sg(sg, s, nents, i) {
++			struct page *page = sg_page(s);
++
++			if (!plat_device_is_coherent(dev))
++				__dma_sync(page, s->offset, s->length, dir);
++#ifdef CONFIG_NEED_SG_DMA_LENGTH
++			s->dma_length = s->length;
++#endif
++			s->dma_address =
++				plat_map_dma_mem_page(dev, page) + s->offset;
++		}
++		ents = nents;
++	}
++	BUG_ON(ents < 0);
++	debug_dma_map_sg(dev, sg, nents, ents, dir);
++
++	return ents;
++}
++
++static inline void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
++				      int nents, enum dma_data_direction dir,
++				      struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	debug_dma_unmap_sg(dev, sg, nents, dir);
++	if (ops) {
++		ops->unmap_sg(dev, sg, nents, dir, attrs);
++		return;
++	}
++	for_each_sg(sg, s, nents, i) {
++		if (!plat_device_is_coherent(dev) && dir != DMA_TO_DEVICE)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++		plat_unmap_dma_mem(dev, s->dma_address, s->length, dir);
++	}
++}
++
++static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
++				      size_t offset, size_t size,
++				      enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	dma_addr_t addr;
++
++	kmemcheck_mark_initialized(page_address(page) + offset, size);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		addr = ops->map_page(dev, page, offset, size, dir, NULL);
++	} else {
++		if (!plat_device_is_coherent(dev))
++			__dma_sync(page, offset, size, dir);
++
++		addr = plat_map_dma_mem_page(dev, page) + offset;
++	}
++	debug_dma_map_page(dev, page, offset, size, dir, addr, false);
++
++	return addr;
++}
++
++static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
++				  size_t size, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->unmap_page(dev, addr, size, dir, NULL);
++	} else {
++		if (cpu_needs_post_dma_flush(dev))
++			__dma_sync(dma_addr_to_page(dev, addr),
++				   addr & ~PAGE_MASK, size, dir);
++		plat_post_dma_flush(dev);
++		plat_unmap_dma_mem(dev, addr, size, dir);
++	}
++	debug_dma_unmap_page(dev, addr, size, dir, false);
++}
++
++static inline void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,
++					   size_t size,
++					   enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->sync_single_for_cpu(dev, addr, size, dir);
++	} else {
++		if (cpu_needs_post_dma_flush(dev))
++			__dma_sync(dma_addr_to_page(dev, addr),
++				   addr & ~PAGE_MASK, size, dir);
++		plat_post_dma_flush(dev);
++	}
++	debug_dma_sync_single_for_cpu(dev, addr, size, dir);
++}
++
++static inline void dma_sync_single_for_device(struct device *dev,
++					      dma_addr_t addr, size_t size,
++					      enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_device(dev, addr, size, dir);
++	else if (!plat_device_is_coherent(dev))
++		__dma_sync(dma_addr_to_page(dev, addr),
++			   addr & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_for_device(dev, addr, size, dir);
++}
++
++static inline void dma_sync_single_range_for_cpu(struct device *dev,
++						 dma_addr_t addr,
++						 unsigned long offset,
++						 size_t size,
++						 enum dma_data_direction dir)
++{
++	const struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->sync_single_for_cpu(dev, addr + offset, size, dir);
++	} else {
++		if (cpu_needs_post_dma_flush(dev))
++			__dma_sync(dma_addr_to_page(dev, addr + offset),
++				   (addr + offset) & ~PAGE_MASK, size, dir);
++		plat_post_dma_flush(dev);
++	}
++
++	debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, dir);
++}
++
++static inline void dma_sync_single_range_for_device(struct device *dev,
++						    dma_addr_t addr,
++						    unsigned long offset,
++						    size_t size,
++						    enum dma_data_direction dir)
++{
++	const struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_device(dev, addr + offset, size, dir);
++	else if (!plat_device_is_coherent(dev))
++		__dma_sync(dma_addr_to_page(dev, addr + offset),
++			   (addr + offset) & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_range_for_device(dev, addr, offset, size, dir);
++}
++
++static inline void
++dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
++		    int nelems, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
++	} else if (cpu_needs_post_dma_flush(dev)) {
++		for_each_sg(sg, s, nelems, i)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++	}
++	plat_post_dma_flush(dev);
++	debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
++}
++
++static inline void
++dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
++		       int nelems, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->sync_sg_for_device(dev, sg, nelems, dir);
++	} else if (!plat_device_is_coherent(dev)) {
++		for_each_sg(sg, s, nelems, i)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++	}
++	debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
++
++}
++
++#define dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)
++#define dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)
++#define dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)
++#define dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)
++
++extern int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
++			   void *cpu_addr, dma_addr_t dma_addr, size_t size);
++
++/**
++ * dma_mmap_attrs - map a coherent DMA allocation into user space
++ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
++ * @vma: vm_area_struct describing requested user mapping
++ * @cpu_addr: kernel CPU-view address returned from dma_alloc_attrs
++ * @handle: device-view address returned from dma_alloc_attrs
++ * @size: size of memory originally requested in dma_alloc_attrs
++ * @attrs: attributes of mapping properties requested in dma_alloc_attrs
++ *
++ * Map a coherent DMA buffer previously allocated by dma_alloc_attrs
++ * into user space.  The coherent DMA buffer must not be freed by the
++ * driver until the user space mapping has been released.
++ */
++static inline int
++dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma, void *cpu_addr,
++	       dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	BUG_ON(!ops);
++	if (ops && ops->mmap)
++		return ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);
++	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);
++}
++
++#define dma_mmap_coherent(d, v, c, h, s) dma_mmap_attrs(d, v, c, h, s, NULL)
++
++int
++dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
++		       void *cpu_addr, dma_addr_t dma_addr, size_t size);
++
++static inline int
++dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt, void *cpu_addr,
++		      dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	BUG_ON(!ops);
++	if (ops && ops->get_sgtable)
++		return ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size,
++					attrs);
++	return dma_common_get_sgtable(dev, sgt, cpu_addr, dma_addr, size);
++}
++
++#define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, NULL)
++
++static inline int dma_supported(struct device *dev, u64 mask)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	if (ops)
++		return ops->dma_supported(dev, mask);
++	return plat_dma_supported(dev, mask);
++}
++
++static inline int dma_mapping_error(struct device *dev, u64 mask)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	debug_dma_mapping_error(dev, mask);
++	if (ops)
++		return ops->mapping_error(dev, mask);
++	return 0;
++}
++
++static inline int
++dma_set_mask(struct device *dev, u64 mask)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	if(!dev->dma_mask || !dma_supported(dev, mask))
++		return -EIO;
++
++	if (ops && ops->set_dma_mask)
++		return ops->set_dma_mask(dev, mask);
++
++	*dev->dma_mask = mask;
++
++	return 0;
++}
+ 
+ extern void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+ 	       enum dma_data_direction direction);
+ 
++#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)
++
++static inline void *dma_alloc_attrs(struct device *dev, size_t size,
++				    dma_addr_t *dma_handle, gfp_t gfp,
++				    struct dma_attrs *attrs)
++{
++	void *ret;
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	if (ops)
++		ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
++	else
++		ret = mips_dma_alloc_coherent(dev, size, dma_handle, gfp,
++					      attrs);
++
++	debug_dma_alloc_coherent(dev, size, *dma_handle, ret);
++
++	return ret;
++}
++
++#define dma_free_coherent(d,s,c,h) dma_free_attrs(d,s,c,h,NULL)
++
++static inline void dma_free_attrs(struct device *dev, size_t size,
++				  void *vaddr, dma_addr_t dma_handle,
++				  struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	if (ops)
++		ops->free(dev, size, vaddr, dma_handle, attrs);
++	else
++		mips_dma_free_coherent(dev, size, vaddr, dma_handle, attrs);
++
++	debug_dma_free_coherent(dev, size, vaddr, dma_handle);
++}
++
++static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
++		dma_addr_t *dma_handle, gfp_t gfp)
++{
++	DEFINE_DMA_ATTRS(attrs);
++
++	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
++	return dma_alloc_attrs(dev, size, dma_handle, gfp, &attrs);
++}
++
++static inline void dma_free_noncoherent(struct device *dev, size_t size,
++		void *cpu_addr, dma_addr_t dma_handle)
++{
++	DEFINE_DMA_ATTRS(attrs);
++
++	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
++	dma_free_attrs(dev, size, cpu_addr, dma_handle, &attrs);
++}
++
++
+ #endif /* _ASM_DMA_MAPPING_H */
+--- a/arch/mips/mm/dma-default.c
++++ b/arch/mips/mm/dma-default.c
+@@ -46,35 +46,6 @@ static int __init setnocoherentio(char *
+ early_param("nocoherentio", setnocoherentio);
+ #endif
+ 
+-static inline struct page *dma_addr_to_page(struct device *dev,
+-	dma_addr_t dma_addr)
+-{
+-	return pfn_to_page(
+-		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
+-}
+-
+-/*
+- * The affected CPUs below in 'cpu_needs_post_dma_flush()' can
+- * speculatively fill random cachelines with stale data at any time,
+- * requiring an extra flush post-DMA.
+- *
+- * Warning on the terminology - Linux calls an uncached area coherent;
+- * MIPS terminology calls memory areas with hardware maintained coherency
+- * coherent.
+- *
+- * Note that the R14000 and R16000 should also be checked for in this
+- * condition.  However this function is only called on non-I/O-coherent
+- * systems and only the R10000 and R12000 are used in such systems, the
+- * SGI IP28 Indigo rsp. SGI IP32 aka O2.
+- */
+-static inline int cpu_needs_post_dma_flush(struct device *dev)
+-{
+-	return !plat_device_is_coherent(dev) &&
+-	       (boot_cpu_type() == CPU_R10000 ||
+-		boot_cpu_type() == CPU_R12000 ||
+-		boot_cpu_type() == CPU_BMIPS5000);
+-}
+-
+ static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
+ {
+ 	gfp_t dma_flag;
+@@ -129,7 +100,7 @@ static void *mips_dma_alloc_noncoherent(
+ 	return ret;
+ }
+ 
+-static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
++void *mips_dma_alloc_coherent(struct device *dev, size_t size,
+ 	dma_addr_t * dma_handle, gfp_t gfp, struct dma_attrs *attrs)
+ {
+ 	void *ret;
+@@ -165,6 +136,7 @@ static void *mips_dma_alloc_coherent(str
+ 
+ 	return ret;
+ }
++EXPORT_SYMBOL(mips_dma_alloc_coherent);
+ 
+ 
+ static void mips_dma_free_noncoherent(struct device *dev, size_t size,
+@@ -174,7 +146,7 @@ static void mips_dma_free_noncoherent(st
+ 	free_pages((unsigned long) vaddr, get_order(size));
+ }
+ 
+-static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
++void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+ 	dma_addr_t dma_handle, struct dma_attrs *attrs)
+ {
+ 	unsigned long addr = (unsigned long) vaddr;
+@@ -196,40 +168,7 @@ static void mips_dma_free_coherent(struc
+ 	if (!dma_release_from_contiguous(dev, page, count))
+ 		__free_pages(page, get_order(size));
+ }
+-
+-static int mips_dma_mmap(struct device *dev, struct vm_area_struct *vma,
+-	void *cpu_addr, dma_addr_t dma_addr, size_t size,
+-	struct dma_attrs *attrs)
+-{
+-	unsigned long user_count = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+-	unsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+-	unsigned long addr = (unsigned long)cpu_addr;
+-	unsigned long off = vma->vm_pgoff;
+-	unsigned long pfn;
+-	int ret = -ENXIO;
+-
+-	if (!plat_device_is_coherent(dev) && !hw_coherentio)
+-		addr = CAC_ADDR(addr);
+-
+-	pfn = page_to_pfn(virt_to_page((void *)addr));
+-
+-	if (dma_get_attr(DMA_ATTR_WRITE_COMBINE, attrs))
+-		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+-	else
+-		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+-
+-	if (dma_mmap_from_coherent(dev, vma, cpu_addr, size, &ret))
+-		return ret;
+-
+-	if (off < count && user_count <= (count - off)) {
+-		ret = remap_pfn_range(vma, vma->vm_start,
+-				      pfn + off,
+-				      user_count << PAGE_SHIFT,
+-				      vma->vm_page_prot);
+-	}
+-
+-	return ret;
+-}
++EXPORT_SYMBOL(mips_dma_free_coherent);
+ 
+ static inline void __dma_sync_virtual(void *addr, size_t size,
+ 	enum dma_data_direction direction)
+@@ -258,7 +197,7 @@ static inline void __dma_sync_virtual(vo
+  * If highmem is not configured then the bulk of this loop gets
+  * optimized out.
+  */
+-static inline void __dma_sync(struct page *page,
++void __dma_sync(struct page *page,
+ 	unsigned long offset, size_t size, enum dma_data_direction direction)
+ {
+ 	size_t left = size;
+@@ -288,120 +227,7 @@ static inline void __dma_sync(struct pag
+ 		left -= len;
+ 	} while (left);
+ }
+-
+-static void mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,
+-	size_t size, enum dma_data_direction direction, struct dma_attrs *attrs)
+-{
+-	if (cpu_needs_post_dma_flush(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_addr),
+-			   dma_addr & ~PAGE_MASK, size, direction);
+-	plat_post_dma_flush(dev);
+-	plat_unmap_dma_mem(dev, dma_addr, size, direction);
+-}
+-
+-static int mips_dma_map_sg(struct device *dev, struct scatterlist *sglist,
+-	int nents, enum dma_data_direction direction, struct dma_attrs *attrs)
+-{
+-	int i;
+-	struct scatterlist *sg;
+-
+-	for_each_sg(sglist, sg, nents, i) {
+-		if (!plat_device_is_coherent(dev))
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-#ifdef CONFIG_NEED_SG_DMA_LENGTH
+-		sg->dma_length = sg->length;
+-#endif
+-		sg->dma_address = plat_map_dma_mem_page(dev, sg_page(sg)) +
+-				  sg->offset;
+-	}
+-
+-	return nents;
+-}
+-
+-static dma_addr_t mips_dma_map_page(struct device *dev, struct page *page,
+-	unsigned long offset, size_t size, enum dma_data_direction direction,
+-	struct dma_attrs *attrs)
+-{
+-	if (!plat_device_is_coherent(dev))
+-		__dma_sync(page, offset, size, direction);
+-
+-	return plat_map_dma_mem_page(dev, page) + offset;
+-}
+-
+-static void mips_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,
+-	int nhwentries, enum dma_data_direction direction,
+-	struct dma_attrs *attrs)
+-{
+-	int i;
+-	struct scatterlist *sg;
+-
+-	for_each_sg(sglist, sg, nhwentries, i) {
+-		if (!plat_device_is_coherent(dev) &&
+-		    direction != DMA_TO_DEVICE)
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-		plat_unmap_dma_mem(dev, sg->dma_address, sg->length, direction);
+-	}
+-}
+-
+-static void mips_dma_sync_single_for_cpu(struct device *dev,
+-	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+-{
+-	if (cpu_needs_post_dma_flush(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_handle),
+-			   dma_handle & ~PAGE_MASK, size, direction);
+-	plat_post_dma_flush(dev);
+-}
+-
+-static void mips_dma_sync_single_for_device(struct device *dev,
+-	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+-{
+-	if (!plat_device_is_coherent(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_handle),
+-			   dma_handle & ~PAGE_MASK, size, direction);
+-}
+-
+-static void mips_dma_sync_sg_for_cpu(struct device *dev,
+-	struct scatterlist *sglist, int nelems,
+-	enum dma_data_direction direction)
+-{
+-	int i;
+-	struct scatterlist *sg;
+-
+-	if (cpu_needs_post_dma_flush(dev)) {
+-		for_each_sg(sglist, sg, nelems, i) {
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-		}
+-	}
+-	plat_post_dma_flush(dev);
+-}
+-
+-static void mips_dma_sync_sg_for_device(struct device *dev,
+-	struct scatterlist *sglist, int nelems,
+-	enum dma_data_direction direction)
+-{
+-	int i;
+-	struct scatterlist *sg;
+-
+-	if (!plat_device_is_coherent(dev)) {
+-		for_each_sg(sglist, sg, nelems, i) {
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-		}
+-	}
+-}
+-
+-int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+-int mips_dma_supported(struct device *dev, u64 mask)
+-{
+-	return plat_dma_supported(dev, mask);
+-}
++EXPORT_SYMBOL(__dma_sync);
+ 
+ void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+ 			 enum dma_data_direction direction)
+@@ -414,24 +240,10 @@ void dma_cache_sync(struct device *dev,
+ 
+ EXPORT_SYMBOL(dma_cache_sync);
+ 
+-static struct dma_map_ops mips_default_dma_map_ops = {
+-	.alloc = mips_dma_alloc_coherent,
+-	.free = mips_dma_free_coherent,
+-	.mmap = mips_dma_mmap,
+-	.map_page = mips_dma_map_page,
+-	.unmap_page = mips_dma_unmap_page,
+-	.map_sg = mips_dma_map_sg,
+-	.unmap_sg = mips_dma_unmap_sg,
+-	.sync_single_for_cpu = mips_dma_sync_single_for_cpu,
+-	.sync_single_for_device = mips_dma_sync_single_for_device,
+-	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
+-	.sync_sg_for_device = mips_dma_sync_sg_for_device,
+-	.mapping_error = mips_dma_mapping_error,
+-	.dma_supported = mips_dma_supported
+-};
+-
+-struct dma_map_ops *mips_dma_map_ops = &mips_default_dma_map_ops;
++#ifdef CONFIG_SYS_HAS_DMA_OPS
++struct dma_map_ops *mips_dma_map_ops = NULL;
+ EXPORT_SYMBOL(mips_dma_map_ops);
++#endif
+ 
+ #define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
+ 
diff --git a/target/linux/generic/pending-4.4/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch b/target/linux/generic/pending-4.4/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch
new file mode 100644
index 0000000000..e1b84ae52c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/140-mtd-part-add-generic-parsing-of-linux-part-probe.patch
@@ -0,0 +1,183 @@
+From 3e7056c3a369e9ef9ca804bc626b60ef6b62ee27 Mon Sep 17 00:00:00 2001
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Sun, 17 May 2015 18:48:38 +0200
+Subject: [PATCH 2/3] mtd: part: add generic parsing of linux,part-probe
+
+This moves the linux,part-probe device tree parsing code from
+physmap_of.c to mtdpart.c. Now all drivers can use this feature by just
+providing a reference to their device tree node in struct
+mtd_part_parser_data.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ Documentation/devicetree/bindings/mtd/nand.txt | 16 +++++++++
+ drivers/mtd/maps/physmap_of.c                  | 46 +-------------------------
+ drivers/mtd/mtdpart.c                          | 45 +++++++++++++++++++++++++
+ 3 files changed, 62 insertions(+), 45 deletions(-)
+
+--- a/Documentation/devicetree/bindings/mtd/nand.txt
++++ b/Documentation/devicetree/bindings/mtd/nand.txt
+@@ -12,6 +12,22 @@
+ - nand-ecc-step-size: integer representing the number of data bytes
+ 		      that are covered by a single ECC step.
+ 
++- linux,part-probe: list of name as strings of the partition parser
++		    which should be used to parse the partition table.
++		    They will be tried in the specified ordering and
++		    the next one will be used if the previous one
++		    failed.
++
++		    Example: linux,part-probe = "cmdlinepart", "ofpart";
++
++		    This is also the default value, which will be used
++		    if this attribute is not specified. It could be
++		    that the flash driver in use overwrote the default
++		    value and uses some other default.
++
++		    Possible values are: bcm47xxpart, afs, ar7part,
++		    ofoldpart, ofpart, bcm63xxpart, RedBoot, cmdlinepart
++
+ The ECC strength and ECC step size properties define the correction capability
+ of a controller. Together, they say a controller can correct "{strength} bit
+ errors per {size} bytes".
+--- a/drivers/mtd/maps/physmap_of.c
++++ b/drivers/mtd/maps/physmap_of.c
+@@ -112,47 +112,9 @@ static struct mtd_info *obsolete_probe(s
+ static const char * const part_probe_types_def[] = {
+ 	"cmdlinepart", "RedBoot", "ofpart", "ofoldpart", NULL };
+ 
+-static const char * const *of_get_probes(struct device_node *dp)
+-{
+-	const char *cp;
+-	int cplen;
+-	unsigned int l;
+-	unsigned int count;
+-	const char **res;
+-
+-	cp = of_get_property(dp, "linux,part-probe", &cplen);
+-	if (cp == NULL)
+-		return part_probe_types_def;
+-
+-	count = 0;
+-	for (l = 0; l != cplen; l++)
+-		if (cp[l] == 0)
+-			count++;
+-
+-	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);
+-	if (!res)
+-		return NULL;
+-	count = 0;
+-	while (cplen > 0) {
+-		res[count] = cp;
+-		l = strlen(cp) + 1;
+-		cp += l;
+-		cplen -= l;
+-		count++;
+-	}
+-	return res;
+-}
+-
+-static void of_free_probes(const char * const *probes)
+-{
+-	if (probes != part_probe_types_def)
+-		kfree(probes);
+-}
+-
+ static const struct of_device_id of_flash_match[];
+ static int of_flash_probe(struct platform_device *dev)
+ {
+-	const char * const *part_probe_types;
+ 	const struct of_device_id *match;
+ 	struct device_node *dp = dev->dev.of_node;
+ 	struct resource res;
+@@ -311,14 +273,8 @@ static int of_flash_probe(struct platfor
+ 		goto err_out;
+ 
+ 	ppdata.of_node = dp;
+-	part_probe_types = of_get_probes(dp);
+-	if (!part_probe_types) {
+-		err = -ENOMEM;
+-		goto err_out;
+-	}
+-	mtd_device_parse_register(info->cmtd, part_probe_types, &ppdata,
++	mtd_device_parse_register(info->cmtd, part_probe_types_def, &ppdata,
+ 			NULL, 0);
+-	of_free_probes(part_probe_types);
+ 
+ 	kfree(mtd_list);
+ 
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -29,6 +29,7 @@
+ #include <linux/kmod.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/of.h>
+ #include <linux/err.h>
+ #include <linux/kconfig.h>
+ 
+@@ -721,6 +722,42 @@ void deregister_mtd_parser(struct mtd_pa
+ EXPORT_SYMBOL_GPL(deregister_mtd_parser);
+ 
+ /*
++ * Parses the linux,part-probe device tree property.
++ * When a non null value is returned it has to be freed with kfree() by
++ * the caller.
++ */
++static const char * const *of_get_probes(struct device_node *dp)
++{
++	const char *cp;
++	int cplen;
++	unsigned int l;
++	unsigned int count;
++	const char **res;
++
++	cp = of_get_property(dp, "linux,part-probe", &cplen);
++	if (cp == NULL)
++		return NULL;
++
++	count = 0;
++	for (l = 0; l != cplen; l++)
++		if (cp[l] == 0)
++			count++;
++
++	res = kzalloc((count + 1) * sizeof(*res), GFP_KERNEL);
++	if (!res)
++		return NULL;
++	count = 0;
++	while (cplen > 0) {
++		res[count] = cp;
++		l = strlen(cp) + 1;
++		cp += l;
++		cplen -= l;
++		count++;
++	}
++	return res;
++}
++
++/*
+  * Do not forget to update 'parse_mtd_partitions()' kerneldoc comment if you
+  * are changing this array!
+  */
+@@ -756,6 +793,13 @@ int parse_mtd_partitions(struct mtd_info
+ {
+ 	struct mtd_part_parser *parser;
+ 	int ret, err = 0;
++	const char *const *types_of = NULL;
++
++	if (data && data->of_node) {
++		types_of = of_get_probes(data->of_node);
++		if (types_of != NULL)
++			types = types_of;
++	}
+ 
+ 	if (!types)
+ 		types = default_mtd_part_types;
+@@ -785,6 +829,7 @@ int parse_mtd_partitions(struct mtd_info
+ 		if (ret < 0 && !err)
+ 			err = ret;
+ 	}
++	kfree(types_of);
+ 	return err;
+ }
+ 
diff --git a/target/linux/generic/pending-4.4/150-mtd-spi-nor-add-support-for-ESMT_f25l32qa-and-ESMT_f.patch b/target/linux/generic/pending-4.4/150-mtd-spi-nor-add-support-for-ESMT_f25l32qa-and-ESMT_f.patch
new file mode 100644
index 0000000000..d6e577be8c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/150-mtd-spi-nor-add-support-for-ESMT_f25l32qa-and-ESMT_f.patch
@@ -0,0 +1,21 @@
+From: "L. D. Pinney" <ldpinney@gmail.com>
+Date: Thu, 25 Aug 2016 13:07:56 -0500
+Subject: [PATCH] mtd: spi-nor: add support for ESMT_f25l32qa and ESMT_f25l64qa
+
+Add Support for the ESMT_F25L32QA and ESMT_F25L64QA
+These are 4MB and 8MB SPI NOR Chips from Elite Semiconductor Memory Technology
+
+Signed-off-by: L. D. Pinney <ldpinney@gmail.com>
+---
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -689,6 +689,8 @@ static const struct flash_info spi_nor_i
+ 
+ 	/* ESMT */
+ 	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K) },
++	{ "f25l32qa", INFO(0x8c4116, 0, 64 * 1024, 64, SECT_4K) },
++	{ "f25l64qa", INFO(0x8c4117, 0, 64 * 1024, 128, SECT_4K) },
+ 
+ 	/* Everspin */
+ 	{ "mr25h256", CAT25_INFO( 32 * 1024, 1, 256, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
diff --git a/target/linux/generic/pending-4.4/160-usb-gadget-udc-net2280-add-usb2380-support.patch b/target/linux/generic/pending-4.4/160-usb-gadget-udc-net2280-add-usb2380-support.patch
new file mode 100644
index 0000000000..94f78102b7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/160-usb-gadget-udc-net2280-add-usb2380-support.patch
@@ -0,0 +1,253 @@
+From 5185c91385d73cdf79836eb8548e4726e43ae831 Mon Sep 17 00:00:00 2001
+From: Tim Harvey <tharvey@gateworks.com>
+Date: Mon, 23 May 2016 06:58:41 -0700
+Subject: [PATCH] usb: gadget: net2280: add USB2380 support
+
+The PLX USB2380 is a PCIe version of the NET2280 and behaves more like the
+USB338x but without the USB3.0 superspeed support.
+
+This was tested with g_ether, g_serial, g_mass_storage on a Gateworks
+Ventana GW2383.
+
+Cc: Justin DeFields <justindefields@gmail.com>
+Signed-off-by: Tim Harvey <tharvey@gateworks.com>
+Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
+---
+ drivers/usb/gadget/udc/Kconfig   |  4 +++-
+ drivers/usb/gadget/udc/net2280.c | 51 +++++++++++++++++++++++-----------------
+ drivers/usb/gadget/udc/net2280.h |  1 +
+ 3 files changed, 34 insertions(+), 22 deletions(-)
+
+--- a/drivers/usb/gadget/udc/Kconfig
++++ b/drivers/usb/gadget/udc/Kconfig
+@@ -298,7 +298,7 @@ config USB_NET2272_DMA
+ 	  If unsure, say "N" here.  The driver works fine in PIO mode.
+ 
+ config USB_NET2280
+-	tristate "NetChip 228x / PLX USB338x"
++	tristate "NetChip NET228x / PLX USB3x8x"
+ 	depends on PCI
+ 	help
+ 	   NetChip 2280 / 2282 is a PCI based USB peripheral controller which
+@@ -308,6 +308,8 @@ config USB_NET2280
+ 	   (for control transfers) and several endpoints with dedicated
+ 	   functions.
+ 
++	   PLX 2380 is a PCIe version of the PLX 2380.
++
+ 	   PLX 3380 / 3382 is a PCIe based USB peripheral controller which
+ 	   supports full, high speed USB 2.0 and super speed USB 3.0
+ 	   data transfers.
+--- a/drivers/usb/gadget/udc/net2280.c
++++ b/drivers/usb/gadget/udc/net2280.c
+@@ -211,7 +211,7 @@ net2280_enable(struct usb_ep *_ep, const
+ 		goto print_err;
+ 	}
+ 
+-	if (dev->quirks & PLX_SUPERSPEED) {
++	if (dev->quirks & PLX_PCIE) {
+ 		if ((desc->bEndpointAddress & 0x0f) >= 0x0c) {
+ 			ret = -EDOM;
+ 			goto print_err;
+@@ -245,7 +245,7 @@ net2280_enable(struct usb_ep *_ep, const
+ 	/* set type, direction, address; reset fifo counters */
+ 	writel(BIT(FIFO_FLUSH), &ep->regs->ep_stat);
+ 
+-	if ((dev->quirks & PLX_SUPERSPEED) && dev->enhanced_mode) {
++	if ((dev->quirks & PLX_PCIE) && dev->enhanced_mode) {
+ 		tmp = readl(&ep->cfg->ep_cfg);
+ 		/* If USB ep number doesn't match hardware ep number */
+ 		if ((tmp & 0xf) != usb_endpoint_num(desc)) {
+@@ -316,7 +316,7 @@ net2280_enable(struct usb_ep *_ep, const
+ 			BIT(CLEAR_NAK_OUT_PACKETS_MODE), &ep->regs->ep_rsp);
+ 	}
+ 
+-	if (dev->quirks & PLX_SUPERSPEED)
++	if (dev->quirks & PLX_PCIE)
+ 		ep_clear_seqnum(ep);
+ 	writel(tmp, &ep->cfg->ep_cfg);
+ 
+@@ -527,7 +527,7 @@ static int net2280_disable(struct usb_ep
+ 	spin_lock_irqsave(&ep->dev->lock, flags);
+ 	nuke(ep);
+ 
+-	if (ep->dev->quirks & PLX_SUPERSPEED)
++	if (ep->dev->quirks & PLX_PCIE)
+ 		ep_reset_338x(ep->dev->regs, ep);
+ 	else
+ 		ep_reset_228x(ep->dev->regs, ep);
+@@ -862,7 +862,7 @@ static void start_queue(struct net2280_e
+ 	writel(readl(&dma->dmastat), &dma->dmastat);
+ 
+ 	writel(td_dma, &dma->dmadesc);
+-	if (ep->dev->quirks & PLX_SUPERSPEED)
++	if (ep->dev->quirks & PLX_PCIE)
+ 		dmactl |= BIT(DMA_REQUEST_OUTSTANDING);
+ 	writel(dmactl, &dma->dmactl);
+ 
+@@ -1046,7 +1046,7 @@ net2280_queue(struct usb_ep *_ep, struct
+ 
+ 	/* kickstart this i/o queue? */
+ 	if  (list_empty(&ep->queue) && !ep->stopped &&
+-		!((dev->quirks & PLX_SUPERSPEED) && ep->dma &&
++		!((dev->quirks & PLX_PCIE) && ep->dma &&
+ 		  (readl(&ep->regs->ep_rsp) & BIT(CLEAR_ENDPOINT_HALT)))) {
+ 
+ 		/* use DMA if the endpoint supports it, else pio */
+@@ -1169,7 +1169,7 @@ static void scan_dma_completions(struct
+ 			break;
+ 		} else if (!ep->is_in &&
+ 			   (req->req.length % ep->ep.maxpacket) &&
+-			   !(ep->dev->quirks & PLX_SUPERSPEED)) {
++			   !(ep->dev->quirks & PLX_PCIE)) {
+ 
+ 			tmp = readl(&ep->regs->ep_stat);
+ 			/* AVOID TROUBLE HERE by not issuing short reads from
+@@ -1367,7 +1367,7 @@ net2280_set_halt_and_wedge(struct usb_ep
+ 				ep->wedged = 1;
+ 		} else {
+ 			clear_halt(ep);
+-			if (ep->dev->quirks & PLX_SUPERSPEED &&
++			if (ep->dev->quirks & PLX_PCIE &&
+ 				!list_empty(&ep->queue) && ep->td_dma)
+ 					restart_dma(ep);
+ 			ep->wedged = 0;
+@@ -2394,7 +2394,7 @@ static int net2280_start(struct usb_gadg
+ 	 */
+ 	net2280_led_active(dev, 1);
+ 
+-	if ((dev->quirks & PLX_SUPERSPEED) && !dev->bug7734_patched)
++	if ((dev->quirks & PLX_PCIE) && !dev->bug7734_patched)
+ 		defect7374_enable_data_eps_zero(dev);
+ 
+ 	ep0_start(dev);
+@@ -3060,7 +3060,7 @@ static void handle_stat0_irqs(struct net
+ 		}
+ 		ep->stopped = 0;
+ 		dev->protocol_stall = 0;
+-		if (!(dev->quirks & PLX_SUPERSPEED)) {
++		if (!(dev->quirks & PLX_PCIE)) {
+ 			if (ep->dev->quirks & PLX_2280)
+ 				tmp = BIT(FIFO_OVERFLOW) |
+ 				    BIT(FIFO_UNDERFLOW);
+@@ -3087,7 +3087,7 @@ static void handle_stat0_irqs(struct net
+ 		cpu_to_le32s(&u.raw[0]);
+ 		cpu_to_le32s(&u.raw[1]);
+ 
+-		if ((dev->quirks & PLX_SUPERSPEED) && !dev->bug7734_patched)
++		if ((dev->quirks & PLX_PCIE) && !dev->bug7734_patched)
+ 			defect7374_workaround(dev, u.r);
+ 
+ 		tmp = 0;
+@@ -3170,7 +3170,7 @@ static void handle_stat0_irqs(struct net
+ 			} else {
+ 				ep_vdbg(dev, "%s clear halt\n", e->ep.name);
+ 				clear_halt(e);
+-				if ((ep->dev->quirks & PLX_SUPERSPEED) &&
++				if ((ep->dev->quirks & PLX_PCIE) &&
+ 					!list_empty(&e->queue) && e->td_dma)
+ 						restart_dma(e);
+ 			}
+@@ -3192,7 +3192,7 @@ static void handle_stat0_irqs(struct net
+ 			if (e->ep.name == ep0name)
+ 				goto do_stall;
+ 			set_halt(e);
+-			if ((dev->quirks & PLX_SUPERSPEED) && e->dma)
++			if ((dev->quirks & PLX_PCIE) && e->dma)
+ 				abort_dma(e);
+ 			allow_status(ep);
+ 			ep_vdbg(dev, "%s set halt\n", ep->ep.name);
+@@ -3231,7 +3231,7 @@ do_stall:
+ #undef	w_length
+ 
+ next_endpoints:
+-	if ((dev->quirks & PLX_SUPERSPEED) && dev->enhanced_mode) {
++	if ((dev->quirks & PLX_PCIE) && dev->enhanced_mode) {
+ 		u32 mask = (BIT(ENDPOINT_0_INTERRUPT) |
+ 			USB3380_IRQSTAT0_EP_INTR_MASK_IN |
+ 			USB3380_IRQSTAT0_EP_INTR_MASK_OUT);
+@@ -3392,7 +3392,7 @@ static void handle_stat1_irqs(struct net
+ 		writel(tmp, &dma->dmastat);
+ 
+ 		/* dma sync*/
+-		if (dev->quirks & PLX_SUPERSPEED) {
++		if (dev->quirks & PLX_PCIE) {
+ 			u32 r_dmacount = readl(&dma->dmacount);
+ 			if (!ep->is_in &&  (r_dmacount & 0x00FFFFFF) &&
+ 			    (tmp & BIT(DMA_TRANSACTION_DONE_INTERRUPT)))
+@@ -3461,7 +3461,7 @@ static irqreturn_t net2280_irq(int irq,
+ 	/* control requests and PIO */
+ 	handle_stat0_irqs(dev, readl(&dev->regs->irqstat0));
+ 
+-	if (dev->quirks & PLX_SUPERSPEED) {
++	if (dev->quirks & PLX_PCIE) {
+ 		/* re-enable interrupt to trigger any possible new interrupt */
+ 		u32 pciirqenb1 = readl(&dev->regs->pciirqenb1);
+ 		writel(pciirqenb1 & 0x7FFFFFFF, &dev->regs->pciirqenb1);
+@@ -3506,7 +3506,7 @@ static void net2280_remove(struct pci_de
+ 	}
+ 	if (dev->got_irq)
+ 		free_irq(pdev->irq, dev);
+-	if (dev->quirks & PLX_SUPERSPEED)
++	if (dev->quirks & PLX_PCIE)
+ 		pci_disable_msi(pdev);
+ 	if (dev->regs)
+ 		iounmap(dev->regs);
+@@ -3586,7 +3586,7 @@ static int net2280_probe(struct pci_dev
+ 	dev->dep = (struct net2280_dep_regs __iomem *) (base + 0x0200);
+ 	dev->epregs = (struct net2280_ep_regs __iomem *) (base + 0x0300);
+ 
+-	if (dev->quirks & PLX_SUPERSPEED) {
++	if (dev->quirks & PLX_PCIE) {
+ 		u32 fsmvalue;
+ 		u32 usbstat;
+ 		dev->usb_ext = (struct usb338x_usb_ext_regs __iomem *)
+@@ -3630,7 +3630,7 @@ static int net2280_probe(struct pci_dev
+ 		goto done;
+ 	}
+ 
+-	if (dev->quirks & PLX_SUPERSPEED)
++	if (dev->quirks & PLX_PCIE)
+ 		if (pci_enable_msi(pdev))
+ 			ep_err(dev, "Failed to enable MSI mode\n");
+ 
+@@ -3748,10 +3748,19 @@ static const struct pci_device_id pci_id
+ 	.class =	((PCI_CLASS_SERIAL_USB << 8) | 0xfe),
+ 	.class_mask =	~0,
+ 	.vendor =	PCI_VENDOR_ID_PLX,
++	.device =	0x2380,
++	.subvendor =	PCI_ANY_ID,
++	.subdevice =	PCI_ANY_ID,
++	.driver_data =	PLX_PCIE,
++	 },
++	{
++	.class =	((PCI_CLASS_SERIAL_USB << 8) | 0xfe),
++	.class_mask =	~0,
++	.vendor =	PCI_VENDOR_ID_PLX,
+ 	.device =	0x3380,
+ 	.subvendor =	PCI_ANY_ID,
+ 	.subdevice =	PCI_ANY_ID,
+-	.driver_data =	PLX_SUPERSPEED,
++	.driver_data =	PLX_PCIE | PLX_SUPERSPEED,
+ 	 },
+ 	{
+ 	.class =	((PCI_CLASS_SERIAL_USB << 8) | 0xfe),
+@@ -3760,7 +3769,7 @@ static const struct pci_device_id pci_id
+ 	.device =	0x3382,
+ 	.subvendor =	PCI_ANY_ID,
+ 	.subdevice =	PCI_ANY_ID,
+-	.driver_data =	PLX_SUPERSPEED,
++	.driver_data =	PLX_PCIE | PLX_SUPERSPEED,
+ 	 },
+ { /* end: all zeroes */ }
+ };
+--- a/drivers/usb/gadget/udc/net2280.h
++++ b/drivers/usb/gadget/udc/net2280.h
+@@ -47,6 +47,7 @@ set_idx_reg(struct net2280_regs __iomem
+ #define PLX_LEGACY		BIT(0)
+ #define PLX_2280		BIT(1)
+ #define PLX_SUPERSPEED		BIT(2)
++#define PLX_PCIE		BIT(3)
+ 
+ #define REG_DIAG		0x0
+ #define     RETRY_COUNTER                                       16
diff --git a/target/linux/generic/pending-4.4/180-Revert-bcma-init-serial-console-directly-from-ChipCo.patch b/target/linux/generic/pending-4.4/180-Revert-bcma-init-serial-console-directly-from-ChipCo.patch
new file mode 100644
index 0000000000..affe090457
--- /dev/null
+++ b/target/linux/generic/pending-4.4/180-Revert-bcma-init-serial-console-directly-from-ChipCo.patch
@@ -0,0 +1,92 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH] Revert "bcma: init serial console directly from ChipCommon
+ code"
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This reverts commit 4c81acab3816 ("bcma: init serial console directly
+from ChipCommon code") as it broke IRQ assignment. Getting IRQ with
+bcma_core_irq helper on SoC requires MIPS core to be set. It happens
+*after* ChipCommon initialization so we can't do this so early.
+
+This fixes a user reported regression. It wasn't critical as serial was
+still somehow working but lack of IRQs was making in unreliable.
+
+Fixes: 4c81acab3816 ("bcma: init serial console directly from ChipCommon code")
+Reported-by: Felix Fietkau <nbd@nbd.name>
+Cc: stable@vger.kernel.org # 4.6+
+Signed-off-by: Rafa Miecki <rafal@milecki.pl>
+---
+ drivers/bcma/bcma_private.h      |  3 +++
+ drivers/bcma/driver_chipcommon.c | 11 +++--------
+ drivers/bcma/driver_mips.c       |  3 +++
+ 3 files changed, 9 insertions(+), 8 deletions(-)
+
+--- a/drivers/bcma/bcma_private.h
++++ b/drivers/bcma/bcma_private.h
+@@ -45,6 +45,9 @@ int bcma_sprom_get(struct bcma_bus *bus)
+ void bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);
+ void bcma_core_chipcommon_init(struct bcma_drv_cc *cc);
+ void bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);
++#ifdef CONFIG_BCMA_DRIVER_MIPS
++void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
++#endif /* CONFIG_BCMA_DRIVER_MIPS */
+ 
+ /* driver_chipcommon_b.c */
+ int bcma_core_chipcommon_b_init(struct bcma_drv_cc_b *ccb);
+--- a/drivers/bcma/driver_chipcommon.c
++++ b/drivers/bcma/driver_chipcommon.c
+@@ -15,8 +15,6 @@
+ #include <linux/platform_device.h>
+ #include <linux/bcma/bcma.h>
+ 
+-static void bcma_chipco_serial_init(struct bcma_drv_cc *cc);
+-
+ static inline u32 bcma_cc_write32_masked(struct bcma_drv_cc *cc, u16 offset,
+ 					 u32 mask, u32 value)
+ {
+@@ -186,9 +184,6 @@ void bcma_core_chipcommon_early_init(str
+ 	if (cc->capabilities & BCMA_CC_CAP_PMU)
+ 		bcma_pmu_early_init(cc);
+ 
+-	if (IS_BUILTIN(CONFIG_BCM47XX) && bus->hosttype == BCMA_HOSTTYPE_SOC)
+-		bcma_chipco_serial_init(cc);
+-
+ 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
+ 		bcma_core_chipcommon_flash_detect(cc);
+ 
+@@ -378,9 +373,9 @@ u32 bcma_chipco_gpio_pulldown(struct bcm
+ 	return res;
+ }
+ 
+-static void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
++#ifdef CONFIG_BCMA_DRIVER_MIPS
++void bcma_chipco_serial_init(struct bcma_drv_cc *cc)
+ {
+-#if IS_BUILTIN(CONFIG_BCM47XX)
+ 	unsigned int irq;
+ 	u32 baud_base;
+ 	u32 i;
+@@ -422,5 +417,5 @@ static void bcma_chipco_serial_init(stru
+ 		ports[i].baud_base = baud_base;
+ 		ports[i].reg_shift = 0;
+ 	}
+-#endif /* CONFIG_BCM47XX */
+ }
++#endif /* CONFIG_BCMA_DRIVER_MIPS */
+--- a/drivers/bcma/driver_mips.c
++++ b/drivers/bcma/driver_mips.c
+@@ -278,9 +278,12 @@ static void bcma_core_mips_nvram_init(st
+ 
+ void bcma_core_mips_early_init(struct bcma_drv_mips *mcore)
+ {
++	struct bcma_bus *bus = mcore->core->bus;
++
+ 	if (mcore->early_setup_done)
+ 		return;
+ 
++	bcma_chipco_serial_init(&bus->drv_cc);
+ 	bcma_core_mips_nvram_init(mcore);
+ 
+ 	mcore->early_setup_done = true;
diff --git a/target/linux/generic/pending-4.4/200-fix_localversion.patch b/target/linux/generic/pending-4.4/200-fix_localversion.patch
new file mode 100644
index 0000000000..70228bb5f4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/200-fix_localversion.patch
@@ -0,0 +1,11 @@
+--- a/scripts/setlocalversion
++++ b/scripts/setlocalversion
+@@ -165,7 +165,7 @@ else
+ 	# annotated or signed tagged state (as git describe only
+ 	# looks at signed or annotated tags - git tag -a/-s) and
+ 	# LOCALVERSION= is not specified
+-	if test "${LOCALVERSION+set}" != "set"; then
++	if test "${CONFIG_LOCALVERSION+set}" != "set"; then
+ 		scm=$(scm_version --short)
+ 		res="$res${scm:++}"
+ 	fi
diff --git a/target/linux/generic/pending-4.4/201-extra_optimization.patch b/target/linux/generic/pending-4.4/201-extra_optimization.patch
new file mode 100644
index 0000000000..b4235a11d4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/201-extra_optimization.patch
@@ -0,0 +1,18 @@
+--- a/Makefile
++++ b/Makefile
+@@ -626,12 +626,12 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
+ KBUILD_CFLAGS	+= $(call cc-disable-warning, int-in-bool-context)
+ 
+ ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+-KBUILD_CFLAGS	+= -Os
++KBUILD_CFLAGS	+= -Os $(EXTRA_OPTIMIZATION)
+ else
+ ifdef CONFIG_PROFILE_ALL_BRANCHES
+-KBUILD_CFLAGS	+= -O2
++KBUILD_CFLAGS	+= -O2 $(EXTRA_OPTIMIZATION)
+ else
+-KBUILD_CFLAGS   += -O2
++KBUILD_CFLAGS   += -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
+ endif
+ endif
+ 
diff --git a/target/linux/generic/pending-4.4/202-reduce_module_size.patch b/target/linux/generic/pending-4.4/202-reduce_module_size.patch
new file mode 100644
index 0000000000..1aabf3e722
--- /dev/null
+++ b/target/linux/generic/pending-4.4/202-reduce_module_size.patch
@@ -0,0 +1,11 @@
+--- a/Makefile
++++ b/Makefile
+@@ -405,7 +405,7 @@ KBUILD_CFLAGS_KERNEL :=
+ KBUILD_AFLAGS   := -D__ASSEMBLY__ $(call cc-option,-fno-PIE)
+ KBUILD_AFLAGS_MODULE  := -DMODULE
+ KBUILD_CFLAGS_MODULE  := -DMODULE
+-KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
++KBUILD_LDFLAGS_MODULE = -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
+ 
+ # Read KERNELRELEASE from include/config/kernel.release (if it exists)
+ KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
diff --git a/target/linux/generic/pending-4.4/203-kallsyms_uncompressed.patch b/target/linux/generic/pending-4.4/203-kallsyms_uncompressed.patch
new file mode 100644
index 0000000000..cf8a447bbc
--- /dev/null
+++ b/target/linux/generic/pending-4.4/203-kallsyms_uncompressed.patch
@@ -0,0 +1,108 @@
+--- a/scripts/kallsyms.c
++++ b/scripts/kallsyms.c
+@@ -58,6 +58,7 @@ static struct addr_range percpu_range =
+ static struct sym_entry *table;
+ static unsigned int table_size, table_cnt;
+ static int all_symbols = 0;
++static int uncompressed = 0;
+ static int absolute_percpu = 0;
+ static char symbol_prefix_char = '\0';
+ static unsigned long long kernel_start_addr = 0;
+@@ -403,6 +404,9 @@ static void write_src(void)
+ 
+ 	free(markers);
+ 
++	if (uncompressed)
++		return;
++
+ 	output_label("kallsyms_token_table");
+ 	off = 0;
+ 	for (i = 0; i < 256; i++) {
+@@ -461,6 +465,9 @@ static void *find_token(unsigned char *s
+ {
+ 	int i;
+ 
++	if (uncompressed)
++		return NULL;
++
+ 	for (i = 0; i < len - 1; i++) {
+ 		if (str[i] == token[0] && str[i+1] == token[1])
+ 			return &str[i];
+@@ -533,6 +540,9 @@ static void optimize_result(void)
+ {
+ 	int i, best;
+ 
++	if (uncompressed)
++		return;
++
+ 	/* using the '\0' symbol last allows compress_symbols to use standard
+ 	 * fast string functions */
+ 	for (i = 255; i >= 0; i--) {
+@@ -703,7 +713,9 @@ int main(int argc, char **argv)
+ 			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
+ 				const char *p = &argv[i][14];
+ 				kernel_start_addr = strtoull(p, NULL, 16);
+-			} else
++			} else if (strcmp(argv[i], "--uncompressed") == 0)
++				uncompressed = 1;
++			else
+ 				usage();
+ 		}
+ 	} else if (argc != 1)
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1345,6 +1345,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
+ 	  the unaligned access emulation.
+ 	  see arch/parisc/kernel/unaligned.c for reference
+ 
++config KALLSYMS_UNCOMPRESSED
++	bool "Keep kallsyms uncompressed"
++	depends on KALLSYMS
++	help
++		Normally kallsyms contains compressed symbols (using a token table),
++		reducing the uncompressed kernel image size. Keeping the symbol table
++		uncompressed significantly improves the size of this part in compressed
++		kernel images.
++
++		Say N unless you need compressed kernel images to be small.
++
+ config HAVE_PCSPKR_PLATFORM
+ 	bool
+ 
+--- a/scripts/link-vmlinux.sh
++++ b/scripts/link-vmlinux.sh
+@@ -90,6 +90,10 @@ kallsyms()
+ 		kallsymopt="${kallsymopt} --absolute-percpu"
+ 	fi
+ 
++	if [ -n "${CONFIG_KALLSYMS_UNCOMPRESSED}" ]; then
++		kallsymopt="${kallsymopt} --uncompressed"
++	fi
++
+ 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
+ 		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
+ 
+--- a/kernel/kallsyms.c
++++ b/kernel/kallsyms.c
+@@ -109,6 +109,11 @@ static unsigned int kallsyms_expand_symb
+ 	 * For every byte on the compressed symbol data, copy the table
+ 	 * entry for that byte.
+ 	 */
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	memcpy(result, data + 1, len - 1);
++	result += len - 1;
++	len = 0;
++#endif
+ 	while (len) {
+ 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
+ 		data++;
+@@ -141,6 +146,9 @@ tail:
+  */
+ static char kallsyms_get_symbol_type(unsigned int off)
+ {
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	return kallsyms_names[off + 1];
++#endif
+ 	/*
+ 	 * Get just the first code, look it up in the token table,
+ 	 * and return the first char from this token.
diff --git a/target/linux/generic/pending-4.4/204-module_strip.patch b/target/linux/generic/pending-4.4/204-module_strip.patch
new file mode 100644
index 0000000000..a661f98c65
--- /dev/null
+++ b/target/linux/generic/pending-4.4/204-module_strip.patch
@@ -0,0 +1,193 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH] build: add a hack for removing non-essential module info
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/include/linux/module.h
++++ b/include/linux/module.h
+@@ -169,6 +169,7 @@ void trim_init_extable(struct module *m)
+ 
+ /* Generic info of form tag = "info" */
+ #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
++#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
+ 
+ /* For userspace: you can also call me... */
+ #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
+@@ -212,12 +213,12 @@ void trim_init_extable(struct module *m)
+  * Author(s), use "Name <email>" or just "Name", for multiple
+  * authors use multiple MODULE_AUTHOR() statements/lines.
+  */
+-#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
++#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
+ 
+ /* What your module does. */
+-#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
++#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
+ 
+-#ifdef MODULE
++#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
+ /* Creates an alias so file2alias.c can find device table. */
+ #define MODULE_DEVICE_TABLE(type, name)					\
+ extern const typeof(name) __mod_##type##__##name##_device_table		\
+@@ -244,7 +245,9 @@ extern const typeof(name) __mod_##type##
+  */
+ 
+ #if defined(MODULE) || !defined(CONFIG_SYSFS)
+-#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
++#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
++#elif defined(CONFIG_MODULE_STRIPPED)
++#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
+ #else
+ #define MODULE_VERSION(_version)					\
+ 	static struct module_version_attribute ___modver_attr = {	\
+@@ -266,7 +269,7 @@ extern const typeof(name) __mod_##type##
+ /* Optional firmware file (or files) needed by the module
+  * format is simply firmware file name.  Multiple firmware
+  * files require multiple MODULE_FIRMWARE() specifiers */
+-#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
++#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
+ 
+ /* Given an address, look for it in the exception tables */
+ const struct exception_table_entry *search_exception_tables(unsigned long add);
+--- a/include/linux/moduleparam.h
++++ b/include/linux/moduleparam.h
+@@ -16,6 +16,16 @@
+ /* Chosen so that structs with an unsigned long line up. */
+ #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
+ 
++/* This struct is here for syntactic coherency, it is not used */
++#define __MODULE_INFO_DISABLED(name)					  \
++  struct __UNIQUE_ID(name) {}
++
++#ifdef CONFIG_MODULE_STRIPPED
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
++#else
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
++#endif
++
+ #ifdef MODULE
+ #define __MODULE_INFO(tag, name, info)					  \
+ static const char __UNIQUE_ID(name)[]					  \
+@@ -23,8 +33,7 @@ static const char __UNIQUE_ID(name)[]
+   = __stringify(tag) "=" info
+ #else  /* !MODULE */
+ /* This struct is here for syntactic coherency, it is not used */
+-#define __MODULE_INFO(tag, name, info)					  \
+-  struct __UNIQUE_ID(name) {}
++#define __MODULE_INFO(tag, name, info) __MODULE_INFO_DISABLED(name)
+ #endif
+ #define __MODULE_PARM_TYPE(name, _type)					  \
+   __MODULE_INFO(parmtype, name##type, #name ":" _type)
+@@ -32,7 +41,7 @@ static const char __UNIQUE_ID(name)[]
+ /* One for each parameter, describing how to use it.  Some files do
+    multiple of these per line, so can't just use MODULE_INFO. */
+ #define MODULE_PARM_DESC(_parm, desc) \
+-	__MODULE_INFO(parm, _parm, #_parm ":" desc)
++	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
+ 
+ struct kernel_param;
+ 
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -2033,6 +2033,13 @@ config MODULE_COMPRESS_XZ
+ 
+ endchoice
+ 
++config MODULE_STRIPPED
++	bool "Reduce module size"
++	depends on MODULES
++	help
++	  Remove module parameter descriptions, author info, version, aliases,
++	  device tables, etc.
++
+ endif # MODULES
+ 
+ config MODULES_TREE_LOOKUP
+--- a/kernel/module.c
++++ b/kernel/module.c
+@@ -2880,6 +2880,7 @@ static void check_modinfo_retpoline(stru
+ 
+ static int check_modinfo(struct module *mod, struct load_info *info, int flags)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	const char *modmagic = get_modinfo(info, "vermagic");
+ 	int err;
+ 
+@@ -2911,6 +2912,7 @@ static int check_modinfo(struct module *
+ 		pr_warn("%s: module is from the staging directory, the quality "
+ 			"is unknown, you have been warned.\n", mod->name);
+ 	}
++#endif
+ 
+ 	/* Set up license info based on the info section */
+ 	set_license(mod, get_modinfo(info, "license"));
+--- a/scripts/mod/modpost.c
++++ b/scripts/mod/modpost.c
+@@ -1964,7 +1964,9 @@ static void read_symbols(char *modname)
+ 		symname = remove_dot(info.strtab + sym->st_name);
+ 
+ 		handle_modversions(mod, &info, sym, symname);
++#ifndef CONFIG_MODULE_STRIPPED
+ 		handle_moddevtable(mod, &info, sym, symname);
++#endif
+ 	}
+ 	if (!is_vmlinux(modname) ||
+ 	     (is_vmlinux(modname) && vmlinux_section_warnings))
+@@ -2108,7 +2110,9 @@ static void add_header(struct buffer *b,
+ 	buf_printf(b, "#include <linux/vermagic.h>\n");
+ 	buf_printf(b, "#include <linux/compiler.h>\n");
+ 	buf_printf(b, "\n");
++#ifndef CONFIG_MODULE_STRIPPED
+ 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
++#endif
+ 	buf_printf(b, "\n");
+ 	buf_printf(b, "__visible struct module __this_module\n");
+ 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
+@@ -2125,8 +2129,10 @@ static void add_header(struct buffer *b,
+ 
+ static void add_intree_flag(struct buffer *b, int is_intree)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (is_intree)
+ 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
++#endif
+ }
+ 
+ /* Cannot check for assembler */
+@@ -2139,10 +2145,12 @@ static void add_retpoline(struct buffer
+ 
+ static void add_staging_flag(struct buffer *b, const char *name)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	static const char *staging_dir = "drivers/staging";
+ 
+ 	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
+ 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
++#endif
+ }
+ 
+ /* In kernel, this size is defined in linux/module.h;
+@@ -2246,11 +2254,13 @@ static void add_depends(struct buffer *b
+ 
+ static void add_srcversion(struct buffer *b, struct module *mod)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (mod->srcversion[0]) {
+ 		buf_printf(b, "\n");
+ 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
+ 			   mod->srcversion);
+ 	}
++#endif
+ }
+ 
+ static void write_if_changed(struct buffer *b, const char *fname)
+@@ -2485,7 +2495,9 @@ int main(int argc, char **argv)
+ 		add_staging_flag(&buf, mod->name);
+ 		err |= add_versions(&buf, mod);
+ 		add_depends(&buf, mod, modules);
++#ifndef CONFIG_MODULE_STRIPPED
+ 		add_moddevtable(&buf, mod);
++#endif
+ 		add_srcversion(&buf, mod);
+ 
+ 		sprintf(fname, "%s.mod.c", mod->name);
diff --git a/target/linux/generic/pending-4.4/205-backtrace_module_info.patch b/target/linux/generic/pending-4.4/205-backtrace_module_info.patch
new file mode 100644
index 0000000000..0550ec4399
--- /dev/null
+++ b/target/linux/generic/pending-4.4/205-backtrace_module_info.patch
@@ -0,0 +1,36 @@
+--- a/lib/vsprintf.c
++++ b/lib/vsprintf.c
+@@ -618,8 +618,10 @@ char *symbol_string(char *buf, char *end
+ 		    struct printf_spec spec, const char *fmt)
+ {
+ 	unsigned long value;
+-#ifdef CONFIG_KALLSYMS
+ 	char sym[KSYM_SYMBOL_LEN];
++#ifndef CONFIG_KALLSYMS
++	struct module *mod;
++	int len;
+ #endif
+ 
+ 	if (fmt[1] == 'R')
+@@ -633,15 +635,15 @@ char *symbol_string(char *buf, char *end
+ 		sprint_symbol(sym, value);
+ 	else
+ 		sprint_symbol_no_offset(sym, value);
+-
+-	return string(buf, end, sym, spec);
+ #else
+-	spec.field_width = 2 * sizeof(void *);
+-	spec.flags |= SPECIAL | SMALL | ZEROPAD;
+-	spec.base = 16;
++	len = snprintf(sym, sizeof(sym), "0x%lx", value);
+ 
+-	return number(buf, end, value, spec);
++	mod = __module_address(value);
++	if (mod)
++		snprintf(sym + len, sizeof(sym) - len, " [%s@%p+0x%x]",
++			 mod->name, mod->module_core, mod->core_size);
+ #endif
++	return string(buf, end, sym, spec);
+ }
+ 
+ static noinline_for_stack
diff --git a/target/linux/generic/pending-4.4/206-mips-disable-vdso.patch b/target/linux/generic/pending-4.4/206-mips-disable-vdso.patch
new file mode 100644
index 0000000000..51b1d041bf
--- /dev/null
+++ b/target/linux/generic/pending-4.4/206-mips-disable-vdso.patch
@@ -0,0 +1,21 @@
+Disable MIPS VDSO until the cache issues have been sorted out.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/arch/mips/vdso/Makefile
++++ b/arch/mips/vdso/Makefile
+@@ -28,11 +28,11 @@ aflags-vdso := $(ccflags-vdso) \
+ # the comments on that file.
+ #
+ ifndef CONFIG_CPU_MIPSR6
+-  ifeq ($(call ld-ifversion, -lt, 22500000, y),y)
+-    $(warning MIPS VDSO requires binutils >= 2.25)
++#  ifeq ($(call ld-ifversion, -lt, 22500000, y),y)
++#    $(warning MIPS VDSO requires binutils >= 2.25)
+     obj-vdso-y := $(filter-out gettimeofday.o, $(obj-vdso-y))
+     ccflags-vdso += -DDISABLE_MIPS_VDSO
+-  endif
++#  endif
+ endif
+ 
+ # VDSO linker flags.
diff --git a/target/linux/generic/pending-4.4/207-mips-vdso-dbg-rebuild-after-genvdso.patch b/target/linux/generic/pending-4.4/207-mips-vdso-dbg-rebuild-after-genvdso.patch
new file mode 100644
index 0000000000..cfcd0b33a0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/207-mips-vdso-dbg-rebuild-after-genvdso.patch
@@ -0,0 +1,29 @@
+--- a/arch/mips/vdso/Makefile
++++ b/arch/mips/vdso/Makefile
+@@ -77,7 +77,7 @@ $(obj-vdso): KBUILD_AFLAGS := $(aflags-v
+ 
+ $(obj)/vdso.lds: KBUILD_CPPFLAGS := $(ccflags-vdso) $(native-abi)
+ 
+-$(obj)/vdso.so.dbg: $(obj)/vdso.lds $(obj-vdso) FORCE
++$(obj)/vdso.so.dbg: $(obj)/vdso.lds $(obj-vdso) $(obj)/genvdso FORCE
+ 	$(call if_changed,vdsold)
+ 
+ $(obj)/vdso-image.c: $(obj)/vdso.so.dbg $(obj)/genvdso FORCE
+@@ -111,7 +111,7 @@ $(obj)/vdso-o32.lds: KBUILD_CPPFLAGS :=
+ $(obj)/vdso-o32.lds: $(src)/vdso.lds.S FORCE
+ 	$(call if_changed_dep,cpp_lds_S)
+ 
+-$(obj)/vdso-o32.so.dbg: $(obj)/vdso-o32.lds $(obj-vdso-o32) FORCE
++$(obj)/vdso-o32.so.dbg: $(obj)/vdso-o32.lds $(obj-vdso-o32) $(obj)/genvdso FORCE
+ 	$(call if_changed,vdsold)
+ 
+ $(obj)/vdso-o32-image.c: VDSO_NAME := o32
+@@ -147,7 +147,7 @@ $(obj)/vdso-n32.lds: KBUILD_CPPFLAGS :=
+ $(obj)/vdso-n32.lds: $(src)/vdso.lds.S FORCE
+ 	$(call if_changed_dep,cpp_lds_S)
+ 
+-$(obj)/vdso-n32.so.dbg: $(obj)/vdso-n32.lds $(obj-vdso-n32) FORCE
++$(obj)/vdso-n32.so.dbg: $(obj)/vdso-n32.lds $(obj-vdso-n32) $(obj)/genvdso FORCE
+ 	$(call if_changed,vdsold)
+ 
+ $(obj)/vdso-n32-image.c: VDSO_NAME := n32
diff --git a/target/linux/generic/pending-4.4/208-disable-modorder.patch b/target/linux/generic/pending-4.4/208-disable-modorder.patch
new file mode 100644
index 0000000000..1707d520be
--- /dev/null
+++ b/target/linux/generic/pending-4.4/208-disable-modorder.patch
@@ -0,0 +1,34 @@
+Disable modules.order to improve build performance.
+This file is not needed for anything in LEDE
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/Makefile
++++ b/Makefile
+@@ -1123,7 +1123,6 @@ all: modules
+ 
+ PHONY += modules
+ modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
+-	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
+ 	@$(kecho) '  Building modules, stage 2.';
+ 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+ 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modbuild
+@@ -1153,7 +1152,6 @@ _modinst_:
+ 		rm -f $(MODLIB)/build ; \
+ 		ln -s $(CURDIR) $(MODLIB)/build ; \
+ 	fi
+-	@cp -f $(objtree)/modules.order $(MODLIB)/
+ 	@cp -f $(objtree)/modules.builtin $(MODLIB)/
+ 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
+ 
+--- a/scripts/Makefile.build
++++ b/scripts/Makefile.build
+@@ -92,7 +92,7 @@ modorder-target := $(obj)/modules.order
+ # We keep a list of all modules in $(MODVERDIR)
+ 
+ __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
+-	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
++	 $(if $(KBUILD_MODULES),$(obj-m)) \
+ 	 $(subdir-ym) $(always)
+ 	@:
+ 
diff --git a/target/linux/generic/pending-4.4/210-darwin_scripts_include.patch b/target/linux/generic/pending-4.4/210-darwin_scripts_include.patch
new file mode 100644
index 0000000000..2afeb23b52
--- /dev/null
+++ b/target/linux/generic/pending-4.4/210-darwin_scripts_include.patch
@@ -0,0 +1,3088 @@
+--- a/scripts/kallsyms.c
++++ b/scripts/kallsyms.c
+@@ -22,6 +22,35 @@
+ #include <stdlib.h>
+ #include <string.h>
+ #include <ctype.h>
++#ifdef __APPLE__
++/* Darwin has no memmem implementation, this one is ripped of the uClibc-0.9.28 source */
++void *memmem (const void *haystack, size_t haystack_len,
++                          const void *needle,  size_t needle_len)
++{
++  const char *begin;
++  const char *const last_possible
++    = (const char *) haystack + haystack_len - needle_len;
++
++  if (needle_len == 0)
++    /* The first occurrence of the empty string is deemed to occur at
++       the beginning of the string.  */
++    return (void *) haystack;
++
++  /* Sanity check, otherwise the loop might search through the whole
++     memory.  */
++  if (__builtin_expect (haystack_len < needle_len, 0))
++    return NULL;
++
++  for (begin = (const char *) haystack; begin <= last_possible; ++begin)
++    if (begin[0] == ((const char *) needle)[0] &&
++        !memcmp ((const void *) &begin[1],
++                 (const void *) ((const char *) needle + 1),
++                 needle_len - 1))
++      return (void *) begin;
++
++  return NULL;
++}
++#endif
+ 
+ #ifndef ARRAY_SIZE
+ #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
+--- a/scripts/kconfig/Makefile
++++ b/scripts/kconfig/Makefile
+@@ -161,6 +161,9 @@ check-lxdialog  := $(srctree)/$(src)/lxd
+ # we really need to do so. (Do not call gcc as part of make mrproper)
+ HOST_EXTRACFLAGS += $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags) \
+                     -DLOCALE
++ifeq ($(shell uname -s),Darwin)
++HOST_LOADLIBES  += -lncurses
++endif
+ 
+ # ===========================================================================
+ # Shared Makefile for the various kconfig executables:
+--- a/scripts/mod/mk_elfconfig.c
++++ b/scripts/mod/mk_elfconfig.c
+@@ -1,7 +1,11 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
++#ifndef __APPLE__
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ 
+ int
+ main(int argc, char **argv)
+--- a/scripts/mod/modpost.h
++++ b/scripts/mod/modpost.h
+@@ -7,7 +7,11 @@
+ #include <sys/mman.h>
+ #include <fcntl.h>
+ #include <unistd.h>
++#if !(defined(__APPLE__) || defined(__CYGWIN__))
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ 
+ #include "elfconfig.h"
+ 
+--- /dev/null
++++ b/scripts/mod/elf.h
+@@ -0,0 +1,3007 @@
++/* This file defines standard ELF types, structures, and macros.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _ELF_H
++#define	_ELF_H 1
++
++/* Standard ELF types.  */
++
++#include <stdint.h>
++
++/* Type for a 16-bit quantity.  */
++typedef uint16_t Elf32_Half;
++typedef uint16_t Elf64_Half;
++
++/* Types for signed and unsigned 32-bit quantities.  */
++typedef uint32_t Elf32_Word;
++typedef	int32_t  Elf32_Sword;
++typedef uint32_t Elf64_Word;
++typedef	int32_t  Elf64_Sword;
++
++/* Types for signed and unsigned 64-bit quantities.  */
++typedef uint64_t Elf32_Xword;
++typedef	int64_t  Elf32_Sxword;
++typedef uint64_t Elf64_Xword;
++typedef	int64_t  Elf64_Sxword;
++
++/* Type of addresses.  */
++typedef uint32_t Elf32_Addr;
++typedef uint64_t Elf64_Addr;
++
++/* Type of file offsets.  */
++typedef uint32_t Elf32_Off;
++typedef uint64_t Elf64_Off;
++
++/* Type for section indices, which are 16-bit quantities.  */
++typedef uint16_t Elf32_Section;
++typedef uint16_t Elf64_Section;
++
++/* Type for version symbol information.  */
++typedef Elf32_Half Elf32_Versym;
++typedef Elf64_Half Elf64_Versym;
++
++
++/* The ELF file header.  This appears at the start of every ELF file.  */
++
++#define EI_NIDENT (16)
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf32_Half	e_type;			/* Object file type */
++  Elf32_Half	e_machine;		/* Architecture */
++  Elf32_Word	e_version;		/* Object file version */
++  Elf32_Addr	e_entry;		/* Entry point virtual address */
++  Elf32_Off	e_phoff;		/* Program header table file offset */
++  Elf32_Off	e_shoff;		/* Section header table file offset */
++  Elf32_Word	e_flags;		/* Processor-specific flags */
++  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf32_Half	e_phentsize;		/* Program header table entry size */
++  Elf32_Half	e_phnum;		/* Program header table entry count */
++  Elf32_Half	e_shentsize;		/* Section header table entry size */
++  Elf32_Half	e_shnum;		/* Section header table entry count */
++  Elf32_Half	e_shstrndx;		/* Section header string table index */
++} Elf32_Ehdr;
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf64_Half	e_type;			/* Object file type */
++  Elf64_Half	e_machine;		/* Architecture */
++  Elf64_Word	e_version;		/* Object file version */
++  Elf64_Addr	e_entry;		/* Entry point virtual address */
++  Elf64_Off	e_phoff;		/* Program header table file offset */
++  Elf64_Off	e_shoff;		/* Section header table file offset */
++  Elf64_Word	e_flags;		/* Processor-specific flags */
++  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf64_Half	e_phentsize;		/* Program header table entry size */
++  Elf64_Half	e_phnum;		/* Program header table entry count */
++  Elf64_Half	e_shentsize;		/* Section header table entry size */
++  Elf64_Half	e_shnum;		/* Section header table entry count */
++  Elf64_Half	e_shstrndx;		/* Section header string table index */
++} Elf64_Ehdr;
++
++/* Fields in the e_ident array.  The EI_* macros are indices into the
++   array.  The macros under each EI_* macro are the values the byte
++   may have.  */
++
++#define EI_MAG0		0		/* File identification byte 0 index */
++#define ELFMAG0		0x7f		/* Magic number byte 0 */
++
++#define EI_MAG1		1		/* File identification byte 1 index */
++#define ELFMAG1		'E'		/* Magic number byte 1 */
++
++#define EI_MAG2		2		/* File identification byte 2 index */
++#define ELFMAG2		'L'		/* Magic number byte 2 */
++
++#define EI_MAG3		3		/* File identification byte 3 index */
++#define ELFMAG3		'F'		/* Magic number byte 3 */
++
++/* Conglomeration of the identification bytes, for easy testing as a word.  */
++#define	ELFMAG		"\177ELF"
++#define	SELFMAG		4
++
++#define EI_CLASS	4		/* File class byte index */
++#define ELFCLASSNONE	0		/* Invalid class */
++#define ELFCLASS32	1		/* 32-bit objects */
++#define ELFCLASS64	2		/* 64-bit objects */
++#define ELFCLASSNUM	3
++
++#define EI_DATA		5		/* Data encoding byte index */
++#define ELFDATANONE	0		/* Invalid data encoding */
++#define ELFDATA2LSB	1		/* 2's complement, little endian */
++#define ELFDATA2MSB	2		/* 2's complement, big endian */
++#define ELFDATANUM	3
++
++#define EI_VERSION	6		/* File version byte index */
++					/* Value must be EV_CURRENT */
++
++#define EI_OSABI	7		/* OS ABI identification */
++#define ELFOSABI_NONE		0	/* UNIX System V ABI */
++#define ELFOSABI_SYSV		0	/* Alias.  */
++#define ELFOSABI_HPUX		1	/* HP-UX */
++#define ELFOSABI_NETBSD		2	/* NetBSD.  */
++#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
++#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
++#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
++#define ELFOSABI_AIX		7	/* IBM AIX.  */
++#define ELFOSABI_IRIX		8	/* SGI Irix.  */
++#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
++#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
++#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
++#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
++#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
++#define ELFOSABI_ARM		97	/* ARM */
++#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
++
++#define EI_ABIVERSION	8		/* ABI version */
++
++#define EI_PAD		9		/* Byte index of padding bytes */
++
++/* Legal values for e_type (object file type).  */
++
++#define ET_NONE		0		/* No file type */
++#define ET_REL		1		/* Relocatable file */
++#define ET_EXEC		2		/* Executable file */
++#define ET_DYN		3		/* Shared object file */
++#define ET_CORE		4		/* Core file */
++#define	ET_NUM		5		/* Number of defined types */
++#define ET_LOOS		0xfe00		/* OS-specific range start */
++#define ET_HIOS		0xfeff		/* OS-specific range end */
++#define ET_LOPROC	0xff00		/* Processor-specific range start */
++#define ET_HIPROC	0xffff		/* Processor-specific range end */
++
++/* Legal values for e_machine (architecture).  */
++
++#define EM_NONE		 0		/* No machine */
++#define EM_M32		 1		/* AT&T WE 32100 */
++#define EM_SPARC	 2		/* SUN SPARC */
++#define EM_386		 3		/* Intel 80386 */
++#define EM_68K		 4		/* Motorola m68k family */
++#define EM_88K		 5		/* Motorola m88k family */
++#define EM_860		 7		/* Intel 80860 */
++#define EM_MIPS		 8		/* MIPS R3000 big-endian */
++#define EM_S370		 9		/* IBM System/370 */
++#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
++
++#define EM_PARISC	15		/* HPPA */
++#define EM_VPP500	17		/* Fujitsu VPP500 */
++#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
++#define EM_960		19		/* Intel 80960 */
++#define EM_PPC		20		/* PowerPC */
++#define EM_PPC64	21		/* PowerPC 64-bit */
++#define EM_S390		22		/* IBM S390 */
++
++#define EM_V800		36		/* NEC V800 series */
++#define EM_FR20		37		/* Fujitsu FR20 */
++#define EM_RH32		38		/* TRW RH-32 */
++#define EM_RCE		39		/* Motorola RCE */
++#define EM_ARM		40		/* ARM */
++#define EM_FAKE_ALPHA	41		/* Digital Alpha */
++#define EM_SH		42		/* Hitachi SH */
++#define EM_SPARCV9	43		/* SPARC v9 64-bit */
++#define EM_TRICORE	44		/* Siemens Tricore */
++#define EM_ARC		45		/* Argonaut RISC Core */
++#define EM_H8_300	46		/* Hitachi H8/300 */
++#define EM_H8_300H	47		/* Hitachi H8/300H */
++#define EM_H8S		48		/* Hitachi H8S */
++#define EM_H8_500	49		/* Hitachi H8/500 */
++#define EM_IA_64	50		/* Intel Merced */
++#define EM_MIPS_X	51		/* Stanford MIPS-X */
++#define EM_COLDFIRE	52		/* Motorola Coldfire */
++#define EM_68HC12	53		/* Motorola M68HC12 */
++#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
++#define EM_PCP		55		/* Siemens PCP */
++#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
++#define EM_NDR1		57		/* Denso NDR1 microprocessor */
++#define EM_STARCORE	58		/* Motorola Start*Core processor */
++#define EM_ME16		59		/* Toyota ME16 processor */
++#define EM_ST100	60		/* STMicroelectronic ST100 processor */
++#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
++#define EM_X86_64	62		/* AMD x86-64 architecture */
++#define EM_PDSP		63		/* Sony DSP Processor */
++
++#define EM_FX66		66		/* Siemens FX66 microcontroller */
++#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
++#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
++#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
++#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
++#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
++#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
++#define EM_SVX		73		/* Silicon Graphics SVx */
++#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
++#define EM_VAX		75		/* Digital VAX */
++#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
++#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
++#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
++#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
++#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
++#define EM_HUANY	81		/* Harvard University machine-independent object files */
++#define EM_PRISM	82		/* SiTera Prism */
++#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
++#define EM_FR30		84		/* Fujitsu FR30 */
++#define EM_D10V		85		/* Mitsubishi D10V */
++#define EM_D30V		86		/* Mitsubishi D30V */
++#define EM_V850		87		/* NEC v850 */
++#define EM_M32R		88		/* Mitsubishi M32R */
++#define EM_MN10300	89		/* Matsushita MN10300 */
++#define EM_MN10200	90		/* Matsushita MN10200 */
++#define EM_PJ		91		/* picoJava */
++#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
++#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
++#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
++#define EM_TILEPRO	188		/* Tilera TILEPro */
++#define EM_TILEGX	191		/* Tilera TILE-Gx */
++#define EM_NUM		192
++
++/* If it is necessary to assign new unofficial EM_* values, please
++   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
++   chances of collision with official or non-GNU unofficial values.  */
++
++#define EM_ALPHA	0x9026
++
++/* Legal values for e_version (version).  */
++
++#define EV_NONE		0		/* Invalid ELF version */
++#define EV_CURRENT	1		/* Current version */
++#define EV_NUM		2
++
++/* Section header.  */
++
++typedef struct
++{
++  Elf32_Word	sh_name;		/* Section name (string tbl index) */
++  Elf32_Word	sh_type;		/* Section type */
++  Elf32_Word	sh_flags;		/* Section flags */
++  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf32_Off	sh_offset;		/* Section file offset */
++  Elf32_Word	sh_size;		/* Section size in bytes */
++  Elf32_Word	sh_link;		/* Link to another section */
++  Elf32_Word	sh_info;		/* Additional section information */
++  Elf32_Word	sh_addralign;		/* Section alignment */
++  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
++} Elf32_Shdr;
++
++typedef struct
++{
++  Elf64_Word	sh_name;		/* Section name (string tbl index) */
++  Elf64_Word	sh_type;		/* Section type */
++  Elf64_Xword	sh_flags;		/* Section flags */
++  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf64_Off	sh_offset;		/* Section file offset */
++  Elf64_Xword	sh_size;		/* Section size in bytes */
++  Elf64_Word	sh_link;		/* Link to another section */
++  Elf64_Word	sh_info;		/* Additional section information */
++  Elf64_Xword	sh_addralign;		/* Section alignment */
++  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
++} Elf64_Shdr;
++
++/* Special section indices.  */
++
++#define SHN_UNDEF	0		/* Undefined section */
++#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
++#define SHN_LOPROC	0xff00		/* Start of processor-specific */
++#define SHN_BEFORE	0xff00		/* Order section before all others
++					   (Solaris).  */
++#define SHN_AFTER	0xff01		/* Order section after all others
++					   (Solaris).  */
++#define SHN_HIPROC	0xff1f		/* End of processor-specific */
++#define SHN_LOOS	0xff20		/* Start of OS-specific */
++#define SHN_HIOS	0xff3f		/* End of OS-specific */
++#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
++#define SHN_COMMON	0xfff2		/* Associated symbol is common */
++#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
++#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
++
++/* Legal values for sh_type (section type).  */
++
++#define SHT_NULL	  0		/* Section header table entry unused */
++#define SHT_PROGBITS	  1		/* Program data */
++#define SHT_SYMTAB	  2		/* Symbol table */
++#define SHT_STRTAB	  3		/* String table */
++#define SHT_RELA	  4		/* Relocation entries with addends */
++#define SHT_HASH	  5		/* Symbol hash table */
++#define SHT_DYNAMIC	  6		/* Dynamic linking information */
++#define SHT_NOTE	  7		/* Notes */
++#define SHT_NOBITS	  8		/* Program space with no data (bss) */
++#define SHT_REL		  9		/* Relocation entries, no addends */
++#define SHT_SHLIB	  10		/* Reserved */
++#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
++#define SHT_INIT_ARRAY	  14		/* Array of constructors */
++#define SHT_FINI_ARRAY	  15		/* Array of destructors */
++#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
++#define SHT_GROUP	  17		/* Section group */
++#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
++#define	SHT_NUM		  19		/* Number of defined types.  */
++#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
++#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
++#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
++#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
++#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
++#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
++#define SHT_SUNW_move	  0x6ffffffa
++#define SHT_SUNW_COMDAT   0x6ffffffb
++#define SHT_SUNW_syminfo  0x6ffffffc
++#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
++#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
++#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
++#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
++#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
++#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
++#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
++#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
++#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
++
++/* Legal values for sh_flags (section flags).  */
++
++#define SHF_WRITE	     (1 << 0)	/* Writable */
++#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
++#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
++#define SHF_MERGE	     (1 << 4)	/* Might be merged */
++#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
++#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
++#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
++#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
++					   required */
++#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
++#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
++#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
++#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
++#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
++					   (Solaris).  */
++#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
++					   referenced or allocated (Solaris).*/
++
++/* Section group handling.  */
++#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
++
++/* Symbol table entry.  */
++
++typedef struct
++{
++  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
++  Elf32_Addr	st_value;		/* Symbol value */
++  Elf32_Word	st_size;		/* Symbol size */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char	st_other;		/* Symbol visibility */
++  Elf32_Section	st_shndx;		/* Section index */
++} Elf32_Sym;
++
++typedef struct
++{
++  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char st_other;		/* Symbol visibility */
++  Elf64_Section	st_shndx;		/* Section index */
++  Elf64_Addr	st_value;		/* Symbol value */
++  Elf64_Xword	st_size;		/* Symbol size */
++} Elf64_Sym;
++
++/* The syminfo section if available contains additional information about
++   every dynamic symbol.  */
++
++typedef struct
++{
++  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf32_Half si_flags;			/* Per symbol flags */
++} Elf32_Syminfo;
++
++typedef struct
++{
++  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf64_Half si_flags;			/* Per symbol flags */
++} Elf64_Syminfo;
++
++/* Possible values for si_boundto.  */
++#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
++#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
++#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
++
++/* Possible bitmasks for si_flags.  */
++#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
++#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
++#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
++#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
++					   loaded */
++/* Syminfo version values.  */
++#define SYMINFO_NONE		0
++#define SYMINFO_CURRENT		1
++#define SYMINFO_NUM		2
++
++
++/* How to extract and insert information held in the st_info field.  */
++
++#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
++#define ELF32_ST_TYPE(val)		((val) & 0xf)
++#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
++
++/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
++#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
++#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
++#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
++
++/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
++
++#define STB_LOCAL	0		/* Local symbol */
++#define STB_GLOBAL	1		/* Global symbol */
++#define STB_WEAK	2		/* Weak symbol */
++#define	STB_NUM		3		/* Number of defined types.  */
++#define STB_LOOS	10		/* Start of OS-specific */
++#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
++#define STB_HIOS	12		/* End of OS-specific */
++#define STB_LOPROC	13		/* Start of processor-specific */
++#define STB_HIPROC	15		/* End of processor-specific */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_NOTYPE	0		/* Symbol type is unspecified */
++#define STT_OBJECT	1		/* Symbol is a data object */
++#define STT_FUNC	2		/* Symbol is a code object */
++#define STT_SECTION	3		/* Symbol associated with a section */
++#define STT_FILE	4		/* Symbol's name is file name */
++#define STT_COMMON	5		/* Symbol is a common data object */
++#define STT_TLS		6		/* Symbol is thread-local data object*/
++#define	STT_NUM		7		/* Number of defined types.  */
++#define STT_LOOS	10		/* Start of OS-specific */
++#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
++#define STT_HIOS	12		/* End of OS-specific */
++#define STT_LOPROC	13		/* Start of processor-specific */
++#define STT_HIPROC	15		/* End of processor-specific */
++
++
++/* Symbol table indices are found in the hash buckets and chain table
++   of a symbol hash table section.  This special index value indicates
++   the end of a chain, meaning no further symbols are found in that bucket.  */
++
++#define STN_UNDEF	0		/* End of a chain.  */
++
++
++/* How to extract and insert information held in the st_other field.  */
++
++#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
++
++/* For ELF64 the definitions are the same.  */
++#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
++
++/* Symbol visibility specification encoded in the st_other field.  */
++#define STV_DEFAULT	0		/* Default symbol visibility rules */
++#define STV_INTERNAL	1		/* Processor specific hidden class */
++#define STV_HIDDEN	2		/* Sym unavailable in other modules */
++#define STV_PROTECTED	3		/* Not preemptible, not exported */
++
++
++/* Relocation table entry without addend (in section of type SHT_REL).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++} Elf32_Rel;
++
++/* I have seen two different definitions of the Elf64_Rel and
++   Elf64_Rela structures, so we'll leave them out until Novell (or
++   whoever) gets their act together.  */
++/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++} Elf64_Rel;
++
++/* Relocation table entry with addend (in section of type SHT_RELA).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++  Elf32_Sword	r_addend;		/* Addend */
++} Elf32_Rela;
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++  Elf64_Sxword	r_addend;		/* Addend */
++} Elf64_Rela;
++
++/* How to extract and insert information held in the r_info field.  */
++
++#define ELF32_R_SYM(val)		((val) >> 8)
++#define ELF32_R_TYPE(val)		((val) & 0xff)
++#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
++
++#define ELF64_R_SYM(i)			((i) >> 32)
++#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
++#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
++
++/* Program segment header.  */
++
++typedef struct
++{
++  Elf32_Word	p_type;			/* Segment type */
++  Elf32_Off	p_offset;		/* Segment file offset */
++  Elf32_Addr	p_vaddr;		/* Segment virtual address */
++  Elf32_Addr	p_paddr;		/* Segment physical address */
++  Elf32_Word	p_filesz;		/* Segment size in file */
++  Elf32_Word	p_memsz;		/* Segment size in memory */
++  Elf32_Word	p_flags;		/* Segment flags */
++  Elf32_Word	p_align;		/* Segment alignment */
++} Elf32_Phdr;
++
++typedef struct
++{
++  Elf64_Word	p_type;			/* Segment type */
++  Elf64_Word	p_flags;		/* Segment flags */
++  Elf64_Off	p_offset;		/* Segment file offset */
++  Elf64_Addr	p_vaddr;		/* Segment virtual address */
++  Elf64_Addr	p_paddr;		/* Segment physical address */
++  Elf64_Xword	p_filesz;		/* Segment size in file */
++  Elf64_Xword	p_memsz;		/* Segment size in memory */
++  Elf64_Xword	p_align;		/* Segment alignment */
++} Elf64_Phdr;
++
++/* Special value for e_phnum.  This indicates that the real number of
++   program headers is too large to fit into e_phnum.  Instead the real
++   value is in the field sh_info of section 0.  */
++
++#define PN_XNUM		0xffff
++
++/* Legal values for p_type (segment type).  */
++
++#define	PT_NULL		0		/* Program header table entry unused */
++#define PT_LOAD		1		/* Loadable program segment */
++#define PT_DYNAMIC	2		/* Dynamic linking information */
++#define PT_INTERP	3		/* Program interpreter */
++#define PT_NOTE		4		/* Auxiliary information */
++#define PT_SHLIB	5		/* Reserved */
++#define PT_PHDR		6		/* Entry for header table itself */
++#define PT_TLS		7		/* Thread-local storage segment */
++#define	PT_NUM		8		/* Number of defined types */
++#define PT_LOOS		0x60000000	/* Start of OS-specific */
++#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
++#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
++#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
++#define PT_LOSUNW	0x6ffffffa
++#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
++#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
++#define PT_HISUNW	0x6fffffff
++#define PT_HIOS		0x6fffffff	/* End of OS-specific */
++#define PT_LOPROC	0x70000000	/* Start of processor-specific */
++#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
++
++/* Legal values for p_flags (segment flags).  */
++
++#define PF_X		(1 << 0)	/* Segment is executable */
++#define PF_W		(1 << 1)	/* Segment is writable */
++#define PF_R		(1 << 2)	/* Segment is readable */
++#define PF_MASKOS	0x0ff00000	/* OS-specific */
++#define PF_MASKPROC	0xf0000000	/* Processor-specific */
++
++/* Legal values for note segment descriptor types for core files. */
++
++#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
++#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
++#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
++#define NT_PRXREG	4		/* Contains copy of prxregset struct */
++#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
++#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
++#define NT_AUXV		6		/* Contains copy of auxv array */
++#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
++#define NT_ASRS		8		/* Contains copy of asrset struct */
++#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
++#define NT_PSINFO	13		/* Contains copy of psinfo struct */
++#define NT_PRCRED	14		/* Contains copy of prcred struct */
++#define NT_UTSNAME	15		/* Contains copy of utsname struct */
++#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
++#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
++#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
++#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
++#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
++#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
++#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
++#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
++#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
++#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
++
++/* Legal values for the note segment descriptor types for object files.  */
++
++#define NT_VERSION	1		/* Contains a version string.  */
++
++
++/* Dynamic section entry.  */
++
++typedef struct
++{
++  Elf32_Sword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf32_Word d_val;			/* Integer value */
++      Elf32_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf32_Dyn;
++
++typedef struct
++{
++  Elf64_Sxword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf64_Xword d_val;		/* Integer value */
++      Elf64_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf64_Dyn;
++
++/* Legal values for d_tag (dynamic entry type).  */
++
++#define DT_NULL		0		/* Marks end of dynamic section */
++#define DT_NEEDED	1		/* Name of needed library */
++#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
++#define DT_PLTGOT	3		/* Processor defined value */
++#define DT_HASH		4		/* Address of symbol hash table */
++#define DT_STRTAB	5		/* Address of string table */
++#define DT_SYMTAB	6		/* Address of symbol table */
++#define DT_RELA		7		/* Address of Rela relocs */
++#define DT_RELASZ	8		/* Total size of Rela relocs */
++#define DT_RELAENT	9		/* Size of one Rela reloc */
++#define DT_STRSZ	10		/* Size of string table */
++#define DT_SYMENT	11		/* Size of one symbol table entry */
++#define DT_INIT		12		/* Address of init function */
++#define DT_FINI		13		/* Address of termination function */
++#define DT_SONAME	14		/* Name of shared object */
++#define DT_RPATH	15		/* Library search path (deprecated) */
++#define DT_SYMBOLIC	16		/* Start symbol search here */
++#define DT_REL		17		/* Address of Rel relocs */
++#define DT_RELSZ	18		/* Total size of Rel relocs */
++#define DT_RELENT	19		/* Size of one Rel reloc */
++#define DT_PLTREL	20		/* Type of reloc in PLT */
++#define DT_DEBUG	21		/* For debugging; unspecified */
++#define DT_TEXTREL	22		/* Reloc might modify .text */
++#define DT_JMPREL	23		/* Address of PLT relocs */
++#define	DT_BIND_NOW	24		/* Process relocations of object */
++#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
++#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
++#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
++#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
++#define DT_RUNPATH	29		/* Library search path */
++#define DT_FLAGS	30		/* Flags for the object being loaded */
++#define DT_ENCODING	32		/* Start of encoded range */
++#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
++#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
++#define	DT_NUM		34		/* Number used */
++#define DT_LOOS		0x6000000d	/* Start of OS-specific */
++#define DT_HIOS		0x6ffff000	/* End of OS-specific */
++#define DT_LOPROC	0x70000000	/* Start of processor-specific */
++#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
++#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
++
++/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
++   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
++   approach.  */
++#define DT_VALRNGLO	0x6ffffd00
++#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
++#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
++#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
++#define DT_CHECKSUM	0x6ffffdf8
++#define DT_PLTPADSZ	0x6ffffdf9
++#define DT_MOVEENT	0x6ffffdfa
++#define DT_MOVESZ	0x6ffffdfb
++#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
++#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
++					   the following DT_* entry.  */
++#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
++#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
++#define DT_VALRNGHI	0x6ffffdff
++#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
++#define DT_VALNUM 12
++
++/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
++   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
++
++   If any adjustment is made to the ELF object after it has been
++   built these entries will need to be adjusted.  */
++#define DT_ADDRRNGLO	0x6ffffe00
++#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
++#define DT_TLSDESC_PLT	0x6ffffef6
++#define DT_TLSDESC_GOT	0x6ffffef7
++#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
++#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
++#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
++#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
++#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
++#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
++#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
++#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
++#define DT_ADDRRNGHI	0x6ffffeff
++#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
++#define DT_ADDRNUM 11
++
++/* The versioning entry types.  The next are defined as part of the
++   GNU extension.  */
++#define DT_VERSYM	0x6ffffff0
++
++#define DT_RELACOUNT	0x6ffffff9
++#define DT_RELCOUNT	0x6ffffffa
++
++/* These were chosen by Sun.  */
++#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
++#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
++					   table */
++#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
++#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
++					   versions */
++#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
++#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
++#define DT_VERSIONTAGNUM 16
++
++/* Sun added these machine-independent extensions in the "processor-specific"
++   range.  Be compatible.  */
++#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
++#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
++#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
++#define DT_EXTRANUM	3
++
++/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
++#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
++#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
++#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
++#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
++#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
++
++/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
++   entry in the dynamic section.  */
++#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
++#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
++#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
++#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
++#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
++#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
++#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
++#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
++#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
++#define DF_1_TRANS	0x00000200
++#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
++#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
++#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
++#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
++#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
++#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
++#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
++
++/* Flags for the feature selection in DT_FEATURE_1.  */
++#define DTF_1_PARINIT	0x00000001
++#define DTF_1_CONFEXP	0x00000002
++
++/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
++#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
++#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
++					   generally available.  */
++
++/* Version definition sections.  */
++
++typedef struct
++{
++  Elf32_Half	vd_version;		/* Version revision */
++  Elf32_Half	vd_flags;		/* Version information */
++  Elf32_Half	vd_ndx;			/* Version Index */
++  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vd_hash;		/* Version name hash value */
++  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf32_Verdef;
++
++typedef struct
++{
++  Elf64_Half	vd_version;		/* Version revision */
++  Elf64_Half	vd_flags;		/* Version information */
++  Elf64_Half	vd_ndx;			/* Version Index */
++  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vd_hash;		/* Version name hash value */
++  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf64_Verdef;
++
++
++/* Legal values for vd_version (version revision).  */
++#define VER_DEF_NONE	0		/* No version */
++#define VER_DEF_CURRENT	1		/* Current version */
++#define VER_DEF_NUM	2		/* Given version number */
++
++/* Legal values for vd_flags (version information flags).  */
++#define VER_FLG_BASE	0x1		/* Version definition of file itself */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++/* Versym symbol index values.  */
++#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
++#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
++#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
++#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
++
++/* Auxialiary version information.  */
++
++typedef struct
++{
++  Elf32_Word	vda_name;		/* Version or dependency names */
++  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf32_Verdaux;
++
++typedef struct
++{
++  Elf64_Word	vda_name;		/* Version or dependency names */
++  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf64_Verdaux;
++
++
++/* Version dependency section.  */
++
++typedef struct
++{
++  Elf32_Half	vn_version;		/* Version of structure */
++  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf32_Verneed;
++
++typedef struct
++{
++  Elf64_Half	vn_version;		/* Version of structure */
++  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf64_Verneed;
++
++
++/* Legal values for vn_version (version revision).  */
++#define VER_NEED_NONE	 0		/* No version */
++#define VER_NEED_CURRENT 1		/* Current version */
++#define VER_NEED_NUM	 2		/* Given version number */
++
++/* Auxiliary needed version information.  */
++
++typedef struct
++{
++  Elf32_Word	vna_hash;		/* Hash value of dependency name */
++  Elf32_Half	vna_flags;		/* Dependency specific information */
++  Elf32_Half	vna_other;		/* Unused */
++  Elf32_Word	vna_name;		/* Dependency name string offset */
++  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf32_Vernaux;
++
++typedef struct
++{
++  Elf64_Word	vna_hash;		/* Hash value of dependency name */
++  Elf64_Half	vna_flags;		/* Dependency specific information */
++  Elf64_Half	vna_other;		/* Unused */
++  Elf64_Word	vna_name;		/* Dependency name string offset */
++  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf64_Vernaux;
++
++
++/* Legal values for vna_flags.  */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++
++/* Auxiliary vector.  */
++
++/* This vector is normally only used by the program interpreter.  The
++   usual definition in an ABI supplement uses the name auxv_t.  The
++   vector is not usually defined in a standard <elf.h> file, but it
++   can't hurt.  We rename it to avoid conflicts.  The sizes of these
++   types are an arrangement between the exec server and the program
++   interpreter, so we don't fully specify them here.  */
++
++typedef struct
++{
++  uint32_t a_type;		/* Entry type */
++  union
++    {
++      uint32_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf32_auxv_t;
++
++typedef struct
++{
++  uint64_t a_type;		/* Entry type */
++  union
++    {
++      uint64_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf64_auxv_t;
++
++/* Legal values for a_type (entry type).  */
++
++#define AT_NULL		0		/* End of vector */
++#define AT_IGNORE	1		/* Entry should be ignored */
++#define AT_EXECFD	2		/* File descriptor of program */
++#define AT_PHDR		3		/* Program headers for program */
++#define AT_PHENT	4		/* Size of program header entry */
++#define AT_PHNUM	5		/* Number of program headers */
++#define AT_PAGESZ	6		/* System page size */
++#define AT_BASE		7		/* Base address of interpreter */
++#define AT_FLAGS	8		/* Flags */
++#define AT_ENTRY	9		/* Entry point of program */
++#define AT_NOTELF	10		/* Program is not ELF */
++#define AT_UID		11		/* Real uid */
++#define AT_EUID		12		/* Effective uid */
++#define AT_GID		13		/* Real gid */
++#define AT_EGID		14		/* Effective gid */
++#define AT_CLKTCK	17		/* Frequency of times() */
++
++/* Some more special a_type values describing the hardware.  */
++#define AT_PLATFORM	15		/* String identifying platform.  */
++#define AT_HWCAP	16		/* Machine dependent hints about
++					   processor capabilities.  */
++
++/* This entry gives some information about the FPU initialization
++   performed by the kernel.  */
++#define AT_FPUCW	18		/* Used FPU control word.  */
++
++/* Cache block sizes.  */
++#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
++#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
++#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
++
++/* A special ignored value for PPC, used by the kernel to control the
++   interpretation of the AUXV. Must be > 16.  */
++#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
++
++#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
++
++#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
++
++#define AT_RANDOM	25		/* Address of 16 random bytes.  */
++
++#define AT_EXECFN	31		/* Filename of executable.  */
++
++/* Pointer to the global system page used for system calls and other
++   nice things.  */
++#define AT_SYSINFO	32
++#define AT_SYSINFO_EHDR	33
++
++/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
++   log2 of line size; mask those to get cache size.  */
++#define AT_L1I_CACHESHAPE	34
++#define AT_L1D_CACHESHAPE	35
++#define AT_L2_CACHESHAPE	36
++#define AT_L3_CACHESHAPE	37
++
++/* Note section contents.  Each entry in the note section begins with
++   a header of a fixed form.  */
++
++typedef struct
++{
++  Elf32_Word n_namesz;			/* Length of the note's name.  */
++  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf32_Word n_type;			/* Type of the note.  */
++} Elf32_Nhdr;
++
++typedef struct
++{
++  Elf64_Word n_namesz;			/* Length of the note's name.  */
++  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf64_Word n_type;			/* Type of the note.  */
++} Elf64_Nhdr;
++
++/* Known names of notes.  */
++
++/* Solaris entries in the note section have this name.  */
++#define ELF_NOTE_SOLARIS	"SUNW Solaris"
++
++/* Note entries for GNU systems have this name.  */
++#define ELF_NOTE_GNU		"GNU"
++
++
++/* Defined types of notes for Solaris.  */
++
++/* Value of descriptor (one word) is desired pagesize for the binary.  */
++#define ELF_NOTE_PAGESIZE_HINT	1
++
++
++/* Defined note types for GNU systems.  */
++
++/* ABI information.  The descriptor consists of words:
++   word 0: OS descriptor
++   word 1: major version of the ABI
++   word 2: minor version of the ABI
++   word 3: subminor version of the ABI
++*/
++#define NT_GNU_ABI_TAG	1
++#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
++
++/* Known OSes.  These values can appear in word 0 of an
++   NT_GNU_ABI_TAG note section entry.  */
++#define ELF_NOTE_OS_LINUX	0
++#define ELF_NOTE_OS_GNU		1
++#define ELF_NOTE_OS_SOLARIS2	2
++#define ELF_NOTE_OS_FREEBSD	3
++
++/* Synthetic hwcap information.  The descriptor begins with two words:
++   word 0: number of entries
++   word 1: bitmask of enabled entries
++   Then follow variable-length entries, one byte followed by a
++   '\0'-terminated hwcap name string.  The byte gives the bit
++   number to test if enabled, (1U << bit) & bitmask.  */
++#define NT_GNU_HWCAP	2
++
++/* Build ID bits as generated by ld --build-id.
++   The descriptor consists of any nonzero number of bytes.  */
++#define NT_GNU_BUILD_ID	3
++
++/* Version note generated by GNU gold containing a version string.  */
++#define NT_GNU_GOLD_VERSION	4
++
++
++/* Move records.  */
++typedef struct
++{
++  Elf32_Xword m_value;		/* Symbol value.  */
++  Elf32_Word m_info;		/* Size and index.  */
++  Elf32_Word m_poffset;		/* Symbol offset.  */
++  Elf32_Half m_repeat;		/* Repeat count.  */
++  Elf32_Half m_stride;		/* Stride info.  */
++} Elf32_Move;
++
++typedef struct
++{
++  Elf64_Xword m_value;		/* Symbol value.  */
++  Elf64_Xword m_info;		/* Size and index.  */
++  Elf64_Xword m_poffset;	/* Symbol offset.  */
++  Elf64_Half m_repeat;		/* Repeat count.  */
++  Elf64_Half m_stride;		/* Stride info.  */
++} Elf64_Move;
++
++/* Macro to construct move records.  */
++#define ELF32_M_SYM(info)	((info) >> 8)
++#define ELF32_M_SIZE(info)	((unsigned char) (info))
++#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
++
++#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
++#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
++#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
++
++
++/* Motorola 68k specific definitions.  */
++
++/* Values for Elf32_Ehdr.e_flags.  */
++#define EF_CPU32	0x00810000
++
++/* m68k relocs.  */
++
++#define R_68K_NONE	0		/* No reloc */
++#define R_68K_32	1		/* Direct 32 bit  */
++#define R_68K_16	2		/* Direct 16 bit  */
++#define R_68K_8		3		/* Direct 8 bit  */
++#define R_68K_PC32	4		/* PC relative 32 bit */
++#define R_68K_PC16	5		/* PC relative 16 bit */
++#define R_68K_PC8	6		/* PC relative 8 bit */
++#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
++#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
++#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
++#define R_68K_GOT32O	10		/* 32 bit GOT offset */
++#define R_68K_GOT16O	11		/* 16 bit GOT offset */
++#define R_68K_GOT8O	12		/* 8 bit GOT offset */
++#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
++#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
++#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
++#define R_68K_PLT32O	16		/* 32 bit PLT offset */
++#define R_68K_PLT16O	17		/* 16 bit PLT offset */
++#define R_68K_PLT8O	18		/* 8 bit PLT offset */
++#define R_68K_COPY	19		/* Copy symbol at runtime */
++#define R_68K_GLOB_DAT	20		/* Create GOT entry */
++#define R_68K_JMP_SLOT	21		/* Create PLT entry */
++#define R_68K_RELATIVE	22		/* Adjust by program base */
++#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
++#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
++#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
++#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
++#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
++#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
++#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
++#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
++#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
++#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
++#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
++#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
++#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
++#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
++#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
++/* Keep this the last entry.  */
++#define R_68K_NUM	43
++
++/* Intel 80386 specific definitions.  */
++
++/* i386 relocs.  */
++
++#define R_386_NONE	   0		/* No reloc */
++#define R_386_32	   1		/* Direct 32 bit  */
++#define R_386_PC32	   2		/* PC relative 32 bit */
++#define R_386_GOT32	   3		/* 32 bit GOT entry */
++#define R_386_PLT32	   4		/* 32 bit PLT address */
++#define R_386_COPY	   5		/* Copy symbol at runtime */
++#define R_386_GLOB_DAT	   6		/* Create GOT entry */
++#define R_386_JMP_SLOT	   7		/* Create PLT entry */
++#define R_386_RELATIVE	   8		/* Adjust by program base */
++#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
++#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
++#define R_386_32PLT	   11
++#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
++#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
++					   block offset */
++#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
++					   offset */
++#define R_386_TLS_LE	   17		/* Offset relative to static TLS
++					   block */
++#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
++					   general dynamic thread local data */
++#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
++					   local dynamic thread local data
++					   in LE code */
++#define R_386_16	   20
++#define R_386_PC16	   21
++#define R_386_8		   22
++#define R_386_PC8	   23
++#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
++					   thread local data */
++#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
++#define R_386_TLS_GD_CALL  26		/* Relocation for call to
++					   __tls_get_addr() */
++#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
++#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
++					   thread local data in LE code */
++#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
++#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
++					   __tls_get_addr() in LDM code */
++#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
++#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
++#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
++					   block offset */
++#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
++					   TLS block */
++#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
++#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
++#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
++/* 38? */
++#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
++#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
++					   descriptor for
++					   relaxation.  */
++#define R_386_TLS_DESC     41		/* TLS descriptor containing
++					   pointer to code and to
++					   argument, returning the TLS
++					   offset for the symbol.  */
++#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
++/* Keep this the last entry.  */
++#define R_386_NUM	   43
++
++/* SUN SPARC specific definitions.  */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
++
++/* Values for Elf64_Ehdr.e_flags.  */
++
++#define EF_SPARCV9_MM		3
++#define EF_SPARCV9_TSO		0
++#define EF_SPARCV9_PSO		1
++#define EF_SPARCV9_RMO		2
++#define EF_SPARC_LEDATA		0x800000 /* little endian data */
++#define EF_SPARC_EXT_MASK	0xFFFF00
++#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
++#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
++#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
++#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
++
++/* SPARC relocs.  */
++
++#define R_SPARC_NONE		0	/* No reloc */
++#define R_SPARC_8		1	/* Direct 8 bit */
++#define R_SPARC_16		2	/* Direct 16 bit */
++#define R_SPARC_32		3	/* Direct 32 bit */
++#define R_SPARC_DISP8		4	/* PC relative 8 bit */
++#define R_SPARC_DISP16		5	/* PC relative 16 bit */
++#define R_SPARC_DISP32		6	/* PC relative 32 bit */
++#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
++#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
++#define R_SPARC_HI22		9	/* High 22 bit */
++#define R_SPARC_22		10	/* Direct 22 bit */
++#define R_SPARC_13		11	/* Direct 13 bit */
++#define R_SPARC_LO10		12	/* Truncated 10 bit */
++#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
++#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
++#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
++#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
++#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
++#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
++#define R_SPARC_COPY		19	/* Copy symbol at runtime */
++#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
++#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
++#define R_SPARC_RELATIVE	22	/* Adjust by program base */
++#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
++
++/* Additional Sparc64 relocs.  */
++
++#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
++#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
++#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
++#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
++#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
++#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
++#define R_SPARC_10		30	/* Direct 10 bit */
++#define R_SPARC_11		31	/* Direct 11 bit */
++#define R_SPARC_64		32	/* Direct 64 bit */
++#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
++#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
++#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
++#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
++#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
++#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
++#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
++#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
++#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
++#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
++#define R_SPARC_7		43	/* Direct 7 bit */
++#define R_SPARC_5		44	/* Direct 5 bit */
++#define R_SPARC_6		45	/* Direct 6 bit */
++#define R_SPARC_DISP64		46	/* PC relative 64 bit */
++#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
++#define R_SPARC_HIX22		48	/* High 22 bit complemented */
++#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
++#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
++#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
++#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
++#define R_SPARC_REGISTER	53	/* Global register usage */
++#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
++#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
++#define R_SPARC_TLS_GD_HI22	56
++#define R_SPARC_TLS_GD_LO10	57
++#define R_SPARC_TLS_GD_ADD	58
++#define R_SPARC_TLS_GD_CALL	59
++#define R_SPARC_TLS_LDM_HI22	60
++#define R_SPARC_TLS_LDM_LO10	61
++#define R_SPARC_TLS_LDM_ADD	62
++#define R_SPARC_TLS_LDM_CALL	63
++#define R_SPARC_TLS_LDO_HIX22	64
++#define R_SPARC_TLS_LDO_LOX10	65
++#define R_SPARC_TLS_LDO_ADD	66
++#define R_SPARC_TLS_IE_HI22	67
++#define R_SPARC_TLS_IE_LO10	68
++#define R_SPARC_TLS_IE_LD	69
++#define R_SPARC_TLS_IE_LDX	70
++#define R_SPARC_TLS_IE_ADD	71
++#define R_SPARC_TLS_LE_HIX22	72
++#define R_SPARC_TLS_LE_LOX10	73
++#define R_SPARC_TLS_DTPMOD32	74
++#define R_SPARC_TLS_DTPMOD64	75
++#define R_SPARC_TLS_DTPOFF32	76
++#define R_SPARC_TLS_DTPOFF64	77
++#define R_SPARC_TLS_TPOFF32	78
++#define R_SPARC_TLS_TPOFF64	79
++#define R_SPARC_GOTDATA_HIX22	80
++#define R_SPARC_GOTDATA_LOX10	81
++#define R_SPARC_GOTDATA_OP_HIX22	82
++#define R_SPARC_GOTDATA_OP_LOX10	83
++#define R_SPARC_GOTDATA_OP	84
++#define R_SPARC_H34		85
++#define R_SPARC_SIZE32		86
++#define R_SPARC_SIZE64		87
++#define R_SPARC_WDISP10		88
++#define R_SPARC_JMP_IREL	248
++#define R_SPARC_IRELATIVE	249
++#define R_SPARC_GNU_VTINHERIT	250
++#define R_SPARC_GNU_VTENTRY	251
++#define R_SPARC_REV32		252
++/* Keep this the last entry.  */
++#define R_SPARC_NUM		253
++
++/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
++
++#define DT_SPARC_REGISTER 0x70000001
++#define DT_SPARC_NUM	2
++
++/* MIPS R3000 specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
++#define EF_MIPS_PIC	    2		/* Contains PIC code */
++#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
++#define EF_MIPS_XGOT	    8
++#define EF_MIPS_64BIT_WHIRL 16
++#define EF_MIPS_ABI2	    32
++#define EF_MIPS_ABI_ON32    64
++#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
++
++/* Legal values for MIPS architecture level.  */
++
++#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
++#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
++#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
++#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
++#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
++#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
++#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
++
++/* The following are non-official names and should not be used.  */
++
++#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
++#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
++#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
++#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
++#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
++#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
++#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
++
++/* Special section indices.  */
++
++#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
++#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
++#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
++#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
++#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
++#define SHT_MIPS_MSYM	       0x70000001
++#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
++#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
++#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
++#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
++#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
++#define SHT_MIPS_PACKAGE       0x70000007
++#define SHT_MIPS_PACKSYM       0x70000008
++#define SHT_MIPS_RELD	       0x70000009
++#define SHT_MIPS_IFACE         0x7000000b
++#define SHT_MIPS_CONTENT       0x7000000c
++#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
++#define SHT_MIPS_SHDR	       0x70000010
++#define SHT_MIPS_FDESC	       0x70000011
++#define SHT_MIPS_EXTSYM	       0x70000012
++#define SHT_MIPS_DENSE	       0x70000013
++#define SHT_MIPS_PDESC	       0x70000014
++#define SHT_MIPS_LOCSYM	       0x70000015
++#define SHT_MIPS_AUXSYM	       0x70000016
++#define SHT_MIPS_OPTSYM	       0x70000017
++#define SHT_MIPS_LOCSTR	       0x70000018
++#define SHT_MIPS_LINE	       0x70000019
++#define SHT_MIPS_RFDESC	       0x7000001a
++#define SHT_MIPS_DELTASYM      0x7000001b
++#define SHT_MIPS_DELTAINST     0x7000001c
++#define SHT_MIPS_DELTACLASS    0x7000001d
++#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
++#define SHT_MIPS_DELTADECL     0x7000001f
++#define SHT_MIPS_SYMBOL_LIB    0x70000020
++#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
++#define SHT_MIPS_TRANSLATE     0x70000022
++#define SHT_MIPS_PIXIE	       0x70000023
++#define SHT_MIPS_XLATE	       0x70000024
++#define SHT_MIPS_XLATE_DEBUG   0x70000025
++#define SHT_MIPS_WHIRL	       0x70000026
++#define SHT_MIPS_EH_REGION     0x70000027
++#define SHT_MIPS_XLATE_OLD     0x70000028
++#define SHT_MIPS_PDR_EXCEPTION 0x70000029
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
++#define SHF_MIPS_MERGE	 0x20000000
++#define SHF_MIPS_ADDR	 0x40000000
++#define SHF_MIPS_STRINGS 0x80000000
++#define SHF_MIPS_NOSTRIP 0x08000000
++#define SHF_MIPS_LOCAL	 0x04000000
++#define SHF_MIPS_NAMES	 0x02000000
++#define SHF_MIPS_NODUPE	 0x01000000
++
++
++/* Symbol tables.  */
++
++/* MIPS specific values for `st_other'.  */
++#define STO_MIPS_DEFAULT		0x0
++#define STO_MIPS_INTERNAL		0x1
++#define STO_MIPS_HIDDEN			0x2
++#define STO_MIPS_PROTECTED		0x3
++#define STO_MIPS_PLT			0x8
++#define STO_MIPS_SC_ALIGN_UNUSED	0xff
++
++/* MIPS specific values for `st_info'.  */
++#define STB_MIPS_SPLIT_COMMON		13
++
++/* Entries found in sections of type SHT_MIPS_GPTAB.  */
++
++typedef union
++{
++  struct
++    {
++      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
++      Elf32_Word gt_unused;		/* Not used */
++    } gt_header;			/* First entry in section */
++  struct
++    {
++      Elf32_Word gt_g_value;		/* If this value were used for -G */
++      Elf32_Word gt_bytes;		/* This many bytes would be used */
++    } gt_entry;				/* Subsequent entries in section */
++} Elf32_gptab;
++
++/* Entry found in sections of type SHT_MIPS_REGINFO.  */
++
++typedef struct
++{
++  Elf32_Word	ri_gprmask;		/* General registers used */
++  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
++  Elf32_Sword	ri_gp_value;		/* $gp register value */
++} Elf32_RegInfo;
++
++/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
++
++typedef struct
++{
++  unsigned char kind;		/* Determines interpretation of the
++				   variable part of descriptor.  */
++  unsigned char size;		/* Size of descriptor, including header.  */
++  Elf32_Section section;	/* Section header index of section affected,
++				   0 for global options.  */
++  Elf32_Word info;		/* Kind-specific information.  */
++} Elf_Options;
++
++/* Values for `kind' field in Elf_Options.  */
++
++#define ODK_NULL	0	/* Undefined.  */
++#define ODK_REGINFO	1	/* Register usage information.  */
++#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
++#define ODK_PAD		3	/* Section padding options.  */
++#define ODK_HWPATCH	4	/* Hardware workarounds performed */
++#define ODK_FILL	5	/* record the fill value used by the linker. */
++#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
++#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
++#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
++
++/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
++
++#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
++#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
++#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
++#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
++#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
++#define OEX_PRECISEFP	OEX_FPDBUG
++#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
++
++#define OEX_FPU_INVAL	0x10
++#define OEX_FPU_DIV0	0x08
++#define OEX_FPU_OFLO	0x04
++#define OEX_FPU_UFLO	0x02
++#define OEX_FPU_INEX	0x01
++
++/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
++
++#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
++#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
++#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
++#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
++
++#define OPAD_PREFIX	0x1
++#define OPAD_POSTFIX	0x2
++#define OPAD_SYMBOL	0x4
++
++/* Entry found in `.options' section.  */
++
++typedef struct
++{
++  Elf32_Word hwp_flags1;	/* Extra flags.  */
++  Elf32_Word hwp_flags2;	/* Extra flags.  */
++} Elf_Options_Hw;
++
++/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
++
++#define OHWA0_R4KEOP_CHECKED	0x00000001
++#define OHWA1_R4KEOP_CLEAN	0x00000002
++
++/* MIPS relocs.  */
++
++#define R_MIPS_NONE		0	/* No reloc */
++#define R_MIPS_16		1	/* Direct 16 bit */
++#define R_MIPS_32		2	/* Direct 32 bit */
++#define R_MIPS_REL32		3	/* PC relative 32 bit */
++#define R_MIPS_26		4	/* Direct 26 bit shifted */
++#define R_MIPS_HI16		5	/* High 16 bit */
++#define R_MIPS_LO16		6	/* Low 16 bit */
++#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
++#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
++#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
++#define R_MIPS_PC16		10	/* PC relative 16 bit */
++#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
++#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
++
++#define R_MIPS_SHIFT5		16
++#define R_MIPS_SHIFT6		17
++#define R_MIPS_64		18
++#define R_MIPS_GOT_DISP		19
++#define R_MIPS_GOT_PAGE		20
++#define R_MIPS_GOT_OFST		21
++#define R_MIPS_GOT_HI16		22
++#define R_MIPS_GOT_LO16		23
++#define R_MIPS_SUB		24
++#define R_MIPS_INSERT_A		25
++#define R_MIPS_INSERT_B		26
++#define R_MIPS_DELETE		27
++#define R_MIPS_HIGHER		28
++#define R_MIPS_HIGHEST		29
++#define R_MIPS_CALL_HI16	30
++#define R_MIPS_CALL_LO16	31
++#define R_MIPS_SCN_DISP		32
++#define R_MIPS_REL16		33
++#define R_MIPS_ADD_IMMEDIATE	34
++#define R_MIPS_PJUMP		35
++#define R_MIPS_RELGOT		36
++#define R_MIPS_JALR		37
++#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
++#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
++#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
++#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
++#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
++#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
++#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
++#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
++#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
++#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
++#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
++#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
++#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
++#define R_MIPS_GLOB_DAT		51
++#define R_MIPS_COPY		126
++#define R_MIPS_JUMP_SLOT        127
++/* Keep this the last entry.  */
++#define R_MIPS_NUM		128
++
++/* Legal values for p_type field of Elf32_Phdr.  */
++
++#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
++#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
++#define PT_MIPS_OPTIONS 0x70000002
++
++/* Special program header types.  */
++
++#define PF_MIPS_LOCAL	0x10000000
++
++/* Legal values for d_tag field of Elf32_Dyn.  */
++
++#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
++#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
++#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
++#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
++#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
++#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
++#define DT_MIPS_MSYM	     0x70000007
++#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
++#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
++#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
++#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
++#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
++#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
++#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
++#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
++#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
++#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
++#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
++#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
++						DT_MIPS_DELTA_CLASS.  */
++#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
++#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
++						DT_MIPS_DELTA_INSTANCE.  */
++#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
++#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
++					     DT_MIPS_DELTA_RELOC.  */
++#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
++					   relocations refer to.  */
++#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
++					   DT_MIPS_DELTA_SYM.  */
++#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
++					     class declaration.  */
++#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
++						DT_MIPS_DELTA_CLASSSYM.  */
++#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
++#define DT_MIPS_PIXIE_INIT   0x70000023
++#define DT_MIPS_SYMBOL_LIB   0x70000024
++#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
++#define DT_MIPS_LOCAL_GOTIDX 0x70000026
++#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
++#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
++#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
++#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
++#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
++#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
++#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
++						    function stored in GOT.  */
++#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
++					   by rld on dlopen() calls.  */
++#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
++#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
++#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
++/* The address of .got.plt in an executable using the new non-PIC ABI.  */
++#define DT_MIPS_PLTGOT	     0x70000032
++/* The base of the PLT in an executable using the new non-PIC ABI if that
++   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
++   value.  */
++#define DT_MIPS_RWPLT        0x70000034
++#define DT_MIPS_NUM	     0x35
++
++/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
++
++#define RHF_NONE		   0		/* No flags */
++#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
++#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
++#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
++#define RHF_NO_MOVE		   (1 << 3)
++#define RHF_SGI_ONLY		   (1 << 4)
++#define RHF_GUARANTEE_INIT	   (1 << 5)
++#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
++#define RHF_GUARANTEE_START_INIT   (1 << 7)
++#define RHF_PIXIE		   (1 << 8)
++#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
++#define RHF_REQUICKSTART	   (1 << 10)
++#define RHF_REQUICKSTARTED	   (1 << 11)
++#define RHF_CORD		   (1 << 12)
++#define RHF_NO_UNRES_UNDEF	   (1 << 13)
++#define RHF_RLD_ORDER_SAFE	   (1 << 14)
++
++/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
++
++typedef struct
++{
++  Elf32_Word l_name;		/* Name (string table index) */
++  Elf32_Word l_time_stamp;	/* Timestamp */
++  Elf32_Word l_checksum;	/* Checksum */
++  Elf32_Word l_version;		/* Interface version */
++  Elf32_Word l_flags;		/* Flags */
++} Elf32_Lib;
++
++typedef struct
++{
++  Elf64_Word l_name;		/* Name (string table index) */
++  Elf64_Word l_time_stamp;	/* Timestamp */
++  Elf64_Word l_checksum;	/* Checksum */
++  Elf64_Word l_version;		/* Interface version */
++  Elf64_Word l_flags;		/* Flags */
++} Elf64_Lib;
++
++
++/* Legal values for l_flags.  */
++
++#define LL_NONE		  0
++#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
++#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
++#define LL_REQUIRE_MINOR  (1 << 2)
++#define LL_EXPORTS	  (1 << 3)
++#define LL_DELAY_LOAD	  (1 << 4)
++#define LL_DELTA	  (1 << 5)
++
++/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
++
++typedef Elf32_Addr Elf32_Conflict;
++
++
++/* HPPA specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
++#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
++#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
++#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
++#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
++					      prediction.  */
++#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
++#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
++
++/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
++
++#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
++#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
++#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
++
++/* Additional section indeces.  */
++
++#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
++					      symbols in ANSI C.  */
++#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
++#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
++#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
++#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
++#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
++
++#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
++#define STT_HP_STUB		(STT_LOOS + 0x2)
++
++/* HPPA relocs.  */
++
++#define R_PARISC_NONE		0	/* No reloc.  */
++#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
++#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
++#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
++#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
++#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
++#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
++#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
++#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
++#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
++#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
++#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
++#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
++#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
++#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
++#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
++#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
++#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
++#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
++#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
++#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
++#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
++#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
++#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
++#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
++#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
++#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
++#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
++#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
++#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
++#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
++#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
++#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
++#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
++#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
++#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
++#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
++#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
++#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
++#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
++#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
++#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
++#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LORESERVE	128
++#define R_PARISC_COPY		128	/* Copy relocation.  */
++#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
++#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
++#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
++#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
++#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
++#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
++#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
++#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
++#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_GNU_VTENTRY	232
++#define R_PARISC_GNU_VTINHERIT	233
++#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
++#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
++#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
++#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
++#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
++#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
++#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
++#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
++#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
++#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
++#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
++#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
++#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
++#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
++#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
++#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
++#define R_PARISC_HIRESERVE	255
++
++/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PT_HP_TLS		(PT_LOOS + 0x0)
++#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
++#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
++#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
++#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
++#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
++#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
++#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
++#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
++#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
++#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
++#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
++#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
++#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
++#define PT_HP_STACK		(PT_LOOS + 0x14)
++
++#define PT_PARISC_ARCHEXT	0x70000000
++#define PT_PARISC_UNWIND	0x70000001
++
++/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PF_PARISC_SBP		0x08000000
++
++#define PF_HP_PAGE_SIZE		0x00100000
++#define PF_HP_FAR_SHARED	0x00200000
++#define PF_HP_NEAR_SHARED	0x00400000
++#define PF_HP_CODE		0x01000000
++#define PF_HP_MODIFY		0x02000000
++#define PF_HP_LAZYSWAP		0x04000000
++#define PF_HP_SBP		0x08000000
++
++
++/* Alpha specific definitions.  */
++
++/* Legal values for e_flags field of Elf64_Ehdr.  */
++
++#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
++#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
++
++/* Legal values for sh_type field of Elf64_Shdr.  */
++
++/* These two are primerily concerned with ECOFF debugging info.  */
++#define SHT_ALPHA_DEBUG		0x70000001
++#define SHT_ALPHA_REGINFO	0x70000002
++
++/* Legal values for sh_flags field of Elf64_Shdr.  */
++
++#define SHF_ALPHA_GPREL		0x10000000
++
++/* Legal values for st_other field of Elf64_Sym.  */
++#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
++#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
++
++/* Alpha relocs.  */
++
++#define R_ALPHA_NONE		0	/* No reloc */
++#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
++#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
++#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
++#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
++#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
++#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
++#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
++#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
++#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
++#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
++#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
++#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
++#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
++#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
++#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
++#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
++#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
++#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
++#define R_ALPHA_TLS_GD_HI	28
++#define R_ALPHA_TLSGD		29
++#define R_ALPHA_TLS_LDM		30
++#define R_ALPHA_DTPMOD64	31
++#define R_ALPHA_GOTDTPREL	32
++#define R_ALPHA_DTPREL64	33
++#define R_ALPHA_DTPRELHI	34
++#define R_ALPHA_DTPRELLO	35
++#define R_ALPHA_DTPREL16	36
++#define R_ALPHA_GOTTPREL	37
++#define R_ALPHA_TPREL64		38
++#define R_ALPHA_TPRELHI		39
++#define R_ALPHA_TPRELLO		40
++#define R_ALPHA_TPREL16		41
++/* Keep this the last entry.  */
++#define R_ALPHA_NUM		46
++
++/* Magic values of the LITUSE relocation addend.  */
++#define LITUSE_ALPHA_ADDR	0
++#define LITUSE_ALPHA_BASE	1
++#define LITUSE_ALPHA_BYTOFF	2
++#define LITUSE_ALPHA_JSR	3
++#define LITUSE_ALPHA_TLS_GD	4
++#define LITUSE_ALPHA_TLS_LDM	5
++
++/* Legal values for d_tag of Elf64_Dyn.  */
++#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
++#define DT_ALPHA_NUM		1
++
++/* PowerPC specific declarations */
++
++/* Values for Elf32/64_Ehdr.e_flags.  */
++#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
++
++/* Cygnus local bits below */
++#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
++#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
++						   flag */
++
++/* PowerPC relocations defined by the ABIs */
++#define R_PPC_NONE		0
++#define R_PPC_ADDR32		1	/* 32bit absolute address */
++#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
++#define R_PPC_ADDR16		3	/* 16bit absolute address */
++#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
++#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
++#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
++#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
++#define R_PPC_ADDR14_BRTAKEN	8
++#define R_PPC_ADDR14_BRNTAKEN	9
++#define R_PPC_REL24		10	/* PC relative 26 bit */
++#define R_PPC_REL14		11	/* PC relative 16 bit */
++#define R_PPC_REL14_BRTAKEN	12
++#define R_PPC_REL14_BRNTAKEN	13
++#define R_PPC_GOT16		14
++#define R_PPC_GOT16_LO		15
++#define R_PPC_GOT16_HI		16
++#define R_PPC_GOT16_HA		17
++#define R_PPC_PLTREL24		18
++#define R_PPC_COPY		19
++#define R_PPC_GLOB_DAT		20
++#define R_PPC_JMP_SLOT		21
++#define R_PPC_RELATIVE		22
++#define R_PPC_LOCAL24PC		23
++#define R_PPC_UADDR32		24
++#define R_PPC_UADDR16		25
++#define R_PPC_REL32		26
++#define R_PPC_PLT32		27
++#define R_PPC_PLTREL32		28
++#define R_PPC_PLT16_LO		29
++#define R_PPC_PLT16_HI		30
++#define R_PPC_PLT16_HA		31
++#define R_PPC_SDAREL16		32
++#define R_PPC_SECTOFF		33
++#define R_PPC_SECTOFF_LO	34
++#define R_PPC_SECTOFF_HI	35
++#define R_PPC_SECTOFF_HA	36
++
++/* PowerPC relocations defined for the TLS access ABI.  */
++#define R_PPC_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
++#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
++#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
++#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
++#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
++#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
++#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
++#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
++#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
++#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
++
++/* The remaining relocs are from the Embedded ELF ABI, and are not
++   in the SVR4 ELF ABI.  */
++#define R_PPC_EMB_NADDR32	101
++#define R_PPC_EMB_NADDR16	102
++#define R_PPC_EMB_NADDR16_LO	103
++#define R_PPC_EMB_NADDR16_HI	104
++#define R_PPC_EMB_NADDR16_HA	105
++#define R_PPC_EMB_SDAI16	106
++#define R_PPC_EMB_SDA2I16	107
++#define R_PPC_EMB_SDA2REL	108
++#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
++#define R_PPC_EMB_MRKREF	110
++#define R_PPC_EMB_RELSEC16	111
++#define R_PPC_EMB_RELST_LO	112
++#define R_PPC_EMB_RELST_HI	113
++#define R_PPC_EMB_RELST_HA	114
++#define R_PPC_EMB_BIT_FLD	115
++#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
++
++/* Diab tool relocations.  */
++#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
++#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
++#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
++#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
++#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
++#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC_IRELATIVE		248
++
++/* GNU relocs used in PIC code sequences.  */
++#define R_PPC_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
++#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
++#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
++
++/* This is a phony reloc to handle any old fashioned TOC16 references
++   that may still be in object files.  */
++#define R_PPC_TOC16		255
++
++/* PowerPC specific values for the Dyn d_tag field.  */
++#define DT_PPC_GOT		(DT_LOPROC + 0)
++#define DT_PPC_NUM		1
++
++/* PowerPC64 relocations defined by the ABIs */
++#define R_PPC64_NONE		R_PPC_NONE
++#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
++#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
++#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
++#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
++#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
++#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
++#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
++#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
++#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
++#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
++#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
++#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
++#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
++#define R_PPC64_GOT16		R_PPC_GOT16
++#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
++#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
++#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
++
++#define R_PPC64_COPY		R_PPC_COPY
++#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
++#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
++#define R_PPC64_RELATIVE	R_PPC_RELATIVE
++
++#define R_PPC64_UADDR32		R_PPC_UADDR32
++#define R_PPC64_UADDR16		R_PPC_UADDR16
++#define R_PPC64_REL32		R_PPC_REL32
++#define R_PPC64_PLT32		R_PPC_PLT32
++#define R_PPC64_PLTREL32	R_PPC_PLTREL32
++#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
++#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
++#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
++
++#define R_PPC64_SECTOFF		R_PPC_SECTOFF
++#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
++#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
++#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
++#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
++#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
++#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
++#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
++#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
++#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
++#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
++#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
++#define R_PPC64_PLT64		45 /* doubleword64 L + A */
++#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
++#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
++#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
++#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
++#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
++#define R_PPC64_TOC		51 /* doubleword64 .TOC */
++#define R_PPC64_PLTGOT16	52 /* half16* M + A */
++#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
++#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
++#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
++
++#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
++#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
++#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
++#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
++#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
++#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
++#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
++#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
++#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
++#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
++#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
++
++/* PowerPC64 relocations defined for the TLS access ABI.  */
++#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
++#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
++#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
++#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
++#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
++#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
++#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
++#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
++#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
++#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
++#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
++#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
++#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
++#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
++#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
++#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
++#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC64_JMP_IREL	247
++#define R_PPC64_IRELATIVE	248
++#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
++#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
++#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
++
++/* PowerPC64 specific values for the Dyn d_tag field.  */
++#define DT_PPC64_GLINK  (DT_LOPROC + 0)
++#define DT_PPC64_OPD	(DT_LOPROC + 1)
++#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
++#define DT_PPC64_NUM    3
++
++
++/* ARM specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_ARM_RELEXEC		0x01
++#define EF_ARM_HASENTRY		0x02
++#define EF_ARM_INTERWORK	0x04
++#define EF_ARM_APCS_26		0x08
++#define EF_ARM_APCS_FLOAT	0x10
++#define EF_ARM_PIC		0x20
++#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
++#define EF_ARM_NEW_ABI		0x80
++#define EF_ARM_OLD_ABI		0x100
++#define EF_ARM_SOFT_FLOAT	0x200
++#define EF_ARM_VFP_FLOAT	0x400
++#define EF_ARM_MAVERICK_FLOAT	0x800
++
++
++/* Other constants defined in the ARM ELF spec. version B-01.  */
++/* NB. These conflict with values defined above.  */
++#define EF_ARM_SYMSARESORTED	0x04
++#define EF_ARM_DYNSYMSUSESEGIDX	0x08
++#define EF_ARM_MAPSYMSFIRST	0x10
++#define EF_ARM_EABIMASK		0XFF000000
++
++/* Constants defined in AAELF.  */
++#define EF_ARM_BE8	    0x00800000
++#define EF_ARM_LE8	    0x00400000
++
++#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
++#define EF_ARM_EABI_UNKNOWN	0x00000000
++#define EF_ARM_EABI_VER1	0x01000000
++#define EF_ARM_EABI_VER2	0x02000000
++#define EF_ARM_EABI_VER3	0x03000000
++#define EF_ARM_EABI_VER4	0x04000000
++#define EF_ARM_EABI_VER5	0x05000000
++
++/* Additional symbol types for Thumb.  */
++#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
++#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
++
++/* ARM-specific values for sh_flags */
++#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
++#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
++					      in the input to a link step.  */
++
++/* ARM-specific program header flags */
++#define PF_ARM_SB		0x10000000 /* Segment contains the location
++					      addressed by the static base. */
++#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
++#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
++#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
++#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
++
++
++/* ARM relocs.  */
++
++#define R_ARM_NONE		0	/* No reloc */
++#define R_ARM_PC24		1	/* PC relative 26 bit branch */
++#define R_ARM_ABS32		2	/* Direct 32 bit  */
++#define R_ARM_REL32		3	/* PC relative 32 bit */
++#define R_ARM_PC13		4
++#define R_ARM_ABS16		5	/* Direct 16 bit */
++#define R_ARM_ABS12		6	/* Direct 12 bit */
++#define R_ARM_THM_ABS5		7
++#define R_ARM_ABS8		8	/* Direct 8 bit */
++#define R_ARM_SBREL32		9
++#define R_ARM_THM_PC22		10
++#define R_ARM_THM_PC8		11
++#define R_ARM_AMP_VCALL9	12
++#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
++#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
++#define R_ARM_THM_SWI8		14
++#define R_ARM_XPC25		15
++#define R_ARM_THM_XPC22		16
++#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
++#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
++#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
++#define R_ARM_COPY		20	/* Copy symbol at runtime */
++#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
++#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
++#define R_ARM_RELATIVE		23	/* Adjust by program base */
++#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
++#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
++#define R_ARM_GOT32		26	/* 32 bit GOT entry */
++#define R_ARM_PLT32		27	/* 32 bit PLT address */
++#define R_ARM_ALU_PCREL_7_0	32
++#define R_ARM_ALU_PCREL_15_8	33
++#define R_ARM_ALU_PCREL_23_15	34
++#define R_ARM_LDR_SBREL_11_0	35
++#define R_ARM_ALU_SBREL_19_12	36
++#define R_ARM_ALU_SBREL_27_20	37
++#define R_ARM_TLS_GOTDESC	90
++#define R_ARM_TLS_CALL		91
++#define R_ARM_TLS_DESCSEQ	92
++#define R_ARM_THM_TLS_CALL	93
++#define R_ARM_GNU_VTENTRY	100
++#define R_ARM_GNU_VTINHERIT	101
++#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
++#define R_ARM_THM_PC9		103	/* thumb conditional branch */
++#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
++					   thread local data */
++#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
++					   thread local data */
++#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
++					   block */
++#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
++					   static TLS block offset */
++#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
++					   TLS block */
++#define	R_ARM_THM_TLS_DESCSEQ	129
++#define R_ARM_IRELATIVE		160
++#define R_ARM_RXPC25		249
++#define R_ARM_RSBREL32		250
++#define R_ARM_THM_RPC22		251
++#define R_ARM_RREL32		252
++#define R_ARM_RABS22		253
++#define R_ARM_RPC24		254
++#define R_ARM_RBASE		255
++/* Keep this the last entry.  */
++#define R_ARM_NUM		256
++
++/* IA-64 specific declarations.  */
++
++/* Processor specific flags for the Ehdr e_flags field.  */
++#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
++#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
++#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
++#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
++#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
++#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
++#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
++
++/* Processor specific flags for the Phdr p_flags field.  */
++#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
++#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
++
++/* Processor specific flags for the Shdr sh_flags field.  */
++#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
++#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Dyn d_tag field.  */
++#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
++#define DT_IA_64_NUM		1
++
++/* IA-64 relocations.  */
++#define R_IA64_NONE		0x00	/* none */
++#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
++#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
++#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
++#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
++#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
++#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
++#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
++#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
++#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
++#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
++#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
++#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
++#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
++#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
++#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
++#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
++#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
++#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
++#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
++#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
++#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
++#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
++#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
++#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
++#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
++#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
++#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
++#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
++#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
++#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
++#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
++#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
++#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
++#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
++#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
++#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
++#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
++#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
++#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
++#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
++#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
++#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
++#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
++#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
++#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
++#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
++#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
++#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
++#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
++#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
++#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
++#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
++#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
++#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
++#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
++#define R_IA64_COPY		0x84	/* copy relocation */
++#define R_IA64_SUB		0x85	/* Addend and symbol difference */
++#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
++#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
++#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
++#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
++#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
++#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
++#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
++#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
++#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
++#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
++#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
++#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
++#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
++#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
++#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
++#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
++
++/* SH specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_SH_MACH_MASK		0x1f
++#define EF_SH_UNKNOWN		0x0
++#define EF_SH1			0x1
++#define EF_SH2			0x2
++#define EF_SH3			0x3
++#define EF_SH_DSP		0x4
++#define EF_SH3_DSP		0x5
++#define EF_SH4AL_DSP		0x6
++#define EF_SH3E			0x8
++#define EF_SH4			0x9
++#define EF_SH2E			0xb
++#define EF_SH4A			0xc
++#define EF_SH2A			0xd
++#define EF_SH4_NOFPU		0x10
++#define EF_SH4A_NOFPU		0x11
++#define EF_SH4_NOMMU_NOFPU	0x12
++#define EF_SH2A_NOFPU		0x13
++#define EF_SH3_NOMMU		0x14
++#define EF_SH2A_SH4_NOFPU	0x15
++#define EF_SH2A_SH3_NOFPU	0x16
++#define EF_SH2A_SH4		0x17
++#define EF_SH2A_SH3E		0x18
++
++/* SH relocs.  */
++#define	R_SH_NONE		0
++#define	R_SH_DIR32		1
++#define	R_SH_REL32		2
++#define	R_SH_DIR8WPN		3
++#define	R_SH_IND12W		4
++#define	R_SH_DIR8WPL		5
++#define	R_SH_DIR8WPZ		6
++#define	R_SH_DIR8BP		7
++#define	R_SH_DIR8W		8
++#define	R_SH_DIR8L		9
++#define	R_SH_SWITCH16		25
++#define	R_SH_SWITCH32		26
++#define	R_SH_USES		27
++#define	R_SH_COUNT		28
++#define	R_SH_ALIGN		29
++#define	R_SH_CODE		30
++#define	R_SH_DATA		31
++#define	R_SH_LABEL		32
++#define	R_SH_SWITCH8		33
++#define	R_SH_GNU_VTINHERIT	34
++#define	R_SH_GNU_VTENTRY	35
++#define	R_SH_TLS_GD_32		144
++#define	R_SH_TLS_LD_32		145
++#define	R_SH_TLS_LDO_32		146
++#define	R_SH_TLS_IE_32		147
++#define	R_SH_TLS_LE_32		148
++#define	R_SH_TLS_DTPMOD32	149
++#define	R_SH_TLS_DTPOFF32	150
++#define	R_SH_TLS_TPOFF32	151
++#define	R_SH_GOT32		160
++#define	R_SH_PLT32		161
++#define	R_SH_COPY		162
++#define	R_SH_GLOB_DAT		163
++#define	R_SH_JMP_SLOT		164
++#define	R_SH_RELATIVE		165
++#define	R_SH_GOTOFF		166
++#define	R_SH_GOTPC		167
++/* Keep this the last entry.  */
++#define	R_SH_NUM		256
++
++/* S/390 specific definitions.  */
++
++/* Valid values for the e_flags field.  */
++
++#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
++
++/* Additional s390 relocs */
++
++#define R_390_NONE		0	/* No reloc.  */
++#define R_390_8			1	/* Direct 8 bit.  */
++#define R_390_12		2	/* Direct 12 bit.  */
++#define R_390_16		3	/* Direct 16 bit.  */
++#define R_390_32		4	/* Direct 32 bit.  */
++#define R_390_PC32		5	/* PC relative 32 bit.	*/
++#define R_390_GOT12		6	/* 12 bit GOT offset.  */
++#define R_390_GOT32		7	/* 32 bit GOT offset.  */
++#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
++#define R_390_COPY		9	/* Copy symbol at runtime.  */
++#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
++#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
++#define R_390_RELATIVE		12	/* Adjust by program base.  */
++#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
++#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
++#define R_390_GOT16		15	/* 16 bit GOT offset.  */
++#define R_390_PC16		16	/* PC relative 16 bit.	*/
++#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
++#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
++#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
++#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
++#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
++#define R_390_64		22	/* Direct 64 bit.  */
++#define R_390_PC64		23	/* PC relative 64 bit.	*/
++#define R_390_GOT64		24	/* 64 bit GOT offset.  */
++#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
++#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
++#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
++#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
++#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
++#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
++#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
++#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
++#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
++#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
++#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
++#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
++#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
++#define R_390_TLS_GDCALL	38	/* Tag for function call in general
++					   dynamic TLS code. */
++#define R_390_TLS_LDCALL	39	/* Tag for function call in local
++					   dynamic TLS code. */
++#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
++					   thread local data.  */
++#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
++					  thread local data.  */
++#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
++					   block offset. */
++#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
++#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
++#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
++					   block.  */
++#define R_390_20		57	/* Direct 20 bit.  */
++#define R_390_GOT20		58	/* 20 bit GOT offset.  */
++#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
++#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
++/* Keep this the last entry.  */
++#define R_390_NUM		62
++
++
++/* CRIS relocations.  */
++#define R_CRIS_NONE		0
++#define R_CRIS_8		1
++#define R_CRIS_16		2
++#define R_CRIS_32		3
++#define R_CRIS_8_PCREL		4
++#define R_CRIS_16_PCREL		5
++#define R_CRIS_32_PCREL		6
++#define R_CRIS_GNU_VTINHERIT	7
++#define R_CRIS_GNU_VTENTRY	8
++#define R_CRIS_COPY		9
++#define R_CRIS_GLOB_DAT		10
++#define R_CRIS_JUMP_SLOT	11
++#define R_CRIS_RELATIVE		12
++#define R_CRIS_16_GOT		13
++#define R_CRIS_32_GOT		14
++#define R_CRIS_16_GOTPLT	15
++#define R_CRIS_32_GOTPLT	16
++#define R_CRIS_32_GOTREL	17
++#define R_CRIS_32_PLT_GOTREL	18
++#define R_CRIS_32_PLT_PCREL	19
++
++#define R_CRIS_NUM		20
++
++
++/* AMD x86-64 relocations.  */
++#define R_X86_64_NONE		0	/* No reloc */
++#define R_X86_64_64		1	/* Direct 64 bit  */
++#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
++#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
++#define R_X86_64_PLT32		4	/* 32 bit PLT address */
++#define R_X86_64_COPY		5	/* Copy symbol at runtime */
++#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
++#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
++#define R_X86_64_RELATIVE	8	/* Adjust by program base */
++#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
++					   offset to GOT */
++#define R_X86_64_32		10	/* Direct 32 bit zero extended */
++#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
++#define R_X86_64_16		12	/* Direct 16 bit zero extended */
++#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
++#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
++#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
++#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
++#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
++#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
++#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
++					   to two GOT entries for GD symbol */
++#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
++					   to two GOT entries for LD symbol */
++#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
++#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
++					   to GOT entry for IE symbol */
++#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
++#define R_X86_64_PC64		24	/* PC relative 64 bit */
++#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
++#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
++					   offset to GOT */
++#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
++#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
++					   to GOT entry */
++#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
++#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
++#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
++					   to PLT entry */
++#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
++#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
++#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
++#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
++					   descriptor.  */
++#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
++#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
++#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
++
++#define R_X86_64_NUM		39
++
++
++/* AM33 relocations.  */
++#define R_MN10300_NONE		0	/* No reloc.  */
++#define R_MN10300_32		1	/* Direct 32 bit.  */
++#define R_MN10300_16		2	/* Direct 16 bit.  */
++#define R_MN10300_8		3	/* Direct 8 bit.  */
++#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
++#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
++#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
++#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
++#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
++#define R_MN10300_24		9	/* Direct 24 bit.  */
++#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
++#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
++#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
++#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
++#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
++#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
++#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
++#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
++#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
++#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
++#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
++#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
++
++#define R_MN10300_NUM		24
++
++
++/* M32R relocs.  */
++#define R_M32R_NONE		0	/* No reloc. */
++#define R_M32R_16		1	/* Direct 16 bit. */
++#define R_M32R_32		2	/* Direct 32 bit. */
++#define R_M32R_24		3	/* Direct 24 bit. */
++#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
++#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
++#define R_M32R_LO16		9	/* Low 16 bit. */
++#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
++#define R_M32R_GNU_VTINHERIT	11
++#define R_M32R_GNU_VTENTRY	12
++/* M32R relocs use SHT_RELA.  */
++#define R_M32R_16_RELA		33	/* Direct 16 bit. */
++#define R_M32R_32_RELA		34	/* Direct 32 bit. */
++#define R_M32R_24_RELA		35	/* Direct 24 bit. */
++#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
++#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
++#define R_M32R_LO16_RELA	41	/* Low 16 bit */
++#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
++#define R_M32R_RELA_GNU_VTINHERIT	43
++#define R_M32R_RELA_GNU_VTENTRY	44
++#define R_M32R_REL32		45	/* PC relative 32 bit.  */
++
++#define R_M32R_GOT24		48	/* 24 bit GOT entry */
++#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
++#define R_M32R_COPY		50	/* Copy symbol at runtime */
++#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
++#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
++#define R_M32R_RELATIVE		53	/* Adjust by program base */
++#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
++#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
++#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
++					   low */
++#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
++					   low */
++#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
++#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
++					   GOT with unsigned low */
++#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
++					   GOT with signed low */
++#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
++					   GOT */
++#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
++					   with unsigned low */
++#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
++					   with signed low */
++#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
++#define R_M32R_NUM		256	/* Keep this the last entry. */
++
++
++/* TILEPro relocations.  */
++#define R_TILEPRO_NONE		0	/* No reloc */
++#define R_TILEPRO_32		1	/* Direct 32 bit */
++#define R_TILEPRO_16		2	/* Direct 16 bit */
++#define R_TILEPRO_8		3	/* Direct 8 bit */
++#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
++#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
++#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
++#define R_TILEPRO_LO16		7	/* Low 16 bit */
++#define R_TILEPRO_HI16		8	/* High 16 bit */
++#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
++#define R_TILEPRO_COPY		10	/* Copy relocation */
++#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
++#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
++#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
++#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
++#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
++#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
++#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
++#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
++#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
++#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
++#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
++#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
++#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
++#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
++#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
++#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
++#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
++#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
++#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
++/* Relocs 56-59 are currently not defined.  */
++#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
++#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
++#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
++#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
++#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
++#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
++
++#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEPRO_NUM		130
++
++
++/* TILE-Gx relocations.  */
++#define R_TILEGX_NONE		0	/* No reloc */
++#define R_TILEGX_64		1	/* Direct 64 bit */
++#define R_TILEGX_32		2	/* Direct 32 bit */
++#define R_TILEGX_16		3	/* Direct 16 bit */
++#define R_TILEGX_8		4	/* Direct 8 bit */
++#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
++#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
++#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
++#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
++#define R_TILEGX_HW0		9	/* hword 0 16-bit */
++#define R_TILEGX_HW1		10	/* hword 1 16-bit */
++#define R_TILEGX_HW2		11	/* hword 2 16-bit */
++#define R_TILEGX_HW3		12	/* hword 3 16-bit */
++#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
++#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
++#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
++#define R_TILEGX_COPY		16	/* Copy relocation */
++#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
++#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
++#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
++#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
++#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
++#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
++#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
++#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
++#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
++#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
++#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
++#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
++#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
++#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
++#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
++#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
++#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
++#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
++#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
++#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
++#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
++#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
++#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
++#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
++#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
++#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
++#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
++/* Relocs 66-71 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
++#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
++/* Relocs 76-77 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
++/* Relocs 90-91 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
++/* Relocs 94-99 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
++/* Relocs 104-105 are currently not defined.  */
++#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
++#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
++#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
++#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
++#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
++
++#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEGX_NUM		130
++
++#endif	/* elf.h */
diff --git a/target/linux/generic/pending-4.4/211-sign-file-libressl.patch b/target/linux/generic/pending-4.4/211-sign-file-libressl.patch
new file mode 100644
index 0000000000..c174087f10
--- /dev/null
+++ b/target/linux/generic/pending-4.4/211-sign-file-libressl.patch
@@ -0,0 +1,16 @@
+LibreSSL disables the CMS subsystem, so sign-file.c needs to fall back to using
+PKCS#7 in that case.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/scripts/sign-file.c
++++ b/scripts/sign-file.c
+@@ -39,7 +39,7 @@
+  * signing with anything other than SHA1 - so we're stuck with that if such is
+  * the case.
+  */
+-#if OPENSSL_VERSION_NUMBER < 0x10000000L
++#if defined(LIBRESSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10000000L
+ #define USE_PKCS7
+ #endif
+ #ifndef USE_PKCS7
diff --git a/target/linux/generic/pending-4.4/212-byteshift_portability.patch b/target/linux/generic/pending-4.4/212-byteshift_portability.patch
new file mode 100644
index 0000000000..0f23ba9be9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/212-byteshift_portability.patch
@@ -0,0 +1,51 @@
+--- a/tools/include/tools/be_byteshift.h
++++ b/tools/include/tools/be_byteshift.h
+@@ -1,6 +1,10 @@
+ #ifndef _TOOLS_BE_BYTESHIFT_H
+ #define _TOOLS_BE_BYTESHIFT_H
+ 
++#ifndef __linux__
++#include "linux_types.h"
++#endif
++
+ #include <stdint.h>
+ 
+ static inline uint16_t __get_unaligned_be16(const uint8_t *p)
+--- a/tools/include/tools/le_byteshift.h
++++ b/tools/include/tools/le_byteshift.h
+@@ -1,6 +1,10 @@
+ #ifndef _TOOLS_LE_BYTESHIFT_H
+ #define _TOOLS_LE_BYTESHIFT_H
+ 
++#ifndef __linux__
++#include "linux_types.h"
++#endif
++
+ #include <stdint.h>
+ 
+ static inline uint16_t __get_unaligned_le16(const uint8_t *p)
+--- /dev/null
++++ b/tools/include/tools/linux_types.h
+@@ -0,0 +1,22 @@
++#ifndef __LINUX_TYPES_H
++#define __LINUX_TYPES_H
++
++#include <stdint.h>
++
++typedef uint8_t __u8;
++typedef uint8_t __be8;
++typedef uint8_t __le8;
++
++typedef uint16_t __u16;
++typedef uint16_t __be16;
++typedef uint16_t __le16;
++
++typedef uint32_t __u32;
++typedef uint32_t __be32;
++typedef uint32_t __le32;
++
++typedef uint64_t __u64;
++typedef uint64_t __be64;
++typedef uint64_t __le64;
++
++#endif
diff --git a/target/linux/generic/pending-4.4/214-spidev_h_portability.patch b/target/linux/generic/pending-4.4/214-spidev_h_portability.patch
new file mode 100644
index 0000000000..39fa32ffa2
--- /dev/null
+++ b/target/linux/generic/pending-4.4/214-spidev_h_portability.patch
@@ -0,0 +1,11 @@
+--- a/include/uapi/linux/spi/spidev.h
++++ b/include/uapi/linux/spi/spidev.h
+@@ -112,7 +112,7 @@ struct spi_ioc_transfer {
+ 
+ /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
+ #define SPI_MSGSIZE(N) \
+-	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
++	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << 13)) \
+ 		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
+ #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
+ 
diff --git a/target/linux/generic/pending-4.4/220-gc_sections.patch b/target/linux/generic/pending-4.4/220-gc_sections.patch
new file mode 100644
index 0000000000..cbe03d5c5e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/220-gc_sections.patch
@@ -0,0 +1,536 @@
+From: Felix Fietkau <nbd@nbd.name>
+
+use -ffunction-sections, -fdata-sections and --gc-sections
+
+In combination with kernel symbol export stripping this significantly reduces
+the kernel image size. Used on both ARM and MIPS architectures.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -89,10 +89,14 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ #
+ cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
+ cflags-y			+= -msoft-float
+-LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
++LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
+ KBUILD_CFLAGS_MODULE		+= -mlong-calls
+ 
++ifndef CONFIG_FUNCTION_TRACER
++KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
++endif
++
+ #
+ # pass -msoft-float to GAS if it supports it.  However on newer binutils
+ # (specifically newer than 2.24.51.20140728) we then also need to explicitly
+--- a/arch/mips/kernel/vmlinux.lds.S
++++ b/arch/mips/kernel/vmlinux.lds.S
+@@ -69,7 +69,7 @@ SECTIONS
+ 	/* Exception table for data bus errors */
+ 	__dbe_table : {
+ 		__start___dbe_table = .;
+-		*(__dbe_table)
++		KEEP(*(__dbe_table))
+ 		__stop___dbe_table = .;
+ 	}
+ 
+@@ -119,7 +119,7 @@ SECTIONS
+ 	. = ALIGN(4);
+ 	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
+ 		__mips_machines_start = .;
+-		*(.mips.machines.init)
++		KEEP(*(.mips.machines.init))
+ 		__mips_machines_end = .;
+ 	}
+ 
+--- a/include/asm-generic/vmlinux.lds.h
++++ b/include/asm-generic/vmlinux.lds.h
+@@ -89,7 +89,7 @@
+ #ifdef CONFIG_FTRACE_MCOUNT_RECORD
+ #define MCOUNT_REC()	. = ALIGN(8);				\
+ 			VMLINUX_SYMBOL(__start_mcount_loc) = .; \
+-			*(__mcount_loc)				\
++			KEEP(*(__mcount_loc))			\
+ 			VMLINUX_SYMBOL(__stop_mcount_loc) = .;
+ #else
+ #define MCOUNT_REC()
+@@ -97,7 +97,7 @@
+ 
+ #ifdef CONFIG_TRACE_BRANCH_PROFILING
+ #define LIKELY_PROFILE()	VMLINUX_SYMBOL(__start_annotated_branch_profile) = .; \
+-				*(_ftrace_annotated_branch)			      \
++				KEEP(*(_ftrace_annotated_branch))		      \
+ 				VMLINUX_SYMBOL(__stop_annotated_branch_profile) = .;
+ #else
+ #define LIKELY_PROFILE()
+@@ -105,7 +105,7 @@
+ 
+ #ifdef CONFIG_PROFILE_ALL_BRANCHES
+ #define BRANCH_PROFILE()	VMLINUX_SYMBOL(__start_branch_profile) = .;   \
+-				*(_ftrace_branch)			      \
++				KEEP(*(_ftrace_branch))			      \
+ 				VMLINUX_SYMBOL(__stop_branch_profile) = .;
+ #else
+ #define BRANCH_PROFILE()
+@@ -114,7 +114,7 @@
+ #ifdef CONFIG_KPROBES
+ #define KPROBE_BLACKLIST()	. = ALIGN(8);				      \
+ 				VMLINUX_SYMBOL(__start_kprobe_blacklist) = .; \
+-				*(_kprobe_blacklist)			      \
++				KEEP(*(_kprobe_blacklist))		      \
+ 				VMLINUX_SYMBOL(__stop_kprobe_blacklist) = .;
+ #else
+ #define KPROBE_BLACKLIST()
+@@ -123,10 +123,10 @@
+ #ifdef CONFIG_EVENT_TRACING
+ #define FTRACE_EVENTS()	. = ALIGN(8);					\
+ 			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\
+-			*(_ftrace_events)				\
++			KEEP(*(_ftrace_events))				\
+ 			VMLINUX_SYMBOL(__stop_ftrace_events) = .;	\
+ 			VMLINUX_SYMBOL(__start_ftrace_enum_maps) = .;	\
+-			*(_ftrace_enum_map)				\
++			KEEP(*(_ftrace_enum_map))			\
+ 			VMLINUX_SYMBOL(__stop_ftrace_enum_maps) = .;
+ #else
+ #define FTRACE_EVENTS()
+@@ -134,7 +134,7 @@
+ 
+ #ifdef CONFIG_TRACING
+ #define TRACE_PRINTKS() VMLINUX_SYMBOL(__start___trace_bprintk_fmt) = .;      \
+-			 *(__trace_printk_fmt) /* Trace_printk fmt' pointer */ \
++			 KEEP(*(__trace_printk_fmt)) /* Trace_printk fmt' pointer */ \
+ 			 VMLINUX_SYMBOL(__stop___trace_bprintk_fmt) = .;
+ #define TRACEPOINT_STR() VMLINUX_SYMBOL(__start___tracepoint_str) = .;	\
+ 			 *(__tracepoint_str) /* Trace_printk fmt' pointer */ \
+@@ -147,7 +147,7 @@
+ #ifdef CONFIG_FTRACE_SYSCALLS
+ #define TRACE_SYSCALLS() . = ALIGN(8);					\
+ 			 VMLINUX_SYMBOL(__start_syscalls_metadata) = .;	\
+-			 *(__syscalls_metadata)				\
++			 KEEP(*(__syscalls_metadata))			\
+ 			 VMLINUX_SYMBOL(__stop_syscalls_metadata) = .;
+ #else
+ #define TRACE_SYSCALLS()
+@@ -169,8 +169,8 @@
+ #define _OF_TABLE_1(name)						\
+ 	. = ALIGN(8);							\
+ 	VMLINUX_SYMBOL(__##name##_of_table) = .;			\
+-	*(__##name##_of_table)						\
+-	*(__##name##_of_table_end)
++	KEEP(*(__##name##_of_table))					\
++	KEEP(*(__##name##_of_table_end))
+ 
+ #define CLKSRC_OF_TABLES()	OF_TABLE(CONFIG_CLKSRC_OF, clksrc)
+ #define IRQCHIP_OF_MATCH_TABLE() OF_TABLE(CONFIG_IRQCHIP, irqchip)
+@@ -194,7 +194,7 @@
+ #define KERNEL_DTB()							\
+ 	STRUCT_ALIGN();							\
+ 	VMLINUX_SYMBOL(__dtb_start) = .;				\
+-	*(.dtb.init.rodata)						\
++	KEEP(*(.dtb.init.rodata))					\
+ 	VMLINUX_SYMBOL(__dtb_end) = .;
+ 
+ /* .data section */
+@@ -210,16 +210,17 @@
+ 	/* implement dynamic printk debug */				\
+ 	. = ALIGN(8);                                                   \
+ 	VMLINUX_SYMBOL(__start___jump_table) = .;                       \
+-	*(__jump_table)                                                 \
++	KEEP(*(__jump_table))                                           \
+ 	VMLINUX_SYMBOL(__stop___jump_table) = .;                        \
+ 	. = ALIGN(8);							\
+ 	VMLINUX_SYMBOL(__start___verbose) = .;                          \
+-	*(__verbose)                                                    \
++	KEEP(*(__verbose))                                              \
+ 	VMLINUX_SYMBOL(__stop___verbose) = .;				\
+ 	LIKELY_PROFILE()		       				\
+ 	BRANCH_PROFILE()						\
+ 	TRACE_PRINTKS()							\
+-	TRACEPOINT_STR()
++	TRACEPOINT_STR()                                                \
++	*(.data.[a-zA-Z_]*)
+ 
+ /*
+  * Data section helpers
+@@ -273,35 +274,35 @@
+ 	/* PCI quirks */						\
+ 	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_early) = .;		\
+-		*(.pci_fixup_early)					\
++		KEEP(*(.pci_fixup_early))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_early) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\
+-		*(.pci_fixup_header)					\
++		KEEP(*(.pci_fixup_header))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\
+-		*(.pci_fixup_final)					\
++		KEEP(*(.pci_fixup_final))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_enable) = .;		\
+-		*(.pci_fixup_enable)					\
++		KEEP(*(.pci_fixup_enable))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_enable) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\
+-		*(.pci_fixup_resume)					\
++		KEEP(*(.pci_fixup_resume))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_resume_early) = .;	\
+-		*(.pci_fixup_resume_early)				\
++		KEEP(*(.pci_fixup_resume_early))			\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_resume_early) = .;	\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_suspend) = .;		\
+-		*(.pci_fixup_suspend)					\
++		KEEP(*(.pci_fixup_suspend))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_suspend) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_suspend_late) = .;	\
+-		*(.pci_fixup_suspend_late)				\
++		KEEP(*(.pci_fixup_suspend_late))			\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_suspend_late) = .;	\
+ 	}								\
+ 									\
+ 	/* Built-in firmware blobs */					\
+ 	.builtin_fw        : AT(ADDR(.builtin_fw) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start_builtin_fw) = .;			\
+-		*(.builtin_fw)						\
++		KEEP(*(.builtin_fw))					\
+ 		VMLINUX_SYMBOL(__end_builtin_fw) = .;			\
+ 	}								\
+ 									\
+@@ -310,49 +311,49 @@
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
+-		*(SORT(___ksymtab+*))					\
++		KEEP(*(SORT(___ksymtab+*)))				\
+ 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
+-		*(SORT(___ksymtab_gpl+*))				\
++		KEEP(*(SORT(___ksymtab_gpl+*)))				\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: Normal unused symbols */		\
+ 	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\
+-		*(SORT(___ksymtab_unused+*))				\
++		KEEP(*(SORT(___ksymtab_unused+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only unused symbols */		\
+ 	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\
+-		*(SORT(___ksymtab_unused_gpl+*))			\
++		KEEP(*(SORT(___ksymtab_unused_gpl+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-future-only symbols */		\
+ 	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\
+-		*(SORT(___ksymtab_gpl_future+*))			\
++		KEEP(*(SORT(___ksymtab_gpl_future+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__kcrctab         : AT(ADDR(__kcrctab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___kcrctab) = .;			\
+-		*(SORT(___kcrctab+*))					\
++		KEEP(*(SORT(___kcrctab+*)))				\
+ 		VMLINUX_SYMBOL(__stop___kcrctab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__kcrctab_gpl     : AT(ADDR(__kcrctab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___kcrctab_gpl) = .;		\
+-		*(SORT(___kcrctab_gpl+*))				\
++		KEEP(*(SORT(___kcrctab_gpl+*)))				\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_gpl) = .;		\
+ 	}								\
+ 									\
+@@ -366,14 +367,14 @@
+ 	/* Kernel symbol table: GPL-only unused symbols */		\
+ 	__kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___kcrctab_unused_gpl) = .;	\
+-		*(SORT(___kcrctab_unused_gpl+*))			\
++		KEEP(*(SORT(___kcrctab_unused_gpl+*)))			\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_unused_gpl) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-future-only symbols */		\
+ 	__kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___kcrctab_gpl_future) = .;	\
+-		*(SORT(___kcrctab_gpl_future+*))			\
++		KEEP(*(SORT(___kcrctab_gpl_future+*)))			\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_gpl_future) = .;	\
+ 	}								\
+ 									\
+@@ -392,14 +393,14 @@
+ 	/* Built-in module parameters. */				\
+ 	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\
+ 		VMLINUX_SYMBOL(__start___param) = .;			\
+-		*(__param)						\
++		KEEP(*(__param))					\
+ 		VMLINUX_SYMBOL(__stop___param) = .;			\
+ 	}								\
+ 									\
+ 	/* Built-in module versions. */					\
+ 	__modver : AT(ADDR(__modver) - LOAD_OFFSET) {			\
+ 		VMLINUX_SYMBOL(__start___modver) = .;			\
+-		*(__modver)						\
++		KEEP(*(__modver))					\
+ 		VMLINUX_SYMBOL(__stop___modver) = .;			\
+ 		. = ALIGN((align));					\
+ 		VMLINUX_SYMBOL(__end_rodata) = .;			\
+@@ -453,7 +454,7 @@
+ #define ENTRY_TEXT							\
+ 		ALIGN_FUNCTION();					\
+ 		VMLINUX_SYMBOL(__entry_text_start) = .;			\
+-		*(.entry.text)						\
++		KEEP(*(.entry.text))					\
+ 		VMLINUX_SYMBOL(__entry_text_end) = .;
+ 
+ #ifdef CONFIG_FUNCTION_GRAPH_TRACER
+@@ -481,7 +482,7 @@
+ 	. = ALIGN(align);						\
+ 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ex_table) = .;			\
+-		*(__ex_table)						\
++		KEEP(*(__ex_table))						\
+ 		VMLINUX_SYMBOL(__stop___ex_table) = .;			\
+ 	}
+ 
+@@ -497,9 +498,9 @@
+ #ifdef CONFIG_CONSTRUCTORS
+ #define KERNEL_CTORS()	. = ALIGN(8);			   \
+ 			VMLINUX_SYMBOL(__ctors_start) = .; \
+-			*(.ctors)			   \
++			KEEP(*(.ctors))			   \
+ 			*(SORT(.init_array.*))		   \
+-			*(.init_array)			   \
++			KEEP(*(.init_array))		   \
+ 			VMLINUX_SYMBOL(__ctors_end) = .;
+ #else
+ #define KERNEL_CTORS()
+@@ -556,7 +557,7 @@
+ #define SBSS(sbss_align)						\
+ 	. = ALIGN(sbss_align);						\
+ 	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\
+-		*(.sbss)						\
++		*(.sbss .sbss.*)					\
+ 		*(.scommon)						\
+ 	}
+ 
+@@ -574,7 +575,7 @@
+ 		BSS_FIRST_SECTIONS					\
+ 		*(.bss..page_aligned)					\
+ 		*(.dynbss)						\
+-		*(.bss)							\
++		*(.bss .bss.*)						\
+ 		*(COMMON)						\
+ 	}
+ 
+@@ -623,7 +624,7 @@
+ 	. = ALIGN(8);							\
+ 	__bug_table : AT(ADDR(__bug_table) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___bug_table) = .;		\
+-		*(__bug_table)						\
++		KEEP(*(__bug_table))					\
+ 		VMLINUX_SYMBOL(__stop___bug_table) = .;			\
+ 	}
+ #else
+@@ -635,7 +636,7 @@
+ 	. = ALIGN(4);							\
+ 	.tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__tracedata_start) = .;			\
+-		*(.tracedata)						\
++		KEEP(*(.tracedata))					\
+ 		VMLINUX_SYMBOL(__tracedata_end) = .;			\
+ 	}
+ #else
+@@ -652,17 +653,17 @@
+ #define INIT_SETUP(initsetup_align)					\
+ 		. = ALIGN(initsetup_align);				\
+ 		VMLINUX_SYMBOL(__setup_start) = .;			\
+-		*(.init.setup)						\
++		KEEP(*(.init.setup))					\
+ 		VMLINUX_SYMBOL(__setup_end) = .;
+ 
+ #define INIT_CALLS_LEVEL(level)						\
+ 		VMLINUX_SYMBOL(__initcall##level##_start) = .;		\
+-		*(.initcall##level##.init)				\
+-		*(.initcall##level##s.init)				\
++		KEEP(*(.initcall##level##.init))			\
++		KEEP(*(.initcall##level##s.init))			\
+ 
+ #define INIT_CALLS							\
+ 		VMLINUX_SYMBOL(__initcall_start) = .;			\
+-		*(.initcallearly.init)					\
++		KEEP(*(.initcallearly.init))				\
+ 		INIT_CALLS_LEVEL(0)					\
+ 		INIT_CALLS_LEVEL(1)					\
+ 		INIT_CALLS_LEVEL(2)					\
+@@ -676,21 +677,21 @@
+ 
+ #define CON_INITCALL							\
+ 		VMLINUX_SYMBOL(__con_initcall_start) = .;		\
+-		*(.con_initcall.init)					\
++		KEEP(*(.con_initcall.init))				\
+ 		VMLINUX_SYMBOL(__con_initcall_end) = .;
+ 
+ #define SECURITY_INITCALL						\
+ 		VMLINUX_SYMBOL(__security_initcall_start) = .;		\
+-		*(.security_initcall.init)				\
++		KEEP(*(.security_initcall.init))			\
+ 		VMLINUX_SYMBOL(__security_initcall_end) = .;
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ #define INIT_RAM_FS							\
+ 	. = ALIGN(4);							\
+ 	VMLINUX_SYMBOL(__initramfs_start) = .;				\
+-	*(.init.ramfs)							\
++	KEEP(*(.init.ramfs))						\
+ 	. = ALIGN(8);							\
+-	*(.init.ramfs.info)
++	KEEP(*(.init.ramfs.info))
+ #else
+ #define INIT_RAM_FS
+ #endif
+--- a/arch/arm/Makefile
++++ b/arch/arm/Makefile
+@@ -22,11 +22,16 @@ endif
+ ifeq ($(CONFIG_ARM_MODULE_PLTS),y)
+ LDFLAGS_MODULE	+= -T $(srctree)/arch/arm/kernel/module.lds
+ endif
++LDFLAGS_vmlinux += --gc-sections
+ 
+ OBJCOPYFLAGS	:=-O binary -R .comment -S
+ GZFLAGS		:=-9
+ #KBUILD_CFLAGS	+=-pipe
+ 
++ifndef CONFIG_FUNCTION_TRACER
++KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
++endif
++
+ # Never generate .eh_frame
+ KBUILD_CFLAGS	+= $(call cc-option,-fno-dwarf2-cfi-asm)
+ 
+--- a/arch/arm/kernel/vmlinux.lds.S
++++ b/arch/arm/kernel/vmlinux.lds.S
+@@ -15,13 +15,13 @@
+ #define PROC_INFO							\
+ 	. = ALIGN(4);							\
+ 	VMLINUX_SYMBOL(__proc_info_begin) = .;				\
+-	*(.proc.info.init)						\
++	KEEP(*(.proc.info.init))					\
+ 	VMLINUX_SYMBOL(__proc_info_end) = .;
+ 
+ #define IDMAP_TEXT							\
+ 	ALIGN_FUNCTION();						\
+ 	VMLINUX_SYMBOL(__idmap_text_start) = .;				\
+-	*(.idmap.text)							\
++	KEEP(*(.idmap.text))						\
+ 	VMLINUX_SYMBOL(__idmap_text_end) = .;				\
+ 	. = ALIGN(PAGE_SIZE);						\
+ 	VMLINUX_SYMBOL(__hyp_idmap_text_start) = .;			\
+@@ -102,7 +102,7 @@ SECTIONS
+ 		_stext = .;		/* Text and read-only data	*/
+ 			IDMAP_TEXT
+ 			__exception_text_start = .;
+-			*(.exception.text)
++			KEEP(*(.exception.text))
+ 			__exception_text_end = .;
+ 			IRQENTRY_TEXT
+ 			TEXT_TEXT
+@@ -126,7 +126,7 @@ SECTIONS
+ 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
+ 		__start___ex_table = .;
+ #ifdef CONFIG_MMU
+-		*(__ex_table)
++		KEEP(*(__ex_table))
+ #endif
+ 		__stop___ex_table = .;
+ 	}
+@@ -138,12 +138,12 @@ SECTIONS
+ 	. = ALIGN(8);
+ 	.ARM.unwind_idx : {
+ 		__start_unwind_idx = .;
+-		*(.ARM.exidx*)
++		KEEP(*(.ARM.exidx*))
+ 		__stop_unwind_idx = .;
+ 	}
+ 	.ARM.unwind_tab : {
+ 		__start_unwind_tab = .;
+-		*(.ARM.extab*)
++		KEEP(*(.ARM.extab*))
+ 		__stop_unwind_tab = .;
+ 	}
+ #endif
+@@ -166,14 +166,14 @@ SECTIONS
+ 	 */
+ 	__vectors_start = .;
+ 	.vectors 0 : AT(__vectors_start) {
+-		*(.vectors)
++		KEEP(*(.vectors))
+ 	}
+ 	. = __vectors_start + SIZEOF(.vectors);
+ 	__vectors_end = .;
+ 
+ 	__stubs_start = .;
+ 	.stubs 0x1000 : AT(__stubs_start) {
+-		*(.stubs)
++		KEEP(*(.stubs))
+ 	}
+ 	. = __stubs_start + SIZEOF(.stubs);
+ 	__stubs_end = .;
+@@ -187,24 +187,24 @@ SECTIONS
+ 	}
+ 	.init.arch.info : {
+ 		__arch_info_begin = .;
+-		*(.arch.info.init)
++		KEEP(*(.arch.info.init))
+ 		__arch_info_end = .;
+ 	}
+ 	.init.tagtable : {
+ 		__tagtable_begin = .;
+-		*(.taglist.init)
++		KEEP(*(.taglist.init))
+ 		__tagtable_end = .;
+ 	}
+ #ifdef CONFIG_SMP_ON_UP
+ 	.init.smpalt : {
+ 		__smpalt_begin = .;
+-		*(.alt.smp.init)
++		KEEP(*(.alt.smp.init))
+ 		__smpalt_end = .;
+ 	}
+ #endif
+ 	.init.pv_table : {
+ 		__pv_table_begin = .;
+-		*(.pv_table)
++		KEEP(*(.pv_table))
+ 		__pv_table_end = .;
+ 	}
+ 	.init.data : {
+--- a/arch/arm/boot/compressed/Makefile
++++ b/arch/arm/boot/compressed/Makefile
+@@ -105,6 +105,7 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
+ ORIG_CFLAGS := $(KBUILD_CFLAGS)
+ KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
+ endif
++KBUILD_CFLAGS_KERNEL := $(patsubst -f%-sections,,$(KBUILD_CFLAGS_KERNEL))
+ 
+ ccflags-y := -fpic -mno-single-pic-base -fno-builtin -I$(obj)
+ asflags-y := -DZIMAGE
diff --git a/target/linux/generic/pending-4.4/221-module_exports.patch b/target/linux/generic/pending-4.4/221-module_exports.patch
new file mode 100644
index 0000000000..44c0a6dec6
--- /dev/null
+++ b/target/linux/generic/pending-4.4/221-module_exports.patch
@@ -0,0 +1,88 @@
+--- a/include/asm-generic/vmlinux.lds.h
++++ b/include/asm-generic/vmlinux.lds.h
+@@ -54,6 +54,16 @@
+ #define LOAD_OFFSET 0
+ #endif
+ 
++#ifndef SYMTAB_KEEP
++#define SYMTAB_KEEP KEEP(*(SORT(___ksymtab+*)))
++#define SYMTAB_KEEP_GPL KEEP(*(SORT(___ksymtab_gpl+*)))
++#endif
++
++#ifndef SYMTAB_DISCARD
++#define SYMTAB_DISCARD
++#define SYMTAB_DISCARD_GPL
++#endif
++
+ #include <linux/export.h>
+ 
+ /* Align . to a 8 byte boundary equals to maximum function alignment. */
+@@ -311,14 +321,14 @@
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
+-		KEEP(*(SORT(___ksymtab+*)))				\
++		SYMTAB_KEEP						\
+ 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
+-		KEEP(*(SORT(___ksymtab_gpl+*)))				\
++		SYMTAB_KEEP_GPL						\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
+ 	}								\
+ 									\
+@@ -380,7 +390,7 @@
+ 									\
+ 	/* Kernel symbol table: strings */				\
+         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
+-		*(__ksymtab_strings)					\
++		*(__ksymtab_strings+*)					\
+ 	}								\
+ 									\
+ 	/* __*init sections */						\
+@@ -710,6 +720,8 @@
+ 	EXIT_TEXT							\
+ 	EXIT_DATA							\
+ 	EXIT_CALL							\
++	SYMTAB_DISCARD							\
++	SYMTAB_DISCARD_GPL						\
+ 	*(.discard)							\
+ 	*(.discard.*)							\
+ 	}
+--- a/scripts/Makefile.build
++++ b/scripts/Makefile.build
+@@ -372,7 +372,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
+ # Linker scripts preprocessor (.lds.S -> .lds)
+ # ---------------------------------------------------------------------------
+ quiet_cmd_cpp_lds_S = LDS     $@
+-      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \
++      cmd_cpp_lds_S = $(CPP) $(EXTRA_LDSFLAGS) $(cpp_flags) -P -C -U$(ARCH) \
+ 	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<
+ 
+ $(obj)/%.lds: $(src)/%.lds.S FORCE
+--- a/include/linux/export.h
++++ b/include/linux/export.h
+@@ -52,12 +52,19 @@ extern struct module __this_module;
+ #define __CRC_SYMBOL(sym, sec)
+ #endif
+ 
++#ifdef MODULE
++#define __EXPORT_SUFFIX(sym)
++#else
++#define __EXPORT_SUFFIX(sym) "+" #sym
++#endif
++
+ /* For every exported symbol, place a struct in the __ksymtab section */
+ #define __EXPORT_SYMBOL(sym, sec)				\
+ 	extern typeof(sym) sym;					\
+ 	__CRC_SYMBOL(sym, sec)					\
+ 	static const char __kstrtab_##sym[]			\
+-	__attribute__((section("__ksymtab_strings"), aligned(1))) \
++	__attribute__((section("__ksymtab_strings"		\
++	  __EXPORT_SUFFIX(sym)), aligned(1)))			\
+ 	= VMLINUX_SYMBOL_STR(sym);				\
+ 	extern const struct kernel_symbol __ksymtab_##sym;	\
+ 	__visible const struct kernel_symbol __ksymtab_##sym	\
diff --git a/target/linux/generic/pending-4.4/222-arm_zimage_none.patch b/target/linux/generic/pending-4.4/222-arm_zimage_none.patch
new file mode 100644
index 0000000000..47fa6c928d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/222-arm_zimage_none.patch
@@ -0,0 +1,133 @@
+ARM: implement "uncompressed zImage"
+
+Based on RFC patch by Uwe Kleine-Knig
+http://www.spinics.net/lists/arm-kernel/msg230153.html
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/arch/arm/boot/compressed/Makefile
++++ b/arch/arm/boot/compressed/Makefile
+@@ -71,6 +71,7 @@ suffix_$(CONFIG_KERNEL_LZO)  = lzo
+ suffix_$(CONFIG_KERNEL_LZMA) = lzma
+ suffix_$(CONFIG_KERNEL_XZ)   = xzkern
+ suffix_$(CONFIG_KERNEL_LZ4)  = lz4
++suffix_$(CONFIG_KERNEL_CAT)  = cat
+ 
+ # Borrowed libfdt files for the ATAG compatibility mode
+ 
+@@ -95,7 +96,7 @@ targets       := vmlinux vmlinux.lds \
+ 		 bswapsdi2.S font.o font.c head.o misc.o $(OBJS)
+ 
+ # Make sure files are removed during clean
+-extra-y       += piggy.gzip piggy.lzo piggy.lzma piggy.xzkern piggy.lz4 \
++extra-y       += piggy.gzip piggy.lzo piggy.lzma piggy.xzkern piggy.lz4 piggy.cat \
+ 		 lib1funcs.S ashldi3.S bswapsdi2.S $(libfdt) $(libfdt_hdrs) \
+ 		 hyp-stub.S
+ 
+--- a/arch/arm/boot/compressed/decompress.c
++++ b/arch/arm/boot/compressed/decompress.c
+@@ -55,6 +55,10 @@ extern char * strstr(const char * s1, co
+ #include "../../../../lib/decompress_unlz4.c"
+ #endif
+ 
++#ifdef CONFIG_KERNEL_CAT
++#include "../../../../lib/decompress_uncat.c"
++#endif
++
+ int do_decompress(u8 *input, int len, u8 *output, void (*error)(char *x))
+ {
+ 	return __decompress(input, len, NULL, NULL, output, 0, NULL, error);
+--- /dev/null
++++ b/arch/arm/boot/compressed/piggy.cat.S
+@@ -0,0 +1,6 @@
++	.section .piggydata,#alloc
++	.globl	input_data
++input_data:
++	.incbin	"arch/arm/boot/compressed/piggy.cat"
++	.globl	input_data_end
++input_data_end:
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -115,6 +115,9 @@ config HAVE_KERNEL_LZO
+ config HAVE_KERNEL_LZ4
+ 	bool
+ 
++config HAVE_KERNEL_CAT
++	bool
++
+ choice
+ 	prompt "Kernel compression mode"
+ 	default KERNEL_GZIP
+@@ -181,9 +184,10 @@ config KERNEL_LZO
+ 	bool "LZO"
+ 	depends on HAVE_KERNEL_LZO
+ 	help
+-	  Its compression ratio is the poorest among the choices. The kernel
+-	  size is about 10% bigger than gzip; however its speed
+-	  (both compression and decompression) is the fastest.
++	  Its compression ratio is the poorest among the choices (apart from
++	  uncompressed below). The kernel size is about 10% bigger than gzip;
++	  however its speed (both compression and decompression) is the
++	  fastest.
+ 
+ config KERNEL_LZ4
+ 	bool "LZ4"
+@@ -197,6 +201,12 @@ config KERNEL_LZ4
+ 	  is about 8% bigger than LZO. But the decompression speed is
+ 	  faster than LZO.
+ 
++config KERNEL_CAT
++	bool "uncompressed"
++	depends on HAVE_KERNEL_CAT
++	help
++	  Don't use compression at all.
++
+ endchoice
+ 
+ config DEFAULT_HOSTNAME
+--- /dev/null
++++ b/lib/decompress_uncat.c
+@@ -0,0 +1,17 @@
++#include <linux/types.h>
++#include <linux/compiler.h>
++
++#ifdef STATIC
++
++STATIC int __decompress(unsigned char *buf, long in_len,
++			long (*fill)(void*, unsigned long),
++			long (*flush)(void*, unsigned long),
++			unsigned char *output, long out_len,
++			long *posp,
++			void (*error)(char *x))
++{
++	memmove(output, buf, in_len);
++	return 0;
++}
++
++#endif
+--- a/scripts/Makefile.lib
++++ b/scripts/Makefile.lib
+@@ -337,6 +337,13 @@ cmd_lz4 = (cat $(filter-out FORCE,$^) |
+ 	lz4c -l -c1 stdin stdout && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
+ 	(rm -f $@ ; false)
+ 
++# uncompressed
++# ---------------------------------------------------------------------------
++quiet_cmd_cat = CAT     $@
++cmd_cat = (cat $(filter-out FORCE,$^) \
++	&& $(call size_append, $(filter-out FORCE,$^))) > $@ || \
++	(rm -f $@ ; false)
++
+ # U-Boot mkimage
+ # ---------------------------------------------------------------------------
+ 
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -59,6 +59,7 @@ config ARM
+ 	select HAVE_KERNEL_LZMA
+ 	select HAVE_KERNEL_LZO
+ 	select HAVE_KERNEL_XZ
++	select HAVE_KERNEL_CAT
+ 	select HAVE_KPROBES if !XIP_KERNEL && !CPU_ENDIAN_BE32 && !CPU_V7M
+ 	select HAVE_KRETPROBES if (HAVE_KPROBES)
+ 	select HAVE_MEMBLOCK
diff --git a/target/linux/generic/pending-4.4/230-openwrt_lzma_options.patch b/target/linux/generic/pending-4.4/230-openwrt_lzma_options.patch
new file mode 100644
index 0000000000..d5bbb19cfe
--- /dev/null
+++ b/target/linux/generic/pending-4.4/230-openwrt_lzma_options.patch
@@ -0,0 +1,58 @@
+--- a/scripts/Makefile.lib
++++ b/scripts/Makefile.lib
+@@ -324,7 +324,7 @@ cmd_bzip2 = (cat $(filter-out FORCE,$^)
+ 
+ quiet_cmd_lzma = LZMA    $@
+ cmd_lzma = (cat $(filter-out FORCE,$^) | \
+-	lzma -9 && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
++	lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
+ 	(rm -f $@ ; false)
+ 
+ quiet_cmd_lzo = LZO     $@
+--- a/scripts/gen_initramfs_list.sh
++++ b/scripts/gen_initramfs_list.sh
+@@ -226,7 +226,7 @@ cpio_list=
+ output="/dev/stdout"
+ output_file=""
+ is_cpio_compressed=
+-compr="gzip -n -9 -f"
++compr="gzip -n -9 -f -"
+ 
+ arg="$1"
+ case "$arg" in
+@@ -242,13 +242,13 @@ case "$arg" in
+ 		output=${cpio_list}
+ 		echo "$output_file" | grep -q "\.gz$" \
+                 && [ -x "`which gzip 2> /dev/null`" ] \
+-                && compr="gzip -n -9 -f"
++                && compr="gzip -n -9 -f -"
+ 		echo "$output_file" | grep -q "\.bz2$" \
+                 && [ -x "`which bzip2 2> /dev/null`" ] \
+-                && compr="bzip2 -9 -f"
++                && compr="bzip2 -9 -f -"
+ 		echo "$output_file" | grep -q "\.lzma$" \
+                 && [ -x "`which lzma 2> /dev/null`" ] \
+-                && compr="lzma -9 -f"
++                && compr="lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so"
+ 		echo "$output_file" | grep -q "\.xz$" \
+                 && [ -x "`which xz 2> /dev/null`" ] \
+                 && compr="xz --check=crc32 --lzma2=dict=1MiB"
+@@ -315,7 +315,7 @@ if [ ! -z ${output_file} ]; then
+ 	if [ "${is_cpio_compressed}" = "compressed" ]; then
+ 		cat ${cpio_tfile} > ${output_file}
+ 	else
+-		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
++		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
+ 		|| (rm -f ${output_file} ; false)
+ 	fi
+ 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
+--- a/lib/decompress.c
++++ b/lib/decompress.c
+@@ -48,6 +48,7 @@ static const struct compress_format comp
+ 	{ {0x1f, 0x9e}, "gzip", gunzip },
+ 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
+ 	{ {0x5d, 0x00}, "lzma", unlzma },
++	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
+ 	{ {0xfd, 0x37}, "xz", unxz },
+ 	{ {0x89, 0x4c}, "lzo", unlzo },
+ 	{ {0x02, 0x21}, "lz4", unlz4 },
diff --git a/target/linux/generic/pending-4.4/250-netfilter_depends.patch b/target/linux/generic/pending-4.4/250-netfilter_depends.patch
new file mode 100644
index 0000000000..b39d971a76
--- /dev/null
+++ b/target/linux/generic/pending-4.4/250-netfilter_depends.patch
@@ -0,0 +1,18 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -218,7 +218,6 @@ config NF_CONNTRACK_FTP
+ 
+ config NF_CONNTRACK_H323
+ 	tristate "H.323 protocol support"
+-	depends on IPV6 || IPV6=n
+ 	depends on NETFILTER_ADVANCED
+ 	help
+ 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
+@@ -930,7 +929,6 @@ config NETFILTER_XT_TARGET_SECMARK
+ 
+ config NETFILTER_XT_TARGET_TCPMSS
+ 	tristate '"TCPMSS" target support'
+-	depends on IPV6 || IPV6=n
+ 	default m if NETFILTER_ADVANCED=n
+ 	---help---
+ 	  This option adds a `TCPMSS' target, which allows you to alter the
diff --git a/target/linux/generic/pending-4.4/251-sound_kconfig.patch b/target/linux/generic/pending-4.4/251-sound_kconfig.patch
new file mode 100644
index 0000000000..4cb67adc70
--- /dev/null
+++ b/target/linux/generic/pending-4.4/251-sound_kconfig.patch
@@ -0,0 +1,18 @@
+--- a/sound/core/Kconfig
++++ b/sound/core/Kconfig
+@@ -16,13 +16,13 @@ config SND_DMAENGINE_PCM
+ 	tristate
+ 
+ config SND_HWDEP
+-	tristate
++	tristate "Sound hardware support"
+ 
+ config SND_RAWMIDI
+ 	tristate
+ 
+ config SND_COMPRESS_OFFLOAD
+-	tristate
++	tristate "Compression offloading support"
+ 
+ # To be effective this also requires INPUT - users should say:
+ #    select SND_JACK if INPUT=y || INPUT=SND
diff --git a/target/linux/generic/pending-4.4/252-mv_cesa_depends.patch b/target/linux/generic/pending-4.4/252-mv_cesa_depends.patch
new file mode 100644
index 0000000000..f54f3c7fcc
--- /dev/null
+++ b/target/linux/generic/pending-4.4/252-mv_cesa_depends.patch
@@ -0,0 +1,10 @@
+--- a/drivers/crypto/Kconfig
++++ b/drivers/crypto/Kconfig
+@@ -163,6 +163,7 @@ config CRYPTO_DEV_MV_CESA
+ 	tristate "Marvell's Cryptographic Engine"
+ 	depends on PLAT_ORION
+ 	select CRYPTO_AES
++	select CRYPTO_HASH2
+ 	select CRYPTO_BLKCIPHER
+ 	select CRYPTO_HASH
+ 	select SRAM
diff --git a/target/linux/generic/pending-4.4/253-ssb_b43_default_on.patch b/target/linux/generic/pending-4.4/253-ssb_b43_default_on.patch
new file mode 100644
index 0000000000..29d2a41a3b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/253-ssb_b43_default_on.patch
@@ -0,0 +1,29 @@
+--- a/drivers/ssb/Kconfig
++++ b/drivers/ssb/Kconfig
+@@ -29,6 +29,7 @@ config SSB_SPROM
+ config SSB_BLOCKIO
+ 	bool
+ 	depends on SSB
++	default y
+ 
+ config SSB_PCIHOST_POSSIBLE
+ 	bool
+@@ -49,7 +50,7 @@ config SSB_PCIHOST
+ config SSB_B43_PCI_BRIDGE
+ 	bool
+ 	depends on SSB_PCIHOST
+-	default n
++	default y
+ 
+ config SSB_PCMCIAHOST_POSSIBLE
+ 	bool
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -17,6 +17,7 @@ config BCMA
+ config BCMA_BLOCKIO
+ 	bool
+ 	depends on BCMA
++	default y
+ 
+ config BCMA_HOST_PCI_POSSIBLE
+ 	bool
diff --git a/target/linux/generic/pending-4.4/254-textsearch_kconfig_hacks.patch b/target/linux/generic/pending-4.4/254-textsearch_kconfig_hacks.patch
new file mode 100644
index 0000000000..12cedbed15
--- /dev/null
+++ b/target/linux/generic/pending-4.4/254-textsearch_kconfig_hacks.patch
@@ -0,0 +1,23 @@
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -334,16 +334,16 @@ config BCH_CONST_T
+ # Textsearch support is select'ed if needed
+ #
+ config TEXTSEARCH
+-	bool
++	boolean	"Textsearch support"
+ 
+ config TEXTSEARCH_KMP
+-	tristate
++	tristate "Textsearch KMP"
+ 
+ config TEXTSEARCH_BM
+-	tristate
++	tristate "Textsearch BM"
+ 
+ config TEXTSEARCH_FSM
+-	tristate
++	tristate "Textsearch FSM"
+ 
+ config BTREE
+ 	bool
diff --git a/target/linux/generic/pending-4.4/255-lib80211_kconfig_hacks.patch b/target/linux/generic/pending-4.4/255-lib80211_kconfig_hacks.patch
new file mode 100644
index 0000000000..be75806e6b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/255-lib80211_kconfig_hacks.patch
@@ -0,0 +1,31 @@
+--- a/net/wireless/Kconfig
++++ b/net/wireless/Kconfig
+@@ -201,7 +201,7 @@ config CFG80211_WEXT_EXPORT
+ 	  wext compatibility symbols to be exported.
+ 
+ config LIB80211
+-	tristate
++	tristate "LIB80211"
+ 	default n
+ 	help
+ 	  This options enables a library of common routines used
+@@ -210,13 +210,16 @@ config LIB80211
+ 	  Drivers should select this themselves if needed.
+ 
+ config LIB80211_CRYPT_WEP
+-	tristate
++	tristate "LIB80211_CRYPT_WEP"
++	select LIB80211
+ 
+ config LIB80211_CRYPT_CCMP
+-	tristate
++	tristate "LIB80211_CRYPT_CCMP"
++	select LIB80211
+ 
+ config LIB80211_CRYPT_TKIP
+-	tristate
++	tristate "LIB80211_CRYPT_TKIP"
++	select LIB80211
+ 
+ config LIB80211_DEBUG
+ 	bool "lib80211 debugging messages"
diff --git a/target/linux/generic/pending-4.4/256-crypto_add_kconfig_prompts.patch b/target/linux/generic/pending-4.4/256-crypto_add_kconfig_prompts.patch
new file mode 100644
index 0000000000..fb5d5dc4b4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/256-crypto_add_kconfig_prompts.patch
@@ -0,0 +1,47 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -32,7 +32,7 @@ config CRYPTO_FIPS
+ 	  this is.
+ 
+ config CRYPTO_ALGAPI
+-	tristate
++	tristate "ALGAPI"
+ 	select CRYPTO_ALGAPI2
+ 	help
+ 	  This option provides the API for cryptographic algorithms.
+@@ -41,7 +41,7 @@ config CRYPTO_ALGAPI2
+ 	tristate
+ 
+ config CRYPTO_AEAD
+-	tristate
++	tristate "AEAD"
+ 	select CRYPTO_AEAD2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -52,7 +52,7 @@ config CRYPTO_AEAD2
+ 	select CRYPTO_RNG2
+ 
+ config CRYPTO_BLKCIPHER
+-	tristate
++	tristate "BLKCIPHER"
+ 	select CRYPTO_BLKCIPHER2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -63,7 +63,7 @@ config CRYPTO_BLKCIPHER2
+ 	select CRYPTO_WORKQUEUE
+ 
+ config CRYPTO_HASH
+-	tristate
++	tristate "HASH"
+ 	select CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -72,7 +72,7 @@ config CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_RNG
+-	tristate
++	tristate "RNG"
+ 	select CRYPTO_RNG2
+ 	select CRYPTO_ALGAPI
+ 
diff --git a/target/linux/generic/pending-4.4/257-wireless_ext_kconfig_hack.patch b/target/linux/generic/pending-4.4/257-wireless_ext_kconfig_hack.patch
new file mode 100644
index 0000000000..daac5898ae
--- /dev/null
+++ b/target/linux/generic/pending-4.4/257-wireless_ext_kconfig_hack.patch
@@ -0,0 +1,22 @@
+--- a/net/wireless/Kconfig
++++ b/net/wireless/Kconfig
+@@ -1,5 +1,5 @@
+ config WIRELESS_EXT
+-	bool
++	bool "Wireless extensions"
+ 
+ config WEXT_CORE
+ 	def_bool y
+@@ -11,10 +11,10 @@ config WEXT_PROC
+ 	depends on WEXT_CORE
+ 
+ config WEXT_SPY
+-	bool
++	bool "WEXT_SPY"
+ 
+ config WEXT_PRIV
+-	bool
++	bool "WEXT_PRIV"
+ 
+ config CFG80211
+ 	tristate "cfg80211 - wireless configuration API"
diff --git a/target/linux/generic/pending-4.4/258-netfilter_netlink_kconfig_hack.patch b/target/linux/generic/pending-4.4/258-netfilter_netlink_kconfig_hack.patch
new file mode 100644
index 0000000000..4206c9a74a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/258-netfilter_netlink_kconfig_hack.patch
@@ -0,0 +1,11 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -10,7 +10,7 @@ config NETFILTER_INGRESS
+ 	  infrastructure.
+ 
+ config NETFILTER_NETLINK
+-	tristate
++	tristate "Netfilter NFNETLINK interface"
+ 
+ config NETFILTER_NETLINK_ACCT
+ tristate "Netfilter NFACCT over NFNETLINK interface"
diff --git a/target/linux/generic/pending-4.4/259-regmap_dynamic.patch b/target/linux/generic/pending-4.4/259-regmap_dynamic.patch
new file mode 100644
index 0000000000..42a9728567
--- /dev/null
+++ b/target/linux/generic/pending-4.4/259-regmap_dynamic.patch
@@ -0,0 +1,90 @@
+--- a/drivers/base/regmap/Kconfig
++++ b/drivers/base/regmap/Kconfig
+@@ -3,9 +3,8 @@
+ # subsystems should select the appropriate symbols.
+ 
+ config REGMAP
+-	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ)
+ 	select IRQ_DOMAIN if REGMAP_IRQ
+-	bool
++	tristate "Regmap"
+ 
+ config REGCACHE_COMPRESSED
+ 	select LZO_COMPRESS
+@@ -16,19 +15,25 @@ config REGMAP_AC97
+ 	tristate
+ 
+ config REGMAP_I2C
+-	tristate
++	tristate "Regmap I2C"
++	select REGMAP
+ 	depends on I2C
+ 
+ config REGMAP_SPI
+-	tristate
++	tristate "Regmap SPI"
++	select REGMAP
++	depends on SPI_MASTER
+ 	depends on SPI
+ 
+ config REGMAP_SPMI
++	select REGMAP
+ 	tristate
+ 	depends on SPMI
+ 
+ config REGMAP_MMIO
+-	tristate
++	tristate "Regmap MMIO"
++	select REGMAP
+ 
+ config REGMAP_IRQ
++	select REGMAP
+ 	bool
+--- a/include/linux/regmap.h
++++ b/include/linux/regmap.h
+@@ -65,7 +65,7 @@ struct reg_sequence {
+ 	unsigned int delay_us;
+ };
+ 
+-#ifdef CONFIG_REGMAP
++#if IS_ENABLED(CONFIG_REGMAP)
+ 
+ enum regmap_endian {
+ 	/* Unspecified -> 0 -> Backwards compatible default */
+--- a/drivers/base/regmap/Makefile
++++ b/drivers/base/regmap/Makefile
+@@ -1,10 +1,14 @@
+ # For include/trace/define_trace.h to include trace.h
+ CFLAGS_regmap.o := -I$(src)
+ 
+-obj-$(CONFIG_REGMAP) += regmap.o regcache.o
+-obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o
+-obj-$(CONFIG_REGCACHE_COMPRESSED) += regcache-lzo.o
+-obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
++regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-flat.o
++ifdef CONFIG_DEBUG_FS
++regmap-core-objs += regmap-debugfs.o
++endif
++ifdef CONFIG_REGCACHE_COMPRESSED
++regmap-core-objs += regcache-lzo.o
++endif
++obj-$(CONFIG_REGMAP) += regmap-core.o
+ obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
+ obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
+ obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
+--- a/drivers/base/regmap/regmap.c
++++ b/drivers/base/regmap/regmap.c
+@@ -13,6 +13,7 @@
+ #include <linux/device.h>
+ #include <linux/slab.h>
+ #include <linux/export.h>
++#include <linux/module.h>
+ #include <linux/mutex.h>
+ #include <linux/err.h>
+ #include <linux/of.h>
+@@ -2869,3 +2870,5 @@ static int __init regmap_initcall(void)
+ 	return 0;
+ }
+ postcore_initcall(regmap_initcall);
++
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-4.4/260-crypto_test_dependencies.patch b/target/linux/generic/pending-4.4/260-crypto_test_dependencies.patch
new file mode 100644
index 0000000000..54b8730a93
--- /dev/null
+++ b/target/linux/generic/pending-4.4/260-crypto_test_dependencies.patch
@@ -0,0 +1,48 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -118,12 +118,12 @@ config CRYPTO_MANAGER
+ 	  cbc(aes).
+ 
+ config CRYPTO_MANAGER2
+-	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
+-	select CRYPTO_AEAD2
+-	select CRYPTO_HASH2
+-	select CRYPTO_BLKCIPHER2
+-	select CRYPTO_PCOMP2
+-	select CRYPTO_AKCIPHER2
++	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y && !CRYPTO_MANAGER_DISABLE_TESTS)
++	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_BLKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_PCOMP2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_AKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
+ 
+ config CRYPTO_USER
+ 	tristate "Userspace cryptographic algorithm configuration"
+@@ -136,7 +136,6 @@ config CRYPTO_USER
+ config CRYPTO_MANAGER_DISABLE_TESTS
+ 	bool "Disable run-time self tests"
+ 	default y
+-	depends on CRYPTO_MANAGER2
+ 	help
+ 	  Disable run-time self tests that normally take place at
+ 	  algorithm registration.
+--- a/crypto/algboss.c
++++ b/crypto/algboss.c
+@@ -248,12 +248,16 @@ static int cryptomgr_schedule_test(struc
+ 	type = alg->cra_flags;
+ 
+ 	/* This piece of crap needs to disappear into per-type test hooks. */
++#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
++	type |= CRYPTO_ALG_TESTED;
++#else
+ 	if (!((type ^ CRYPTO_ALG_TYPE_BLKCIPHER) &
+ 	      CRYPTO_ALG_TYPE_BLKCIPHER_MASK) && !(type & CRYPTO_ALG_GENIV) &&
+ 	    ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
+ 	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
+ 					 alg->cra_ablkcipher.ivsize))
+ 		type |= CRYPTO_ALG_TESTED;
++#endif
+ 
+ 	param->type = type;
+ 
diff --git a/target/linux/generic/pending-4.4/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch b/target/linux/generic/pending-4.4/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch
new file mode 100644
index 0000000000..06ad9bba9d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/270-uapi-libc-compat-add-fallback-for-unsupported-libcs.patch
@@ -0,0 +1,130 @@
+From c6bdd0d302119819de72439972d0462c26ef9eda Mon Sep 17 00:00:00 2001
+From: Felix Janda <felix.janda@posteo.de>
+Date: Sun, 12 Nov 2017 13:30:17 -0500
+Subject: uapi libc compat: add fallback for unsupported libcs
+
+libc-compat.h aims to prevent symbol collisions between uapi and libc
+headers for each supported libc. This requires continuous coordination
+between them.
+
+The goal of this commit is to improve the situation for libcs (such as
+musl) which are not yet supported and/or do not wish to be explicitly
+supported, while not affecting supported libcs. More precisely, with
+this commit, unsupported libcs can request the suppression of any
+specific uapi definition by defining the correspondings _UAPI_DEF_*
+macro as 0. This can fix symbol collisions for them, as long as the
+libc headers are included before the uapi headers. Inclusion in the
+other order is outside the scope of this commit.
+
+All infrastructure in order to enable this fallback for unsupported
+libcs is already in place, except that libc-compat.h unconditionally
+defines all _UAPI_DEF_* macros to 1 for all unsupported libcs so that
+any previous definitions are ignored. In order to fix this, this commit
+merely makes these definitions conditional.
+
+This commit together with the musl libc commit
+
+http://git.musl-libc.org/cgit/musl/commit/?id=04983f2272382af92eb8f8838964ff944fbb8258
+
+fixes for example the following compiler errors when <linux/in6.h> is
+included after musl's <netinet/in.h>:
+
+./linux/in6.h:32:8: error: redefinition of 'struct in6_addr'
+./linux/in6.h:49:8: error: redefinition of 'struct sockaddr_in6'
+./linux/in6.h:59:8: error: redefinition of 'struct ipv6_mreq'
+
+The comments referencing glibc are still correct, but this file is not
+only used for glibc any more.
+
+Signed-off-by: Felix Janda <felix.janda@posteo.de>
+Reviewed-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ include/uapi/linux/libc-compat.h | 55 +++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 54 insertions(+), 1 deletion(-)
+
+--- a/include/uapi/linux/libc-compat.h
++++ b/include/uapi/linux/libc-compat.h
+@@ -148,39 +148,82 @@
+ 
+ /* If we did not see any headers from any supported C libraries,
+  * or we are being included in the kernel, then define everything
+- * that we need. */
++ * that we need. Check for previous __UAPI_* definitions to give
++ * unsupported C libraries a way to opt out of any kernel definition. */
+ #else /* !defined(__GLIBC__) */
+ 
+ /* Definitions for if.h */
++#ifndef __UAPI_DEF_IF_IFCONF
+ #define __UAPI_DEF_IF_IFCONF 1
++#endif
++#ifndef __UAPI_DEF_IF_IFMAP
+ #define __UAPI_DEF_IF_IFMAP 1
++#endif
++#ifndef __UAPI_DEF_IF_IFNAMSIZ
+ #define __UAPI_DEF_IF_IFNAMSIZ 1
++#endif
++#ifndef __UAPI_DEF_IF_IFREQ
+ #define __UAPI_DEF_IF_IFREQ 1
++#endif
+ /* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
++#ifndef __UAPI_DEF_IF_NET_DEVICE_FLAGS
+ #define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1
++#endif
+ /* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
++#ifndef __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
+ #define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
++#endif
+ 
+ /* Definitions for in.h */
++#ifndef __UAPI_DEF_IN_ADDR
+ #define __UAPI_DEF_IN_ADDR		1
++#endif
++#ifndef __UAPI_DEF_IN_IPPROTO
+ #define __UAPI_DEF_IN_IPPROTO		1
++#endif
++#ifndef __UAPI_DEF_IN_PKTINFO
+ #define __UAPI_DEF_IN_PKTINFO		1
++#endif
++#ifndef __UAPI_DEF_IP_MREQ
+ #define __UAPI_DEF_IP_MREQ		1
++#endif
++#ifndef __UAPI_DEF_SOCKADDR_IN
+ #define __UAPI_DEF_SOCKADDR_IN		1
++#endif
++#ifndef __UAPI_DEF_IN_CLASS
+ #define __UAPI_DEF_IN_CLASS		1
++#endif
+ 
+ /* Definitions for in6.h */
++#ifndef __UAPI_DEF_IN6_ADDR
+ #define __UAPI_DEF_IN6_ADDR		1
++#endif
++#ifndef __UAPI_DEF_IN6_ADDR_ALT
+ #define __UAPI_DEF_IN6_ADDR_ALT		1
++#endif
++#ifndef __UAPI_DEF_SOCKADDR_IN6
+ #define __UAPI_DEF_SOCKADDR_IN6		1
++#endif
++#ifndef __UAPI_DEF_IPV6_MREQ
+ #define __UAPI_DEF_IPV6_MREQ		1
++#endif
++#ifndef __UAPI_DEF_IPPROTO_V6
+ #define __UAPI_DEF_IPPROTO_V6		1
++#endif
++#ifndef __UAPI_DEF_IPV6_OPTIONS
+ #define __UAPI_DEF_IPV6_OPTIONS		1
++#endif
++#ifndef __UAPI_DEF_IN6_PKTINFO
+ #define __UAPI_DEF_IN6_PKTINFO		1
++#endif
++#ifndef __UAPI_DEF_IP6_MTUINFO
+ #define __UAPI_DEF_IP6_MTUINFO		1
++#endif
+ 
+ /* Definitions for xattr.h */
++#ifndef __UAPI_DEF_XATTR
+ #define __UAPI_DEF_XATTR		1
++#endif
+ 
+ #endif /* __GLIBC__ */
+ 
diff --git a/target/linux/generic/pending-4.4/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch b/target/linux/generic/pending-4.4/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch
new file mode 100644
index 0000000000..21494b9256
--- /dev/null
+++ b/target/linux/generic/pending-4.4/272-uapi-if_ether.h-prevent-redefinition-of-struct-ethhd.patch
@@ -0,0 +1,55 @@
+From 649affd04813c43e0a72886517fcfccd63230981 Mon Sep 17 00:00:00 2001
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Mon, 29 Jun 2015 16:53:03 +0200
+Subject: uapi/if_ether.h: prevent redefinition of struct ethhdr
+
+Musl provides its own ethhdr struct definition. Add a guard to prevent
+its definition of the appropriate musl header has already been included.
+
+glibc does not implement this header, but when glibc will implement this
+they can just define __UAPI_DEF_ETHHDR 0 to make it work with the
+kernel.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ include/uapi/linux/if_ether.h    | 3 +++
+ include/uapi/linux/libc-compat.h | 6 ++++++
+ 2 files changed, 9 insertions(+)
+
+--- a/include/uapi/linux/if_ether.h
++++ b/include/uapi/linux/if_ether.h
+@@ -22,6 +22,7 @@
+ #define _UAPI_LINUX_IF_ETHER_H
+ 
+ #include <linux/types.h>
++#include <linux/libc-compat.h>
+ 
+ /*
+  *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+@@ -135,11 +136,13 @@
+  *	This is an Ethernet frame header.
+  */
+ 
++#if __UAPI_DEF_ETHHDR
+ struct ethhdr {
+ 	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+ 	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+ 	__be16		h_proto;		/* packet type ID field	*/
+ } __attribute__((packed));
++#endif
+ 
+ 
+ #endif /* _UAPI_LINUX_IF_ETHER_H */
+--- a/include/uapi/linux/libc-compat.h
++++ b/include/uapi/linux/libc-compat.h
+@@ -227,4 +227,10 @@
+ 
+ #endif /* __GLIBC__ */
+ 
++/* Definitions for if_ether.h */
++/* allow libcs like musl to deactivate this, glibc does not implement this. */
++#ifndef __UAPI_DEF_ETHHDR
++#define __UAPI_DEF_ETHHDR		1
++#endif
++
+ #endif /* _UAPI_LIBC_COMPAT_H */
diff --git a/target/linux/generic/pending-4.4/280-rfkill-stubs.patch b/target/linux/generic/pending-4.4/280-rfkill-stubs.patch
new file mode 100644
index 0000000000..96a98e219a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/280-rfkill-stubs.patch
@@ -0,0 +1,79 @@
+--- a/net/rfkill/Kconfig
++++ b/net/rfkill/Kconfig
+@@ -1,7 +1,11 @@
+ #
+ # RF switch subsystem configuration
+ #
+-menuconfig RFKILL
++config RFKILL
++	bool
++	default y
++
++menuconfig RFKILL_FULL
+ 	tristate "RF switch subsystem support"
+ 	help
+ 	  Say Y here if you want to have control over RF switches
+@@ -13,19 +17,19 @@ menuconfig RFKILL
+ # LED trigger support
+ config RFKILL_LEDS
+ 	bool
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on LEDS_TRIGGERS = y || RFKILL = LEDS_TRIGGERS
+ 	default y
+ 
+ config RFKILL_INPUT
+ 	bool "RF switch input support" if EXPERT
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on INPUT = y || RFKILL = INPUT
+ 	default y if !EXPERT
+ 
+ config RFKILL_REGULATOR
+ 	tristate "Generic rfkill regulator driver"
+-	depends on RFKILL || !RFKILL
++	depends on RFKILL_FULL || !RFKILL_FULL
+ 	depends on REGULATOR
+ 	help
+           This options enable controlling radio transmitters connected to
+@@ -36,7 +40,7 @@ config RFKILL_REGULATOR
+ 
+ config RFKILL_GPIO
+ 	tristate "GPIO RFKILL driver"
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on GPIOLIB || COMPILE_TEST
+ 	default n
+ 	help
+--- a/net/rfkill/Makefile
++++ b/net/rfkill/Makefile
+@@ -4,6 +4,6 @@
+ 
+ rfkill-y			+= core.o
+ rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
+-obj-$(CONFIG_RFKILL)		+= rfkill.o
++obj-$(CONFIG_RFKILL_FULL)	+= rfkill.o
+ obj-$(CONFIG_RFKILL_REGULATOR)	+= rfkill-regulator.o
+ obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
+--- a/net/Makefile
++++ b/net/Makefile
+@@ -49,7 +49,7 @@ obj-$(CONFIG_MAC80211)		+= mac80211/
+ obj-$(CONFIG_TIPC)		+= tipc/
+ obj-$(CONFIG_NETLABEL)		+= netlabel/
+ obj-$(CONFIG_IUCV)		+= iucv/
+-obj-$(CONFIG_RFKILL)		+= rfkill/
++obj-$(CONFIG_RFKILL_FULL)	+= rfkill/
+ obj-$(CONFIG_NET_9P)		+= 9p/
+ obj-$(CONFIG_CAIF)		+= caif/
+ ifneq ($(CONFIG_DCB),)
+--- a/include/linux/rfkill.h
++++ b/include/linux/rfkill.h
+@@ -64,7 +64,7 @@ struct rfkill_ops {
+ 	int	(*set_block)(void *data, bool blocked);
+ };
+ 
+-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
++#if defined(CONFIG_RFKILL_FULL) || defined(CONFIG_RFKILL_FULL_MODULE)
+ /**
+  * rfkill_alloc - allocate rfkill structure
+  * @name: name of the struct -- the string is not copied internally
diff --git a/target/linux/generic/pending-4.4/300-mips_expose_boot_raw.patch b/target/linux/generic/pending-4.4/300-mips_expose_boot_raw.patch
new file mode 100644
index 0000000000..0980c26d50
--- /dev/null
+++ b/target/linux/generic/pending-4.4/300-mips_expose_boot_raw.patch
@@ -0,0 +1,39 @@
+From: Mark Miller <mark@mirell.org>
+
+This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
+certain Broadcom chipsets running CFE in order to load the kernel.
+
+Signed-off-by: Mark Miller <mark@mirell.org>
+Acked-by: Rob Landley <rob@landley.net>
+---
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1033,9 +1033,6 @@ config FW_ARC
+ config ARCH_MAY_HAVE_PC_FDC
+ 	bool
+ 
+-config BOOT_RAW
+-	bool
+-
+ config CEVT_BCM1480
+ 	bool
+ 
+@@ -2793,6 +2790,18 @@ choice
+ 		bool "Bootloader kernel arguments if available"
+ endchoice
+ 
++config BOOT_RAW
++	bool "Enable the kernel to be executed from the load address"
++	default n
++	help
++	 Allow the kernel to be executed from the load address for
++	 bootloaders which cannot read the ELF format. This places
++	 a jump to start_kernel at the load address.
++
++	 If unsure, say N.
++
++
++
+ endmenu
+ 
+ config LOCKDEP_SUPPORT
diff --git a/target/linux/generic/pending-4.4/301-mips_image_cmdline_hack.patch b/target/linux/generic/pending-4.4/301-mips_image_cmdline_hack.patch
new file mode 100644
index 0000000000..625a84c814
--- /dev/null
+++ b/target/linux/generic/pending-4.4/301-mips_image_cmdline_hack.patch
@@ -0,0 +1,28 @@
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1124,6 +1124,10 @@ config SYNC_R4K
+ config MIPS_MACHINE
+ 	def_bool n
+ 
++config IMAGE_CMDLINE_HACK
++	bool "OpenWrt specific image command line hack"
++	default n
++
+ config NO_IOPORT_MAP
+ 	def_bool n
+ 
+--- a/arch/mips/kernel/head.S
++++ b/arch/mips/kernel/head.S
+@@ -80,6 +80,12 @@ FEXPORT(__kernel_entry)
+ 	j	kernel_entry
+ #endif
+ 
++#ifdef CONFIG_IMAGE_CMDLINE_HACK
++	.ascii	"CMDLINE:"
++EXPORT(__image_cmdline)
++	.fill	0x400
++#endif /* CONFIG_IMAGE_CMDLINE_HACK */
++
+ 	__REF
+ 
+ NESTED(kernel_entry, 16, sp)			# kernel entry point
diff --git a/target/linux/generic/pending-4.4/302-mips_no_branch_likely.patch b/target/linux/generic/pending-4.4/302-mips_no_branch_likely.patch
new file mode 100644
index 0000000000..44c6b04fcf
--- /dev/null
+++ b/target/linux/generic/pending-4.4/302-mips_no_branch_likely.patch
@@ -0,0 +1,11 @@
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -87,7 +87,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ # machines may also.  Since BFD is incredibly buggy with respect to
+ # crossformat linking we rely on the elf2ecoff tool for format conversion.
+ #
+-cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
++cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
diff --git a/target/linux/generic/pending-4.4/304-mips_disable_fpu.patch b/target/linux/generic/pending-4.4/304-mips_disable_fpu.patch
new file mode 100644
index 0000000000..a08564dcea
--- /dev/null
+++ b/target/linux/generic/pending-4.4/304-mips_disable_fpu.patch
@@ -0,0 +1,106 @@
+From:   Manuel Lauss <manuel.lauss@gmail.com>
+Subject: [RFC PATCH v4 2/2] MIPS: make FPU emulator optional
+Date:   Mon,  7 Apr 2014 12:57:04 +0200
+Message-Id: <1396868224-252888-2-git-send-email-manuel.lauss@gmail.com>
+
+This small patch makes the MIPS FPU emulator optional. The kernel
+kills float-users on systems without a hardware FPU by sending a SIGILL.
+
+Disabling the emulator shrinks vmlinux by about 54kBytes (32bit,
+optimizing for size).
+
+Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
+---
+v4: rediffed because of patch 1/2, should now work with micromips as well
+v3: updated patch description with size savings.
+v2: incorporated changes suggested by Jonas Gorski
+    force the fpu emulator on for micromips: relocating the parts
+    of the mmips code in the emulator to other areas would be a
+    much larger change; I went the cheap route instead with this.
+
+ arch/mips/Kbuild                     |  2 +-
+ arch/mips/Kconfig                    | 14 ++++++++++++++
+ arch/mips/include/asm/fpu.h          |  5 +++--
+ arch/mips/include/asm/fpu_emulator.h | 15 +++++++++++++++
+ 4 files changed, 33 insertions(+), 3 deletions(-)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -2725,6 +2725,20 @@ config MIPS_O32_FP64_SUPPORT
+ 
+ 	  If unsure, say N.
+ 
++config MIPS_FPU_EMULATOR
++	bool "MIPS FPU Emulator"
++	default y
++	help
++	  This option lets you disable the built-in MIPS FPU (Coprocessor 1)
++	  emulator, which handles floating-point instructions on processors
++	  without a hardware FPU.  It is generally a good idea to keep the
++	  emulator built-in, unless you are perfectly sure you have a
++	  complete soft-float environment.  With the emulator disabled, all
++	  users of float operations will be killed with an illegal instr-
++	  uction exception.
++
++	  Say Y, please.
++
+ config USE_OF
+ 	bool
+ 	select OF
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -285,7 +285,7 @@ OBJCOPYFLAGS		+= --remove-section=.regin
+ head-y := arch/mips/kernel/head.o
+ 
+ libs-y			+= arch/mips/lib/
+-libs-y			+= arch/mips/math-emu/
++libs-$(CONFIG_MIPS_FPU_EMULATOR)	+= arch/mips/math-emu/
+ 
+ # See arch/mips/Kbuild for content of core part of the kernel
+ core-y += arch/mips/
+--- a/arch/mips/include/asm/fpu.h
++++ b/arch/mips/include/asm/fpu.h
+@@ -223,8 +223,10 @@ static inline int init_fpu(void)
+ 		/* Restore FRE */
+ 		write_c0_config5(config5);
+ 		enable_fpu_hazard();
+-	} else
++	} else if (IS_ENABLED(CONFIG_MIPS_FPU_EMULATOR))
+ 		fpu_emulator_init_fpu();
++	else
++		ret = SIGILL;
+ 
+ 	return ret;
+ }
+--- a/arch/mips/include/asm/fpu_emulator.h
++++ b/arch/mips/include/asm/fpu_emulator.h
+@@ -30,6 +30,7 @@
+ #include <asm/local.h>
+ #include <asm/processor.h>
+ 
++#ifdef CONFIG_MIPS_FPU_EMULATOR
+ #ifdef CONFIG_DEBUG_FS
+ 
+ struct mips_fpu_emulator_stats {
+@@ -66,6 +67,21 @@ extern int do_dsemulret(struct pt_regs *
+ extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
+ 				    struct mips_fpu_struct *ctx, int has_fpu,
+ 				    void *__user *fault_addr);
++#else	/* no CONFIG_MIPS_FPU_EMULATOR */
++static inline int do_dsemulret(struct pt_regs *xcp)
++{
++	return 0;	/* 0 means error, should never get here anyway */
++}
++
++static inline int fpu_emulator_cop1Handler(struct pt_regs *xcp,
++				struct mips_fpu_struct *ctx, int has_fpu,
++				void *__user *fault_addr)
++{
++	*fault_addr = NULL;
++	return SIGILL;	/* we don't speak MIPS FPU */
++}
++#endif	/* CONFIG_MIPS_FPU_EMULATOR */
++
+ int process_fpemu_return(int sig, void __user *fault_addr,
+ 			 unsigned long fcr31);
+ int mm_isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,
diff --git a/target/linux/generic/pending-4.4/305-mips_module_reloc.patch b/target/linux/generic/pending-4.4/305-mips_module_reloc.patch
new file mode 100644
index 0000000000..944921fff7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/305-mips_module_reloc.patch
@@ -0,0 +1,355 @@
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -90,8 +90,13 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
++ifdef CONFIG_64BIT
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
+ KBUILD_CFLAGS_MODULE		+= -mlong-calls
++else
++KBUILD_AFLAGS_MODULE		+= -mno-long-calls
++KBUILD_CFLAGS_MODULE		+= -mno-long-calls
++endif
+ 
+ ifndef CONFIG_FUNCTION_TRACER
+ KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
+--- a/arch/mips/include/asm/module.h
++++ b/arch/mips/include/asm/module.h
+@@ -11,6 +11,11 @@ struct mod_arch_specific {
+ 	const struct exception_table_entry *dbe_start;
+ 	const struct exception_table_entry *dbe_end;
+ 	struct mips_hi16 *r_mips_hi16_list;
++
++	void *phys_plt_tbl;
++	void *virt_plt_tbl;
++	unsigned int phys_plt_offset;
++	unsigned int virt_plt_offset;
+ };
+ 
+ typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
+--- a/arch/mips/kernel/module.c
++++ b/arch/mips/kernel/module.c
+@@ -43,14 +43,221 @@ struct mips_hi16 {
+ static LIST_HEAD(dbe_list);
+ static DEFINE_SPINLOCK(dbe_lock);
+ 
+-#ifdef MODULE_START
++/*
++ * Get the potential max trampolines size required of the init and
++ * non-init sections. Only used if we cannot find enough contiguous
++ * physically mapped memory to put the module into.
++ */
++static unsigned int
++get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
++             const char *secstrings, unsigned int symindex, bool is_init)
++{
++	unsigned long ret = 0;
++	unsigned int i, j;
++	Elf_Sym *syms;
++
++	/* Everything marked ALLOC (this includes the exported symbols) */
++	for (i = 1; i < hdr->e_shnum; ++i) {
++		unsigned int info = sechdrs[i].sh_info;
++
++		if (sechdrs[i].sh_type != SHT_REL
++		    && sechdrs[i].sh_type != SHT_RELA)
++			continue;
++
++		/* Not a valid relocation section? */
++		if (info >= hdr->e_shnum)
++			continue;
++
++		/* Don't bother with non-allocated sections */
++		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
++			continue;
++
++		/* If it's called *.init*, and we're not init, we're
++                   not interested */
++		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
++		    != is_init)
++			continue;
++
++		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
++		if (sechdrs[i].sh_type == SHT_REL) {
++			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rel[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		} else {
++			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rela[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		}
++	}
++
++	return ret;
++}
++
++#ifndef MODULE_START
++static void *alloc_phys(unsigned long size)
++{
++	unsigned order;
++	struct page *page;
++	struct page *p;
++
++	size = PAGE_ALIGN(size);
++	order = get_order(size);
++
++	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
++			__GFP_THISNODE, order);
++	if (!page)
++		return NULL;
++
++	split_page(page, order);
++
++	/* mark all pages except for the last one */
++	for (p = page; p + 1 < page + (size >> PAGE_SHIFT); ++p)
++		set_bit(PG_owner_priv_1, &p->flags);
++
++	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
++		__free_page(p);
++
++	return page_address(page);
++}
++#endif
++
++static void free_phys(void *ptr)
++{
++	struct page *page;
++	bool free;
++
++	page = virt_to_page(ptr);
++	do {
++		free = test_and_clear_bit(PG_owner_priv_1, &page->flags);
++		__free_page(page);
++		page++;
++	} while (free);
++}
++
++
+ void *module_alloc(unsigned long size)
+ {
++#ifdef MODULE_START
+ 	return __vmalloc_node_range(size, 1, MODULE_START, MODULE_END,
+ 				GFP_KERNEL, PAGE_KERNEL, 0, NUMA_NO_NODE,
+ 				__builtin_return_address(0));
++#else
++	void *ptr;
++
++	if (size == 0)
++		return NULL;
++
++	ptr = alloc_phys(size);
++
++	/* If we failed to allocate physically contiguous memory,
++	 * fall back to regular vmalloc. The module loader code will
++	 * create jump tables to handle long jumps */
++	if (!ptr)
++		return vmalloc(size);
++
++	return ptr;
++#endif
+ }
++
++static inline bool is_phys_addr(void *ptr)
++{
++#ifdef CONFIG_64BIT
++	return (KSEGX((unsigned long)ptr) == CKSEG0);
++#else
++	return (KSEGX(ptr) == KSEG0);
+ #endif
++}
++
++/* Free memory returned from module_alloc */
++void module_memfree(void *module_region)
++{
++	if (is_phys_addr(module_region))
++		free_phys(module_region);
++	else
++		vfree(module_region);
++}
++
++static void *__module_alloc(int size, bool phys)
++{
++	void *ptr;
++
++	if (phys)
++		ptr = kmalloc(size, GFP_KERNEL);
++	else
++		ptr = vmalloc(size);
++	return ptr;
++}
++
++static void __module_free(void *ptr)
++{
++	if (is_phys_addr(ptr))
++		kfree(ptr);
++	else
++		vfree(ptr);
++}
++
++int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
++			      char *secstrings, struct module *mod)
++{
++	unsigned int symindex = 0;
++	unsigned int core_size, init_size;
++	int i;
++
++	mod->arch.phys_plt_offset = 0;
++	mod->arch.virt_plt_offset = 0;
++	mod->arch.phys_plt_tbl = NULL;
++	mod->arch.virt_plt_tbl = NULL;
++
++	if (IS_ENABLED(CONFIG_64BIT))
++		return 0;
++
++	for (i = 1; i < hdr->e_shnum; i++)
++		if (sechdrs[i].sh_type == SHT_SYMTAB)
++			symindex = i;
++
++	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
++	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
++
++	if ((core_size + init_size) == 0)
++		return 0;
++
++	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
++	if (!mod->arch.phys_plt_tbl)
++		return -ENOMEM;
++
++	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
++	if (!mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++		return -ENOMEM;
++	}
++
++	return 0;
++}
+ 
+ int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
+ {
+@@ -64,8 +271,39 @@ static int apply_r_mips_32_rel(struct mo
+ 	return 0;
+ }
+ 
++static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
++				 void *start, Elf_Addr v)
++{
++	unsigned *tramp = start + *plt_offset;
++	*plt_offset += 4 * sizeof(int);
++
++	/* adjust carry for addiu */
++	if (v & 0x00008000)
++		v += 0x10000;
++
++	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
++	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
++	tramp[2] = 0x03200008;                  /* jr t9 */
++	tramp[3] = 0x00000000;                  /* nop */
++
++	return (Elf_Addr) tramp;
++}
++
++static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
++{
++	if (is_phys_addr(location))
++		return add_plt_entry_to(&me->arch.phys_plt_offset,
++				me->arch.phys_plt_tbl, v);
++	else
++		return add_plt_entry_to(&me->arch.virt_plt_offset,
++				me->arch.virt_plt_tbl, v);
++
++}
++
+ static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+ {
++	u32 ofs = *location & 0x03ffffff;
++
+ 	if (v % 4) {
+ 		pr_err("module %s: dangerous R_MIPS_26 REL relocation\n",
+ 		       me->name);
+@@ -73,14 +311,17 @@ static int apply_r_mips_26_rel(struct mo
+ 	}
+ 
+ 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+-		printk(KERN_ERR
+-		       "module %s: relocation overflow\n",
+-		       me->name);
+-		return -ENOEXEC;
++		v = add_plt_entry(me, location, v + (ofs << 2));
++		if (!v) {
++			printk(KERN_ERR
++				"module %s: relocation overflow\n", me->name);
++			return -ENOEXEC;
++		}
++		ofs = 0;
+ 	}
+ 
+ 	*location = (*location & ~0x03ffffff) |
+-		    ((*location + (v >> 2)) & 0x03ffffff);
++		    ((ofs + (v >> 2)) & 0x03ffffff);
+ 
+ 	return 0;
+ }
+@@ -287,9 +528,36 @@ int module_finalize(const Elf_Ehdr *hdr,
+ 		list_add(&me->arch.dbe_list, &dbe_list);
+ 		spin_unlock_irq(&dbe_lock);
+ 	}
++
++	/* Get rid of the fixup trampoline if we're running the module
++	 * from physically mapped address space */
++	if (me->arch.phys_plt_offset == 0) {
++		__module_free(me->arch.phys_plt_tbl);
++		me->arch.phys_plt_tbl = NULL;
++	}
++	if (me->arch.virt_plt_offset == 0) {
++		__module_free(me->arch.virt_plt_tbl);
++		me->arch.virt_plt_tbl = NULL;
++	}
++
+ 	return 0;
+ }
+ 
++void module_arch_freeing_init(struct module *mod)
++{
++	if (mod->state == MODULE_STATE_LIVE)
++		return;
++
++	if (mod->arch.phys_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++	}
++	if (mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.virt_plt_tbl);
++		mod->arch.virt_plt_tbl = NULL;
++	}
++}
++
+ void module_arch_cleanup(struct module *mod)
+ {
+ 	spin_lock_irq(&dbe_lock);
diff --git a/target/linux/generic/pending-4.4/306-mips_mem_functions_performance.patch b/target/linux/generic/pending-4.4/306-mips_mem_functions_performance.patch
new file mode 100644
index 0000000000..9818677425
--- /dev/null
+++ b/target/linux/generic/pending-4.4/306-mips_mem_functions_performance.patch
@@ -0,0 +1,83 @@
+--- a/arch/mips/include/asm/string.h
++++ b/arch/mips/include/asm/string.h
+@@ -133,11 +133,44 @@ strncmp(__const__ char *__cs, __const__
+ 
+ #define __HAVE_ARCH_MEMSET
+ extern void *memset(void *__s, int __c, size_t __count);
++#define memset(__s, __c, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memset((__s), (__c), __len);		\
++	else							\
++		__ret = __builtin_memset((__s), (__c), __len);	\
++	__ret;							\
++})
+ 
+ #define __HAVE_ARCH_MEMCPY
+ extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
++#define memcpy(dst, src, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memcpy((dst), (src), __len);		\
++	else							\
++		__ret = __builtin_memcpy((dst), (src), __len);	\
++	__ret;							\
++})
+ 
+ #define __HAVE_ARCH_MEMMOVE
+ extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
++#define memmove(dst, src, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memmove((dst), (src), __len);		\
++	else							\
++		__ret = __builtin_memmove((dst), (src), __len);	\
++	__ret;							\
++})
++
++#define __HAVE_ARCH_MEMCMP
++#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
+ 
+ #endif /* _ASM_STRING_H */
+--- a/arch/mips/lib/Makefile
++++ b/arch/mips/lib/Makefile
+@@ -4,7 +4,7 @@
+ 
+ lib-y	+= bitops.o csum_partial.o delay.o memcpy.o memset.o \
+ 	   mips-atomic.o strlen_user.o strncpy_user.o \
+-	   strnlen_user.o uncached.o
++	   strnlen_user.o uncached.o memcmp.o
+ 
+ obj-y			+= iomap.o
+ obj-$(CONFIG_PCI)	+= iomap-pci.o
+--- /dev/null
++++ b/arch/mips/lib/memcmp.c
+@@ -0,0 +1,22 @@
++/*
++ *  copied from linux/lib/string.c
++ *
++ *  Copyright (C) 1991, 1992  Linus Torvalds
++ */
++
++#include <linux/module.h>
++#include <linux/string.h>
++
++#undef memcmp
++int memcmp(const void *cs, const void *ct, size_t count)
++{
++	const unsigned char *su1, *su2;
++	int res = 0;
++
++	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
++		if ((res = *su1 - *su2) != 0)
++			break;
++	return res;
++}
++EXPORT_SYMBOL(memcmp);
++
diff --git a/target/linux/generic/pending-4.4/307-mips_highmem_offset.patch b/target/linux/generic/pending-4.4/307-mips_highmem_offset.patch
new file mode 100644
index 0000000000..5a7dc9cee9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/307-mips_highmem_offset.patch
@@ -0,0 +1,17 @@
+Adjust highmem offset to 0x10000000 to ensure that all kmalloc allocations
+stay within the same 256M boundary. This ensures that -mlong-calls is not
+needed on systems with more than 256M RAM.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/arch/mips/include/asm/mach-generic/spaces.h
++++ b/arch/mips/include/asm/mach-generic/spaces.h
+@@ -44,7 +44,7 @@
+  * Memory above this physical address will be considered highmem.
+  */
+ #ifndef HIGHMEM_START
+-#define HIGHMEM_START		_AC(0x20000000, UL)
++#define HIGHMEM_START		_AC(0x10000000, UL)
+ #endif
+ 
+ #endif /* CONFIG_32BIT */
diff --git a/target/linux/generic/pending-4.4/308-mips32r2_tune.patch b/target/linux/generic/pending-4.4/308-mips32r2_tune.patch
new file mode 100644
index 0000000000..f4ab89ef28
--- /dev/null
+++ b/target/linux/generic/pending-4.4/308-mips32r2_tune.patch
@@ -0,0 +1,17 @@
+Add -mtune=34kc to MIPS CFLAGS when building for mips32r2
+This provides a good tradeoff across at least 24Kc-74Kc, while also
+producing smaller code.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -145,7 +145,7 @@ cflags-$(CONFIG_CPU_R4X00)	+= -march=r46
+ cflags-$(CONFIG_CPU_TX49XX)	+= -march=r4600 -Wa,--trap
+ cflags-$(CONFIG_CPU_MIPS32_R1)	+= $(call cc-option,-march=mips32,-mips32 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
+ 			-Wa,-mips32 -Wa,--trap
+-cflags-$(CONFIG_CPU_MIPS32_R2)	+= $(call cc-option,-march=mips32r2,-mips32r2 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
++cflags-$(CONFIG_CPU_MIPS32_R2)	+= $(call cc-option,-march=mips32r2 -mtune=34kc,-mips32r2 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS32) \
+ 			-Wa,-mips32r2 -Wa,--trap
+ cflags-$(CONFIG_CPU_MIPS32_R6)	+= -march=mips32r6 -Wa,--trap
+ cflags-$(CONFIG_CPU_MIPS64_R1)	+= $(call cc-option,-march=mips64,-mips64 -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS64) \
diff --git a/target/linux/generic/pending-4.4/310-arm_module_unresolved_weak_sym.patch b/target/linux/generic/pending-4.4/310-arm_module_unresolved_weak_sym.patch
new file mode 100644
index 0000000000..327a475208
--- /dev/null
+++ b/target/linux/generic/pending-4.4/310-arm_module_unresolved_weak_sym.patch
@@ -0,0 +1,13 @@
+--- a/arch/arm/kernel/module.c
++++ b/arch/arm/kernel/module.c
+@@ -88,6 +88,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
+ 			return -ENOEXEC;
+ 		}
+ 
++		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
++		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
++			continue;
++
+ 		loc = dstsec->sh_addr + rel->r_offset;
+ 
+ 		switch (ELF32_R_TYPE(rel->r_info)) {
diff --git a/target/linux/generic/pending-4.4/320-ppc4xx_optimization.patch b/target/linux/generic/pending-4.4/320-ppc4xx_optimization.patch
new file mode 100644
index 0000000000..c1ce37da2f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/320-ppc4xx_optimization.patch
@@ -0,0 +1,31 @@
+Upstream doesn't optimize the kernel and bootwrappers for ppc44x because
+they still want to support gcc 3.3 -- well, we don't.
+
+--- a/arch/powerpc/Makefile
++++ b/arch/powerpc/Makefile
+@@ -205,7 +205,8 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
+ KBUILD_CFLAGS		+= -mno-sched-epilog
+ endif
+ 
+-cpu-as-$(CONFIG_4xx)		+= -Wa,-m405
++cpu-as-$(CONFIG_40x)		+= -Wa,-m405
++cpu-as-$(CONFIG_44x)		+= -Wa,-m440
+ cpu-as-$(CONFIG_ALTIVEC)	+= -Wa,-maltivec
+ cpu-as-$(CONFIG_E200)		+= -Wa,-me200
+ 
+--- a/arch/powerpc/boot/Makefile
++++ b/arch/powerpc/boot/Makefile
+@@ -48,10 +48,10 @@ BOOTCFLAGS	+= -I$(obj) -I$(srctree)/$(ob
+ DTC_FLAGS	?= -p 1024
+ 
+ $(obj)/4xx.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/ebony.o: BOOTCFLAGS += -mcpu=405
++$(obj)/ebony.o: BOOTCFLAGS += -mcpu=440
+ $(obj)/cuboot-hotfoot.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=405
++$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=440
++$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=440
+ $(obj)/cuboot-acadia.o: BOOTCFLAGS += -mcpu=405
+ $(obj)/treeboot-walnut.o: BOOTCFLAGS += -mcpu=405
+ $(obj)/treeboot-iss4xx.o: BOOTCFLAGS += -mcpu=405
diff --git a/target/linux/generic/pending-4.4/321-powerpc_crtsavres_prereq.patch b/target/linux/generic/pending-4.4/321-powerpc_crtsavres_prereq.patch
new file mode 100644
index 0000000000..a1773feb39
--- /dev/null
+++ b/target/linux/generic/pending-4.4/321-powerpc_crtsavres_prereq.patch
@@ -0,0 +1,10 @@
+--- a/arch/powerpc/Makefile
++++ b/arch/powerpc/Makefile
+@@ -167,7 +167,6 @@ CPP		= $(CC) -E $(KBUILD_CFLAGS)
+ 
+ CHECKFLAGS	+= -m$(CONFIG_WORD_SIZE) -D__powerpc__ -D__powerpc$(CONFIG_WORD_SIZE)__
+ 
+-KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
+ 
+ ifeq ($(CONFIG_476FPE_ERR46),y)
+ 	KBUILD_LDFLAGS_MODULE += --ppc476-workaround \
diff --git a/target/linux/generic/pending-4.4/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch b/target/linux/generic/pending-4.4/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
new file mode 100644
index 0000000000..a69d197e62
--- /dev/null
+++ b/target/linux/generic/pending-4.4/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
@@ -0,0 +1,298 @@
+From d8582dcf1ed66eee88a11e4760f42c0d6c8822be Mon Sep 17 00:00:00 2001
+From: Yousong Zhou <yszhou4tech@gmail.com>
+Date: Sat, 31 Jan 2015 22:26:03 +0800
+Subject: [PATCH 331/331] MIPS: kexec: Accept command line parameters from
+ userspace.
+
+Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
+---
+ arch/mips/kernel/machine_kexec.c   |  153 +++++++++++++++++++++++++++++++-----
+ arch/mips/kernel/machine_kexec.h   |   20 +++++
+ arch/mips/kernel/relocate_kernel.S |   21 +++--
+ 3 files changed, 167 insertions(+), 27 deletions(-)
+ create mode 100644 arch/mips/kernel/machine_kexec.h
+
+--- a/arch/mips/kernel/machine_kexec.c
++++ b/arch/mips/kernel/machine_kexec.c
+@@ -10,45 +10,145 @@
+ #include <linux/mm.h>
+ #include <linux/delay.h>
+ 
++#include <asm/bootinfo.h>
+ #include <asm/cacheflush.h>
+ #include <asm/page.h>
+-
+-extern const unsigned char relocate_new_kernel[];
+-extern const size_t relocate_new_kernel_size;
+-
+-extern unsigned long kexec_start_address;
+-extern unsigned long kexec_indirection_page;
++#include <asm/uaccess.h>
++#include "machine_kexec.h"
+ 
+ int (*_machine_kexec_prepare)(struct kimage *) = NULL;
+ void (*_machine_kexec_shutdown)(void) = NULL;
+ void (*_machine_crash_shutdown)(struct pt_regs *regs) = NULL;
++
+ #ifdef CONFIG_SMP
+ void (*relocated_kexec_smp_wait) (void *);
+ atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
+ #endif
+ 
+-int
+-machine_kexec_prepare(struct kimage *kimage)
++static void machine_kexec_print_args(void)
+ {
++	unsigned long argc = (int)kexec_args[0];
++	int i;
++
++	pr_info("kexec_args[0] (argc): %lu\n", argc);
++	pr_info("kexec_args[1] (argv): %p\n", (void *)kexec_args[1]);
++	pr_info("kexec_args[2] (env ): %p\n", (void *)kexec_args[2]);
++	pr_info("kexec_args[3] (desc): %p\n", (void *)kexec_args[3]);
++
++	for (i = 0; i < argc; i++) {
++		pr_info("kexec_argv[%d] = %p, %s\n",
++				i, kexec_argv[i], kexec_argv[i]);
++	}
++}
++
++static void machine_kexec_init_argv(struct kimage *image)
++{
++	void __user *buf = NULL;
++	size_t bufsz;
++	size_t size;
++	int i;
++
++	bufsz = 0;
++	for (i = 0; i < image->nr_segments; i++) {
++		struct kexec_segment *seg;
++
++		seg = &image->segment[i];
++		if (seg->bufsz < 6)
++			continue;
++
++		if (strncmp((char *) seg->buf, "kexec ", 6))
++			continue;
++
++		buf = seg->buf;
++		bufsz = seg->bufsz;
++		break;
++	}
++
++	if (!buf)
++		return;
++
++	size = KEXEC_COMMAND_LINE_SIZE;
++	size = min(size, bufsz);
++	if (size < bufsz)
++		pr_warn("kexec command line truncated to %zd bytes\n", size);
++
++	/* Copy to kernel space */
++	copy_from_user(kexec_argv_buf, buf, size);
++	kexec_argv_buf[size - 1] = 0;
++}
++
++static void machine_kexec_parse_argv(struct kimage *image)
++{
++	char *reboot_code_buffer;
++	int reloc_delta;
++	char *ptr;
++	int argc;
++	int i;
++
++	ptr = kexec_argv_buf;
++	argc = 0;
++
++	/*
++	 * convert command line string to array of parameters
++	 * (as bootloader does).
++	 */
++	while (ptr && *ptr && (KEXEC_MAX_ARGC > argc)) {
++		if (*ptr == ' ') {
++			*ptr++ = '\0';
++			continue;
++		}
++
++		kexec_argv[argc++] = ptr;
++		ptr = strchr(ptr, ' ');
++	}
++
++	if (!argc)
++		return;
++
++	kexec_args[0] = argc;
++	kexec_args[1] = (unsigned long)kexec_argv;
++	kexec_args[2] = 0;
++	kexec_args[3] = 0;
++
++	reboot_code_buffer = page_address(image->control_code_page);
++	reloc_delta = reboot_code_buffer - (char *)kexec_relocate_new_kernel;
++
++	kexec_args[1] += reloc_delta;
++	for (i = 0; i < argc; i++)
++		kexec_argv[i] += reloc_delta;
++}
++
++int machine_kexec_prepare(struct kimage *kimage)
++{
++	/*
++	 * Whenever arguments passed from kexec-tools, Init the arguments as
++	 * the original ones to try avoiding booting failure.
++	 */
++
++	kexec_args[0] = fw_arg0;
++	kexec_args[1] = fw_arg1;
++	kexec_args[2] = fw_arg2;
++	kexec_args[3] = fw_arg3;
++
++	machine_kexec_init_argv(kimage);
++	machine_kexec_parse_argv(kimage);
++
+ 	if (_machine_kexec_prepare)
+ 		return _machine_kexec_prepare(kimage);
+ 	return 0;
+ }
+ 
+-void
+-machine_kexec_cleanup(struct kimage *kimage)
++void machine_kexec_cleanup(struct kimage *kimage)
+ {
+ }
+ 
+-void
+-machine_shutdown(void)
++void machine_shutdown(void)
+ {
+ 	if (_machine_kexec_shutdown)
+ 		_machine_kexec_shutdown();
+ }
+ 
+-void
+-machine_crash_shutdown(struct pt_regs *regs)
++void machine_crash_shutdown(struct pt_regs *regs)
+ {
+ 	if (_machine_crash_shutdown)
+ 		_machine_crash_shutdown(regs);
+@@ -66,10 +166,12 @@ machine_kexec(struct kimage *image)
+ 	unsigned long *ptr;
+ 
+ 	reboot_code_buffer =
+-	  (unsigned long)page_address(image->control_code_page);
++		(unsigned long)page_address(image->control_code_page);
++	pr_info("reboot_code_buffer = %p\n", (void *)reboot_code_buffer);
+ 
+ 	kexec_start_address =
+ 		(unsigned long) phys_to_virt(image->start);
++	pr_info("kexec_start_address = %p\n", (void *)kexec_start_address);
+ 
+ 	if (image->type == KEXEC_TYPE_DEFAULT) {
+ 		kexec_indirection_page =
+@@ -77,9 +179,19 @@ machine_kexec(struct kimage *image)
+ 	} else {
+ 		kexec_indirection_page = (unsigned long)&image->head;
+ 	}
++	pr_info("kexec_indirection_page = %p\n", (void *)kexec_indirection_page);
+ 
+-	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
+-	       relocate_new_kernel_size);
++	pr_info("Where is memcpy: %p\n", memcpy);
++	pr_info("kexec_relocate_new_kernel = %p, kexec_relocate_new_kernel_end = %p\n",
++		(void *)kexec_relocate_new_kernel, &kexec_relocate_new_kernel_end);
++	pr_info("Copy %lu bytes from %p to %p\n", KEXEC_RELOCATE_NEW_KERNEL_SIZE,
++		(void *)kexec_relocate_new_kernel, (void *)reboot_code_buffer);
++	memcpy((void*)reboot_code_buffer, kexec_relocate_new_kernel,
++	       KEXEC_RELOCATE_NEW_KERNEL_SIZE);
++
++	pr_info("Before _print_args().\n");
++	machine_kexec_print_args();
++	pr_info("Before eval loop.\n");
+ 
+ 	/*
+ 	 * The generic kexec code builds a page list with physical
+@@ -98,15 +210,16 @@ machine_kexec(struct kimage *image)
+ 	/*
+ 	 * we do not want to be bothered.
+ 	 */
++	pr_info("Before irq_disable.\n");
+ 	local_irq_disable();
+ 
+-	printk("Will call new kernel at %08lx\n", image->start);
+-	printk("Bye ...\n");
++	pr_info("Will call new kernel at %08lx\n", image->start);
++	pr_info("Bye ...\n");
+ 	__flush_cache_all();
+ #ifdef CONFIG_SMP
+ 	/* All secondary cpus now may jump to kexec_wait cycle */
+ 	relocated_kexec_smp_wait = reboot_code_buffer +
+-		(void *)(kexec_smp_wait - relocate_new_kernel);
++		(void *)(kexec_smp_wait - kexec_relocate_new_kernel);
+ 	smp_wmb();
+ 	atomic_set(&kexec_ready_to_reboot, 1);
+ #endif
+--- /dev/null
++++ b/arch/mips/kernel/machine_kexec.h
+@@ -0,0 +1,20 @@
++#ifndef _MACHINE_KEXEC_H
++#define _MACHINE_KEXEC_H
++
++#ifndef __ASSEMBLY__
++extern const unsigned char kexec_relocate_new_kernel[];
++extern unsigned long kexec_relocate_new_kernel_end;
++extern unsigned long kexec_start_address;
++extern unsigned long kexec_indirection_page;
++
++extern char kexec_argv_buf[];
++extern char *kexec_argv[];
++
++#define KEXEC_RELOCATE_NEW_KERNEL_SIZE	((unsigned long)&kexec_relocate_new_kernel_end - (unsigned long)kexec_relocate_new_kernel)
++#endif /* !__ASSEMBLY__ */
++
++#define KEXEC_COMMAND_LINE_SIZE		256
++#define KEXEC_ARGV_SIZE			(KEXEC_COMMAND_LINE_SIZE / 16)
++#define KEXEC_MAX_ARGC			(KEXEC_ARGV_SIZE / sizeof(long))
++
++#endif
+--- a/arch/mips/kernel/relocate_kernel.S
++++ b/arch/mips/kernel/relocate_kernel.S
+@@ -12,8 +12,9 @@
+ #include <asm/mipsregs.h>
+ #include <asm/stackframe.h>
+ #include <asm/addrspace.h>
++#include "machine_kexec.h"
+ 
+-LEAF(relocate_new_kernel)
++LEAF(kexec_relocate_new_kernel)
+ 	PTR_L a0,	arg0
+ 	PTR_L a1,	arg1
+ 	PTR_L a2,	arg2
+@@ -98,7 +99,7 @@ done:
+ #endif
+ 	/* jump to kexec_start_address */
+ 	j		s1
+-	END(relocate_new_kernel)
++	END(kexec_relocate_new_kernel)
+ 
+ #ifdef CONFIG_SMP
+ /*
+@@ -184,9 +185,15 @@ kexec_indirection_page:
+ 	PTR		0
+ 	.size		kexec_indirection_page, PTRSIZE
+ 
+-relocate_new_kernel_end:
++kexec_argv_buf:
++	EXPORT(kexec_argv_buf)
++	.skip		KEXEC_COMMAND_LINE_SIZE
++	.size		kexec_argv_buf, KEXEC_COMMAND_LINE_SIZE
++
++kexec_argv:
++	EXPORT(kexec_argv)
++	.skip		KEXEC_ARGV_SIZE
++	.size		kexec_argv, KEXEC_ARGV_SIZE
+ 
+-relocate_new_kernel_size:
+-	EXPORT(relocate_new_kernel_size)
+-	PTR		relocate_new_kernel_end - relocate_new_kernel
+-	.size		relocate_new_kernel_size, PTRSIZE
++kexec_relocate_new_kernel_end:
++	EXPORT(kexec_relocate_new_kernel_end)
diff --git a/target/linux/generic/pending-4.4/331-arc-remove-dependency-on-DEVTMPFS.patch b/target/linux/generic/pending-4.4/331-arc-remove-dependency-on-DEVTMPFS.patch
new file mode 100644
index 0000000000..48b3f9b428
--- /dev/null
+++ b/target/linux/generic/pending-4.4/331-arc-remove-dependency-on-DEVTMPFS.patch
@@ -0,0 +1,31 @@
+From adfbf9e6cad93281cffceab078e7f6f2a8e094f9 Mon Sep 17 00:00:00 2001
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Date: Thu, 13 Aug 2015 01:56:02 +0300
+Subject: [PATCH 1/2] openwrt: arc - remove dependency on DEVTMPFS
+
+OpenWRT builds initramfs so that it doesn't require DEVTMPFS so dropping
+this dependency. That helps to escape 2 separate kernel rebuilds with
+and without initramfs.
+
+2 builds happen because OpenWRT first builds kernel and later modules.
+When building entire kernel with simple "make" INITRAMFS sets to a real
+value and so was triggering DEVTMPFS selection. Then when building only
+modules with "make modules" command INITRAMFS is zeroed and so kernel
+config was changing that lead to full kernel rebuild.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+---
+ arch/arc/Kconfig | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/arch/arc/Kconfig
++++ b/arch/arc/Kconfig
+@@ -12,8 +12,6 @@ config ARC
+ 	select BUILDTIME_EXTABLE_SORT
+ 	select COMMON_CLK
+ 	select CLONE_BACKWARDS
+-	# ARC Busybox based initramfs absolutely relies on DEVTMPFS for /dev
+-	select DEVTMPFS if !INITRAMFS_SOURCE=""
+ 	select GENERIC_ATOMIC64
+ 	select GENERIC_CLOCKEVENTS
+ 	select GENERIC_FIND_FIRST_BIT
diff --git a/target/linux/generic/pending-4.4/332-arc-add-OWRTDTB-section.patch b/target/linux/generic/pending-4.4/332-arc-add-OWRTDTB-section.patch
new file mode 100644
index 0000000000..5a2b67cfcd
--- /dev/null
+++ b/target/linux/generic/pending-4.4/332-arc-add-OWRTDTB-section.patch
@@ -0,0 +1,82 @@
+From 690e7f2cad271595ff68cace1c45fb10779bde41 Mon Sep 17 00:00:00 2001
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Date: Fri, 15 Jan 2016 00:34:01 +0300
+Subject: [PATCH 2/2] openwrt: arc - add OWRTDTB section
+
+This change allows OpenWRT to patch resulting kernel binary with
+external .dtb.
+
+That allows us to re-use exactky the same vmlinux on different boards
+given its ARC core configurations match (at least cache line sizes etc).
+
+""patch-dtb" searches for ASCII "OWRTDTB:" strign and copies external
+.dtb right after it, keeping the string in place.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+---
+ arch/arc/kernel/head.S        | 10 ++++++++++
+ arch/arc/kernel/setup.c       |  4 +++-
+ arch/arc/kernel/vmlinux.lds.S | 13 +++++++++++++
+ 3 files changed, 26 insertions(+), 1 deletion(-)
+
+--- a/arch/arc/kernel/head.S
++++ b/arch/arc/kernel/head.S
+@@ -49,6 +49,16 @@
+ 1:
+ .endm
+ 
++; Here "patch-dtb" will embed external .dtb
++; Note "patch-dtb" searches for ASCII "OWRTDTB:" string
++; and pastes .dtb right after it, hense the string precedes
++; __image_dtb symbol.
++	.section .owrt, "aw",@progbits
++	.ascii	"OWRTDTB:"
++ENTRY(__image_dtb)
++	.fill	0x4000
++END(__image_dtb)
++
+ 	.section .init.text, "ax",@progbits
+ 
+ ;----------------------------------------------------------------
+--- a/arch/arc/kernel/setup.c
++++ b/arch/arc/kernel/setup.c
+@@ -366,6 +366,8 @@ static inline int is_kernel(unsigned lon
+ 	return 0;
+ }
+ 
++extern struct boot_param_header __image_dtb;
++
+ void __init setup_arch(char **cmdline_p)
+ {
+ #ifdef CONFIG_ARC_UBOOT_SUPPORT
+@@ -379,7 +381,7 @@ void __init setup_arch(char **cmdline_p)
+ #endif
+ 	{
+ 		/* No, so try the embedded one */
+-		machine_desc = setup_machine_fdt(__dtb_start);
++		machine_desc = setup_machine_fdt(&__image_dtb);
+ 		if (!machine_desc)
+ 			panic("Embedded DT invalid\n");
+ 
+--- a/arch/arc/kernel/vmlinux.lds.S
++++ b/arch/arc/kernel/vmlinux.lds.S
+@@ -30,6 +30,19 @@ SECTIONS
+ 
+ 	. = CONFIG_LINUX_LINK_BASE;
+ 
++	/*
++	 * In OpenWRT we want to patch built binary embedding .dtb of choice.
++	 * This is implemented with "patch-dtb" utility which searches for
++	 * "OWRTDTB:" string in first 16k of image and if it is found
++	 * copies .dtb right after mentioned string.
++	 *
++	 * Note: "OWRTDTB:" won't be overwritten with .dtb, .dtb will follow it.
++	 */
++	.owrt : {
++		*(.owrt)
++		. = ALIGN(PAGE_SIZE);
++	}
++
+ 	_int_vec_base_lds = .;
+ 	.vector : {
+ 		*(.vector)
diff --git a/target/linux/generic/pending-4.4/333-arc-enable-unaligned-access-in-kernel-mode.patch b/target/linux/generic/pending-4.4/333-arc-enable-unaligned-access-in-kernel-mode.patch
new file mode 100644
index 0000000000..082f525f1b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/333-arc-enable-unaligned-access-in-kernel-mode.patch
@@ -0,0 +1,26 @@
+From af737b55fc7c61f17da9ae89fba536e0a9338e98 Mon Sep 17 00:00:00 2001
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Date: Mon, 14 Mar 2016 17:26:34 +0300
+Subject: [PATCH] arc: enable unaligned access in kernel mode
+
+This enables misaligned access handling even in kernel mode.
+Some wireless drivers (ath9k-htc and mt7601u) use misaligned accesses
+here and there and to cope with that without fixing stuff in the drivers
+we're just gracefully handling it on ARC.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+---
+ arch/arc/kernel/unaligned.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arc/kernel/unaligned.c
++++ b/arch/arc/kernel/unaligned.c
+@@ -206,7 +206,7 @@ int misaligned_fixup(unsigned long addre
+ 	char buf[TASK_COMM_LEN];
+ 
+ 	/* handle user mode only and only if enabled by sysadmin */
+-	if (!user_mode(regs) || !unaligned_enabled)
++	if (!unaligned_enabled)
+ 		return 1;
+ 
+ 	if (no_unaligned_warning) {
diff --git a/target/linux/generic/pending-4.4/400-mtd-add-rootfs-split-support.patch b/target/linux/generic/pending-4.4/400-mtd-add-rootfs-split-support.patch
new file mode 100644
index 0000000000..7925caf97c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/400-mtd-add-rootfs-split-support.patch
@@ -0,0 +1,113 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -12,6 +12,23 @@ menuconfig MTD
+ 
+ if MTD
+ 
++menu "OpenWrt specific MTD options"
++
++config MTD_ROOTFS_ROOT_DEV
++	bool "Automatically set 'rootfs' partition to be root filesystem"
++	default y
++
++config MTD_SPLIT_FIRMWARE
++	bool "Automatically split firmware partition for kernel+rootfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE_NAME
++	string "Firmware partition name"
++	depends on MTD_SPLIT_FIRMWARE
++	default "firmware"
++
++endmenu
++
+ config MTD_TESTS
+ 	tristate "MTD tests support (DANGEROUS)"
+ 	depends on m
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -29,11 +29,13 @@
+ #include <linux/kmod.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/magic.h>
+ #include <linux/of.h>
+ #include <linux/err.h>
+ #include <linux/kconfig.h>
+ 
+ #include "mtdcore.h"
++#include "mtdsplit/mtdsplit.h"
+ 
+ /* Our partition linked list */
+ static LIST_HEAD(mtd_partitions);
+@@ -47,6 +49,8 @@ struct mtd_part {
+ 	struct list_head list;
+ };
+ 
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
++
+ /*
+  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
+  * the pointer to that structure with this macro.
+@@ -612,6 +616,7 @@ int mtd_add_partition(struct mtd_info *m
+ 	mutex_unlock(&mtd_partitions_mutex);
+ 
+ 	add_mtd_device(&new->mtd);
++	mtd_partition_split(master, new);
+ 
+ 	mtd_add_partition_attrs(new);
+ 
+@@ -644,6 +649,35 @@ int mtd_del_partition(struct mtd_info *m
+ }
+ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
++#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#else
++#define SPLIT_FIRMWARE_NAME	"unused"
++#endif
++
++static void split_firmware(struct mtd_info *master, struct mtd_part *part)
++{
++}
++
++void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
++                                int offset, int size)
++{
++}
++
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
++{
++	static int rootfs_found = 0;
++
++	if (rootfs_found)
++		return;
++
++	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
++	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
++		split_firmware(master, part);
++
++	arch_split_mtd_part(master, part->mtd.name, part->offset,
++			    part->mtd.size);
++}
+ /*
+  * This function, given a master MTD object and a partition table, creates
+  * and registers slave MTD objects which are bound to the master according to
+@@ -675,6 +709,7 @@ int add_mtd_partitions(struct mtd_info *
+ 		mutex_unlock(&mtd_partitions_mutex);
+ 
+ 		add_mtd_device(&slave->mtd);
++		mtd_partition_split(master, slave);
+ 		mtd_add_partition_attrs(slave);
+ 
+ 		cur_offset = slave->offset + slave->mtd.size;
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -84,5 +84,7 @@ int mtd_add_partition(struct mtd_info *m
+ 		      long long offset, long long length);
+ int mtd_del_partition(struct mtd_info *master, int partno);
+ uint64_t mtd_get_device_size(const struct mtd_info *mtd);
++extern void __weak arch_split_mtd_part(struct mtd_info *master,
++				       const char *name, int offset, int size);
+ 
+ #endif
diff --git a/target/linux/generic/pending-4.4/401-mtd-add-support-for-different-partition-parser-types.patch b/target/linux/generic/pending-4.4/401-mtd-add-support-for-different-partition-parser-types.patch
new file mode 100644
index 0000000000..7695d56de9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/401-mtd-add-support-for-different-partition-parser-types.patch
@@ -0,0 +1,113 @@
+From 02cff0ccaa6d364f5c1eeea83f47ac80ccc967d4 Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <juhosg@openwrt.org>
+Date: Tue, 3 Sep 2013 18:11:50 +0200
+Subject: [PATCH] mtd: add support for different partition parser types
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ drivers/mtd/mtdpart.c          |   56 ++++++++++++++++++++++++++++++++++++++++
+ include/linux/mtd/partitions.h |   11 ++++++++
+ 2 files changed, 67 insertions(+)
+
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -740,6 +740,30 @@ static struct mtd_part_parser *get_parti
+ 
+ #define put_partition_parser(p) do { module_put((p)->owner); } while (0)
+ 
++static struct mtd_part_parser *
++get_partition_parser_by_type(enum mtd_parser_type type,
++			     struct mtd_part_parser *start)
++{
++	struct mtd_part_parser *p, *ret = NULL;
++
++	spin_lock(&part_parser_lock);
++
++	p = list_prepare_entry(start, &part_parsers, list);
++	if (start)
++		put_partition_parser(start);
++
++	list_for_each_entry_continue(p, &part_parsers, list) {
++		if (p->type == type && try_module_get(p->owner)) {
++			ret = p;
++			break;
++		}
++	}
++
++	spin_unlock(&part_parser_lock);
++
++	return ret;
++}
++
+ void register_mtd_parser(struct mtd_part_parser *p)
+ {
+ 	spin_lock(&part_parser_lock);
+@@ -868,6 +892,38 @@ int parse_mtd_partitions(struct mtd_info
+ 	return err;
+ }
+ 
++int parse_mtd_partitions_by_type(struct mtd_info *master,
++				 enum mtd_parser_type type,
++				 struct mtd_partition **pparts,
++				 struct mtd_part_parser_data *data)
++{
++	struct mtd_part_parser *prev = NULL;
++	int ret = 0;
++
++	while (1) {
++		struct mtd_part_parser *parser;
++
++		parser = get_partition_parser_by_type(type, prev);
++		if (!parser)
++			break;
++
++		ret = (*parser->parse_fn)(master, pparts, data);
++
++		if (ret > 0) {
++			put_partition_parser(parser);
++			printk(KERN_NOTICE
++			       "%d %s partitions found on MTD device %s\n",
++			       ret, parser->name, master->name);
++			break;
++		}
++
++		prev = parser;
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(parse_mtd_partitions_by_type);
++
+ int mtd_is_partition(const struct mtd_info *mtd)
+ {
+ 	struct mtd_part *part;
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -68,12 +68,17 @@ struct mtd_part_parser_data {
+  * Functions dealing with the various ways of partitioning the space
+  */
+ 
++enum mtd_parser_type {
++	MTD_PARSER_TYPE_DEVICE = 0,
++};
++
+ struct mtd_part_parser {
+ 	struct list_head list;
+ 	struct module *owner;
+ 	const char *name;
+ 	int (*parse_fn)(struct mtd_info *, struct mtd_partition **,
+ 			struct mtd_part_parser_data *);
++	enum mtd_parser_type type;
+ };
+ 
+ extern void register_mtd_parser(struct mtd_part_parser *parser);
+@@ -87,4 +92,9 @@ uint64_t mtd_get_device_size(const struc
+ extern void __weak arch_split_mtd_part(struct mtd_info *master,
+ 				       const char *name, int offset, int size);
+ 
++int parse_mtd_partitions_by_type(struct mtd_info *master,
++				 enum mtd_parser_type type,
++				 struct mtd_partition **pparts,
++				 struct mtd_part_parser_data *data);
++
+ #endif
diff --git a/target/linux/generic/pending-4.4/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch b/target/linux/generic/pending-4.4/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch
new file mode 100644
index 0000000000..2ea2056ba2
--- /dev/null
+++ b/target/linux/generic/pending-4.4/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch
@@ -0,0 +1,71 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -649,6 +649,36 @@ int mtd_del_partition(struct mtd_info *m
+ }
+ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
++static int
++run_parsers_by_type(struct mtd_part *slave, enum mtd_parser_type type)
++{
++	struct mtd_partition *parts;
++	int nr_parts;
++	int i;
++
++	nr_parts = parse_mtd_partitions_by_type(&slave->mtd, type, &parts,
++						NULL);
++	if (nr_parts <= 0)
++		return nr_parts;
++
++	if (WARN_ON(!parts))
++		return 0;
++
++	for (i = 0; i < nr_parts; i++) {
++		/* adjust partition offsets */
++		parts[i].offset += slave->offset;
++
++		mtd_add_partition(slave->master,
++				  parts[i].name,
++				  parts[i].offset,
++				  parts[i].size);
++	}
++
++	kfree(parts);
++
++	return nr_parts;
++}
++
+ #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
+ #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
+ #else
+@@ -657,6 +687,7 @@ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
+ static void split_firmware(struct mtd_info *master, struct mtd_part *part)
+ {
++	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
+ }
+ 
+ void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
+@@ -671,6 +702,12 @@ static void mtd_partition_split(struct m
+ 	if (rootfs_found)
+ 		return;
+ 
++	if (!strcmp(part->mtd.name, "rootfs")) {
++		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
++
++		rootfs_found = 1;
++	}
++
+ 	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
+ 	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
+ 		split_firmware(master, part);
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -70,6 +70,8 @@ struct mtd_part_parser_data {
+ 
+ enum mtd_parser_type {
+ 	MTD_PARSER_TYPE_DEVICE = 0,
++	MTD_PARSER_TYPE_ROOTFS,
++	MTD_PARSER_TYPE_FIRMWARE,
+ };
+ 
+ struct mtd_part_parser {
diff --git a/target/linux/generic/pending-4.4/403-mtd-hook-mtdsplit-to-Kbuild.patch b/target/linux/generic/pending-4.4/403-mtd-hook-mtdsplit-to-Kbuild.patch
new file mode 100644
index 0000000000..0cf1c38555
--- /dev/null
+++ b/target/linux/generic/pending-4.4/403-mtd-hook-mtdsplit-to-Kbuild.patch
@@ -0,0 +1,22 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -27,6 +27,8 @@ config MTD_SPLIT_FIRMWARE_NAME
+ 	depends on MTD_SPLIT_FIRMWARE
+ 	default "firmware"
+ 
++source "drivers/mtd/mtdsplit/Kconfig"
++
+ endmenu
+ 
+ config MTD_TESTS
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -6,6 +6,8 @@
+ obj-$(CONFIG_MTD)		+= mtd.o
+ mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
+ 
++obj-$(CONFIG_MTD_SPLIT)		+= mtdsplit/
++
+ obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
+ obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
diff --git a/target/linux/generic/pending-4.4/404-mtd-add-more-helper-functions.patch b/target/linux/generic/pending-4.4/404-mtd-add-more-helper-functions.patch
new file mode 100644
index 0000000000..3773e1f195
--- /dev/null
+++ b/target/linux/generic/pending-4.4/404-mtd-add-more-helper-functions.patch
@@ -0,0 +1,101 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -454,14 +454,12 @@ static struct mtd_part *allocate_partiti
+ 	if (slave->offset == MTDPART_OFS_APPEND)
+ 		slave->offset = cur_offset;
+ 	if (slave->offset == MTDPART_OFS_NXTBLK) {
+-		slave->offset = cur_offset;
+-		if (mtd_mod_by_eb(cur_offset, master) != 0) {
+-			/* Round up to next erasesize */
+-			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
++		/* Round up to next erasesize */
++		slave->offset = mtd_roundup_to_eb(cur_offset, master);
++		if (slave->offset != cur_offset)
+ 			printk(KERN_NOTICE "Moving partition %d: "
+ 			       "0x%012llx -> 0x%012llx\n", partno,
+ 			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
+-		}
+ 	}
+ 	if (slave->offset == MTDPART_OFS_RETAIN) {
+ 		slave->offset = cur_offset;
+@@ -679,6 +677,17 @@ run_parsers_by_type(struct mtd_part *sla
+ 	return nr_parts;
+ }
+ 
++static inline unsigned long
++mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
++{
++	unsigned long mask = mtd->erasesize - 1;
++
++	len += offset & mask;
++	len = (len + mask) & ~mask;
++	len -= offset & mask;
++	return len;
++}
++
+ #ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
+ #define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
+ #else
+@@ -978,6 +987,24 @@ int mtd_is_partition(const struct mtd_in
+ }
+ EXPORT_SYMBOL_GPL(mtd_is_partition);
+ 
++struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd)
++{
++	if (!mtd_is_partition(mtd))
++		return (struct mtd_info *)mtd;
++
++	return PART(mtd)->master;
++}
++EXPORT_SYMBOL_GPL(mtdpart_get_master);
++
++uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
++{
++	if (!mtd_is_partition(mtd))
++		return 0;
++
++	return PART(mtd)->offset;
++}
++EXPORT_SYMBOL_GPL(mtdpart_get_offset);
++
+ /* Returns the size of the entire flash chip */
+ uint64_t mtd_get_device_size(const struct mtd_info *mtd)
+ {
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -90,6 +90,8 @@ int mtd_is_partition(const struct mtd_in
+ int mtd_add_partition(struct mtd_info *master, const char *name,
+ 		      long long offset, long long length);
+ int mtd_del_partition(struct mtd_info *master, int partno);
++struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd);
++uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
+ uint64_t mtd_get_device_size(const struct mtd_info *mtd);
+ extern void __weak arch_split_mtd_part(struct mtd_info *master,
+ 				       const char *name, int offset, int size);
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -334,6 +334,24 @@ static inline uint32_t mtd_mod_by_eb(uin
+ 	return do_div(sz, mtd->erasesize);
+ }
+ 
++static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round up to next erase block */
++	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
++}
++
++static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round down to the start of the current erase block */
++	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
++}
++
+ static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
+ {
+ 	if (mtd->writesize_shift)
diff --git a/target/linux/generic/pending-4.4/410-mtd-move-forward-declaration-of-struct-mtd_info.patch b/target/linux/generic/pending-4.4/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
new file mode 100644
index 0000000000..78ebbf88ca
--- /dev/null
+++ b/target/linux/generic/pending-4.4/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
@@ -0,0 +1,18 @@
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -35,6 +35,7 @@
+  * Note: writeable partitions require their size and offset be
+  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
+  */
++struct mtd_info;
+ 
+ struct mtd_partition {
+ 	const char *name;		/* identifier string */
+@@ -50,7 +51,6 @@ struct mtd_partition {
+ #define MTDPART_SIZ_FULL	(0)
+ 
+ 
+-struct mtd_info;
+ struct device_node;
+ 
+ /**
diff --git a/target/linux/generic/pending-4.4/411-mtd-partial_eraseblock_write.patch b/target/linux/generic/pending-4.4/411-mtd-partial_eraseblock_write.patch
new file mode 100644
index 0000000000..7ab8eb3442
--- /dev/null
+++ b/target/linux/generic/pending-4.4/411-mtd-partial_eraseblock_write.patch
@@ -0,0 +1,142 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -37,6 +37,8 @@
+ #include "mtdcore.h"
+ #include "mtdsplit/mtdsplit.h"
+ 
++#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
++
+ /* Our partition linked list */
+ static LIST_HEAD(mtd_partitions);
+ static DEFINE_MUTEX(mtd_partitions_mutex);
+@@ -236,13 +238,61 @@ static int part_erase(struct mtd_info *m
+ 	struct mtd_part *part = PART(mtd);
+ 	int ret;
+ 
++
++	instr->partial_start = false;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		size_t readlen = 0;
++		u64 mtd_ofs;
++
++		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
++		if (!instr->erase_buf)
++			return -ENOMEM;
++
++		mtd_ofs = part->offset + instr->addr;
++		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
++
++		if (instr->erase_buf_ofs > 0) {
++			instr->addr -= instr->erase_buf_ofs;
++			ret = mtd_read(part->master,
++				instr->addr + part->offset,
++				part->master->erasesize,
++				&readlen, instr->erase_buf);
++
++			instr->len += instr->erase_buf_ofs;
++			instr->partial_start = true;
++		} else {
++			mtd_ofs = part->offset + part->mtd.size;
++			instr->erase_buf_ofs = part->master->erasesize -
++				do_div(mtd_ofs, part->master->erasesize);
++
++			if (instr->erase_buf_ofs > 0) {
++				instr->len += instr->erase_buf_ofs;
++				ret = mtd_read(part->master,
++					part->offset + instr->addr +
++					instr->len - part->master->erasesize,
++					part->master->erasesize, &readlen,
++					instr->erase_buf);
++			} else {
++				ret = 0;
++			}
++		}
++		if (ret < 0) {
++			kfree(instr->erase_buf);
++			return ret;
++		}
++
++	}
++
+ 	instr->addr += part->offset;
+ 	ret = part->master->_erase(part->master, instr);
+ 	if (ret) {
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
++		if (mtd->flags & MTD_ERASE_PARTIAL)
++			kfree(instr->erase_buf);
+ 	}
++
+ 	return ret;
+ }
+ 
+@@ -250,7 +300,25 @@ void mtd_erase_callback(struct erase_inf
+ {
+ 	if (instr->mtd->_erase == part_erase) {
+ 		struct mtd_part *part = PART(instr->mtd);
++		size_t wrlen = 0;
+ 
++		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
++			if (instr->partial_start) {
++				part->master->_write(part->master,
++					instr->addr, instr->erase_buf_ofs,
++					&wrlen, instr->erase_buf);
++				instr->addr += instr->erase_buf_ofs;
++			} else {
++				instr->len -= instr->erase_buf_ofs;
++				part->master->_write(part->master,
++					instr->addr + instr->len,
++					instr->erase_buf_ofs, &wrlen,
++					instr->erase_buf +
++					part->master->erasesize -
++					instr->erase_buf_ofs);
++			}
++			kfree(instr->erase_buf);
++		}
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
+@@ -523,17 +591,20 @@ static struct mtd_part *allocate_partiti
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+ 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
+ 		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
+-			part->name);
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++		if (((u32) slave->mtd.size) > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+-	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
+-			part->name);
++	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++
++		if ((u32) slave->mtd.size > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
+ 
+ 	slave->mtd.ecclayout = master->ecclayout;
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -55,6 +55,10 @@ struct erase_info {
+ 	u_long priv;
+ 	u_char state;
+ 	struct erase_info *next;
++
++	u8 *erase_buf;
++	u32 erase_buf_ofs;
++	bool partial_start;
+ };
+ 
+ struct mtd_erase_region_info {
diff --git a/target/linux/generic/pending-4.4/412-mtd-partial_eraseblock_unlock.patch b/target/linux/generic/pending-4.4/412-mtd-partial_eraseblock_unlock.patch
new file mode 100644
index 0000000000..990c2aba6e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/412-mtd-partial_eraseblock_unlock.patch
@@ -0,0 +1,18 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -337,7 +337,14 @@ static int part_lock(struct mtd_info *mt
+ static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+ {
+ 	struct mtd_part *part = PART(mtd);
+-	return part->master->_unlock(part->master, ofs + part->offset, len);
++
++	ofs += part->offset;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		/* round up len to next erasesize and round down offset to prev block */
++		len = (mtd_div_by_eb(len, part->master) + 1) * part->master->erasesize;
++		ofs &= ~(part->master->erasesize - 1);
++	}
++	return part->master->_unlock(part->master, ofs, len);
+ }
+ 
+ static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
diff --git a/target/linux/generic/pending-4.4/420-mtd-redboot_space.patch b/target/linux/generic/pending-4.4/420-mtd-redboot_space.patch
new file mode 100644
index 0000000000..f74affcef7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/420-mtd-redboot_space.patch
@@ -0,0 +1,30 @@
+--- a/drivers/mtd/redboot.c
++++ b/drivers/mtd/redboot.c
+@@ -265,14 +265,21 @@ static int parse_redboot_partitions(stru
+ #endif
+ 		names += strlen(names)+1;
+ 
+-#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+ 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
+-			i++;
+-			parts[i].offset = parts[i-1].size + parts[i-1].offset;
+-			parts[i].size = fl->next->img->flash_base - parts[i].offset;
+-			parts[i].name = nullname;
+-		}
++			if (!strcmp(parts[i].name, "rootfs")) {
++				parts[i].size = fl->next->img->flash_base;
++				parts[i].size &= ~(master->erasesize - 1);
++				parts[i].size -= parts[i].offset;
++#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
++				nrparts--;
++			} else {
++				i++;
++				parts[i].offset = parts[i-1].size + parts[i-1].offset;
++				parts[i].size = fl->next->img->flash_base - parts[i].offset;
++				parts[i].name = nullname;
+ #endif
++			}
++		}
+ 		tmp_fl = fl;
+ 		fl = fl->next;
+ 		kfree(tmp_fl);
diff --git a/target/linux/generic/pending-4.4/430-mtd-add-myloader-partition-parser.patch b/target/linux/generic/pending-4.4/430-mtd-add-myloader-partition-parser.patch
new file mode 100644
index 0000000000..a022564e9e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/430-mtd-add-myloader-partition-parser.patch
@@ -0,0 +1,35 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -174,6 +174,22 @@ config MTD_BCM47XX_PARTS
+ 	  This provides partitions parser for devices based on BCM47xx
+ 	  boards.
+ 
++config MTD_MYLOADER_PARTS
++	tristate "MyLoader partition parsing"
++	depends on ADM5120 || ATH25 || ATH79
++	---help---
++	  MyLoader is a bootloader which allows the user to define partitions
++	  in flash devices, by putting a table in the second erase block
++	  on the device, similar to a partition table. This table gives the 
++	  offsets and lengths of the user defined partitions.
++
++	  If you need code which can detect and parse these tables, and
++	  register MTD 'partitions' corresponding to each image detected,
++	  enable this option.
++
++	  You will still need the parsing functions to be called by the driver
++	  for your particular device. It won't happen automatically.
++
+ comment "User Modules And Translation Layers"
+ 
+ #
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -15,6 +15,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
+ obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
+ obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
+ obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
++obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
+ 
+ # 'Users' - code which presents functionality to userspace.
+ obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
diff --git a/target/linux/generic/pending-4.4/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch b/target/linux/generic/pending-4.4/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
new file mode 100644
index 0000000000..379e551b7f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
@@ -0,0 +1,91 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Sat, 2 Jan 2016 01:04:52 +0100
+Subject: [PATCH] mtd: bcm47xxpart: check for bad blocks when calculating
+ offsets
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+---
+ drivers/mtd/bcm47xxpart.c | 50 +++++++++++++++++++++++++++++++++++++----------
+ 1 file changed, 40 insertions(+), 10 deletions(-)
+
+--- a/drivers/mtd/bcm47xxpart.c
++++ b/drivers/mtd/bcm47xxpart.c
+@@ -62,6 +62,34 @@ static void bcm47xxpart_add_part(struct
+ 	part->mask_flags = mask_flags;
+ }
+ 
++/*
++ * Calculate real end offset (address) for a given amount of data. It checks
++ * all blocks skipping bad ones.
++ */
++static size_t bcm47xxpart_real_offset(struct mtd_info *master, size_t offset,
++				      size_t bytes)
++{
++	size_t real_offset = offset;
++
++	if (mtd_block_isbad(master, real_offset))
++		pr_warn("Base offset shouldn't be at bad block");
++
++	while (bytes >= master->erasesize) {
++		bytes -= master->erasesize;
++		real_offset += master->erasesize;
++		while (mtd_block_isbad(master, real_offset)) {
++			real_offset += master->erasesize;
++
++			if (real_offset >= master->size)
++				return real_offset - master->erasesize;
++		}
++	}
++
++	real_offset += bytes;
++
++	return real_offset;
++}
++
+ static const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,
+ 						  size_t offset)
+ {
+@@ -91,6 +119,7 @@ static int bcm47xxpart_parse_trx(struct
+ {
+ 	struct trx_header header;
+ 	size_t bytes_read;
++	size_t offset;
+ 	int curr_part = 0;
+ 	int i, err;
+ 
+@@ -110,21 +139,25 @@ static int bcm47xxpart_parse_trx(struct
+ 
+ 	/* We have LZMA loader if offset[2] points to sth */
+ 	if (header.offset[2]) {
+-		bcm47xxpart_add_part(&parts[curr_part++], "loader",
+-				     trx->offset + header.offset[i], 0);
++		offset = bcm47xxpart_real_offset(master, trx->offset,
++						 header.offset[i]);
++		bcm47xxpart_add_part(&parts[curr_part++], "loader", offset, 0);
+ 		i++;
+ 	}
+ 
+ 	if (header.offset[i]) {
+-		bcm47xxpart_add_part(&parts[curr_part++], "linux",
+-				     trx->offset + header.offset[i], 0);
++		offset = bcm47xxpart_real_offset(master, trx->offset,
++						 header.offset[i]);
++		bcm47xxpart_add_part(&parts[curr_part++], "linux", offset, 0);
+ 		i++;
+ 	}
+ 
+ 	if (header.offset[i]) {
+-		size_t offset = trx->offset + header.offset[i];
+-		const char *name = bcm47xxpart_trx_data_part_name(master,
+-								  offset);
++		const char *name;
++
++		offset = bcm47xxpart_real_offset(master, trx->offset,
++						 header.offset[i]);
++		name = bcm47xxpart_trx_data_part_name(master, offset);
+ 
+ 		bcm47xxpart_add_part(&parts[curr_part++], name, offset, 0);
+ 		i++;
diff --git a/target/linux/generic/pending-4.4/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch b/target/linux/generic/pending-4.4/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
new file mode 100644
index 0000000000..a19e943efe
--- /dev/null
+++ b/target/linux/generic/pending-4.4/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
@@ -0,0 +1,42 @@
+From fd54aa583296f9adfb1f519affbc10ba521eb809 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Date: Wed, 28 Jan 2015 22:14:41 +0100
+Subject: [PATCH] mtd: bcm47xxpart: detect T_Meter partition
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It can be found on many Netgear devices. It consists of many 0x30 blocks
+starting with 4D 54.
+
+Signed-off-by: Rafa Miecki <zajec5@gmail.com>
+---
+ drivers/mtd/bcm47xxpart.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/bcm47xxpart.c
++++ b/drivers/mtd/bcm47xxpart.c
+@@ -39,6 +39,7 @@
+ #define NVRAM_HEADER			0x48534C46	/* FLSH */
+ #define POT_MAGIC1			0x54544f50	/* POTT */
+ #define POT_MAGIC2			0x504f		/* OP */
++#define T_METER_MAGIC			0x4D540000	/* MT */
+ #define ML_MAGIC1			0x39685a42
+ #define ML_MAGIC2			0x26594131
+ #define TRX_MAGIC			0x30524448
+@@ -297,6 +298,15 @@ static int bcm47xxpart_parse(struct mtd_
+ 					     MTD_WRITEABLE);
+ 			continue;
+ 		}
++
++		/* T_Meter */
++		if ((le32_to_cpu(buf[0x000 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
++		    (le32_to_cpu(buf[0x030 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
++		    (le32_to_cpu(buf[0x060 / 4]) & 0xFFFF0000) == T_METER_MAGIC) {
++			bcm47xxpart_add_part(&parts[curr_part++], "T_Meter", offset,
++					     MTD_WRITEABLE);
++			continue;
++		}
+ 
+ 		/* TRX */
+ 		if (buf[0x000 / 4] == TRX_MAGIC) {
diff --git a/target/linux/generic/pending-4.4/440-block2mtd_init.patch b/target/linux/generic/pending-4.4/440-block2mtd_init.patch
new file mode 100644
index 0000000000..f2e62b4401
--- /dev/null
+++ b/target/linux/generic/pending-4.4/440-block2mtd_init.patch
@@ -0,0 +1,108 @@
+--- a/drivers/mtd/devices/block2mtd.c
++++ b/drivers/mtd/devices/block2mtd.c
+@@ -26,6 +26,7 @@
+ #include <linux/list.h>
+ #include <linux/init.h>
+ #include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
+ #include <linux/mutex.h>
+ #include <linux/mount.h>
+ #include <linux/slab.h>
+@@ -219,7 +220,7 @@ static void block2mtd_free_device(struct
+ 
+ 
+ static struct block2mtd_dev *add_device(char *devname, int erase_size,
+-		int timeout)
++		const char *mtdname, int timeout)
+ {
+ #ifndef MODULE
+ 	int i;
+@@ -227,6 +228,7 @@ static struct block2mtd_dev *add_device(
+ 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
+ 	struct block_device *bdev = ERR_PTR(-ENODEV);
+ 	struct block2mtd_dev *dev;
++	struct mtd_partition *part;
+ 	char *name;
+ 
+ 	if (!devname)
+@@ -283,13 +285,16 @@ static struct block2mtd_dev *add_device(
+ 
+ 	/* Setup the MTD structure */
+ 	/* make the name contain the block device in */
+-	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
++	if (!mtdname)
++		mtdname = devname;
++	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
+ 	if (!name)
+ 		goto err_destroy_mutex;
+ 
++	strcpy(name, mtdname);
+ 	dev->mtd.name = name;
+ 
+-	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
++	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
+ 	dev->mtd.erasesize = erase_size;
+ 	dev->mtd.writesize = 1;
+ 	dev->mtd.writebufsize = PAGE_SIZE;
+@@ -302,7 +307,11 @@ static struct block2mtd_dev *add_device(
+ 	dev->mtd.priv = dev;
+ 	dev->mtd.owner = THIS_MODULE;
+ 
+-	if (mtd_device_register(&dev->mtd, NULL, 0)) {
++	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
++	part->name = name;
++	part->offset = 0;
++	part->size = dev->mtd.size;
++	if (mtd_device_register(&dev->mtd, part, 1)) {
+ 		/* Device didn't get added, so free the entry */
+ 		goto err_destroy_mutex;
+ 	}
+@@ -310,8 +319,7 @@ static struct block2mtd_dev *add_device(
+ 	list_add(&dev->list, &blkmtd_device_list);
+ 	pr_info("mtd%d: [%s] erase_size = %dKiB [%d]\n",
+ 		dev->mtd.index,
+-		dev->mtd.name + strlen("block2mtd: "),
+-		dev->mtd.erasesize >> 10, dev->mtd.erasesize);
++		mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+ 	return dev;
+ 
+ err_destroy_mutex:
+@@ -384,7 +392,7 @@ static int block2mtd_setup2(const char *
+ 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
+ 	char buf[80 + 12 + 80 + 8];
+ 	char *str = buf;
+-	char *token[2];
++	char *token[3];
+ 	char *name;
+ 	size_t erase_size = PAGE_SIZE;
+ 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
+@@ -398,7 +406,7 @@ static int block2mtd_setup2(const char *
+ 	strcpy(str, val);
+ 	kill_final_newline(str);
+ 
+-	for (i = 0; i < 2; i++)
++	for (i = 0; i < 3; i++)
+ 		token[i] = strsep(&str, ",");
+ 
+ 	if (str) {
+@@ -424,8 +432,10 @@ static int block2mtd_setup2(const char *
+ 			return 0;
+ 		}
+ 	}
++	if (token[2] && (strlen(token[2]) + 1 > 80))
++		pr_err("mtd device name too long\n");
+ 
+-	add_device(name, erase_size, timeout);
++	add_device(name, erase_size, token[2], timeout);
+ 
+ 	return 0;
+ }
+@@ -459,7 +469,7 @@ static int block2mtd_setup(const char *v
+ 
+ 
+ module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
+-MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
++MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
+ 
+ static int __init block2mtd_init(void)
+ {
diff --git a/target/linux/generic/pending-4.4/441-block2mtd_probe.patch b/target/linux/generic/pending-4.4/441-block2mtd_probe.patch
new file mode 100644
index 0000000000..ed14537a6c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/441-block2mtd_probe.patch
@@ -0,0 +1,39 @@
+--- a/drivers/mtd/devices/block2mtd.c
++++ b/drivers/mtd/devices/block2mtd.c
+@@ -392,7 +392,7 @@ static int block2mtd_setup2(const char *
+ 	/* 80 for device, 12 for erase size, 80 for name, 8 for timeout */
+ 	char buf[80 + 12 + 80 + 8];
+ 	char *str = buf;
+-	char *token[3];
++	char *token[4];
+ 	char *name;
+ 	size_t erase_size = PAGE_SIZE;
+ 	unsigned long timeout = MTD_DEFAULT_TIMEOUT;
+@@ -406,7 +406,7 @@ static int block2mtd_setup2(const char *
+ 	strcpy(str, val);
+ 	kill_final_newline(str);
+ 
+-	for (i = 0; i < 3; i++)
++	for (i = 0; i < 4; i++)
+ 		token[i] = strsep(&str, ",");
+ 
+ 	if (str) {
+@@ -435,6 +435,9 @@ static int block2mtd_setup2(const char *
+ 	if (token[2] && (strlen(token[2]) + 1 > 80))
+ 		pr_err("mtd device name too long\n");
+ 
++	if (token[3] && kstrtoul(token[3], 0, &timeout))
++		pr_err("invalid timeout\n");
++
+ 	add_device(name, erase_size, token[2], timeout);
+ 
+ 	return 0;
+@@ -469,7 +472,7 @@ static int block2mtd_setup(const char *v
+ 
+ 
+ module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
+-MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
++MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>[,<timeout>]]]\"");
+ 
+ static int __init block2mtd_init(void)
+ {
diff --git a/target/linux/generic/pending-4.4/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch b/target/linux/generic/pending-4.4/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch
new file mode 100644
index 0000000000..b1072047c3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch
@@ -0,0 +1,37 @@
+---
+ drivers/mtd/nand/plat_nand.c |   13 ++++++++++++-
+ include/linux/mtd/nand.h     |    1 +
+ 2 files changed, 13 insertions(+), 1 deletion(-)
+
+--- a/include/linux/mtd/nand.h
++++ b/include/linux/mtd/nand.h
+@@ -864,6 +864,7 @@ struct platform_nand_chip {
+ 	unsigned int options;
+ 	unsigned int bbt_options;
+ 	const char **part_probe_types;
++	int (*chip_fixup)(struct mtd_info *mtd);
+ };
+ 
+ /* Keep gcc happy */
+--- a/drivers/mtd/nand/plat_nand.c
++++ b/drivers/mtd/nand/plat_nand.c
+@@ -87,7 +87,18 @@ static int plat_nand_probe(struct platfo
+ 	}
+ 
+ 	/* Scan to find existence of the device */
+-	if (nand_scan(&data->mtd, pdata->chip.nr_chips)) {
++	if (nand_scan_ident(&data->mtd, pdata->chip.nr_chips, NULL)) {
++		err = -ENXIO;
++		goto out;
++	}
++
++	if (pdata->chip.chip_fixup) {
++		err = pdata->chip.chip_fixup(&data->mtd);
++		if (err)
++			goto out;
++	}
++
++	if (nand_scan_tail(&data->mtd)) {
+ 		err = -ENXIO;
+ 		goto out;
+ 	}
diff --git a/target/linux/generic/pending-4.4/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch b/target/linux/generic/pending-4.4/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch
new file mode 100644
index 0000000000..6a2092ce20
--- /dev/null
+++ b/target/linux/generic/pending-4.4/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/nand/nand_ecc.c
++++ b/drivers/mtd/nand/nand_ecc.c
+@@ -507,7 +507,7 @@ int __nand_correct_data(unsigned char *b
+ 		return 1;	/* error in ECC data; no action needed */
+ 
+ 	pr_err("%s: uncorrectable ECC error\n", __func__);
+-	return -1;
++	return -EBADMSG;
+ }
+ EXPORT_SYMBOL(__nand_correct_data);
+ 
diff --git a/target/linux/generic/pending-4.4/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch b/target/linux/generic/pending-4.4/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
new file mode 100644
index 0000000000..68fbd12466
--- /dev/null
+++ b/target/linux/generic/pending-4.4/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -809,7 +809,7 @@ static int get_chip(struct map_info *map
+ 		return 0;
+ 
+ 	case FL_ERASING:
+-		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
++		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
+ 		    !(mode == FL_READY || mode == FL_POINT ||
+ 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
+ 			goto sleep;
diff --git a/target/linux/generic/pending-4.4/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch b/target/linux/generic/pending-4.4/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
new file mode 100644
index 0000000000..c437a140f0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
@@ -0,0 +1,18 @@
+From: George Kashperko <george@znau.edu.ua>
+
+Issue map read after Write Buffer Load command to ensure chip is ready
+to receive data.
+Signed-off-by: George Kashperko <george@znau.edu.ua>
+---
+ drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
+ 1 file changed, 1 insertion(+)
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -1830,6 +1830,7 @@ static int __xipram do_write_buffer(stru
+ 
+ 	/* Write Buffer Load */
+ 	map_write(map, CMD(0x25), cmd_adr);
++	(void) map_read(map, cmd_adr);
+ 
+ 	chip->state = FL_WRITING_TO_BUFFER;
+ 
diff --git a/target/linux/generic/pending-4.4/465-m25p80-mx-disable-software-protection.patch b/target/linux/generic/pending-4.4/465-m25p80-mx-disable-software-protection.patch
new file mode 100644
index 0000000000..e81ebbb3fa
--- /dev/null
+++ b/target/linux/generic/pending-4.4/465-m25p80-mx-disable-software-protection.patch
@@ -0,0 +1,14 @@
+Disable software protection bits for Macronix flashes.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -1166,6 +1166,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 
+ 	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
+ 	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
++	    JEDEC_MFR(info) == SNOR_MFR_MACRONIX ||
+ 	    JEDEC_MFR(info) == SNOR_MFR_SST ||
+ 	    info->flags & SPI_NOR_HAS_LOCK) {
+ 		write_enable(nor);
diff --git a/target/linux/generic/pending-4.4/475-mtd-spi-nor-add-macronix-mx25u25635f.patch b/target/linux/generic/pending-4.4/475-mtd-spi-nor-add-macronix-mx25u25635f.patch
new file mode 100644
index 0000000000..d868a7da25
--- /dev/null
+++ b/target/linux/generic/pending-4.4/475-mtd-spi-nor-add-macronix-mx25u25635f.patch
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -725,6 +725,7 @@ static const struct flash_info spi_nor_i
+ 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
++	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, 0) },
+ 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
+ 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_QUAD_READ) },
+ 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
diff --git a/target/linux/generic/pending-4.4/476-mtd-spi-nor-add-eon-en25q128.patch b/target/linux/generic/pending-4.4/476-mtd-spi-nor-add-eon-en25q128.patch
new file mode 100644
index 0000000000..ab805b71d0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/476-mtd-spi-nor-add-eon-en25q128.patch
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -683,6 +683,7 @@ static const struct flash_info spi_nor_i
+ 	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
+ 	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
+ 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
++	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
+ 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
+ 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
+ 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
diff --git a/target/linux/generic/pending-4.4/477-mtd-add-spi-nor-add-mx25u3235f.patch b/target/linux/generic/pending-4.4/477-mtd-add-spi-nor-add-mx25u3235f.patch
new file mode 100644
index 0000000000..c2a28a099d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/477-mtd-add-spi-nor-add-mx25u3235f.patch
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -722,6 +722,7 @@ static const struct flash_info spi_nor_i
+ 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
++	{ "mx25u3235f",	 INFO(0xc22536, 0, 64 * 1024, 64, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
diff --git a/target/linux/generic/pending-4.4/479-enable_mtd_has_lock_for_f25l32pa.patch b/target/linux/generic/pending-4.4/479-enable_mtd_has_lock_for_f25l32pa.patch
new file mode 100644
index 0000000000..ec67056c65
--- /dev/null
+++ b/target/linux/generic/pending-4.4/479-enable_mtd_has_lock_for_f25l32pa.patch
@@ -0,0 +1,22 @@
+mtd: spi-nor: Add lock/unlock support for f25l32pa
+
+This chip has write protection enabled on power-up,
+so this flag is necessary to support write operations.
+
+Signed-off-by: Victor Shyba <victor1984@riseup.net>
+Acked-by: Marek Vasut <marek.vasut@gmail.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -689,7 +689,7 @@ static const struct flash_info spi_nor_i
+ 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
+ 
+ 	/* ESMT */
+-	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K) },
++	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K | SPI_NOR_HAS_LOCK) },
+ 	{ "f25l32qa", INFO(0x8c4116, 0, 64 * 1024, 64, SECT_4K) },
+ 	{ "f25l64qa", INFO(0x8c4117, 0, 64 * 1024, 128, SECT_4K) },
+ 
diff --git a/target/linux/generic/pending-4.4/480-mtd-set-rootfs-to-be-root-dev.patch b/target/linux/generic/pending-4.4/480-mtd-set-rootfs-to-be-root-dev.patch
new file mode 100644
index 0000000000..d20bd8d4ec
--- /dev/null
+++ b/target/linux/generic/pending-4.4/480-mtd-set-rootfs-to-be-root-dev.patch
@@ -0,0 +1,26 @@
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -39,6 +39,7 @@
+ #include <linux/slab.h>
+ #include <linux/reboot.h>
+ #include <linux/kconfig.h>
++#include <linux/root_dev.h>
+ 
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
+@@ -464,6 +465,15 @@ int add_mtd_device(struct mtd_info *mtd)
+ 	   of this try_ nonsense, and no bitching about it
+ 	   either. :) */
+ 	__module_get(THIS_MODULE);
++
++	if (!strcmp(mtd->name, "rootfs") &&
++	    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    ROOT_DEV == 0) {
++		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
++			  mtd->index, mtd->name);
++		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
++	}
++
+ 	return 0;
+ 
+ fail_added:
diff --git a/target/linux/generic/pending-4.4/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch b/target/linux/generic/pending-4.4/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
new file mode 100644
index 0000000000..b15066f757
--- /dev/null
+++ b/target/linux/generic/pending-4.4/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
@@ -0,0 +1,76 @@
+From 8a52e4100d7c3a4a1dfddfa02b8864a9b0068c13 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 17 May 2014 03:36:18 +0200
+Subject: [PATCH 1/5] ubi: auto-attach mtd device named "ubi" or "data" on boot
+To: openwrt-devel@lists.openwrt.org
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/build.c | 36 ++++++++++++++++++++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+
+--- a/drivers/mtd/ubi/build.c
++++ b/drivers/mtd/ubi/build.c
+@@ -1203,6 +1203,49 @@ static struct mtd_info * __init open_mtd
+ 	return mtd;
+ }
+ 
++/*
++ * This function tries attaching mtd partitions named either "ubi" or "data"
++ * during boot.
++ */
++static void __init ubi_auto_attach(void)
++{
++	int err;
++	struct mtd_info *mtd;
++
++	/* try attaching mtd device named "ubi" or "data" */
++	mtd = open_mtd_device("ubi");
++	if (IS_ERR(mtd))
++		mtd = open_mtd_device("data");
++
++	if (!IS_ERR(mtd)) {
++		size_t len;
++		char magic[4];
++
++		/* check for a valid ubi magic */
++		err = mtd_read(mtd, 0, 4, &len, (void *) magic);
++		if (!err && len == 4 && strncmp(magic, "UBI#", 4)) {
++			pr_err("UBI error: no valid UBI magic found inside mtd%d\n", mtd->index);
++			put_mtd_device(mtd);
++			return;
++		}
++
++		/* auto-add only media types where UBI makes sense */
++		if (mtd->type == MTD_NANDFLASH ||
++		    mtd->type == MTD_NORFLASH ||
++		    mtd->type == MTD_DATAFLASH ||
++		    mtd->type == MTD_MLCNANDFLASH) {
++			mutex_lock(&ubi_devices_mutex);
++			pr_notice("UBI: auto-attach mtd%d\n", mtd->index);
++			err = ubi_attach_mtd_dev(mtd, UBI_DEV_NUM_AUTO, 0, 0);
++			mutex_unlock(&ubi_devices_mutex);
++			if (err < 0) {
++				pr_err("UBI error: cannot attach mtd%d\n", mtd->index);
++				put_mtd_device(mtd);
++			}
++		}
++	}
++}
++
+ static int __init ubi_init(void)
+ {
+ 	int err, i, k;
+@@ -1286,6 +1329,12 @@ static int __init ubi_init(void)
+ 		}
+ 	}
+ 
++	/* auto-attach mtd devices only if built-in to the kernel and no ubi.mtd
++	 * parameter was given */
++	if (config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    !ubi_is_module() && !mtd_devs)
++		ubi_auto_attach();
++
+ 	err = ubiblock_init();
+ 	if (err) {
+ 		pr_err("UBI error: block: cannot initialize, error %d", err);
diff --git a/target/linux/generic/pending-4.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch b/target/linux/generic/pending-4.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
new file mode 100644
index 0000000000..462f7f42cb
--- /dev/null
+++ b/target/linux/generic/pending-4.4/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
@@ -0,0 +1,69 @@
+From 0f3966579815f889bb2fcb4846152c35f65e79c4 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 15 May 2014 21:06:33 +0200
+Subject: [PATCH 2/5] ubi: auto-create ubiblock device for rootfs
+To: openwrt-devel@lists.openwrt.org
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/block.c | 42 ++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 42 insertions(+)
+
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -636,6 +636,44 @@ static void __init ubiblock_create_from_
+ 	}
+ }
+ 
++#define UBIFS_NODE_MAGIC  0x06101831
++static inline int ubi_vol_is_ubifs(struct ubi_volume_desc *desc)
++{
++	int ret;
++	uint32_t magic_of, magic;
++	ret = ubi_read(desc, 0, (char *)&magic_of, 0, 4);
++	if (ret)
++		return 0;
++	magic = le32_to_cpu(magic_of);
++	return magic == UBIFS_NODE_MAGIC;
++}
++
++static void __init ubiblock_create_auto_rootfs(void)
++{
++	int ubi_num, ret, is_ubifs;
++	struct ubi_volume_desc *desc;
++	struct ubi_volume_info vi;
++
++	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
++		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
++		if (IS_ERR(desc))
++			continue;
++
++		ubi_get_volume_info(desc, &vi);
++		is_ubifs = ubi_vol_is_ubifs(desc);
++		ubi_close_volume(desc);
++		if (is_ubifs)
++			break;
++
++		ret = ubiblock_create(&vi);
++		if (ret)
++			pr_err("UBI error: block: can't add '%s' volume, err=%d\n",
++				vi.name, ret);
++		/* always break if we get here */
++		break;
++	}
++}
++
+ static void ubiblock_remove_all(void)
+ {
+ 	struct ubiblock *next;
+@@ -668,6 +706,10 @@ int __init ubiblock_init(void)
+ 	 */
+ 	ubiblock_create_from_param();
+ 
++	/* auto-attach "rootfs" volume if existing and non-ubifs */
++	if (config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV))
++		ubiblock_create_auto_rootfs();
++
+ 	/*
+ 	 * Block devices are only created upon user requests, so we ignore
+ 	 * existing volumes.
diff --git a/target/linux/generic/pending-4.4/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch b/target/linux/generic/pending-4.4/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
new file mode 100644
index 0000000000..ab8b8bb0a2
--- /dev/null
+++ b/target/linux/generic/pending-4.4/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
@@ -0,0 +1,54 @@
+From eea9e1785e4c05c2a3444506aabafa0ae958538f Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 17 May 2014 03:35:02 +0200
+Subject: [PATCH 4/5] try auto-mounting ubi0:rootfs in init/do_mounts.c
+To: openwrt-devel@lists.openwrt.org
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ init/do_mounts.c | 26 +++++++++++++++++++++++++-
+ 1 file changed, 25 insertions(+), 1 deletion(-)
+
+--- a/init/do_mounts.c
++++ b/init/do_mounts.c
+@@ -438,7 +438,28 @@ retry:
+ out:
+ 	put_page(page);
+ }
+- 
++
++static int __init mount_ubi_rootfs(void)
++{
++	int flags = MS_SILENT;
++	int err, tried = 0;
++
++	while (tried < 2) {
++		err = do_mount_root("ubi0:rootfs", "ubifs", flags, \
++					root_mount_data);
++		switch (err) {
++			case -EACCES:
++				flags |= MS_RDONLY;
++				tried++;
++				break;
++			default:
++				return err;
++		}
++	}
++
++	return -EINVAL;
++}
++
+ #ifdef CONFIG_ROOT_NFS
+ 
+ #define NFSROOT_TIMEOUT_MIN	5
+@@ -532,6 +553,10 @@ void __init mount_root(void)
+ 			change_floppy("root floppy");
+ 	}
+ #endif
++#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
++	if (!mount_ubi_rootfs())
++		return;
++#endif
+ #ifdef CONFIG_BLOCK
+ 	{
+ 		int err = create_dev("/dev/root", ROOT_DEV);
diff --git a/target/linux/generic/pending-4.4/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch b/target/linux/generic/pending-4.4/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
new file mode 100644
index 0000000000..9fbfc79927
--- /dev/null
+++ b/target/linux/generic/pending-4.4/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
@@ -0,0 +1,37 @@
+From cd68d1b12b5ea4c01a664c064179ada42bf55d3d Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 15 May 2014 20:55:42 +0200
+Subject: [PATCH 5/5] ubi: set ROOT_DEV to ubiblock "rootfs" if unset
+To: openwrt-devel@lists.openwrt.org
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/block.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -50,6 +50,7 @@
+ #include <linux/scatterlist.h>
+ #include <linux/idr.h>
+ #include <asm/div64.h>
++#include <linux/root_dev.h>
+ 
+ #include "ubi-media.h"
+ #include "ubi.h"
+@@ -447,6 +448,15 @@ int ubiblock_create(struct ubi_volume_in
+ 	add_disk(dev->gd);
+ 	dev_info(disk_to_dev(dev->gd), "created from ubi%d:%d(%s)",
+ 		 dev->ubi_num, dev->vol_id, vi->name);
++
++	if (!strcmp(vi->name, "rootfs") &&
++	    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    ROOT_DEV == 0) {
++		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
++			  dev->ubi_num, dev->vol_id, vi->name);
++		ROOT_DEV = MKDEV(gd->major, gd->first_minor);
++	}
++
+ 	mutex_unlock(&devices_mutex);
+ 	return 0;
+ 
diff --git a/target/linux/generic/pending-4.4/494-mtd-ubi-add-EOF-marker-support.patch b/target/linux/generic/pending-4.4/494-mtd-ubi-add-EOF-marker-support.patch
new file mode 100644
index 0000000000..749232a396
--- /dev/null
+++ b/target/linux/generic/pending-4.4/494-mtd-ubi-add-EOF-marker-support.patch
@@ -0,0 +1,51 @@
+--- a/drivers/mtd/ubi/attach.c
++++ b/drivers/mtd/ubi/attach.c
+@@ -803,6 +803,13 @@ out_unlock:
+ 	return err;
+ }
+ 
++static bool ec_hdr_has_eof(struct ubi_ec_hdr *ech)
++{
++	return ech->padding1[0] == 'E' &&
++	       ech->padding1[1] == 'O' &&
++	       ech->padding1[2] == 'F';
++}
++
+ /**
+  * scan_peb - scan and process UBI headers of a PEB.
+  * @ubi: UBI device description object
+@@ -833,9 +840,21 @@ static int scan_peb(struct ubi_device *u
+ 		return 0;
+ 	}
+ 
+-	err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
+-	if (err < 0)
+-		return err;
++	if (!ai->eof_found) {
++		err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
++		if (err < 0)
++			return err;
++
++		if (ec_hdr_has_eof(ech)) {
++			pr_notice("UBI: EOF marker found, PEBs from %d will be erased\n",
++				pnum);
++			ai->eof_found = true;
++		}
++	}
++
++	if (ai->eof_found)
++		err = UBI_IO_FF_BITFLIPS;
++
+ 	switch (err) {
+ 	case 0:
+ 		break;
+--- a/drivers/mtd/ubi/ubi.h
++++ b/drivers/mtd/ubi/ubi.h
+@@ -741,6 +741,7 @@ struct ubi_attach_info {
+ 	int mean_ec;
+ 	uint64_t ec_sum;
+ 	int ec_count;
++	bool eof_found;
+ 	struct kmem_cache *aeb_slab_cache;
+ };
+ 
diff --git a/target/linux/generic/pending-4.4/530-jffs2_make_lzma_available.patch b/target/linux/generic/pending-4.4/530-jffs2_make_lzma_available.patch
new file mode 100644
index 0000000000..b75dd0f9ff
--- /dev/null
+++ b/target/linux/generic/pending-4.4/530-jffs2_make_lzma_available.patch
@@ -0,0 +1,5142 @@
+--- a/fs/jffs2/Kconfig
++++ b/fs/jffs2/Kconfig
+@@ -139,6 +139,15 @@ config JFFS2_LZO
+ 	  This feature was added in July, 2007. Say 'N' if you need
+ 	  compatibility with older bootloaders or kernels.
+ 
++config JFFS2_LZMA
++	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
++	select LZMA_COMPRESS
++	select LZMA_DECOMPRESS
++	depends on JFFS2_FS
++	default n
++	help
++	  JFFS2 wrapper to the LZMA C SDK
++
+ config JFFS2_RTIME
+ 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
+ 	depends on JFFS2_FS
+--- a/fs/jffs2/Makefile
++++ b/fs/jffs2/Makefile
+@@ -18,4 +18,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
+ jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
+ jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
+ jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
++jffs2-$(CONFIG_JFFS2_LZMA)      += compr_lzma.o
+ jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
++
++CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
+--- a/fs/jffs2/compr.c
++++ b/fs/jffs2/compr.c
+@@ -378,6 +378,9 @@ int __init jffs2_compressors_init(void)
+ #ifdef CONFIG_JFFS2_LZO
+ 	jffs2_lzo_init();
+ #endif
++#ifdef CONFIG_JFFS2_LZMA
++        jffs2_lzma_init();
++#endif
+ /* Setting default compression mode */
+ #ifdef CONFIG_JFFS2_CMODE_NONE
+ 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
+@@ -401,6 +404,9 @@ int __init jffs2_compressors_init(void)
+ int jffs2_compressors_exit(void)
+ {
+ /* Unregistering compressors */
++#ifdef CONFIG_JFFS2_LZMA
++        jffs2_lzma_exit();
++#endif
+ #ifdef CONFIG_JFFS2_LZO
+ 	jffs2_lzo_exit();
+ #endif
+--- a/fs/jffs2/compr.h
++++ b/fs/jffs2/compr.h
+@@ -29,9 +29,9 @@
+ #define JFFS2_DYNRUBIN_PRIORITY  20
+ #define JFFS2_LZARI_PRIORITY     30
+ #define JFFS2_RTIME_PRIORITY     50
+-#define JFFS2_ZLIB_PRIORITY      60
+-#define JFFS2_LZO_PRIORITY       80
+-
++#define JFFS2_LZMA_PRIORITY      70
++#define JFFS2_ZLIB_PRIORITY      80
++#define JFFS2_LZO_PRIORITY       90
+ 
+ #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
+ #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
+@@ -101,5 +101,9 @@ void jffs2_zlib_exit(void);
+ int jffs2_lzo_init(void);
+ void jffs2_lzo_exit(void);
+ #endif
++#ifdef CONFIG_JFFS2_LZMA
++int jffs2_lzma_init(void);
++void jffs2_lzma_exit(void);
++#endif
+ 
+ #endif /* __JFFS2_COMPR_H__ */
+--- /dev/null
++++ b/fs/jffs2/compr_lzma.c
+@@ -0,0 +1,128 @@
++/*
++ * JFFS2 -- Journalling Flash File System, Version 2.
++ *
++ * For licensing information, see the file 'LICENCE' in this directory.
++ *
++ * JFFS2 wrapper to the LZMA C SDK
++ *
++ */
++
++#include <linux/lzma.h>
++#include "compr.h"
++
++#ifdef __KERNEL__
++	static DEFINE_MUTEX(deflate_mutex);
++#endif
++
++CLzmaEncHandle *p;
++Byte propsEncoded[LZMA_PROPS_SIZE];
++SizeT propsSize = sizeof(propsEncoded);
++
++STATIC void lzma_free_workspace(void)
++{
++	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
++}
++
++STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
++{
++	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
++	{
++		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
++		return -ENOMEM;
++	}
++
++	if (LzmaEnc_SetProps(p, props) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++	
++	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++
++        return 0;
++}
++
++STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
++			      uint32_t *sourcelen, uint32_t *dstlen)
++{
++	SizeT compress_size = (SizeT)(*dstlen);
++	int ret;
++
++	#ifdef __KERNEL__
++		mutex_lock(&deflate_mutex);
++	#endif
++
++	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
++		0, NULL, &lzma_alloc, &lzma_alloc);
++
++	#ifdef __KERNEL__
++		mutex_unlock(&deflate_mutex);
++	#endif
++
++	if (ret != SZ_OK)
++		return -1;
++
++	*dstlen = (uint32_t)compress_size;
++
++	return 0;
++}
++
++STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
++				 uint32_t srclen, uint32_t destlen)
++{
++	int ret;
++	SizeT dl = (SizeT)destlen;
++	SizeT sl = (SizeT)srclen;
++	ELzmaStatus status;
++	
++	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
++		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
++
++	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
++		return -1;
++
++	return 0;
++}
++
++static struct jffs2_compressor jffs2_lzma_comp = {
++	.priority = JFFS2_LZMA_PRIORITY,
++	.name = "lzma",
++	.compr = JFFS2_COMPR_LZMA,
++	.compress = &jffs2_lzma_compress,
++	.decompress = &jffs2_lzma_decompress,
++	.disabled = 0,
++};
++
++int INIT jffs2_lzma_init(void)
++{
++        int ret;
++	CLzmaEncProps props;
++	LzmaEncProps_Init(&props);
++
++        props.dictSize = LZMA_BEST_DICT(0x2000);
++        props.level = LZMA_BEST_LEVEL;
++        props.lc = LZMA_BEST_LC;
++        props.lp = LZMA_BEST_LP;
++        props.pb = LZMA_BEST_PB;
++        props.fb = LZMA_BEST_FB;
++
++	ret = lzma_alloc_workspace(&props);
++        if (ret < 0)
++                return ret;
++
++	ret = jffs2_register_compressor(&jffs2_lzma_comp);
++	if (ret)
++		lzma_free_workspace();
++	
++        return ret;
++}
++
++void jffs2_lzma_exit(void)
++{
++	jffs2_unregister_compressor(&jffs2_lzma_comp);
++	lzma_free_workspace();
++}
+--- a/fs/jffs2/super.c
++++ b/fs/jffs2/super.c
+@@ -375,14 +375,41 @@ static int __init init_jffs2_fs(void)
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
+ 
+-	pr_info("version 2.2."
++	pr_info("version 2.2"
+ #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
+ 	       " (NAND)"
+ #endif
+ #ifdef CONFIG_JFFS2_SUMMARY
+-	       " (SUMMARY) "
++	       " (SUMMARY)"
+ #endif
+-	       "  2001-2006 Red Hat, Inc.\n");
++#ifdef CONFIG_JFFS2_ZLIB
++	       " (ZLIB)"
++#endif
++#ifdef CONFIG_JFFS2_LZO
++	       " (LZO)"
++#endif
++#ifdef CONFIG_JFFS2_LZMA
++	       " (LZMA)"
++#endif
++#ifdef CONFIG_JFFS2_RTIME
++	       " (RTIME)"
++#endif
++#ifdef CONFIG_JFFS2_RUBIN
++	       " (RUBIN)"
++#endif
++#ifdef  CONFIG_JFFS2_CMODE_NONE
++	       " (CMODE_NONE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_PRIORITY
++	       " (CMODE_PRIORITY)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_SIZE
++	       " (CMODE_SIZE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
++	       " (CMODE_FAVOURLZO)"
++#endif
++	       " (c) 2001-2006 Red Hat, Inc.\n");
+ 
+ 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
+ 					     sizeof(struct jffs2_inode_info),
+--- a/include/uapi/linux/jffs2.h
++++ b/include/uapi/linux/jffs2.h
+@@ -46,6 +46,7 @@
+ #define JFFS2_COMPR_DYNRUBIN	0x05
+ #define JFFS2_COMPR_ZLIB	0x06
+ #define JFFS2_COMPR_LZO		0x07
++#define JFFS2_COMPR_LZMA	0x08
+ /* Compatibility flags. */
+ #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+ #define JFFS2_NODE_ACCURATE 0x2000
+--- /dev/null
++++ b/include/linux/lzma.h
+@@ -0,0 +1,62 @@
++#ifndef __LZMA_H__
++#define __LZMA_H__
++
++#ifdef __KERNEL__
++	#include <linux/kernel.h>
++	#include <linux/sched.h>
++	#include <linux/slab.h>
++	#include <linux/vmalloc.h>
++	#include <linux/init.h>
++	#define LZMA_MALLOC vmalloc
++	#define LZMA_FREE vfree
++	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
++	#define INIT __init
++	#define STATIC static
++#else
++	#include <stdint.h>
++	#include <stdlib.h>
++	#include <stdio.h>
++	#include <unistd.h>
++	#include <string.h>
++	#include <asm/types.h>
++	#include <errno.h>
++	#include <linux/jffs2.h>
++	#ifndef PAGE_SIZE
++		extern int page_size;
++		#define PAGE_SIZE page_size
++	#endif
++	#define LZMA_MALLOC malloc
++	#define LZMA_FREE free
++	#define PRINT_ERROR(msg) fprintf(stderr, msg)
++	#define INIT
++	#define STATIC
++#endif
++
++#include "lzma/LzmaDec.h"
++#include "lzma/LzmaEnc.h"
++
++#define LZMA_BEST_LEVEL (9)
++#define LZMA_BEST_LC    (0)
++#define LZMA_BEST_LP    (0)
++#define LZMA_BEST_PB    (0)
++#define LZMA_BEST_FB  (273)
++
++#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
++
++static void *p_lzma_malloc(void *p, size_t size)
++{
++        if (size == 0)
++                return NULL;
++
++        return LZMA_MALLOC(size);
++}
++
++static void p_lzma_free(void *p, void *address)
++{
++        if (address != NULL)
++                LZMA_FREE(address);
++}
++
++static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzFind.h
+@@ -0,0 +1,115 @@
++/* LzFind.h -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_FIND_H
++#define __LZ_FIND_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef UInt32 CLzRef;
++
++typedef struct _CMatchFinder
++{
++  Byte *buffer;
++  UInt32 pos;
++  UInt32 posLimit;
++  UInt32 streamPos;
++  UInt32 lenLimit;
++
++  UInt32 cyclicBufferPos;
++  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
++
++  UInt32 matchMaxLen;
++  CLzRef *hash;
++  CLzRef *son;
++  UInt32 hashMask;
++  UInt32 cutValue;
++
++  Byte *bufferBase;
++  ISeqInStream *stream;
++  int streamEndWasReached;
++
++  UInt32 blockSize;
++  UInt32 keepSizeBefore;
++  UInt32 keepSizeAfter;
++
++  UInt32 numHashBytes;
++  int directInput;
++  size_t directInputRem;
++  int btMode;
++  int bigHash;
++  UInt32 historySize;
++  UInt32 fixedHashSize;
++  UInt32 hashSizeSum;
++  UInt32 numSons;
++  SRes result;
++  UInt32 crc[256];
++} CMatchFinder;
++
++#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
++#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
++
++#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
++
++int MatchFinder_NeedMove(CMatchFinder *p);
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
++void MatchFinder_MoveBlock(CMatchFinder *p);
++void MatchFinder_ReadIfRequired(CMatchFinder *p);
++
++void MatchFinder_Construct(CMatchFinder *p);
++
++/* Conditions:
++     historySize <= 3 GB
++     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
++*/
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc);
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
++    UInt32 *distances, UInt32 maxLen);
++
++/*
++Conditions:
++  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
++  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
++*/
++
++typedef void (*Mf_Init_Func)(void *object);
++typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
++typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
++typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
++typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
++typedef void (*Mf_Skip_Func)(void *object, UInt32);
++
++typedef struct _IMatchFinder
++{
++  Mf_Init_Func Init;
++  Mf_GetIndexByte_Func GetIndexByte;
++  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
++  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
++  Mf_GetMatches_Func GetMatches;
++  Mf_Skip_Func Skip;
++} IMatchFinder;
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
++
++void MatchFinder_Init(CMatchFinder *p);
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzHash.h
+@@ -0,0 +1,54 @@
++/* LzHash.h -- HASH functions for LZ algorithms
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_HASH_H
++#define __LZ_HASH_H
++
++#define kHash2Size (1 << 10)
++#define kHash3Size (1 << 16)
++#define kHash4Size (1 << 20)
++
++#define kFix3HashSize (kHash2Size)
++#define kFix4HashSize (kHash2Size + kHash3Size)
++#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
++
++#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
++
++#define HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
++
++#define HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
++
++#define HASH5_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
++  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
++  hash4Value &= (kHash4Size - 1); }
++
++/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
++#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
++
++
++#define MT_HASH2_CALC \
++  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
++
++#define MT_HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
++
++#define MT_HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzmaDec.h
+@@ -0,0 +1,231 @@
++/* LzmaDec.h -- LZMA Decoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_DEC_H
++#define __LZMA_DEC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/* #define _LZMA_PROB32 */
++/* _LZMA_PROB32 can increase the speed on some CPUs,
++   but memory usage for CLzmaDec::probs will be doubled in that case */
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++
++/* ---------- LZMA Properties ---------- */
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaProps
++{
++  unsigned lc, lp, pb;
++  UInt32 dicSize;
++} CLzmaProps;
++
++/* LzmaProps_Decode - decodes properties
++Returns:
++  SZ_OK
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
++
++
++/* ---------- LZMA Decoder state ---------- */
++
++/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
++   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
++
++#define LZMA_REQUIRED_INPUT_MAX 20
++
++typedef struct
++{
++  CLzmaProps prop;
++  CLzmaProb *probs;
++  Byte *dic;
++  const Byte *buf;
++  UInt32 range, code;
++  SizeT dicPos;
++  SizeT dicBufSize;
++  UInt32 processedPos;
++  UInt32 checkDicSize;
++  unsigned state;
++  UInt32 reps[4];
++  unsigned remainLen;
++  int needFlush;
++  int needInitState;
++  UInt32 numProbs;
++  unsigned tempBufSize;
++  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
++} CLzmaDec;
++
++#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
++
++void LzmaDec_Init(CLzmaDec *p);
++
++/* There are two types of LZMA streams:
++     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
++     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
++
++typedef enum
++{
++  LZMA_FINISH_ANY,   /* finish at any point */
++  LZMA_FINISH_END    /* block must be finished at the end */
++} ELzmaFinishMode;
++
++/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
++
++   You must use LZMA_FINISH_END, when you know that current output buffer
++   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
++
++   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
++   and output value of destLen will be less than output buffer size limit.
++   You can check status result also.
++
++   You can use multiple checks to test data integrity after full decompression:
++     1) Check Result and "status" variable.
++     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
++     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
++        You must use correct finish mode in that case. */
++
++typedef enum
++{
++  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
++  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
++  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
++  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
++  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
++} ELzmaStatus;
++
++/* ELzmaStatus is used only as output value for function call */
++
++
++/* ---------- Interfaces ---------- */
++
++/* There are 3 levels of interfaces:
++     1) Dictionary Interface
++     2) Buffer Interface
++     3) One Call Interface
++   You can select any of these interfaces, but don't mix functions from different
++   groups for same object. */
++
++
++/* There are two variants to allocate state for Dictionary Interface:
++     1) LzmaDec_Allocate / LzmaDec_Free
++     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
++   You can use variant 2, if you set dictionary buffer manually.
++   For Buffer Interface you must always use variant 1.
++
++LzmaDec_Allocate* can return:
++  SZ_OK
++  SZ_ERROR_MEM         - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++   
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
++
++SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
++
++/* ---------- Dictionary Interface ---------- */
++
++/* You can use it, if you want to eliminate the overhead for data copying from
++   dictionary to some other external buffer.
++   You must work with CLzmaDec variables directly in this interface.
++
++   STEPS:
++     LzmaDec_Constr()
++     LzmaDec_Allocate()
++     for (each new stream)
++     {
++       LzmaDec_Init()
++       while (it needs more decompression)
++       {
++         LzmaDec_DecodeToDic()
++         use data from CLzmaDec::dic and update CLzmaDec::dicPos
++       }
++     }
++     LzmaDec_Free()
++*/
++
++/* LzmaDec_DecodeToDic
++   
++   The decoding to internal dictionary buffer (CLzmaDec::dic).
++   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (dicLimit).
++  LZMA_FINISH_ANY - Decode just dicLimit bytes.
++  LZMA_FINISH_END - Stream must be finished after dicLimit.
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_NEEDS_MORE_INPUT
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++*/
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- Buffer Interface ---------- */
++
++/* It's zlib-like interface.
++   See LzmaDec_DecodeToDic description for information about STEPS and return results,
++   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
++   to work with CLzmaDec variables manually.
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++*/
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaDecode
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++  SZ_ERROR_MEM  - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
++*/
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzmaEnc.h
+@@ -0,0 +1,80 @@
++/*  LzmaEnc.h -- LZMA Encoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_ENC_H
++#define __LZMA_ENC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaEncProps
++{
++  int level;       /*  0 <= level <= 9 */
++  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
++                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
++                       default = (1 << 24) */
++  int lc;          /* 0 <= lc <= 8, default = 3 */
++  int lp;          /* 0 <= lp <= 4, default = 0 */
++  int pb;          /* 0 <= pb <= 4, default = 2 */
++  int algo;        /* 0 - fast, 1 - normal, default = 1 */
++  int fb;          /* 5 <= fb <= 273, default = 32 */
++  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
++  int numHashBytes; /* 2, 3 or 4, default = 4 */
++  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
++  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
++  int numThreads;  /* 1 or 2, default = 2 */
++} CLzmaEncProps;
++
++void LzmaEncProps_Init(CLzmaEncProps *p);
++void LzmaEncProps_Normalize(CLzmaEncProps *p);
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
++
++
++/* ---------- CLzmaEncHandle Interface ---------- */
++
++/* LzmaEnc_* functions can return the following exit codes:
++Returns:
++  SZ_OK           - OK
++  SZ_ERROR_MEM    - Memory allocation error
++  SZ_ERROR_PARAM  - Incorrect paramater in props
++  SZ_ERROR_WRITE  - Write callback error.
++  SZ_ERROR_PROGRESS - some break from progress callback
++  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
++*/
++
++typedef void * CLzmaEncHandle;
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
++SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaEncode
++Return code:
++  SZ_OK               - OK
++  SZ_ERROR_MEM        - Memory allocation error
++  SZ_ERROR_PARAM      - Incorrect paramater
++  SZ_ERROR_OUTPUT_EOF - output buffer overflow
++  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
++*/
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/Types.h
+@@ -0,0 +1,226 @@
++/* Types.h -- Basic types
++2009-11-23 : Igor Pavlov : Public domain */
++
++#ifndef __7Z_TYPES_H
++#define __7Z_TYPES_H
++
++#include <stddef.h>
++
++#ifdef _WIN32
++#include <windows.h>
++#endif
++
++#ifndef EXTERN_C_BEGIN
++#ifdef __cplusplus
++#define EXTERN_C_BEGIN extern "C" {
++#define EXTERN_C_END }
++#else
++#define EXTERN_C_BEGIN
++#define EXTERN_C_END
++#endif
++#endif
++
++EXTERN_C_BEGIN
++
++#define SZ_OK 0
++
++#define SZ_ERROR_DATA 1
++#define SZ_ERROR_MEM 2
++#define SZ_ERROR_CRC 3
++#define SZ_ERROR_UNSUPPORTED 4
++#define SZ_ERROR_PARAM 5
++#define SZ_ERROR_INPUT_EOF 6
++#define SZ_ERROR_OUTPUT_EOF 7
++#define SZ_ERROR_READ 8
++#define SZ_ERROR_WRITE 9
++#define SZ_ERROR_PROGRESS 10
++#define SZ_ERROR_FAIL 11
++#define SZ_ERROR_THREAD 12
++
++#define SZ_ERROR_ARCHIVE 16
++#define SZ_ERROR_NO_ARCHIVE 17
++
++typedef int SRes;
++
++#ifdef _WIN32
++typedef DWORD WRes;
++#else
++typedef int WRes;
++#endif
++
++#ifndef RINOK
++#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
++#endif
++
++typedef unsigned char Byte;
++typedef short Int16;
++typedef unsigned short UInt16;
++
++#ifdef _LZMA_UINT32_IS_ULONG
++typedef long Int32;
++typedef unsigned long UInt32;
++#else
++typedef int Int32;
++typedef unsigned int UInt32;
++#endif
++
++#ifdef _SZ_NO_INT_64
++
++/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
++   NOTES: Some code will work incorrectly in that case! */
++
++typedef long Int64;
++typedef unsigned long UInt64;
++
++#else
++
++#if defined(_MSC_VER) || defined(__BORLANDC__)
++typedef __int64 Int64;
++typedef unsigned __int64 UInt64;
++#else
++typedef long long int Int64;
++typedef unsigned long long int UInt64;
++#endif
++
++#endif
++
++#ifdef _LZMA_NO_SYSTEM_SIZE_T
++typedef UInt32 SizeT;
++#else
++typedef size_t SizeT;
++#endif
++
++typedef int Bool;
++#define True 1
++#define False 0
++
++
++#ifdef _WIN32
++#define MY_STD_CALL __stdcall
++#else
++#define MY_STD_CALL
++#endif
++
++#ifdef _MSC_VER
++
++#if _MSC_VER >= 1300
++#define MY_NO_INLINE __declspec(noinline)
++#else
++#define MY_NO_INLINE
++#endif
++
++#define MY_CDECL __cdecl
++#define MY_FAST_CALL __fastcall
++
++#else
++
++#define MY_CDECL
++#define MY_FAST_CALL
++
++#endif
++
++
++/* The following interfaces use first parameter as pointer to structure */
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) < input(*size)) is allowed */
++} ISeqInStream;
++
++/* it can return SZ_ERROR_INPUT_EOF */
++SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
++SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
++SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
++
++typedef struct
++{
++  size_t (*Write)(void *p, const void *buf, size_t size);
++    /* Returns: result - the number of actually written bytes.
++       (result < size) means error */
++} ISeqOutStream;
++
++typedef enum
++{
++  SZ_SEEK_SET = 0,
++  SZ_SEEK_CUR = 1,
++  SZ_SEEK_END = 2
++} ESzSeek;
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ISeekInStream;
++
++typedef struct
++{
++  SRes (*Look)(void *p, void **buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) > input(*size)) is not allowed
++       (output(*size) < input(*size)) is allowed */
++  SRes (*Skip)(void *p, size_t offset);
++    /* offset must be <= output(*size) of Look */
++
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* reads directly (without buffer). It's same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ILookInStream;
++
++SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
++SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
++
++/* reads via ILookInStream::Read */
++SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
++SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
++
++#define LookToRead_BUF_SIZE (1 << 14)
++
++typedef struct
++{
++  ILookInStream s;
++  ISeekInStream *realStream;
++  size_t pos;
++  size_t size;
++  Byte buf[LookToRead_BUF_SIZE];
++} CLookToRead;
++
++void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
++void LookToRead_Init(CLookToRead *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToLook;
++
++void SecToLook_CreateVTable(CSecToLook *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToRead;
++
++void SecToRead_CreateVTable(CSecToRead *p);
++
++typedef struct
++{
++  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
++    /* Returns: result. (result != SZ_OK) means break.
++       Value (UInt64)(Int64)-1 for size means unknown value. */
++} ICompressProgress;
++
++typedef struct
++{
++  void *(*Alloc)(void *p, size_t size);
++  void (*Free)(void *p, void *address); /* address can be 0 */
++} ISzAlloc;
++
++#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
++#define IAlloc_Free(p, a) (p)->Free((p), a)
++
++EXTERN_C_END
++
++#endif
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -241,6 +241,12 @@ config LZ4_DECOMPRESS
+ 
+ source "lib/xz/Kconfig"
+ 
++config LZMA_COMPRESS
++    tristate
++
++config LZMA_DECOMPRESS
++    tristate
++
+ #
+ # These all provide a common interface (hence the apparent duplication with
+ # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
+--- a/lib/Makefile
++++ b/lib/Makefile
+@@ -2,6 +2,16 @@
+ # Makefile for some libs needed in the kernel.
+ #
+ 
++ifdef CONFIG_JFFS2_ZLIB
++	CONFIG_ZLIB_INFLATE:=y
++	CONFIG_ZLIB_DEFLATE:=y
++endif
++
++ifdef CONFIG_JFFS2_LZMA
++	CONFIG_LZMA_DECOMPRESS:=y
++	CONFIG_LZMA_COMPRESS:=y
++endif
++
+ ifdef CONFIG_FUNCTION_TRACER
+ ORIG_CFLAGS := $(KBUILD_CFLAGS)
+ KBUILD_CFLAGS = $(subst $(CC_FLAGS_FTRACE),,$(ORIG_CFLAGS))
+@@ -98,6 +108,8 @@ obj-$(CONFIG_LZ4HC_COMPRESS) += lz4/
+ obj-$(CONFIG_LZ4_DECOMPRESS) += lz4/
+ obj-$(CONFIG_XZ_DEC) += xz/
+ obj-$(CONFIG_RAID6_PQ) += raid6/
++obj-$(CONFIG_LZMA_COMPRESS) += lzma/
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
+ 
+ lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
+ lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
+--- /dev/null
++++ b/lib/lzma/LzFind.c
+@@ -0,0 +1,761 @@
++/* LzFind.c -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++#include "LzFind.h"
++#include "LzHash.h"
++
++#define kEmptyHashValue 0
++#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
++#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
++#define kNormalizeMask (~(kNormalizeStepMin - 1))
++#define kMaxHistorySize ((UInt32)3 << 30)
++
++#define kStartMaxLen 3
++
++static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  if (!p->directInput)
++  {
++    alloc->Free(alloc, p->bufferBase);
++    p->bufferBase = 0;
++  }
++}
++
++/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
++
++static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
++{
++  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
++  if (p->directInput)
++  {
++    p->blockSize = blockSize;
++    return 1;
++  }
++  if (p->bufferBase == 0 || p->blockSize != blockSize)
++  {
++    LzInWindow_Free(p, alloc);
++    p->blockSize = blockSize;
++    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
++  }
++  return (p->bufferBase != 0);
++}
++
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++
++UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++{
++  p->posLimit -= subValue;
++  p->pos -= subValue;
++  p->streamPos -= subValue;
++}
++
++static void MatchFinder_ReadBlock(CMatchFinder *p)
++{
++  if (p->streamEndWasReached || p->result != SZ_OK)
++    return;
++  if (p->directInput)
++  {
++    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
++    if (curSize > p->directInputRem)
++      curSize = (UInt32)p->directInputRem;
++    p->directInputRem -= curSize;
++    p->streamPos += curSize;
++    if (p->directInputRem == 0)
++      p->streamEndWasReached = 1;
++    return;
++  }
++  for (;;)
++  {
++    Byte *dest = p->buffer + (p->streamPos - p->pos);
++    size_t size = (p->bufferBase + p->blockSize - dest);
++    if (size == 0)
++      return;
++    p->result = p->stream->Read(p->stream, dest, &size);
++    if (p->result != SZ_OK)
++      return;
++    if (size == 0)
++    {
++      p->streamEndWasReached = 1;
++      return;
++    }
++    p->streamPos += (UInt32)size;
++    if (p->streamPos - p->pos > p->keepSizeAfter)
++      return;
++  }
++}
++
++void MatchFinder_MoveBlock(CMatchFinder *p)
++{
++  memmove(p->bufferBase,
++    p->buffer - p->keepSizeBefore,
++    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
++  p->buffer = p->bufferBase + p->keepSizeBefore;
++}
++
++int MatchFinder_NeedMove(CMatchFinder *p)
++{
++  if (p->directInput)
++    return 0;
++  /* if (p->streamEndWasReached) return 0; */
++  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
++}
++
++void MatchFinder_ReadIfRequired(CMatchFinder *p)
++{
++  if (p->streamEndWasReached)
++    return;
++  if (p->keepSizeAfter >= p->streamPos - p->pos)
++    MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
++{
++  if (MatchFinder_NeedMove(p))
++    MatchFinder_MoveBlock(p);
++  MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
++{
++  p->cutValue = 32;
++  p->btMode = 1;
++  p->numHashBytes = 4;
++  p->bigHash = 0;
++}
++
++#define kCrcPoly 0xEDB88320
++
++void MatchFinder_Construct(CMatchFinder *p)
++{
++  UInt32 i;
++  p->bufferBase = 0;
++  p->directInput = 0;
++  p->hash = 0;
++  MatchFinder_SetDefaultSettings(p);
++
++  for (i = 0; i < 256; i++)
++  {
++    UInt32 r = i;
++    int j;
++    for (j = 0; j < 8; j++)
++      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
++    p->crc[i] = r;
++  }
++}
++
++static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->hash);
++  p->hash = 0;
++}
++
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  MatchFinder_FreeThisClassMemory(p, alloc);
++  LzInWindow_Free(p, alloc);
++}
++
++static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
++{
++  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
++  if (sizeInBytes / sizeof(CLzRef) != num)
++    return 0;
++  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
++}
++
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc)
++{
++  UInt32 sizeReserv;
++  if (historySize > kMaxHistorySize)
++  {
++    MatchFinder_Free(p, alloc);
++    return 0;
++  }
++  sizeReserv = historySize >> 1;
++  if (historySize > ((UInt32)2 << 30))
++    sizeReserv = historySize >> 2;
++  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
++
++  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
++  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
++  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
++  if (LzInWindow_Create(p, sizeReserv, alloc))
++  {
++    UInt32 newCyclicBufferSize = historySize + 1;
++    UInt32 hs;
++    p->matchMaxLen = matchMaxLen;
++    {
++      p->fixedHashSize = 0;
++      if (p->numHashBytes == 2)
++        hs = (1 << 16) - 1;
++      else
++      {
++        hs = historySize - 1;
++        hs |= (hs >> 1);
++        hs |= (hs >> 2);
++        hs |= (hs >> 4);
++        hs |= (hs >> 8);
++        hs >>= 1;
++        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
++        if (hs > (1 << 24))
++        {
++          if (p->numHashBytes == 3)
++            hs = (1 << 24) - 1;
++          else
++            hs >>= 1;
++        }
++      }
++      p->hashMask = hs;
++      hs++;
++      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
++      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
++      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
++      hs += p->fixedHashSize;
++    }
++
++    {
++      UInt32 prevSize = p->hashSizeSum + p->numSons;
++      UInt32 newSize;
++      p->historySize = historySize;
++      p->hashSizeSum = hs;
++      p->cyclicBufferSize = newCyclicBufferSize;
++      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
++      newSize = p->hashSizeSum + p->numSons;
++      if (p->hash != 0 && prevSize == newSize)
++        return 1;
++      MatchFinder_FreeThisClassMemory(p, alloc);
++      p->hash = AllocRefs(newSize, alloc);
++      if (p->hash != 0)
++      {
++        p->son = p->hash + p->hashSizeSum;
++        return 1;
++      }
++    }
++  }
++  MatchFinder_Free(p, alloc);
++  return 0;
++}
++
++static void MatchFinder_SetLimits(CMatchFinder *p)
++{
++  UInt32 limit = kMaxValForNormalize - p->pos;
++  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
++  if (limit2 < limit)
++    limit = limit2;
++  limit2 = p->streamPos - p->pos;
++  if (limit2 <= p->keepSizeAfter)
++  {
++    if (limit2 > 0)
++      limit2 = 1;
++  }
++  else
++    limit2 -= p->keepSizeAfter;
++  if (limit2 < limit)
++    limit = limit2;
++  {
++    UInt32 lenLimit = p->streamPos - p->pos;
++    if (lenLimit > p->matchMaxLen)
++      lenLimit = p->matchMaxLen;
++    p->lenLimit = lenLimit;
++  }
++  p->posLimit = p->pos + limit;
++}
++
++void MatchFinder_Init(CMatchFinder *p)
++{
++  UInt32 i;
++  for (i = 0; i < p->hashSizeSum; i++)
++    p->hash[i] = kEmptyHashValue;
++  p->cyclicBufferPos = 0;
++  p->buffer = p->bufferBase;
++  p->pos = p->streamPos = p->cyclicBufferSize;
++  p->result = SZ_OK;
++  p->streamEndWasReached = 0;
++  MatchFinder_ReadBlock(p);
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
++{
++  return (p->pos - p->historySize - 1) & kNormalizeMask;
++}
++
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++{
++  UInt32 i;
++  for (i = 0; i < numItems; i++)
++  {
++    UInt32 value = items[i];
++    if (value <= subValue)
++      value = kEmptyHashValue;
++    else
++      value -= subValue;
++    items[i] = value;
++  }
++}
++
++static void MatchFinder_Normalize(CMatchFinder *p)
++{
++  UInt32 subValue = MatchFinder_GetSubValue(p);
++  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
++  MatchFinder_ReduceOffsets(p, subValue);
++}
++
++static void MatchFinder_CheckLimits(CMatchFinder *p)
++{
++  if (p->pos == kMaxValForNormalize)
++    MatchFinder_Normalize(p);
++  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
++    MatchFinder_CheckAndMoveAndRead(p);
++  if (p->cyclicBufferPos == p->cyclicBufferSize)
++    p->cyclicBufferPos = 0;
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  son[_cyclicBufferPos] = curMatch;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++      return distances;
++    {
++      const Byte *pb = cur - delta;
++      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
++      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
++      {
++        UInt32 len = 0;
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++            return distances;
++        }
++      }
++    }
++  }
++}
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return distances;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        if (++len != lenLimit && pb[len] == cur[len])
++          while (++len != lenLimit)
++            if (pb[len] != cur[len])
++              break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return distances;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        {
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++#define MOVE_POS \
++  ++p->cyclicBufferPos; \
++  p->buffer++; \
++  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
++
++#define MOVE_POS_RET MOVE_POS return offset;
++
++static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
++
++#define GET_MATCHES_HEADER2(minLen, ret_op) \
++  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
++  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
++  cur = p->buffer;
++
++#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
++#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
++
++#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
++
++#define GET_MATCHES_FOOTER(offset, maxLen) \
++  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
++  distances + offset, maxLen) - distances); MOVE_POS_RET;
++
++#define SKIP_FOOTER \
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
++
++static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(2)
++  HASH2_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 1)
++}
++
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 2)
++}
++
++static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, delta2, maxLen, offset;
++  GET_MATCHES_HEADER(3)
++
++  HASH3_CALC;
++
++  delta2 = p->pos - p->hash[hash2Value];
++  curMatch = p->hash[kFix3HashSize + hashValue];
++  
++  p->hash[hash2Value] =
++  p->hash[kFix3HashSize + hashValue] = p->pos;
++
++
++  maxLen = 2;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[0] = maxLen;
++    distances[1] = delta2 - 1;
++    offset = 2;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++  
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      p->son[p->cyclicBufferPos] = curMatch;
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances + offset, maxLen) - (distances));
++  MOVE_POS_RET
++}
++
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances, 2) - (distances));
++  MOVE_POS_RET
++}
++
++static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(2)
++    HASH2_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value;
++    SKIP_HEADER(3)
++    HASH3_CALC;
++    curMatch = p->hash[kFix3HashSize + hashValue];
++    p->hash[hash2Value] =
++    p->hash[kFix3HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] = p->pos;
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] =
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
++{
++  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
++  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
++  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
++  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
++  if (!p->btMode)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 2)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 3)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
++  }
++  else
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
++  }
++}
+--- /dev/null
++++ b/lib/lzma/LzmaDec.c
+@@ -0,0 +1,999 @@
++/* LzmaDec.c -- LZMA Decoder
++2009-09-20 : Igor Pavlov : Public domain */
++
++#include "LzmaDec.h"
++
++#include <string.h>
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++
++#define RC_INIT_SIZE 5
++
++#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
++#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
++#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
++  { UPDATE_0(p); i = (i + i); A0; } else \
++  { UPDATE_1(p); i = (i + i) + 1; A1; }
++#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
++
++#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
++#define TREE_DECODE(probs, limit, i) \
++  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
++
++/* #define _LZMA_SIZE_OPT */
++
++#ifdef _LZMA_SIZE_OPT
++#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
++#else
++#define TREE_6_DECODE(probs, i) \
++  { i = 1; \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  i -= 0x40; }
++#endif
++
++#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0_CHECK range = bound;
++#define UPDATE_1_CHECK range -= bound; code -= bound;
++#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
++  { UPDATE_0_CHECK; i = (i + i); A0; } else \
++  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
++#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
++#define TREE_DECODE_CHECK(probs, limit, i) \
++  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
++
++
++#define kNumPosBitsMax 4
++#define kNumPosStatesMax (1 << kNumPosBitsMax)
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define LenChoice 0
++#define LenChoice2 (LenChoice + 1)
++#define LenLow (LenChoice2 + 1)
++#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
++#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
++#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
++
++
++#define kNumStates 12
++#define kNumLitStates 7
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#define kNumPosSlotBits 6
++#define kNumLenToPosStates 4
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++
++#define kMatchMinLen 2
++#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define IsMatch 0
++#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
++#define IsRepG0 (IsRep + kNumStates)
++#define IsRepG1 (IsRepG0 + kNumStates)
++#define IsRepG2 (IsRepG1 + kNumStates)
++#define IsRep0Long (IsRepG2 + kNumStates)
++#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
++#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
++#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
++#define LenCoder (Align + kAlignTableSize)
++#define RepLenCoder (LenCoder + kNumLenProbs)
++#define Literal (RepLenCoder + kNumLenProbs)
++
++#define LZMA_BASE_SIZE 1846
++#define LZMA_LIT_SIZE 768
++
++#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
++
++#if Literal != LZMA_BASE_SIZE
++StopCompilingDueBUG
++#endif
++
++#define LZMA_DIC_MIN (1 << 12)
++
++/* First LZMA-symbol is always decoded.
++And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
++Out:
++  Result:
++    SZ_OK - OK
++    SZ_ERROR_DATA - Error
++  p->remainLen:
++    < kMatchSpecLenStart : normal remain
++    = kMatchSpecLenStart : finished
++    = kMatchSpecLenStart + 1 : Flush marker
++    = kMatchSpecLenStart + 2 : State Init Marker
++*/
++
++static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  CLzmaProb *probs = p->probs;
++
++  unsigned state = p->state;
++  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
++  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
++  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
++  unsigned lc = p->prop.lc;
++
++  Byte *dic = p->dic;
++  SizeT dicBufSize = p->dicBufSize;
++  SizeT dicPos = p->dicPos;
++  
++  UInt32 processedPos = p->processedPos;
++  UInt32 checkDicSize = p->checkDicSize;
++  unsigned len = 0;
++
++  const Byte *buf = p->buf;
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++
++  do
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = processedPos & pbMask;
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0(prob)
++    {
++      unsigned symbol;
++      UPDATE_0(prob);
++      prob = probs + Literal;
++      if (checkDicSize != 0 || processedPos != 0)
++        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
++        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
++
++      if (state < kNumLitStates)
++      {
++        state -= (state < 4) ? state : 3;
++        symbol = 1;
++        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++        unsigned offs = 0x100;
++        state -= (state < 10) ? 3 : 6;
++        symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      dic[dicPos++] = (Byte)symbol;
++      processedPos++;
++      continue;
++    }
++    else
++    {
++      UPDATE_1(prob);
++      prob = probs + IsRep + state;
++      IF_BIT_0(prob)
++      {
++        UPDATE_0(prob);
++        state += kNumStates;
++        prob = probs + LenCoder;
++      }
++      else
++      {
++        UPDATE_1(prob);
++        if (checkDicSize == 0 && processedPos == 0)
++          return SZ_ERROR_DATA;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0(prob)
++        {
++          UPDATE_0(prob);
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++            dicPos++;
++            processedPos++;
++            state = state < kNumLitStates ? 9 : 11;
++            continue;
++          }
++          UPDATE_1(prob);
++        }
++        else
++        {
++          UInt32 distance;
++          UPDATE_1(prob);
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            distance = rep1;
++          }
++          else
++          {
++            UPDATE_1(prob);
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0(prob)
++            {
++              UPDATE_0(prob);
++              distance = rep2;
++            }
++            else
++            {
++              UPDATE_1(prob);
++              distance = rep3;
++              rep3 = rep2;
++            }
++            rep2 = rep1;
++          }
++          rep1 = rep0;
++          rep0 = distance;
++        }
++        state = state < kNumLitStates ? 8 : 11;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0(probLen)
++        {
++          UPDATE_0(probLen);
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = (1 << kLenNumLowBits);
++        }
++        else
++        {
++          UPDATE_1(probLen);
++          probLen = prob + LenChoice2;
++          IF_BIT_0(probLen)
++          {
++            UPDATE_0(probLen);
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = (1 << kLenNumMidBits);
++          }
++          else
++          {
++            UPDATE_1(probLen);
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = (1 << kLenNumHighBits);
++          }
++        }
++        TREE_DECODE(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state >= kNumStates)
++      {
++        UInt32 distance;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
++        TREE_6_DECODE(prob, distance);
++        if (distance >= kStartPosModelIndex)
++        {
++          unsigned posSlot = (unsigned)distance;
++          int numDirectBits = (int)(((distance >> 1) - 1));
++          distance = (2 | (distance & 1));
++          if (posSlot < kEndPosModelIndex)
++          {
++            distance <<= numDirectBits;
++            prob = probs + SpecPos + distance - posSlot - 1;
++            {
++              UInt32 mask = 1;
++              unsigned i = 1;
++              do
++              {
++                GET_BIT2(prob + i, i, ; , distance |= mask);
++                mask <<= 1;
++              }
++              while (--numDirectBits != 0);
++            }
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE
++              range >>= 1;
++              
++              {
++                UInt32 t;
++                code -= range;
++                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
++                distance = (distance << 1) + (t + 1);
++                code += range & t;
++              }
++              /*
++              distance <<= 1;
++              if (code >= range)
++              {
++                code -= range;
++                distance |= 1;
++              }
++              */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            distance <<= kNumAlignBits;
++            {
++              unsigned i = 1;
++              GET_BIT2(prob + i, i, ; , distance |= 1);
++              GET_BIT2(prob + i, i, ; , distance |= 2);
++              GET_BIT2(prob + i, i, ; , distance |= 4);
++              GET_BIT2(prob + i, i, ; , distance |= 8);
++            }
++            if (distance == (UInt32)0xFFFFFFFF)
++            {
++              len += kMatchSpecLenStart;
++              state -= kNumStates;
++              break;
++            }
++          }
++        }
++        rep3 = rep2;
++        rep2 = rep1;
++        rep1 = rep0;
++        rep0 = distance + 1;
++        if (checkDicSize == 0)
++        {
++          if (distance >= processedPos)
++            return SZ_ERROR_DATA;
++        }
++        else if (distance >= checkDicSize)
++          return SZ_ERROR_DATA;
++        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
++      }
++
++      len += kMatchMinLen;
++
++      if (limit == dicPos)
++        return SZ_ERROR_DATA;
++      {
++        SizeT rem = limit - dicPos;
++        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
++        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
++
++        processedPos += curLen;
++
++        len -= curLen;
++        if (pos + curLen <= dicBufSize)
++        {
++          Byte *dest = dic + dicPos;
++          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
++          const Byte *lim = dest + curLen;
++          dicPos += curLen;
++          do
++            *(dest) = (Byte)*(dest + src);
++          while (++dest != lim);
++        }
++        else
++        {
++          do
++          {
++            dic[dicPos++] = dic[pos];
++            if (++pos == dicBufSize)
++              pos = 0;
++          }
++          while (--curLen != 0);
++        }
++      }
++    }
++  }
++  while (dicPos < limit && buf < bufLimit);
++  NORMALIZE;
++  p->buf = buf;
++  p->range = range;
++  p->code = code;
++  p->remainLen = len;
++  p->dicPos = dicPos;
++  p->processedPos = processedPos;
++  p->reps[0] = rep0;
++  p->reps[1] = rep1;
++  p->reps[2] = rep2;
++  p->reps[3] = rep3;
++  p->state = state;
++
++  return SZ_OK;
++}
++
++static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
++{
++  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
++  {
++    Byte *dic = p->dic;
++    SizeT dicPos = p->dicPos;
++    SizeT dicBufSize = p->dicBufSize;
++    unsigned len = p->remainLen;
++    UInt32 rep0 = p->reps[0];
++    if (limit - dicPos < len)
++      len = (unsigned)(limit - dicPos);
++
++    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
++      p->checkDicSize = p->prop.dicSize;
++
++    p->processedPos += len;
++    p->remainLen -= len;
++    while (len-- != 0)
++    {
++      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++      dicPos++;
++    }
++    p->dicPos = dicPos;
++  }
++}
++
++static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  do
++  {
++    SizeT limit2 = limit;
++    if (p->checkDicSize == 0)
++    {
++      UInt32 rem = p->prop.dicSize - p->processedPos;
++      if (limit - p->dicPos > rem)
++        limit2 = p->dicPos + rem;
++    }
++    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
++    if (p->processedPos >= p->prop.dicSize)
++      p->checkDicSize = p->prop.dicSize;
++    LzmaDec_WriteRem(p, limit);
++  }
++  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
++
++  if (p->remainLen > kMatchSpecLenStart)
++  {
++    p->remainLen = kMatchSpecLenStart;
++  }
++  return 0;
++}
++
++typedef enum
++{
++  DUMMY_ERROR, /* unexpected end of input stream */
++  DUMMY_LIT,
++  DUMMY_MATCH,
++  DUMMY_REP
++} ELzmaDummy;
++
++static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
++{
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++  const Byte *bufLimit = buf + inSize;
++  CLzmaProb *probs = p->probs;
++  unsigned state = p->state;
++  ELzmaDummy res;
++
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0_CHECK(prob)
++    {
++      UPDATE_0_CHECK
++
++      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
++
++      prob = probs + Literal;
++      if (p->checkDicSize != 0 || p->processedPos != 0)
++        prob += (LZMA_LIT_SIZE *
++          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
++          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
++
++      if (state < kNumLitStates)
++      {
++        unsigned symbol = 1;
++        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
++            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
++        unsigned offs = 0x100;
++        unsigned symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      res = DUMMY_LIT;
++    }
++    else
++    {
++      unsigned len;
++      UPDATE_1_CHECK;
++
++      prob = probs + IsRep + state;
++      IF_BIT_0_CHECK(prob)
++      {
++        UPDATE_0_CHECK;
++        state = 0;
++        prob = probs + LenCoder;
++        res = DUMMY_MATCH;
++      }
++      else
++      {
++        UPDATE_1_CHECK;
++        res = DUMMY_REP;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0_CHECK(prob)
++        {
++          UPDATE_0_CHECK;
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++            NORMALIZE_CHECK;
++            return DUMMY_REP;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++          }
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0_CHECK(prob)
++            {
++              UPDATE_0_CHECK;
++            }
++            else
++            {
++              UPDATE_1_CHECK;
++            }
++          }
++        }
++        state = kNumStates;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0_CHECK(probLen)
++        {
++          UPDATE_0_CHECK;
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = 1 << kLenNumLowBits;
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          probLen = prob + LenChoice2;
++          IF_BIT_0_CHECK(probLen)
++          {
++            UPDATE_0_CHECK;
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = 1 << kLenNumMidBits;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = 1 << kLenNumHighBits;
++          }
++        }
++        TREE_DECODE_CHECK(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state < 4)
++      {
++        unsigned posSlot;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
++            kNumPosSlotBits);
++        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
++        if (posSlot >= kStartPosModelIndex)
++        {
++          int numDirectBits = ((posSlot >> 1) - 1);
++
++          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
++
++          if (posSlot < kEndPosModelIndex)
++          {
++            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE_CHECK
++              range >>= 1;
++              code -= range & (((code - range) >> 31) - 1);
++              /* if (code >= range) code -= range; */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            numDirectBits = kNumAlignBits;
++          }
++          {
++            unsigned i = 1;
++            do
++            {
++              GET_BIT_CHECK(prob + i, i);
++            }
++            while (--numDirectBits != 0);
++          }
++        }
++      }
++    }
++  }
++  NORMALIZE_CHECK;
++  return res;
++}
++
++
++static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
++{
++  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
++  p->range = 0xFFFFFFFF;
++  p->needFlush = 0;
++}
++
++void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++{
++  p->needFlush = 1;
++  p->remainLen = 0;
++  p->tempBufSize = 0;
++
++  if (initDic)
++  {
++    p->processedPos = 0;
++    p->checkDicSize = 0;
++    p->needInitState = 1;
++  }
++  if (initState)
++    p->needInitState = 1;
++}
++
++void LzmaDec_Init(CLzmaDec *p)
++{
++  p->dicPos = 0;
++  LzmaDec_InitDicAndState(p, True, True);
++}
++
++static void LzmaDec_InitStateReal(CLzmaDec *p)
++{
++  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
++  UInt32 i;
++  CLzmaProb *probs = p->probs;
++  for (i = 0; i < numProbs; i++)
++    probs[i] = kBitModelTotal >> 1;
++  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
++  p->state = 0;
++  p->needInitState = 0;
++}
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++    ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT inSize = *srcLen;
++  (*srcLen) = 0;
++  LzmaDec_WriteRem(p, dicLimit);
++  
++  *status = LZMA_STATUS_NOT_SPECIFIED;
++
++  while (p->remainLen != kMatchSpecLenStart)
++  {
++      int checkEndMarkNow;
++
++      if (p->needFlush != 0)
++      {
++        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
++          p->tempBuf[p->tempBufSize++] = *src++;
++        if (p->tempBufSize < RC_INIT_SIZE)
++        {
++          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++          return SZ_OK;
++        }
++        if (p->tempBuf[0] != 0)
++          return SZ_ERROR_DATA;
++
++        LzmaDec_InitRc(p, p->tempBuf);
++        p->tempBufSize = 0;
++      }
++
++      checkEndMarkNow = 0;
++      if (p->dicPos >= dicLimit)
++      {
++        if (p->remainLen == 0 && p->code == 0)
++        {
++          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
++          return SZ_OK;
++        }
++        if (finishMode == LZMA_FINISH_ANY)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_OK;
++        }
++        if (p->remainLen != 0)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_ERROR_DATA;
++        }
++        checkEndMarkNow = 1;
++      }
++
++      if (p->needInitState)
++        LzmaDec_InitStateReal(p);
++  
++      if (p->tempBufSize == 0)
++      {
++        SizeT processed;
++        const Byte *bufLimit;
++        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            memcpy(p->tempBuf, src, inSize);
++            p->tempBufSize = (unsigned)inSize;
++            (*srcLen) += inSize;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++          bufLimit = src;
++        }
++        else
++          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
++        p->buf = src;
++        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
++          return SZ_ERROR_DATA;
++        processed = (SizeT)(p->buf - src);
++        (*srcLen) += processed;
++        src += processed;
++        inSize -= processed;
++      }
++      else
++      {
++        unsigned rem = p->tempBufSize, lookAhead = 0;
++        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
++          p->tempBuf[rem++] = src[lookAhead++];
++        p->tempBufSize = rem;
++        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            (*srcLen) += lookAhead;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++        }
++        p->buf = p->tempBuf;
++        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
++          return SZ_ERROR_DATA;
++        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
++        (*srcLen) += lookAhead;
++        src += lookAhead;
++        inSize -= lookAhead;
++        p->tempBufSize = 0;
++      }
++  }
++  if (p->code == 0)
++    *status = LZMA_STATUS_FINISHED_WITH_MARK;
++  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
++}
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT outSize = *destLen;
++  SizeT inSize = *srcLen;
++  *srcLen = *destLen = 0;
++  for (;;)
++  {
++    SizeT inSizeCur = inSize, outSizeCur, dicPos;
++    ELzmaFinishMode curFinishMode;
++    SRes res;
++    if (p->dicPos == p->dicBufSize)
++      p->dicPos = 0;
++    dicPos = p->dicPos;
++    if (outSize > p->dicBufSize - dicPos)
++    {
++      outSizeCur = p->dicBufSize;
++      curFinishMode = LZMA_FINISH_ANY;
++    }
++    else
++    {
++      outSizeCur = dicPos + outSize;
++      curFinishMode = finishMode;
++    }
++
++    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
++    src += inSizeCur;
++    inSize -= inSizeCur;
++    *srcLen += inSizeCur;
++    outSizeCur = p->dicPos - dicPos;
++    memcpy(dest, p->dic + dicPos, outSizeCur);
++    dest += outSizeCur;
++    outSize -= outSizeCur;
++    *destLen += outSizeCur;
++    if (res != 0)
++      return res;
++    if (outSizeCur == 0 || outSize == 0)
++      return SZ_OK;
++  }
++}
++
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->probs);
++  p->probs = 0;
++}
++
++static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->dic);
++  p->dic = 0;
++}
++
++void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
++{
++  LzmaDec_FreeProbs(p, alloc);
++  LzmaDec_FreeDict(p, alloc);
++}
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++{
++  UInt32 dicSize;
++  Byte d;
++  
++  if (size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_UNSUPPORTED;
++  else
++    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
++ 
++  if (dicSize < LZMA_DIC_MIN)
++    dicSize = LZMA_DIC_MIN;
++  p->dicSize = dicSize;
++
++  d = data[0];
++  if (d >= (9 * 5 * 5))
++    return SZ_ERROR_UNSUPPORTED;
++
++  p->lc = d % 9;
++  d /= 9;
++  p->pb = d / 5;
++  p->lp = d % 5;
++
++  return SZ_OK;
++}
++
++static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
++{
++  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
++  if (p->probs == 0 || numProbs != p->numProbs)
++  {
++    LzmaDec_FreeProbs(p, alloc);
++    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
++    p->numProbs = numProbs;
++    if (p->probs == 0)
++      return SZ_ERROR_MEM;
++  }
++  return SZ_OK;
++}
++
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  SizeT dicBufSize;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  dicBufSize = propNew.dicSize;
++  if (p->dic == 0 || dicBufSize != p->dicBufSize)
++  {
++    LzmaDec_FreeDict(p, alloc);
++    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
++    if (p->dic == 0)
++    {
++      LzmaDec_FreeProbs(p, alloc);
++      return SZ_ERROR_MEM;
++    }
++  }
++  p->dicBufSize = dicBufSize;
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc)
++{
++  CLzmaDec p;
++  SRes res;
++  SizeT inSize = *srcLen;
++  SizeT outSize = *destLen;
++  *srcLen = *destLen = 0;
++  if (inSize < RC_INIT_SIZE)
++    return SZ_ERROR_INPUT_EOF;
++
++  LzmaDec_Construct(&p);
++  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
++  if (res != 0)
++    return res;
++  p.dic = dest;
++  p.dicBufSize = outSize;
++
++  LzmaDec_Init(&p);
++  
++  *srcLen = inSize;
++  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
++
++  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
++    res = SZ_ERROR_INPUT_EOF;
++
++  (*destLen) = p.dicPos;
++  LzmaDec_FreeProbs(&p, alloc);
++  return res;
++}
+--- /dev/null
++++ b/lib/lzma/LzmaEnc.c
+@@ -0,0 +1,2271 @@
++/* LzmaEnc.c -- LZMA Encoder
++2009-11-24 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++/* #define SHOW_STAT */
++/* #define SHOW_STAT2 */
++
++#if defined(SHOW_STAT) || defined(SHOW_STAT2)
++#include <stdio.h>
++#endif
++
++#include "LzmaEnc.h"
++
++/* disable MT */
++#define _7ZIP_ST
++
++#include "LzFind.h"
++#ifndef _7ZIP_ST
++#include "LzFindMt.h"
++#endif
++
++#ifdef SHOW_STAT
++static int ttt = 0;
++#endif
++
++#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
++
++#define kBlockSize (9 << 10)
++#define kUnpackBlockSize (1 << 18)
++#define kMatchArraySize (1 << 21)
++#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
++
++#define kNumMaxDirectBits (31)
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++#define kProbInitValue (kBitModelTotal >> 1)
++
++#define kNumMoveReducingBits 4
++#define kNumBitPriceShiftBits 4
++#define kBitPrice (1 << kNumBitPriceShiftBits)
++
++void LzmaEncProps_Init(CLzmaEncProps *p)
++{
++  p->level = 5;
++  p->dictSize = p->mc = 0;
++  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
++  p->writeEndMark = 0;
++}
++
++void LzmaEncProps_Normalize(CLzmaEncProps *p)
++{
++  int level = p->level;
++  if (level < 0) level = 5;
++  p->level = level;
++  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
++  if (p->lc < 0) p->lc = 3;
++  if (p->lp < 0) p->lp = 0;
++  if (p->pb < 0) p->pb = 2;
++  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
++  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
++  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
++  if (p->numHashBytes < 0) p->numHashBytes = 4;
++  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
++  if (p->numThreads < 0)
++    p->numThreads =
++      #ifndef _7ZIP_ST
++      ((p->btMode && p->algo) ? 2 : 1);
++      #else
++      1;
++      #endif
++}
++
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++{
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++  return props.dictSize;
++}
++
++/* #define LZMA_LOG_BSR */
++/* Define it for Intel's CPU */
++
++
++#ifdef LZMA_LOG_BSR
++
++#define kDicLogSizeMaxCompress 30
++
++#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
++
++UInt32 GetPosSlot1(UInt32 pos)
++{
++  UInt32 res;
++  BSR2_RET(pos, res);
++  return res;
++}
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
++
++#else
++
++#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
++#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
++
++void LzmaEnc_FastPosInit(Byte *g_FastPos)
++{
++  int c = 2, slotFast;
++  g_FastPos[0] = 0;
++  g_FastPos[1] = 1;
++  
++  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
++  {
++    UInt32 k = (1 << ((slotFast >> 1) - 1));
++    UInt32 j;
++    for (j = 0; j < k; j++, c++)
++      g_FastPos[c] = (Byte)slotFast;
++  }
++}
++
++#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
++  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
++  res = p->g_FastPos[pos >> i] + (i * 2); }
++/*
++#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
++  p->g_FastPos[pos >> 6] + 12 : \
++  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
++*/
++
++#define GetPosSlot1(pos) p->g_FastPos[pos]
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
++
++#endif
++
++
++#define LZMA_NUM_REPS 4
++
++typedef unsigned CState;
++
++typedef struct
++{
++  UInt32 price;
++
++  CState state;
++  int prev1IsChar;
++  int prev2;
++
++  UInt32 posPrev2;
++  UInt32 backPrev2;
++
++  UInt32 posPrev;
++  UInt32 backPrev;
++  UInt32 backs[LZMA_NUM_REPS];
++} COptimal;
++
++#define kNumOpts (1 << 12)
++
++#define kNumLenToPosStates 4
++#define kNumPosSlotBits 6
++#define kDicLogSizeMin 0
++#define kDicLogSizeMax 32
++#define kDistTableSizeMax (kDicLogSizeMax * 2)
++
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++#define kAlignMask (kAlignTableSize - 1)
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
++
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++#define LZMA_PB_MAX 4
++#define LZMA_LC_MAX 8
++#define LZMA_LP_MAX 4
++
++#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
++
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define LZMA_MATCH_LEN_MIN 2
++#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
++
++#define kNumStates 12
++
++typedef struct
++{
++  CLzmaProb choice;
++  CLzmaProb choice2;
++  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
++  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
++  CLzmaProb high[kLenNumHighSymbols];
++} CLenEnc;
++
++typedef struct
++{
++  CLenEnc p;
++  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
++  UInt32 tableSize;
++  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
++} CLenPriceEnc;
++
++typedef struct
++{
++  UInt32 range;
++  Byte cache;
++  UInt64 low;
++  UInt64 cacheSize;
++  Byte *buf;
++  Byte *bufLim;
++  Byte *bufBase;
++  ISeqOutStream *outStream;
++  UInt64 processed;
++  SRes res;
++} CRangeEnc;
++
++typedef struct
++{
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++  
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++} CSaveState;
++
++typedef struct
++{
++  IMatchFinder matchFinder;
++  void *matchFinderObj;
++
++  #ifndef _7ZIP_ST
++  Bool mtMode;
++  CMatchFinderMt matchFinderMt;
++  #endif
++
++  CMatchFinder matchFinderBase;
++
++  #ifndef _7ZIP_ST
++  Byte pad[128];
++  #endif
++  
++  UInt32 optimumEndIndex;
++  UInt32 optimumCurrentIndex;
++
++  UInt32 longestMatchLength;
++  UInt32 numPairs;
++  UInt32 numAvail;
++  COptimal opt[kNumOpts];
++  
++  #ifndef LZMA_LOG_BSR
++  Byte g_FastPos[1 << kNumLogBits];
++  #endif
++
++  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
++  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
++  UInt32 numFastBytes;
++  UInt32 additionalOffset;
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++
++  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
++  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
++  UInt32 alignPrices[kAlignTableSize];
++  UInt32 alignPriceCount;
++
++  UInt32 distTableSize;
++
++  unsigned lc, lp, pb;
++  unsigned lpMask, pbMask;
++
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++  
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  unsigned lclp;
++
++  Bool fastMode;
++  
++  CRangeEnc rc;
++
++  Bool writeEndMark;
++  UInt64 nowPos64;
++  UInt32 matchPriceCount;
++  Bool finished;
++  Bool multiThread;
++
++  SRes result;
++  UInt32 dictSize;
++  UInt32 matchFinderCycles;
++
++  int needInit;
++
++  CSaveState saveState;
++} CLzmaEnc;
++
++void LzmaEnc_SaveState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CSaveState *dest = &p->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
++}
++
++void LzmaEnc_RestoreState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *dest = (CLzmaEnc *)pp;
++  const CSaveState *p = &dest->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
++}
++
++SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++
++  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
++      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
++    return SZ_ERROR_PARAM;
++  p->dictSize = props.dictSize;
++  p->matchFinderCycles = props.mc;
++  {
++    unsigned fb = props.fb;
++    if (fb < 5)
++      fb = 5;
++    if (fb > LZMA_MATCH_LEN_MAX)
++      fb = LZMA_MATCH_LEN_MAX;
++    p->numFastBytes = fb;
++  }
++  p->lc = props.lc;
++  p->lp = props.lp;
++  p->pb = props.pb;
++  p->fastMode = (props.algo == 0);
++  p->matchFinderBase.btMode = props.btMode;
++  {
++    UInt32 numHashBytes = 4;
++    if (props.btMode)
++    {
++      if (props.numHashBytes < 2)
++        numHashBytes = 2;
++      else if (props.numHashBytes < 4)
++        numHashBytes = props.numHashBytes;
++    }
++    p->matchFinderBase.numHashBytes = numHashBytes;
++  }
++
++  p->matchFinderBase.cutValue = props.mc;
++
++  p->writeEndMark = props.writeEndMark;
++
++  #ifndef _7ZIP_ST
++  /*
++  if (newMultiThread != _multiThread)
++  {
++    ReleaseMatchFinder();
++    _multiThread = newMultiThread;
++  }
++  */
++  p->multiThread = (props.numThreads > 1);
++  #endif
++
++  return SZ_OK;
++}
++
++static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
++static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
++static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
++static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
++
++#define IsCharState(s) ((s) < 7)
++
++#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
++
++#define kInfinityPrice (1 << 30)
++
++static void RangeEnc_Construct(CRangeEnc *p)
++{
++  p->outStream = 0;
++  p->bufBase = 0;
++}
++
++#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
++
++#define RC_BUF_SIZE (1 << 16)
++static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
++{
++  if (p->bufBase == 0)
++  {
++    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
++    if (p->bufBase == 0)
++      return 0;
++    p->bufLim = p->bufBase + RC_BUF_SIZE;
++  }
++  return 1;
++}
++
++static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->bufBase);
++  p->bufBase = 0;
++}
++
++static void RangeEnc_Init(CRangeEnc *p)
++{
++  /* Stream.Init(); */
++  p->low = 0;
++  p->range = 0xFFFFFFFF;
++  p->cacheSize = 1;
++  p->cache = 0;
++
++  p->buf = p->bufBase;
++
++  p->processed = 0;
++  p->res = SZ_OK;
++}
++
++static void RangeEnc_FlushStream(CRangeEnc *p)
++{
++  size_t num;
++  if (p->res != SZ_OK)
++    return;
++  num = p->buf - p->bufBase;
++  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
++    p->res = SZ_ERROR_WRITE;
++  p->processed += num;
++  p->buf = p->bufBase;
++}
++
++static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
++{
++  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
++  {
++    Byte temp = p->cache;
++    do
++    {
++      Byte *buf = p->buf;
++      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
++      p->buf = buf;
++      if (buf == p->bufLim)
++        RangeEnc_FlushStream(p);
++      temp = 0xFF;
++    }
++    while (--p->cacheSize != 0);
++    p->cache = (Byte)((UInt32)p->low >> 24);
++  }
++  p->cacheSize++;
++  p->low = (UInt32)p->low << 8;
++}
++
++static void RangeEnc_FlushData(CRangeEnc *p)
++{
++  int i;
++  for (i = 0; i < 5; i++)
++    RangeEnc_ShiftLow(p);
++}
++
++static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
++{
++  do
++  {
++    p->range >>= 1;
++    p->low += p->range & (0 - ((value >> --numBits) & 1));
++    if (p->range < kTopValue)
++    {
++      p->range <<= 8;
++      RangeEnc_ShiftLow(p);
++    }
++  }
++  while (numBits != 0);
++}
++
++static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
++{
++  UInt32 ttt = *prob;
++  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
++  if (symbol == 0)
++  {
++    p->range = newBound;
++    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
++  }
++  else
++  {
++    p->low += newBound;
++    p->range -= newBound;
++    ttt -= ttt >> kNumMoveBits;
++  }
++  *prob = (CLzmaProb)ttt;
++  if (p->range < kTopValue)
++  {
++    p->range <<= 8;
++    RangeEnc_ShiftLow(p);
++  }
++}
++
++static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
++{
++  symbol |= 0x100;
++  do
++  {
++    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++}
++
++static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
++{
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++}
++
++void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++{
++  UInt32 i;
++  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
++  {
++    const int kCyclesBits = kNumBitPriceShiftBits;
++    UInt32 w = i;
++    UInt32 bitCount = 0;
++    int j;
++    for (j = 0; j < kCyclesBits; j++)
++    {
++      w = w * w;
++      bitCount <<= 1;
++      while (w >= ((UInt32)1 << 16))
++      {
++        w >>= 1;
++        bitCount++;
++      }
++    }
++    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
++  }
++}
++
++
++#define GET_PRICE(prob, symbol) \
++  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICEa(prob, symbol) \
++  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= 0x100;
++  do
++  {
++    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++
++static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0;)
++  {
++    UInt32 bit;
++    i--;
++    bit = (symbol >> i) & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++  }
++}
++
++static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = 0; i < numBitLevels; i++)
++  {
++    UInt32 bit = symbol & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++    symbol >>= 1;
++  }
++}
++
++static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= (1 << numBitLevels);
++  while (symbol != 1)
++  {
++    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
++    symbol >>= 1;
++  }
++  return price;
++}
++
++static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0; i--)
++  {
++    UInt32 bit = symbol & 1;
++    symbol >>= 1;
++    price += GET_PRICEa(probs[m], bit);
++    m = (m << 1) | bit;
++  }
++  return price;
++}
++
++
++static void LenEnc_Init(CLenEnc *p)
++{
++  unsigned i;
++  p->choice = p->choice2 = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
++    p->low[i] = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
++    p->mid[i] = kProbInitValue;
++  for (i = 0; i < kLenNumHighSymbols; i++)
++    p->high[i] = kProbInitValue;
++}
++
++static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
++{
++  if (symbol < kLenNumLowSymbols)
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 0);
++    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
++  }
++  else
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 1);
++    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 0);
++      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
++    }
++    else
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 1);
++      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
++    }
++  }
++}
++
++static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
++{
++  UInt32 a0 = GET_PRICE_0a(p->choice);
++  UInt32 a1 = GET_PRICE_1a(p->choice);
++  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
++  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
++  UInt32 i = 0;
++  for (i = 0; i < kLenNumLowSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
++  }
++  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
++  }
++  for (; i < numSymbols; i++)
++    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
++}
++
++static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
++{
++  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
++  p->counters[posState] = p->tableSize;
++}
++
++static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
++{
++  UInt32 posState;
++  for (posState = 0; posState < numPosStates; posState++)
++    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
++{
++  LenEnc_Encode(&p->p, rc, symbol, posState);
++  if (updatePrice)
++    if (--p->counters[posState] == 0)
++      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++
++
++
++static void MovePos(CLzmaEnc *p, UInt32 num)
++{
++  #ifdef SHOW_STAT
++  ttt += num;
++  printf("\n MovePos %d", num);
++  #endif
++  if (num != 0)
++  {
++    p->additionalOffset += num;
++    p->matchFinder.Skip(p->matchFinderObj, num);
++  }
++}
++
++static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
++{
++  UInt32 lenRes = 0, numPairs;
++  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
++  #ifdef SHOW_STAT
++  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
++  ttt++;
++  {
++    UInt32 i;
++    for (i = 0; i < numPairs; i += 2)
++      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
++  }
++  #endif
++  if (numPairs > 0)
++  {
++    lenRes = p->matches[numPairs - 2];
++    if (lenRes == p->numFastBytes)
++    {
++      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++      UInt32 distance = p->matches[numPairs - 1] + 1;
++      UInt32 numAvail = p->numAvail;
++      if (numAvail > LZMA_MATCH_LEN_MAX)
++        numAvail = LZMA_MATCH_LEN_MAX;
++      {
++        const Byte *pby2 = pby - distance;
++        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
++      }
++    }
++  }
++  p->additionalOffset++;
++  *numDistancePairsRes = numPairs;
++  return lenRes;
++}
++
++
++#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
++#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
++#define IsShortRep(p) ((p)->backPrev == 0)
++
++static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
++{
++  return
++    GET_PRICE_0(p->isRepG0[state]) +
++    GET_PRICE_0(p->isRep0Long[state][posState]);
++}
++
++static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
++{
++  UInt32 price;
++  if (repIndex == 0)
++  {
++    price = GET_PRICE_0(p->isRepG0[state]);
++    price += GET_PRICE_1(p->isRep0Long[state][posState]);
++  }
++  else
++  {
++    price = GET_PRICE_1(p->isRepG0[state]);
++    if (repIndex == 1)
++      price += GET_PRICE_0(p->isRepG1[state]);
++    else
++    {
++      price += GET_PRICE_1(p->isRepG1[state]);
++      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
++    }
++  }
++  return price;
++}
++
++static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
++{
++  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
++    GetPureRepPrice(p, repIndex, state, posState);
++}
++
++static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
++{
++  UInt32 posMem = p->opt[cur].posPrev;
++  UInt32 backMem = p->opt[cur].backPrev;
++  p->optimumEndIndex = cur;
++  do
++  {
++    if (p->opt[cur].prev1IsChar)
++    {
++      MakeAsChar(&p->opt[posMem])
++      p->opt[posMem].posPrev = posMem - 1;
++      if (p->opt[cur].prev2)
++      {
++        p->opt[posMem - 1].prev1IsChar = False;
++        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
++        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
++      }
++    }
++    {
++      UInt32 posPrev = posMem;
++      UInt32 backCur = backMem;
++      
++      backMem = p->opt[posPrev].backPrev;
++      posMem = p->opt[posPrev].posPrev;
++      
++      p->opt[posPrev].backPrev = backCur;
++      p->opt[posPrev].posPrev = cur;
++      cur = posPrev;
++    }
++  }
++  while (cur != 0);
++  *backRes = p->opt[0].backPrev;
++  p->optimumCurrentIndex  = p->opt[0].posPrev;
++  return p->optimumCurrentIndex;
++}
++
++#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
++
++static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
++  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
++  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
++  UInt32 *matches;
++  const Byte *data;
++  Byte curByte, matchByte;
++  if (p->optimumEndIndex != p->optimumCurrentIndex)
++  {
++    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
++    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
++    *backRes = opt->backPrev;
++    p->optimumCurrentIndex = opt->posPrev;
++    return lenRes;
++  }
++  p->optimumCurrentIndex = p->optimumEndIndex = 0;
++  
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  if (numAvail < 2)
++  {
++    *backRes = (UInt32)(-1);
++    return 1;
++  }
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  repMaxIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 lenTest;
++    const Byte *data2;
++    reps[i] = p->reps[i];
++    data2 = data - (reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++    {
++      repLens[i] = 0;
++      continue;
++    }
++    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++    repLens[i] = lenTest;
++    if (lenTest > repLens[repMaxIndex])
++      repMaxIndex = i;
++  }
++  if (repLens[repMaxIndex] >= p->numFastBytes)
++  {
++    UInt32 lenRes;
++    *backRes = repMaxIndex;
++    lenRes = repLens[repMaxIndex];
++    MovePos(p, lenRes - 1);
++    return lenRes;
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++  curByte = *data;
++  matchByte = *(data - (reps[0] + 1));
++
++  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
++  {
++    *backRes = (UInt32)-1;
++    return 1;
++  }
++
++  p->opt[0].state = (CState)p->state;
++
++  posState = (position & p->pbMask);
++
++  {
++    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
++        (!IsCharState(p->state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++  }
++
++  MakeAsChar(&p->opt[1]);
++
++  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
++  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
++
++  if (matchByte == curByte)
++  {
++    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
++    if (shortRepPrice < p->opt[1].price)
++    {
++      p->opt[1].price = shortRepPrice;
++      MakeAsShortRep(&p->opt[1]);
++    }
++  }
++  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
++
++  if (lenEnd < 2)
++  {
++    *backRes = p->opt[1].backPrev;
++    return 1;
++  }
++
++  p->opt[1].posPrev = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++    p->opt[0].backs[i] = reps[i];
++
++  len = lenEnd;
++  do
++    p->opt[len--].price = kInfinityPrice;
++  while (len >= 2);
++
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 repLen = repLens[i];
++    UInt32 price;
++    if (repLen < 2)
++      continue;
++    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
++    do
++    {
++      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
++      COptimal *opt = &p->opt[repLen];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = i;
++        opt->prev1IsChar = False;
++      }
++    }
++    while (--repLen >= 2);
++  }
++
++  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
++
++  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
++  if (len <= mainLen)
++  {
++    UInt32 offs = 0;
++    while (len > matches[offs])
++      offs += 2;
++    for (; ; len++)
++    {
++      COptimal *opt;
++      UInt32 distance = matches[offs + 1];
++
++      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
++      UInt32 lenToPosState = GetLenToPosState(len);
++      if (distance < kNumFullDistances)
++        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
++      else
++      {
++        UInt32 slot;
++        GetPosSlot2(distance, slot);
++        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
++      }
++      opt = &p->opt[len];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = distance + LZMA_NUM_REPS;
++        opt->prev1IsChar = False;
++      }
++      if (len == matches[offs])
++      {
++        offs += 2;
++        if (offs == numPairs)
++          break;
++      }
++    }
++  }
++
++  cur = 0;
++
++    #ifdef SHOW_STAT2
++    if (position >= 0)
++    {
++      unsigned i;
++      printf("\n pos = %4X", position);
++      for (i = cur; i <= lenEnd; i++)
++      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
++    }
++    #endif
++
++  for (;;)
++  {
++    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
++    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
++    Bool nextIsChar;
++    Byte curByte, matchByte;
++    const Byte *data;
++    COptimal *curOpt;
++    COptimal *nextOpt;
++
++    cur++;
++    if (cur == lenEnd)
++      return Backward(p, backRes, cur);
++
++    newLen = ReadMatchDistances(p, &numPairs);
++    if (newLen >= p->numFastBytes)
++    {
++      p->numPairs = numPairs;
++      p->longestMatchLength = newLen;
++      return Backward(p, backRes, cur);
++    }
++    position++;
++    curOpt = &p->opt[cur];
++    posPrev = curOpt->posPrev;
++    if (curOpt->prev1IsChar)
++    {
++      posPrev--;
++      if (curOpt->prev2)
++      {
++        state = p->opt[curOpt->posPrev2].state;
++        if (curOpt->backPrev2 < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      else
++        state = p->opt[posPrev].state;
++      state = kLiteralNextStates[state];
++    }
++    else
++      state = p->opt[posPrev].state;
++    if (posPrev == cur - 1)
++    {
++      if (IsShortRep(curOpt))
++        state = kShortRepNextStates[state];
++      else
++        state = kLiteralNextStates[state];
++    }
++    else
++    {
++      UInt32 pos;
++      const COptimal *prevOpt;
++      if (curOpt->prev1IsChar && curOpt->prev2)
++      {
++        posPrev = curOpt->posPrev2;
++        pos = curOpt->backPrev2;
++        state = kRepNextStates[state];
++      }
++      else
++      {
++        pos = curOpt->backPrev;
++        if (pos < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      prevOpt = &p->opt[posPrev];
++      if (pos < LZMA_NUM_REPS)
++      {
++        UInt32 i;
++        reps[0] = prevOpt->backs[pos];
++        for (i = 1; i <= pos; i++)
++          reps[i] = prevOpt->backs[i - 1];
++        for (; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i];
++      }
++      else
++      {
++        UInt32 i;
++        reps[0] = (pos - LZMA_NUM_REPS);
++        for (i = 1; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i - 1];
++      }
++    }
++    curOpt->state = (CState)state;
++
++    curOpt->backs[0] = reps[0];
++    curOpt->backs[1] = reps[1];
++    curOpt->backs[2] = reps[2];
++    curOpt->backs[3] = reps[3];
++
++    curPrice = curOpt->price;
++    nextIsChar = False;
++    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++    curByte = *data;
++    matchByte = *(data - (reps[0] + 1));
++
++    posState = (position & p->pbMask);
++
++    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
++    {
++      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++      curAnd1Price +=
++        (!IsCharState(state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++    }
++
++    nextOpt = &p->opt[cur + 1];
++
++    if (curAnd1Price < nextOpt->price)
++    {
++      nextOpt->price = curAnd1Price;
++      nextOpt->posPrev = cur;
++      MakeAsChar(nextOpt);
++      nextIsChar = True;
++    }
++
++    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
++    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
++    
++    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
++    {
++      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
++      if (shortRepPrice <= nextOpt->price)
++      {
++        nextOpt->price = shortRepPrice;
++        nextOpt->posPrev = cur;
++        MakeAsShortRep(nextOpt);
++        nextIsChar = True;
++      }
++    }
++    numAvailFull = p->numAvail;
++    {
++      UInt32 temp = kNumOpts - 1 - cur;
++      if (temp < numAvailFull)
++        numAvailFull = temp;
++    }
++
++    if (numAvailFull < 2)
++      continue;
++    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
++
++    if (!nextIsChar && matchByte != curByte) /* speed optimization */
++    {
++      /* try Literal + rep0 */
++      UInt32 temp;
++      UInt32 lenTest2;
++      const Byte *data2 = data - (reps[0] + 1);
++      UInt32 limit = p->numFastBytes + 1;
++      if (limit > numAvailFull)
++        limit = numAvailFull;
++
++      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
++      lenTest2 = temp - 1;
++      if (lenTest2 >= 2)
++      {
++        UInt32 state2 = kLiteralNextStates[state];
++        UInt32 posStateNext = (position + 1) & p->pbMask;
++        UInt32 nextRepMatchPrice = curAnd1Price +
++            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++            GET_PRICE_1(p->isRep[state2]);
++        /* for (; lenTest2 >= 2; lenTest2--) */
++        {
++          UInt32 curAndLenPrice;
++          COptimal *opt;
++          UInt32 offset = cur + 1 + lenTest2;
++          while (lenEnd < offset)
++            p->opt[++lenEnd].price = kInfinityPrice;
++          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++          opt = &p->opt[offset];
++          if (curAndLenPrice < opt->price)
++          {
++            opt->price = curAndLenPrice;
++            opt->posPrev = cur + 1;
++            opt->backPrev = 0;
++            opt->prev1IsChar = True;
++            opt->prev2 = False;
++          }
++        }
++      }
++    }
++    
++    startLen = 2; /* speed optimization */
++    {
++    UInt32 repIndex;
++    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
++    {
++      UInt32 lenTest;
++      UInt32 lenTestTemp;
++      UInt32 price;
++      const Byte *data2 = data - (reps[repIndex] + 1);
++      if (data[0] != data2[0] || data[1] != data2[1])
++        continue;
++      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++      while (lenEnd < cur + lenTest)
++        p->opt[++lenEnd].price = kInfinityPrice;
++      lenTestTemp = lenTest;
++      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
++      do
++      {
++        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
++        COptimal *opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = repIndex;
++          opt->prev1IsChar = False;
++        }
++      }
++      while (--lenTest >= 2);
++      lenTest = lenTestTemp;
++      
++      if (repIndex == 0)
++        startLen = lenTest + 1;
++        
++      /* if (_maxMode) */
++        {
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kRepNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice =
++                price + p->repLenEnc.prices[posState][lenTest - 2] +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (position + lenTest + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++            
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = repIndex;
++              }
++            }
++          }
++        }
++    }
++    }
++    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
++    if (newLen > numAvail)
++    {
++      newLen = numAvail;
++      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
++      matches[numPairs] = newLen;
++      numPairs += 2;
++    }
++    if (newLen >= startLen)
++    {
++      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
++      UInt32 offs, curBack, posSlot;
++      UInt32 lenTest;
++      while (lenEnd < cur + newLen)
++        p->opt[++lenEnd].price = kInfinityPrice;
++
++      offs = 0;
++      while (startLen > matches[offs])
++        offs += 2;
++      curBack = matches[offs + 1];
++      GetPosSlot2(curBack, posSlot);
++      for (lenTest = /*2*/ startLen; ; lenTest++)
++      {
++        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
++        UInt32 lenToPosState = GetLenToPosState(lenTest);
++        COptimal *opt;
++        if (curBack < kNumFullDistances)
++          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
++        else
++          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
++        
++        opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = curBack + LZMA_NUM_REPS;
++          opt->prev1IsChar = False;
++        }
++
++        if (/*_maxMode && */lenTest == matches[offs])
++        {
++          /* Try Match + Literal + Rep0 */
++          const Byte *data2 = data - (curBack + 1);
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kMatchNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice = curAndLenPrice +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (posStateNext + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++            
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = curBack + LZMA_NUM_REPS;
++              }
++            }
++          }
++          offs += 2;
++          if (offs == numPairs)
++            break;
++          curBack = matches[offs + 1];
++          if (curBack >= kNumFullDistances)
++            GetPosSlot2(curBack, posSlot);
++        }
++      }
++    }
++  }
++}
++
++#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
++
++static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
++  const Byte *data;
++  const UInt32 *matches;
++
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  *backRes = (UInt32)-1;
++  if (numAvail < 2)
++    return 1;
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++
++  repLen = repIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
++    if (len >= p->numFastBytes)
++    {
++      *backRes = i;
++      MovePos(p, len - 1);
++      return len;
++    }
++    if (len > repLen)
++    {
++      repIndex = i;
++      repLen = len;
++    }
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++
++  mainDist = 0; /* for GCC */
++  if (mainLen >= 2)
++  {
++    mainDist = matches[numPairs - 1];
++    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
++    {
++      if (!ChangePair(matches[numPairs - 3], mainDist))
++        break;
++      numPairs -= 2;
++      mainLen = matches[numPairs - 2];
++      mainDist = matches[numPairs - 1];
++    }
++    if (mainLen == 2 && mainDist >= 0x80)
++      mainLen = 1;
++  }
++
++  if (repLen >= 2 && (
++        (repLen + 1 >= mainLen) ||
++        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
++        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
++  {
++    *backRes = repIndex;
++    MovePos(p, repLen - 1);
++    return repLen;
++  }
++  
++  if (mainLen < 2 || numAvail <= 2)
++    return 1;
++
++  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
++  if (p->longestMatchLength >= 2)
++  {
++    UInt32 newDistance = matches[p->numPairs - 1];
++    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
++        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
++        (p->longestMatchLength > mainLen + 1) ||
++        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
++      return 1;
++  }
++  
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len, limit;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    limit = mainLen - 1;
++    for (len = 2; len < limit && data[len] == data2[len]; len++);
++    if (len >= limit)
++      return 1;
++  }
++  *backRes = mainDist + LZMA_NUM_REPS;
++  MovePos(p, mainLen - 2);
++  return mainLen;
++}
++
++static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
++{
++  UInt32 len;
++  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++  p->state = kMatchNextStates[p->state];
++  len = LZMA_MATCH_LEN_MIN;
++  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
++  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
++  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
++}
++
++static SRes CheckErrors(CLzmaEnc *p)
++{
++  if (p->result != SZ_OK)
++    return p->result;
++  if (p->rc.res != SZ_OK)
++    p->result = SZ_ERROR_WRITE;
++  if (p->matchFinderBase.result != SZ_OK)
++    p->result = SZ_ERROR_READ;
++  if (p->result != SZ_OK)
++    p->finished = True;
++  return p->result;
++}
++
++static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
++{
++  /* ReleaseMFStream(); */
++  p->finished = True;
++  if (p->writeEndMark)
++    WriteEndMarker(p, nowPos & p->pbMask);
++  RangeEnc_FlushData(&p->rc);
++  RangeEnc_FlushStream(&p->rc);
++  return CheckErrors(p);
++}
++
++static void FillAlignPrices(CLzmaEnc *p)
++{
++  UInt32 i;
++  for (i = 0; i < kAlignTableSize; i++)
++    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
++  p->alignPriceCount = 0;
++}
++
++static void FillDistancesPrices(CLzmaEnc *p)
++{
++  UInt32 tempPrices[kNumFullDistances];
++  UInt32 i, lenToPosState;
++  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
++  {
++    UInt32 posSlot = GetPosSlot1(i);
++    UInt32 footerBits = ((posSlot >> 1) - 1);
++    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
++  }
++
++  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
++  {
++    UInt32 posSlot;
++    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
++    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
++    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
++    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
++
++    {
++      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
++      UInt32 i;
++      for (i = 0; i < kStartPosModelIndex; i++)
++        distancesPrices[i] = posSlotPrices[i];
++      for (; i < kNumFullDistances; i++)
++        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
++    }
++  }
++  p->matchPriceCount = 0;
++}
++
++void LzmaEnc_Construct(CLzmaEnc *p)
++{
++  RangeEnc_Construct(&p->rc);
++  MatchFinder_Construct(&p->matchFinderBase);
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Construct(&p->matchFinderMt);
++  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
++  #endif
++
++  {
++    CLzmaEncProps props;
++    LzmaEncProps_Init(&props);
++    LzmaEnc_SetProps(p, &props);
++  }
++
++  #ifndef LZMA_LOG_BSR
++  LzmaEnc_FastPosInit(p->g_FastPos);
++  #endif
++
++  LzmaEnc_InitPriceTables(p->ProbPrices);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
++{
++  void *p;
++  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
++  if (p != 0)
++    LzmaEnc_Construct((CLzmaEnc *)p);
++  return p;
++}
++
++void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->litProbs);
++  alloc->Free(alloc, p->saveState.litProbs);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
++  #endif
++  MatchFinder_Free(&p->matchFinderBase, allocBig);
++  LzmaEnc_FreeLits(p, alloc);
++  RangeEnc_Free(&p->rc, alloc);
++}
++
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
++  alloc->Free(alloc, p);
++}
++
++static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
++{
++  UInt32 nowPos32, startPos32;
++  if (p->needInit)
++  {
++    p->matchFinder.Init(p->matchFinderObj);
++    p->needInit = 0;
++  }
++
++  if (p->finished)
++    return p->result;
++  RINOK(CheckErrors(p));
++
++  nowPos32 = (UInt32)p->nowPos64;
++  startPos32 = nowPos32;
++
++  if (p->nowPos64 == 0)
++  {
++    UInt32 numPairs;
++    Byte curByte;
++    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++      return Flush(p, nowPos32);
++    ReadMatchDistances(p, &numPairs);
++    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
++    p->state = kLiteralNextStates[p->state];
++    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
++    LitEnc_Encode(&p->rc, p->litProbs, curByte);
++    p->additionalOffset--;
++    nowPos32++;
++  }
++
++  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
++  for (;;)
++  {
++    UInt32 pos, len, posState;
++
++    if (p->fastMode)
++      len = GetOptimumFast(p, &pos);
++    else
++      len = GetOptimum(p, nowPos32, &pos);
++
++    #ifdef SHOW_STAT2
++    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
++    #endif
++
++    posState = nowPos32 & p->pbMask;
++    if (len == 1 && pos == (UInt32)-1)
++    {
++      Byte curByte;
++      CLzmaProb *probs;
++      const Byte *data;
++
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
++      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++      curByte = *data;
++      probs = LIT_PROBS(nowPos32, *(data - 1));
++      if (IsCharState(p->state))
++        LitEnc_Encode(&p->rc, probs, curByte);
++      else
++        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
++      p->state = kLiteralNextStates[p->state];
++    }
++    else
++    {
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++      if (pos < LZMA_NUM_REPS)
++      {
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
++        if (pos == 0)
++        {
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
++          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
++        }
++        else
++        {
++          UInt32 distance = p->reps[pos];
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
++          if (pos == 1)
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
++          else
++          {
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
++            if (pos == 3)
++              p->reps[3] = p->reps[2];
++            p->reps[2] = p->reps[1];
++          }
++          p->reps[1] = p->reps[0];
++          p->reps[0] = distance;
++        }
++        if (len == 1)
++          p->state = kShortRepNextStates[p->state];
++        else
++        {
++          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++          p->state = kRepNextStates[p->state];
++        }
++      }
++      else
++      {
++        UInt32 posSlot;
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++        p->state = kMatchNextStates[p->state];
++        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++        pos -= LZMA_NUM_REPS;
++        GetPosSlot(pos, posSlot);
++        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
++        
++        if (posSlot >= kStartPosModelIndex)
++        {
++          UInt32 footerBits = ((posSlot >> 1) - 1);
++          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++          UInt32 posReduced = pos - base;
++
++          if (posSlot < kEndPosModelIndex)
++            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
++          else
++          {
++            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
++            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
++            p->alignPriceCount++;
++          }
++        }
++        p->reps[3] = p->reps[2];
++        p->reps[2] = p->reps[1];
++        p->reps[1] = p->reps[0];
++        p->reps[0] = pos;
++        p->matchPriceCount++;
++      }
++    }
++    p->additionalOffset -= len;
++    nowPos32 += len;
++    if (p->additionalOffset == 0)
++    {
++      UInt32 processed;
++      if (!p->fastMode)
++      {
++        if (p->matchPriceCount >= (1 << 7))
++          FillDistancesPrices(p);
++        if (p->alignPriceCount >= kAlignTableSize)
++          FillAlignPrices(p);
++      }
++      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++        break;
++      processed = nowPos32 - startPos32;
++      if (useLimits)
++      {
++        if (processed + kNumOpts + 300 >= maxUnpackSize ||
++            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
++          break;
++      }
++      else if (processed >= (1 << 15))
++      {
++        p->nowPos64 += nowPos32 - startPos32;
++        return CheckErrors(p);
++      }
++    }
++  }
++  p->nowPos64 += nowPos32 - startPos32;
++  return Flush(p, nowPos32);
++}
++
++#define kBigHashDicLimit ((UInt32)1 << 24)
++
++static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 beforeSize = kNumOpts;
++  Bool btMode;
++  if (!RangeEnc_Alloc(&p->rc, alloc))
++    return SZ_ERROR_MEM;
++  btMode = (p->matchFinderBase.btMode != 0);
++  #ifndef _7ZIP_ST
++  p->mtMode = (p->multiThread && !p->fastMode && btMode);
++  #endif
++
++  {
++    unsigned lclp = p->lc + p->lp;
++    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
++    {
++      LzmaEnc_FreeLits(p, alloc);
++      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      if (p->litProbs == 0 || p->saveState.litProbs == 0)
++      {
++        LzmaEnc_FreeLits(p, alloc);
++        return SZ_ERROR_MEM;
++      }
++      p->lclp = lclp;
++    }
++  }
++
++  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
++
++  if (beforeSize + p->dictSize < keepWindowSize)
++    beforeSize = keepWindowSize - p->dictSize;
++
++  #ifndef _7ZIP_ST
++  if (p->mtMode)
++  {
++    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
++    p->matchFinderObj = &p->matchFinderMt;
++    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
++  }
++  else
++  #endif
++  {
++    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
++      return SZ_ERROR_MEM;
++    p->matchFinderObj = &p->matchFinderBase;
++    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
++  }
++  return SZ_OK;
++}
++
++void LzmaEnc_Init(CLzmaEnc *p)
++{
++  UInt32 i;
++  p->state = 0;
++  for (i = 0 ; i < LZMA_NUM_REPS; i++)
++    p->reps[i] = 0;
++
++  RangeEnc_Init(&p->rc);
++
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    UInt32 j;
++    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
++    {
++      p->isMatch[i][j] = kProbInitValue;
++      p->isRep0Long[i][j] = kProbInitValue;
++    }
++    p->isRep[i] = kProbInitValue;
++    p->isRepG0[i] = kProbInitValue;
++    p->isRepG1[i] = kProbInitValue;
++    p->isRepG2[i] = kProbInitValue;
++  }
++
++  {
++    UInt32 num = 0x300 << (p->lp + p->lc);
++    for (i = 0; i < num; i++)
++      p->litProbs[i] = kProbInitValue;
++  }
++
++  {
++    for (i = 0; i < kNumLenToPosStates; i++)
++    {
++      CLzmaProb *probs = p->posSlotEncoder[i];
++      UInt32 j;
++      for (j = 0; j < (1 << kNumPosSlotBits); j++)
++        probs[j] = kProbInitValue;
++    }
++  }
++  {
++    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
++      p->posEncoders[i] = kProbInitValue;
++  }
++
++  LenEnc_Init(&p->lenEnc.p);
++  LenEnc_Init(&p->repLenEnc.p);
++
++  for (i = 0; i < (1 << kNumAlignBits); i++)
++    p->posAlignEncoder[i] = kProbInitValue;
++
++  p->optimumEndIndex = 0;
++  p->optimumCurrentIndex = 0;
++  p->additionalOffset = 0;
++
++  p->pbMask = (1 << p->pb) - 1;
++  p->lpMask = (1 << p->lp) - 1;
++}
++
++void LzmaEnc_InitPrices(CLzmaEnc *p)
++{
++  if (!p->fastMode)
++  {
++    FillDistancesPrices(p);
++    FillAlignPrices(p);
++  }
++
++  p->lenEnc.tableSize =
++  p->repLenEnc.tableSize =
++      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
++  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
++  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
++}
++
++static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 i;
++  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
++    if (p->dictSize <= ((UInt32)1 << i))
++      break;
++  p->distTableSize = i * 2;
++
++  p->finished = False;
++  p->result = SZ_OK;
++  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
++  LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  p->nowPos64 = 0;
++  return SZ_OK;
++}
++
++static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  p->rc.outStream = outStream;
++  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
++}
++
++SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
++    ISeqInStream *inStream, UInt32 keepWindowSize,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
++static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
++{
++  p->matchFinderBase.directInput = 1;
++  p->matchFinderBase.bufferBase = (Byte *)src;
++  p->matchFinderBase.directInputRem = srcLen;
++}
++
++SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++  p->needInit = 1;
++
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
++void LzmaEnc_Finish(CLzmaEncHandle pp)
++{
++  #ifndef _7ZIP_ST
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  if (p->mtMode)
++    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
++  #else
++  pp = pp;
++  #endif
++}
++
++typedef struct
++{
++  ISeqOutStream funcTable;
++  Byte *data;
++  SizeT rem;
++  Bool overflow;
++} CSeqOutStreamBuf;
++
++static size_t MyWrite(void *pp, const void *data, size_t size)
++{
++  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
++  if (p->rem < size)
++  {
++    size = p->rem;
++    p->overflow = True;
++  }
++  memcpy(p->data, data, size);
++  p->rem -= size;
++  p->data += size;
++  return size;
++}
++
++
++UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++}
++
++const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++}
++
++SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
++    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  UInt64 nowPos64;
++  SRes res;
++  CSeqOutStreamBuf outStream;
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = False;
++  p->finished = False;
++  p->result = SZ_OK;
++
++  if (reInit)
++    LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  nowPos64 = p->nowPos64;
++  RangeEnc_Init(&p->rc);
++  p->rc.outStream = &outStream.funcTable;
++
++  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
++  
++  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++
++  return res;
++}
++
++static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
++{
++  SRes res = SZ_OK;
++
++  #ifndef _7ZIP_ST
++  Byte allocaDummy[0x300];
++  int i = 0;
++  for (i = 0; i < 16; i++)
++    allocaDummy[i] = (Byte)i;
++  #endif
++
++  for (;;)
++  {
++    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
++    if (res != SZ_OK || p->finished != 0)
++      break;
++    if (progress != 0)
++    {
++      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
++      if (res != SZ_OK)
++      {
++        res = SZ_ERROR_PROGRESS;
++        break;
++      }
++    }
++  }
++  LzmaEnc_Finish(p);
++  return res;
++}
++
++SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
++  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
++}
++
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  int i;
++  UInt32 dictSize = p->dictSize;
++  if (*size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_PARAM;
++  *size = LZMA_PROPS_SIZE;
++  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
++
++  for (i = 11; i <= 30; i++)
++  {
++    if (dictSize <= ((UInt32)2 << i))
++    {
++      dictSize = (2 << i);
++      break;
++    }
++    if (dictSize <= ((UInt32)3 << i))
++    {
++      dictSize = (3 << i);
++      break;
++    }
++  }
++
++  for (i = 0; i < 4; i++)
++    props[1 + i] = (Byte)(dictSize >> (8 * i));
++  return SZ_OK;
++}
++
++SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  SRes res;
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++
++  CSeqOutStreamBuf outStream;
++
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = writeEndMark;
++
++  p->rc.outStream = &outStream.funcTable;
++  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
++  if (res == SZ_OK)
++    res = LzmaEnc_Encode2(p, progress);
++
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++  return res;
++}
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
++  SRes res;
++  if (p == 0)
++    return SZ_ERROR_MEM;
++
++  res = LzmaEnc_SetProps(p, props);
++  if (res == SZ_OK)
++  {
++    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
++    if (res == SZ_OK)
++      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
++          writeEndMark, progress, alloc, allocBig);
++  }
++
++  LzmaEnc_Destroy(p, alloc, allocBig);
++  return res;
++}
+--- /dev/null
++++ b/lib/lzma/Makefile
+@@ -0,0 +1,7 @@
++lzma_compress-objs := LzFind.o LzmaEnc.o
++lzma_decompress-objs := LzmaDec.o
++
++obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
++
++EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
diff --git a/target/linux/generic/pending-4.4/531-debloat_lzma.patch b/target/linux/generic/pending-4.4/531-debloat_lzma.patch
new file mode 100644
index 0000000000..aa3c498016
--- /dev/null
+++ b/target/linux/generic/pending-4.4/531-debloat_lzma.patch
@@ -0,0 +1,1024 @@
+--- a/include/linux/lzma/LzmaDec.h
++++ b/include/linux/lzma/LzmaDec.h
+@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
+   UInt32 dicSize;
+ } CLzmaProps;
+ 
+-/* LzmaProps_Decode - decodes properties
+-Returns:
+-  SZ_OK
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+-
+ 
+ /* ---------- LZMA Decoder state ---------- */
+ 
+@@ -70,8 +62,6 @@ typedef struct
+ 
+ #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
+ 
+-void LzmaDec_Init(CLzmaDec *p);
+-
+ /* There are two types of LZMA streams:
+      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+@@ -108,97 +98,6 @@ typedef enum
+ 
+ /* ELzmaStatus is used only as output value for function call */
+ 
+-
+-/* ---------- Interfaces ---------- */
+-
+-/* There are 3 levels of interfaces:
+-     1) Dictionary Interface
+-     2) Buffer Interface
+-     3) One Call Interface
+-   You can select any of these interfaces, but don't mix functions from different
+-   groups for same object. */
+-
+-
+-/* There are two variants to allocate state for Dictionary Interface:
+-     1) LzmaDec_Allocate / LzmaDec_Free
+-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+-   You can use variant 2, if you set dictionary buffer manually.
+-   For Buffer Interface you must always use variant 1.
+-
+-LzmaDec_Allocate* can return:
+-  SZ_OK
+-  SZ_ERROR_MEM         - Memory allocation error
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-   
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+-
+-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+-
+-/* ---------- Dictionary Interface ---------- */
+-
+-/* You can use it, if you want to eliminate the overhead for data copying from
+-   dictionary to some other external buffer.
+-   You must work with CLzmaDec variables directly in this interface.
+-
+-   STEPS:
+-     LzmaDec_Constr()
+-     LzmaDec_Allocate()
+-     for (each new stream)
+-     {
+-       LzmaDec_Init()
+-       while (it needs more decompression)
+-       {
+-         LzmaDec_DecodeToDic()
+-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+-       }
+-     }
+-     LzmaDec_Free()
+-*/
+-
+-/* LzmaDec_DecodeToDic
+-   
+-   The decoding to internal dictionary buffer (CLzmaDec::dic).
+-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (dicLimit).
+-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+-  LZMA_FINISH_END - Stream must be finished after dicLimit.
+-
+-Returns:
+-  SZ_OK
+-    status:
+-      LZMA_STATUS_FINISHED_WITH_MARK
+-      LZMA_STATUS_NOT_FINISHED
+-      LZMA_STATUS_NEEDS_MORE_INPUT
+-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+-  SZ_ERROR_DATA - Data error
+-*/
+-
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+-/* ---------- Buffer Interface ---------- */
+-
+-/* It's zlib-like interface.
+-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+-   to work with CLzmaDec variables manually.
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (*destLen).
+-  LZMA_FINISH_ANY - Decode just destLen bytes.
+-  LZMA_FINISH_END - Stream must be finished after (*destLen).
+-*/
+-
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+ /* ---------- One Call Interface ---------- */
+ 
+ /* LzmaDecode
+--- a/lib/lzma/LzmaDec.c
++++ b/lib/lzma/LzmaDec.c
+@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
+   p->needFlush = 0;
+ }
+ 
+-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+ {
+   p->needFlush = 1;
+   p->remainLen = 0;
+@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
+     p->needInitState = 1;
+ }
+ 
+-void LzmaDec_Init(CLzmaDec *p)
++static void LzmaDec_Init(CLzmaDec *p)
+ {
+   p->dicPos = 0;
+   LzmaDec_InitDicAndState(p, True, True);
+@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
+   p->needInitState = 0;
+ }
+ 
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+     ELzmaFinishMode finishMode, ELzmaStatus *status)
+ {
+   SizeT inSize = *srcLen;
+@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
+   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
+ }
+ 
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+-{
+-  SizeT outSize = *destLen;
+-  SizeT inSize = *srcLen;
+-  *srcLen = *destLen = 0;
+-  for (;;)
+-  {
+-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+-    ELzmaFinishMode curFinishMode;
+-    SRes res;
+-    if (p->dicPos == p->dicBufSize)
+-      p->dicPos = 0;
+-    dicPos = p->dicPos;
+-    if (outSize > p->dicBufSize - dicPos)
+-    {
+-      outSizeCur = p->dicBufSize;
+-      curFinishMode = LZMA_FINISH_ANY;
+-    }
+-    else
+-    {
+-      outSizeCur = dicPos + outSize;
+-      curFinishMode = finishMode;
+-    }
+-
+-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
+-    src += inSizeCur;
+-    inSize -= inSizeCur;
+-    *srcLen += inSizeCur;
+-    outSizeCur = p->dicPos - dicPos;
+-    memcpy(dest, p->dic + dicPos, outSizeCur);
+-    dest += outSizeCur;
+-    outSize -= outSizeCur;
+-    *destLen += outSizeCur;
+-    if (res != 0)
+-      return res;
+-    if (outSizeCur == 0 || outSize == 0)
+-      return SZ_OK;
+-  }
+-}
+-
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->probs);
+   p->probs = 0;
+ }
+ 
+-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  alloc->Free(alloc, p->dic);
+-  p->dic = 0;
+-}
+-
+-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  LzmaDec_FreeProbs(p, alloc);
+-  LzmaDec_FreeDict(p, alloc);
+-}
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+ {
+   UInt32 dicSize;
+   Byte d;
+@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
+   return SZ_OK;
+ }
+ 
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+ {
+   CLzmaProps propNew;
+   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
+   p->prop = propNew;
+   return SZ_OK;
+ }
+-
+-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+-{
+-  CLzmaProps propNew;
+-  SizeT dicBufSize;
+-  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+-  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+-  dicBufSize = propNew.dicSize;
+-  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+-  {
+-    LzmaDec_FreeDict(p, alloc);
+-    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+-    if (p->dic == 0)
+-    {
+-      LzmaDec_FreeProbs(p, alloc);
+-      return SZ_ERROR_MEM;
+-    }
+-  }
+-  p->dicBufSize = dicBufSize;
+-  p->prop = propNew;
+-  return SZ_OK;
+-}
+ 
+ SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+--- a/include/linux/lzma/LzmaEnc.h
++++ b/include/linux/lzma/LzmaEnc.h
+@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
+ } CLzmaEncProps;
+ 
+ void LzmaEncProps_Init(CLzmaEncProps *p);
+-void LzmaEncProps_Normalize(CLzmaEncProps *p);
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+-
+ 
+ /* ---------- CLzmaEncHandle Interface ---------- */
+ 
+@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+ void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ 
+-/* ---------- One Call Interface ---------- */
+-
+-/* LzmaEncode
+-Return code:
+-  SZ_OK               - OK
+-  SZ_ERROR_MEM        - Memory allocation error
+-  SZ_ERROR_PARAM      - Incorrect paramater
+-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+-*/
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/lib/lzma/LzmaEnc.c
++++ b/lib/lzma/LzmaEnc.c
+@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
+   p->writeEndMark = 0;
+ }
+ 
+-void LzmaEncProps_Normalize(CLzmaEncProps *p)
++static void LzmaEncProps_Normalize(CLzmaEncProps *p)
+ {
+   int level = p->level;
+   if (level < 0) level = 5;
+@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
+       #endif
+ }
+ 
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+ {
+   CLzmaEncProps props = *props2;
+   LzmaEncProps_Normalize(&props);
+@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
+ 
+ #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
+ 
+-UInt32 GetPosSlot1(UInt32 pos)
++static UInt32 GetPosSlot1(UInt32 pos)
+ {
+   UInt32 res;
+   BSR2_RET(pos, res);
+@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
+ #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+ #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+ 
+-void LzmaEnc_FastPosInit(Byte *g_FastPos)
++static void LzmaEnc_FastPosInit(Byte *g_FastPos)
+ {
+   int c = 2, slotFast;
+   g_FastPos[0] = 0;
+@@ -339,58 +339,6 @@ typedef struct
+   CSaveState saveState;
+ } CLzmaEnc;
+ 
+-void LzmaEnc_SaveState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  CSaveState *dest = &p->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
+-}
+-
+-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *dest = (CLzmaEnc *)pp;
+-  const CSaveState *p = &dest->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
+-}
+-
+ SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
+   while (symbol < 0x10000);
+ }
+ 
+-void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+ {
+   UInt32 i;
+   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
+   p->matchPriceCount = 0;
+ }
+ 
+-void LzmaEnc_Construct(CLzmaEnc *p)
++static void LzmaEnc_Construct(CLzmaEnc *p)
+ {
+   RangeEnc_Construct(&p->rc);
+   MatchFinder_Construct(&p->matchFinderBase);
+@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+   return p;
+ }
+ 
+-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->litProbs);
+   alloc->Free(alloc, p->saveState.litProbs);
+@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
+   p->saveState.litProbs = 0;
+ }
+ 
+-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   #ifndef _7ZIP_ST
+   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
+@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
+   return SZ_OK;
+ }
+ 
+-void LzmaEnc_Init(CLzmaEnc *p)
++static void LzmaEnc_Init(CLzmaEnc *p)
+ {
+   UInt32 i;
+   p->state = 0;
+@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
+   p->lpMask = (1 << p->lp) - 1;
+ }
+ 
+-void LzmaEnc_InitPrices(CLzmaEnc *p)
++static void LzmaEnc_InitPrices(CLzmaEnc *p)
+ {
+   if (!p->fastMode)
+   {
+@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
+   return SZ_OK;
+ }
+ 
+-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  p->rc.outStream = outStream;
+-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+-}
+-
+-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+-    ISeqInStream *inStream, UInt32 keepWindowSize,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+-}
+-
+ static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+ {
+   p->matchFinderBase.directInput = 1;
+@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
+   p->matchFinderBase.directInputRem = srcLen;
+ }
+ 
+-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
+   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+ }
+ 
+-void LzmaEnc_Finish(CLzmaEncHandle pp)
++static void LzmaEnc_Finish(CLzmaEncHandle pp)
+ {
+   #ifndef _7ZIP_ST
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
+   return size;
+ }
+ 
+-
+-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+-}
+-
+-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+-}
+-
+-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  UInt64 nowPos64;
+-  SRes res;
+-  CSeqOutStreamBuf outStream;
+-
+-  outStream.funcTable.Write = MyWrite;
+-  outStream.data = dest;
+-  outStream.rem = *destLen;
+-  outStream.overflow = False;
+-
+-  p->writeEndMark = False;
+-  p->finished = False;
+-  p->result = SZ_OK;
+-
+-  if (reInit)
+-    LzmaEnc_Init(p);
+-  LzmaEnc_InitPrices(p);
+-  nowPos64 = p->nowPos64;
+-  RangeEnc_Init(&p->rc);
+-  p->rc.outStream = &outStream.funcTable;
+-
+-  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+-  
+-  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
+-  *destLen -= outStream.rem;
+-  if (outStream.overflow)
+-    return SZ_ERROR_OUTPUT_EOF;
+-
+-  return res;
+-}
+-
+ static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
+ {
+   SRes res = SZ_OK;
+@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
+   return res;
+ }
+ 
+-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
+-  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
+-}
+-
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
+     return SZ_ERROR_OUTPUT_EOF;
+   return res;
+ }
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+-  SRes res;
+-  if (p == 0)
+-    return SZ_ERROR_MEM;
+-
+-  res = LzmaEnc_SetProps(p, props);
+-  if (res == SZ_OK)
+-  {
+-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+-    if (res == SZ_OK)
+-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+-          writeEndMark, progress, alloc, allocBig);
+-  }
+-
+-  LzmaEnc_Destroy(p, alloc, allocBig);
+-  return res;
+-}
+--- a/include/linux/lzma/LzFind.h
++++ b/include/linux/lzma/LzFind.h
+@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
+ 
+ #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p);
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+-void MatchFinder_MoveBlock(CMatchFinder *p);
+-void MatchFinder_ReadIfRequired(CMatchFinder *p);
+-
+ void MatchFinder_Construct(CMatchFinder *p);
+ 
+ /* Conditions:
+@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
+     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+     ISzAlloc *alloc);
+ void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+-    UInt32 *distances, UInt32 maxLen);
+ 
+ /*
+ Conditions:
+@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
+ 
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+ 
+-void MatchFinder_Init(CMatchFinder *p);
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/lib/lzma/LzFind.c
++++ b/lib/lzma/LzFind.c
+@@ -14,9 +14,15 @@
+ 
+ #define kStartMaxLen 3
+ 
++#if 0
++#define DIRECT_INPUT	p->directInput
++#else
++#define DIRECT_INPUT	1
++#endif
++
+ static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+ {
+-  if (!p->directInput)
++  if (!DIRECT_INPUT)
+   {
+     alloc->Free(alloc, p->bufferBase);
+     p->bufferBase = 0;
+@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
+ static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+ {
+   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     p->blockSize = blockSize;
+     return 1;
+@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
+   return (p->bufferBase != 0);
+ }
+ 
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
+-Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
+ 
+-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
+ 
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+ {
+   p->posLimit -= subValue;
+   p->pos -= subValue;
+@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
+ {
+   if (p->streamEndWasReached || p->result != SZ_OK)
+     return;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
+     if (curSize > p->directInputRem)
+@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
+   }
+ }
+ 
+-void MatchFinder_MoveBlock(CMatchFinder *p)
++static void MatchFinder_MoveBlock(CMatchFinder *p)
+ {
+   memmove(p->bufferBase,
+     p->buffer - p->keepSizeBefore,
+@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
+   p->buffer = p->bufferBase + p->keepSizeBefore;
+ }
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p)
++static int MatchFinder_NeedMove(CMatchFinder *p)
+ {
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+     return 0;
+   /* if (p->streamEndWasReached) return 0; */
+   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
+ }
+ 
+-void MatchFinder_ReadIfRequired(CMatchFinder *p)
+-{
+-  if (p->streamEndWasReached)
+-    return;
+-  if (p->keepSizeAfter >= p->streamPos - p->pos)
+-    MatchFinder_ReadBlock(p);
+-}
+-
+ static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+ {
+   if (MatchFinder_NeedMove(p))
+@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
+   p->posLimit = p->pos + limit;
+ }
+ 
+-void MatchFinder_Init(CMatchFinder *p)
++static void MatchFinder_Init(CMatchFinder *p)
+ {
+   UInt32 i;
+   for (i = 0; i < p->hashSizeSum; i++)
+@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
+   return (p->pos - p->historySize - 1) & kNormalizeMask;
+ }
+ 
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+ {
+   UInt32 i;
+   for (i = 0; i < numItems; i++)
+@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
+   MatchFinder_SetLimits(p);
+ }
+ 
+-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+-    UInt32 *distances, UInt32 maxLen)
+-{
+-  son[_cyclicBufferPos] = curMatch;
+-  for (;;)
+-  {
+-    UInt32 delta = pos - curMatch;
+-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+-      return distances;
+-    {
+-      const Byte *pb = cur - delta;
+-      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+-      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
+-      {
+-        UInt32 len = 0;
+-        while (++len != lenLimit)
+-          if (pb[len] != cur[len])
+-            break;
+-        if (maxLen < len)
+-        {
+-          *distances++ = maxLen = len;
+-          *distances++ = delta - 1;
+-          if (len == lenLimit)
+-            return distances;
+-        }
+-      }
+-    }
+-  }
+-}
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+     UInt32 *distances, UInt32 maxLen)
+ {
+@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
+   p->buffer++; \
+   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
+ 
+-#define MOVE_POS_RET MOVE_POS return offset;
+-
+ static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+ 
++#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
++
+ #define GET_MATCHES_HEADER2(minLen, ret_op) \
+   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
+@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
+   distances + offset, maxLen) - distances); MOVE_POS_RET;
+ 
+ #define SKIP_FOOTER \
+-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+-
+-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(2)
+-  HASH2_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 1)
+-}
+-
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 2)
+-}
+-
+-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, delta2, maxLen, offset;
+-  GET_MATCHES_HEADER(3)
+-
+-  HASH3_CALC;
+-
+-  delta2 = p->pos - p->hash[hash2Value];
+-  curMatch = p->hash[kFix3HashSize + hashValue];
+-  
+-  p->hash[hash2Value] =
+-  p->hash[kFix3HashSize + hashValue] = p->pos;
+-
+-
+-  maxLen = 2;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[0] = maxLen;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-    if (maxLen == lenLimit)
+-    {
+-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+-      MOVE_POS_RET;
+-    }
+-  }
+-  GET_MATCHES_FOOTER(offset, maxLen)
+-}
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
+ 
+ static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+ {
+@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
+   GET_MATCHES_FOOTER(offset, maxLen)
+ }
+ 
+-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+-  GET_MATCHES_HEADER(4)
+-
+-  HASH4_CALC;
+-
+-  delta2 = p->pos - p->hash[                hash2Value];
+-  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+-  curMatch = p->hash[kFix4HashSize + hashValue];
+-
+-  p->hash[                hash2Value] =
+-  p->hash[kFix3HashSize + hash3Value] =
+-  p->hash[kFix4HashSize + hashValue] = p->pos;
+-
+-  maxLen = 1;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    distances[0] = maxLen = 2;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-  }
+-  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+-  {
+-    maxLen = 3;
+-    distances[offset + 1] = delta3 - 1;
+-    offset += 2;
+-    delta2 = delta3;
+-  }
+-  if (offset != 0)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[offset - 2] = maxLen;
+-    if (maxLen == lenLimit)
+-    {
+-      p->son[p->cyclicBufferPos] = curMatch;
+-      MOVE_POS_RET;
+-    }
+-  }
+-  if (maxLen < 3)
+-    maxLen = 3;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances + offset, maxLen) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances, 2) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(2)
+-    HASH2_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value;
+-    SKIP_HEADER(3)
+-    HASH3_CALC;
+-    curMatch = p->hash[kFix3HashSize + hashValue];
+-    p->hash[hash2Value] =
+-    p->hash[kFix3HashSize + hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+ static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+ {
+   do
+@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
+   while (--num != 0);
+ }
+ 
+-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value, hash3Value;
+-    SKIP_HEADER(4)
+-    HASH4_CALC;
+-    curMatch = p->hash[kFix4HashSize + hashValue];
+-    p->hash[                hash2Value] =
+-    p->hash[kFix3HashSize + hash3Value] =
+-    p->hash[kFix4HashSize + hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+ {
+   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
+   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+-  if (!p->btMode)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 2)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 3)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+-  }
+-  else
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+-  }
++  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+ }
diff --git a/target/linux/generic/pending-4.4/532-jffs2_eofdetect.patch b/target/linux/generic/pending-4.4/532-jffs2_eofdetect.patch
new file mode 100644
index 0000000000..8ce53d8bed
--- /dev/null
+++ b/target/linux/generic/pending-4.4/532-jffs2_eofdetect.patch
@@ -0,0 +1,56 @@
+--- a/fs/jffs2/build.c
++++ b/fs/jffs2/build.c
+@@ -116,6 +116,16 @@ static int jffs2_build_filesystem(struct
+ 	dbg_fsbuild("scanned flash completely\n");
+ 	jffs2_dbg_dump_block_lists_nolock(c);
+ 
++	if (c->flags & (1 << 7)) {
++		printk("%s(): unlocking the mtd device... ", __func__);
++		mtd_unlock(c->mtd, 0, c->mtd->size);
++		printk("done.\n");
++
++		printk("%s(): erasing all blocks after the end marker... ", __func__);
++		jffs2_erase_pending_blocks(c, -1);
++		printk("done.\n");
++	}
++
+ 	dbg_fsbuild("pass 1 starting\n");
+ 	c->flags |= JFFS2_SB_FLAG_BUILDING;
+ 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
+--- a/fs/jffs2/scan.c
++++ b/fs/jffs2/scan.c
+@@ -148,8 +148,14 @@ int jffs2_scan_medium(struct jffs2_sb_in
+ 		/* reset summary info for next eraseblock scan */
+ 		jffs2_sum_reset_collected(s);
+ 
+-		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
+-						buf_size, s);
++		if (c->flags & (1 << 7)) {
++			if (mtd_block_isbad(c->mtd, jeb->offset))
++				ret = BLK_STATE_BADBLOCK;
++			else
++				ret = BLK_STATE_ALLFF;
++		} else
++			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
++							buf_size, s);
+ 
+ 		if (ret < 0)
+ 			goto out;
+@@ -561,6 +567,17 @@ full_scan:
+ 			return err;
+ 	}
+ 
++	if ((buf[0] == 0xde) &&
++		(buf[1] == 0xad) &&
++		(buf[2] == 0xc0) &&
++		(buf[3] == 0xde)) {
++		/* end of filesystem. erase everything after this point */
++		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
++		c->flags |= (1 << 7);
++
++		return BLK_STATE_ALLFF;
++	}
++
+ 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
+ 	ofs = 0;
+ 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
diff --git a/target/linux/generic/pending-4.4/551-ubifs-fix-default-compression-selection.patch b/target/linux/generic/pending-4.4/551-ubifs-fix-default-compression-selection.patch
new file mode 100644
index 0000000000..1b0f30718c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/551-ubifs-fix-default-compression-selection.patch
@@ -0,0 +1,29 @@
+--- a/fs/ubifs/sb.c
++++ b/fs/ubifs/sb.c
+@@ -63,6 +63,17 @@
+ /* Default time granularity in nanoseconds */
+ #define DEFAULT_TIME_GRAN 1000000000
+ 
++static int get_default_compressor(void)
++{
++	if (ubifs_compr_present(UBIFS_COMPR_LZO))
++		return UBIFS_COMPR_LZO;
++
++	if (ubifs_compr_present(UBIFS_COMPR_ZLIB))
++		return UBIFS_COMPR_ZLIB;
++
++	return UBIFS_COMPR_NONE;
++}
++
+ /**
+  * create_default_filesystem - format empty UBI volume.
+  * @c: UBIFS file-system description object
+@@ -183,7 +194,7 @@ static int create_default_filesystem(str
+ 	if (c->mount_opts.override_compr)
+ 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
+ 	else
+-		sup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);
++		sup->default_compr = cpu_to_le16(get_default_compressor());
+ 
+ 	generate_random_uuid(sup->uuid);
+ 
diff --git a/target/linux/generic/pending-4.4/600-netfilter_conntrack_flush.patch b/target/linux/generic/pending-4.4/600-netfilter_conntrack_flush.patch
new file mode 100644
index 0000000000..8794739658
--- /dev/null
+++ b/target/linux/generic/pending-4.4/600-netfilter_conntrack_flush.patch
@@ -0,0 +1,86 @@
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -17,6 +17,7 @@
+ #include <linux/percpu.h>
+ #include <linux/netdevice.h>
+ #include <linux/security.h>
++#include <linux/inet.h>
+ #include <net/net_namespace.h>
+ #ifdef CONFIG_SYSCTL
+ #include <linux/sysctl.h>
+@@ -288,10 +289,66 @@ static int ct_open(struct inode *inode,
+ 			sizeof(struct ct_iter_state));
+ }
+ 
++struct kill_request {
++	u16 family;
++	union nf_inet_addr addr;
++};
++
++static int kill_matching(struct nf_conn *i, void *data)
++{
++	struct kill_request *kr = data;
++	struct nf_conntrack_tuple *t1 = &i->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
++	struct nf_conntrack_tuple *t2 = &i->tuplehash[IP_CT_DIR_REPLY].tuple;
++
++	if (!kr->family)
++		return 1;
++
++	if (t1->src.l3num != kr->family)
++		return 0;
++
++	return (nf_inet_addr_cmp(&kr->addr, &t1->src.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t1->dst.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t2->src.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t2->dst.u3));
++}
++
++static ssize_t ct_file_write(struct file *file, const char __user *buf,
++			     size_t count, loff_t *ppos)
++{
++	struct seq_file *seq = file->private_data;
++	struct net *net = seq_file_net(seq);
++	struct kill_request kr = { };
++	char req[INET6_ADDRSTRLEN] = { };
++
++	if (count == 0)
++		return 0;
++
++	if (count >= INET6_ADDRSTRLEN)
++		count = INET6_ADDRSTRLEN - 1;
++
++	if (copy_from_user(req, buf, count))
++		return -EFAULT;
++
++	if (strnchr(req, count, ':')) {
++		kr.family = AF_INET6;
++		if (!in6_pton(req, count, (void *)&kr.addr, '\n', NULL))
++			return -EINVAL;
++	} else if (strnchr(req, count, '.')) {
++		kr.family = AF_INET;
++		if (!in4_pton(req, count, (void *)&kr.addr, '\n', NULL))
++			return -EINVAL;
++	}
++
++	nf_ct_iterate_cleanup(net, kill_matching, &kr, 0, 0);
++
++	return count;
++}
++
+ static const struct file_operations ct_file_ops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = ct_open,
+ 	.read    = seq_read,
++	.write	 = ct_file_write,
+ 	.llseek  = seq_lseek,
+ 	.release = seq_release_net,
+ };
+@@ -393,7 +450,7 @@ static int nf_conntrack_standalone_init_
+ {
+ 	struct proc_dir_entry *pde;
+ 
+-	pde = proc_create("nf_conntrack", 0440, net->proc_net, &ct_file_ops);
++	pde = proc_create("nf_conntrack", 0660, net->proc_net, &ct_file_ops);
+ 	if (!pde)
+ 		goto out_nf_conntrack;
+ 
diff --git a/target/linux/generic/pending-4.4/610-netfilter_match_bypass_default_checks.patch b/target/linux/generic/pending-4.4/610-netfilter_match_bypass_default_checks.patch
new file mode 100644
index 0000000000..dce8020c92
--- /dev/null
+++ b/target/linux/generic/pending-4.4/610-netfilter_match_bypass_default_checks.patch
@@ -0,0 +1,101 @@
+--- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
++++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
+@@ -87,6 +87,7 @@ struct ipt_ip {
+ #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
+ #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
+ #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
++#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
+ 
+ /* Values for "inv" field in struct ipt_ip. */
+ #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -82,6 +82,9 @@ ip_packet_match(const struct iphdr *ip,
+ 
+ #define FWINV(bool, invflg) ((bool) ^ !!(ipinfo->invflags & (invflg)))
+ 
++	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
++		return true;
++
+ 	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
+ 		  IPT_INV_SRCIP) ||
+ 	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
+@@ -135,6 +138,29 @@ ip_packet_match(const struct iphdr *ip,
+ 	return true;
+ }
+ 
++static void
++ip_checkdefault(struct ipt_ip *ip)
++{
++	static const char iface_mask[IFNAMSIZ] = {};
++
++	if (ip->invflags || ip->flags & IPT_F_FRAG)
++		return;
++
++	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (ip->smsk.s_addr || ip->dmsk.s_addr)
++		return;
++
++	if (ip->proto)
++		return;
++
++	ip->flags |= IPT_F_NO_DEF_MATCH;
++}
++
+ static bool
+ ip_checkentry(const struct ipt_ip *ip)
+ {
+@@ -655,6 +681,8 @@ find_check_entry(struct ipt_entry *e, st
+ 	struct xt_entry_match *ematch;
+ 	unsigned long pcnt;
+ 
++	ip_checkdefault(&e->ip);
++
+ 	pcnt = xt_percpu_counter_alloc();
+ 	if (IS_ERR_VALUE(pcnt))
+ 		return -ENOMEM;
+@@ -953,6 +981,7 @@ copy_entries_to_user(unsigned int total_
+ 	const struct xt_table_info *private = table->private;
+ 	int ret = 0;
+ 	const void *loc_cpu_entry;
++	u8 flags;
+ 
+ 	counters = alloc_counters(table);
+ 	if (IS_ERR(counters))
+@@ -980,6 +1009,14 @@ copy_entries_to_user(unsigned int total_
+ 			goto free_counters;
+ 		}
+ 
++		flags = e->ip.flags & IPT_F_MASK;
++		if (copy_to_user(userptr + off
++				 + offsetof(struct ipt_entry, ip.flags),
++				 &flags, sizeof(flags)) != 0) {
++			ret = -EFAULT;
++			goto free_counters;
++		}
++
+ 		for (i = sizeof(struct ipt_entry);
+ 		     i < e->target_offset;
+ 		     i += m->u.match_size) {
+@@ -1385,12 +1422,15 @@ compat_copy_entry_to_user(struct ipt_ent
+ 	compat_uint_t origsize;
+ 	const struct xt_entry_match *ematch;
+ 	int ret = 0;
++	u8 flags = e->ip.flags & IPT_F_MASK;
+ 
+ 	origsize = *size;
+ 	ce = (struct compat_ipt_entry __user *)*dstptr;
+ 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)) != 0 ||
+ 	    copy_to_user(&ce->counters, &counters[i],
+-	    sizeof(counters[i])) != 0)
++	    sizeof(counters[i])) != 0 ||
++	    copy_to_user(&ce->ip.flags, &flags,
++	    sizeof(flags)) != 0)
+ 		return -EFAULT;
+ 
+ 	*dstptr += sizeof(struct compat_ipt_entry);
diff --git a/target/linux/generic/pending-4.4/611-netfilter_match_bypass_default_table.patch b/target/linux/generic/pending-4.4/611-netfilter_match_bypass_default_table.patch
new file mode 100644
index 0000000000..1c565198b4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/611-netfilter_match_bypass_default_table.patch
@@ -0,0 +1,111 @@
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -308,6 +308,33 @@ struct ipt_entry *ipt_next_entry(const s
+ 	return (void *)entry + entry->next_offset;
+ }
+ 
++static bool
++ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
++{
++	struct xt_entry_target *t;
++	struct xt_standard_target *st;
++
++	if (e->target_offset != sizeof(struct ipt_entry))
++		return false;
++
++	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
++		return false;
++
++	t = ipt_get_target(e);
++	if (t->u.kernel.target->target)
++		return false;
++
++	st = (struct xt_standard_target *) t;
++	if (st->verdict == XT_RETURN)
++		return false;
++
++	if (st->verdict >= 0)
++		return false;
++
++	*verdict = (unsigned)(-st->verdict) - 1;
++	return true;
++}
++
+ /* Returns one of the generic firewall policies, like NF_ACCEPT. */
+ unsigned int
+ ipt_do_table(struct sk_buff *skb,
+@@ -328,28 +355,8 @@ ipt_do_table(struct sk_buff *skb,
+ 	unsigned int addend;
+ 
+ 	/* Initialization */
+-	stackidx = 0;
+-	ip = ip_hdr(skb);
+-	indev = state->in ? state->in->name : nulldevname;
+-	outdev = state->out ? state->out->name : nulldevname;
+-	/* We handle fragments by dealing with the first fragment as
+-	 * if it was a normal packet.  All other fragments are treated
+-	 * normally, except that they will NEVER match rules that ask
+-	 * things we don't know, ie. tcp syn flag or ports).  If the
+-	 * rule is also a fragment-specific rule, non-fragments won't
+-	 * match it. */
+-	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
+-	acpar.thoff   = ip_hdrlen(skb);
+-	acpar.hotdrop = false;
+-	acpar.net     = state->net;
+-	acpar.in      = state->in;
+-	acpar.out     = state->out;
+-	acpar.family  = NFPROTO_IPV4;
+-	acpar.hooknum = hook;
+-
+ 	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
+ 	local_bh_disable();
+-	addend = xt_write_recseq_begin();
+ 	private = table->private;
+ 	cpu        = smp_processor_id();
+ 	/*
+@@ -358,6 +365,23 @@ ipt_do_table(struct sk_buff *skb,
+ 	 */
+ 	smp_read_barrier_depends();
+ 	table_base = private->entries;
++
++	e = get_entry(table_base, private->hook_entry[hook]);
++	if (ipt_handle_default_rule(e, &verdict)) {
++		struct xt_counters *counter;
++
++		counter = xt_get_this_cpu_counter(&e->counters);
++		ADD_COUNTER(*counter, skb->len, 1);
++		local_bh_enable();
++		return verdict;
++	}
++
++	stackidx = 0;
++	ip = ip_hdr(skb);
++	indev = state->in ? state->in->name : nulldevname;
++	outdev = state->out ? state->out->name : nulldevname;
++
++	addend = xt_write_recseq_begin();
+ 	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
+ 
+ 	/* Switch to alternate jumpstack if we're being invoked via TEE.
+@@ -370,7 +394,20 @@ ipt_do_table(struct sk_buff *skb,
+ 	if (static_key_false(&xt_tee_enabled))
+ 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
+ 
+-	e = get_entry(table_base, private->hook_entry[hook]);
++	/* We handle fragments by dealing with the first fragment as
++	 * if it was a normal packet.  All other fragments are treated
++	 * normally, except that they will NEVER match rules that ask
++	 * things we don't know, ie. tcp syn flag or ports).  If the
++	 * rule is also a fragment-specific rule, non-fragments won't
++	 * match it. */
++	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
++	acpar.thoff   = ip_hdrlen(skb);
++	acpar.hotdrop = false;
++	acpar.net     = state->net;
++	acpar.in      = state->in;
++	acpar.out     = state->out;
++	acpar.family  = NFPROTO_IPV4;
++	acpar.hooknum = hook;
+ 
+ 	pr_debug("Entering %s(hook %u), UF %p\n",
+ 		 table->name, hook,
diff --git a/target/linux/generic/pending-4.4/612-netfilter_match_reduce_memory_access.patch b/target/linux/generic/pending-4.4/612-netfilter_match_reduce_memory_access.patch
new file mode 100644
index 0000000000..72172d8bb4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/612-netfilter_match_reduce_memory_access.patch
@@ -0,0 +1,16 @@
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -85,9 +85,11 @@ ip_packet_match(const struct iphdr *ip,
+ 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
+ 		return true;
+ 
+-	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
++	if (FWINV(ipinfo->smsk.s_addr &&
++		  (ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
+ 		  IPT_INV_SRCIP) ||
+-	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
++	    FWINV(ipinfo->dmsk.s_addr &&
++		  (ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
+ 		  IPT_INV_DSTIP)) {
+ 		dprintf("Source or dest mismatch.\n");
+ 
diff --git a/target/linux/generic/pending-4.4/613-netfilter_optional_tcp_window_check.patch b/target/linux/generic/pending-4.4/613-netfilter_optional_tcp_window_check.patch
new file mode 100644
index 0000000000..3740dd74e5
--- /dev/null
+++ b/target/linux/generic/pending-4.4/613-netfilter_optional_tcp_window_check.patch
@@ -0,0 +1,36 @@
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -33,6 +33,9 @@
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+ 
++/* Do not check the TCP window for incoming packets  */
++static int nf_ct_tcp_no_window_check __read_mostly = 1;
++
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+     If it's non-zero, we mark only out of window RST segments as INVALID. */
+@@ -515,6 +518,9 @@ static bool tcp_in_window(const struct n
+ 	s32 receiver_offset;
+ 	bool res, in_recv_win;
+ 
++	if (nf_ct_tcp_no_window_check)
++		return true;
++
+ 	/*
+ 	 * Get the required data from the packet.
+ 	 */
+@@ -1481,6 +1487,13 @@ static struct ctl_table tcp_sysctl_table
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
++	{
++		.procname       = "nf_conntrack_tcp_no_window_check",
++		.data           = &nf_ct_tcp_no_window_check,
++		.maxlen         = sizeof(unsigned int),
++		.mode           = 0644,
++		.proc_handler   = proc_dointvec,
++	},
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/pending-4.4/616-net_optimize_xfrm_calls.patch b/target/linux/generic/pending-4.4/616-net_optimize_xfrm_calls.patch
new file mode 100644
index 0000000000..e4634e321b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/616-net_optimize_xfrm_calls.patch
@@ -0,0 +1,12 @@
+--- a/net/netfilter/nf_nat_core.c
++++ b/net/netfilter/nf_nat_core.c
+@@ -90,6 +90,9 @@ int nf_xfrm_me_harder(struct net *net, s
+ 	struct dst_entry *dst;
+ 	int err;
+ 
++	if (skb->dev && !dev_net(skb->dev)->xfrm.policy_count[XFRM_POLICY_OUT])
++		return 0;
++
+ 	err = xfrm_decode_session(skb, &fl, family);
+ 	if (err < 0)
+ 		return err;
diff --git a/target/linux/generic/pending-4.4/620-net_sched-codel-do-not-defer-queue-length-update.patch b/target/linux/generic/pending-4.4/620-net_sched-codel-do-not-defer-queue-length-update.patch
new file mode 100644
index 0000000000..2ec9c7a9e2
--- /dev/null
+++ b/target/linux/generic/pending-4.4/620-net_sched-codel-do-not-defer-queue-length-update.patch
@@ -0,0 +1,86 @@
+From: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
+Date: Mon, 21 Aug 2017 11:14:14 +0300
+Subject: [PATCH] net_sched/codel: do not defer queue length update
+
+When codel wants to drop last packet in ->dequeue() it cannot call
+qdisc_tree_reduce_backlog() right away - it will notify parent qdisc
+about zero qlen and HTB/HFSC will deactivate class. The same class will
+be deactivated second time by caller of ->dequeue(). Currently codel and
+fq_codel defer update. This triggers warning in HFSC when it's qlen != 0
+but there is no active classes.
+
+This patch update parent queue length immediately: just temporary increase
+qlen around qdisc_tree_reduce_backlog() to prevent first class deactivation
+if we have skb to return.
+
+This might open another problem in HFSC - now operation peek could fail and
+deactivate parent class.
+
+Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
+Link: https://bugzilla.kernel.org/show_bug.cgi?id=109581
+---
+
+--- a/net/sched/sch_codel.c
++++ b/net/sched/sch_codel.c
+@@ -79,11 +79,17 @@ static struct sk_buff *codel_qdisc_deque
+ 
+ 	skb = codel_dequeue(sch, &q->params, &q->vars, &q->stats, dequeue);
+ 
+-	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
+-	 * or HTB crashes. Defer it for next round.
++	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
++	 * parent class, dequeue in parent qdisc will do the same if we
++	 * return skb. Temporary increment qlen if we have skb.
+ 	 */
+-	if (q->stats.drop_count && sch->q.qlen) {
+-		qdisc_tree_reduce_backlog(sch, q->stats.drop_count, q->stats.drop_len);
++	if (q->stats.drop_count) {
++		if (skb)
++			sch->q.qlen++;
++		qdisc_tree_reduce_backlog(sch, q->stats.drop_count,
++					  q->stats.drop_len);
++		if (skb)
++			sch->q.qlen--;
+ 		q->stats.drop_count = 0;
+ 		q->stats.drop_len = 0;
+ 	}
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -311,6 +311,21 @@ begin:
+ 	flow->dropped += q->cstats.drop_count - prev_drop_count;
+ 	flow->dropped += q->cstats.ecn_mark - prev_ecn_mark;
+ 
++	/* If our qlen is 0 qdisc_tree_reduce_backlog() will deactivate
++	 * parent class, dequeue in parent qdisc will do the same if we
++	 * return skb. Temporary increment qlen if we have skb.
++	 */
++	if (q->cstats.drop_count) {
++		if (skb)
++			sch->q.qlen++;
++		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
++					  q->cstats.drop_len);
++		if (skb)
++			sch->q.qlen--;
++		q->cstats.drop_count = 0;
++		q->cstats.drop_len = 0;
++	}
++
+ 	if (!skb) {
+ 		/* force a pass through old_flows to prevent starvation */
+ 		if ((head == &q->new_flows) && !list_empty(&q->old_flows))
+@@ -321,15 +336,6 @@ begin:
+ 	}
+ 	qdisc_bstats_update(sch, skb);
+ 	flow->deficit -= qdisc_pkt_len(skb);
+-	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,
+-	 * or HTB crashes. Defer it for next round.
+-	 */
+-	if (q->cstats.drop_count && sch->q.qlen) {
+-		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,
+-					  q->cstats.drop_len);
+-		q->cstats.drop_count = 0;
+-		q->cstats.drop_len = 0;
+-	}
+ 	return skb;
+ }
+ 
diff --git a/target/linux/generic/pending-4.4/630-packet_socket_type.patch b/target/linux/generic/pending-4.4/630-packet_socket_type.patch
new file mode 100644
index 0000000000..0314938ac4
--- /dev/null
+++ b/target/linux/generic/pending-4.4/630-packet_socket_type.patch
@@ -0,0 +1,134 @@
+This patch allows the user to specify desired packet types (outgoing,
+broadcast, unicast, etc.) on packet sockets via setsockopt.
+This can reduce the load in situations where only a limited number
+of packet types are necessary
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/include/uapi/linux/if_packet.h
++++ b/include/uapi/linux/if_packet.h
+@@ -31,6 +31,8 @@ struct sockaddr_ll {
+ #define PACKET_KERNEL		7		/* To kernel space	*/
+ /* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
+ #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
++#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
++
+ 
+ /* Packet socket options */
+ 
+@@ -56,6 +58,7 @@ struct sockaddr_ll {
+ #define PACKET_QDISC_BYPASS		20
+ #define PACKET_ROLLOVER_STATS		21
+ #define PACKET_FANOUT_DATA		22
++#define PACKET_RECV_TYPE		23
+ 
+ #define PACKET_FANOUT_HASH		0
+ #define PACKET_FANOUT_LB		1
+--- a/net/packet/af_packet.c
++++ b/net/packet/af_packet.c
+@@ -1777,6 +1777,7 @@ static int packet_rcv_spkt(struct sk_buf
+ {
+ 	struct sock *sk;
+ 	struct sockaddr_pkt *spkt;
++	struct packet_sock *po;
+ 
+ 	/*
+ 	 *	When we registered the protocol we saved the socket in the data
+@@ -1784,6 +1785,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 */
+ 
+ 	sk = pt->af_packet_priv;
++	po = pkt_sk(sk);
+ 
+ 	/*
+ 	 *	Yank back the headers [hope the device set this
+@@ -1796,7 +1798,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 *	so that this procedure is noop.
+ 	 */
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
+ 		goto out;
+ 
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+@@ -1999,12 +2001,12 @@ static int packet_rcv(struct sk_buff *sk
+ 	int skb_len = skb->len;
+ 	unsigned int snaplen, res;
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -2124,12 +2126,12 @@ static int tpacket_rcv(struct sk_buff *s
+ 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
+ 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -3126,6 +3128,7 @@ static int packet_create(struct net *net
+ 	mutex_init(&po->pg_vec_lock);
+ 	po->rollover = NULL;
+ 	po->prot_hook.func = packet_rcv;
++	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
+ 
+ 	if (sock->type == SOCK_PACKET)
+ 		po->prot_hook.func = packet_rcv_spkt;
+@@ -3755,6 +3758,16 @@ packet_setsockopt(struct socket *sock, i
+ 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
+ 		return 0;
+ 	}
++        case PACKET_RECV_TYPE:
++        {
++                unsigned int val;
++                if (optlen != sizeof(val))
++                        return -EINVAL;
++                if (copy_from_user(&val, optval, sizeof(val)))
++                        return -EFAULT;
++                po->pkt_type = val & ~BIT(PACKET_LOOPBACK);
++                return 0;
++        }
+ 	default:
+ 		return -ENOPROTOOPT;
+ 	}
+@@ -3807,6 +3820,13 @@ static int packet_getsockopt(struct sock
+ 	case PACKET_VNET_HDR:
+ 		val = po->has_vnet_hdr;
+ 		break;
++	case PACKET_RECV_TYPE:
++		if (len > sizeof(unsigned int))
++			len = sizeof(unsigned int);
++		val = po->pkt_type;
++
++		data = &val;
++		break;
+ 	case PACKET_VERSION:
+ 		val = po->tp_version;
+ 		break;
+--- a/net/packet/internal.h
++++ b/net/packet/internal.h
+@@ -128,6 +128,7 @@ struct packet_sock {
+ 	struct net_device __rcu	*cached_dev;
+ 	int			(*xmit)(struct sk_buff *skb);
+ 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
++	unsigned int		pkt_type;
+ };
+ 
+ static struct packet_sock *pkt_sk(struct sock *sk)
diff --git a/target/linux/generic/pending-4.4/640-bridge_no_eap_forward.patch b/target/linux/generic/pending-4.4/640-bridge_no_eap_forward.patch
new file mode 100644
index 0000000000..a6dfb4ee59
--- /dev/null
+++ b/target/linux/generic/pending-4.4/640-bridge_no_eap_forward.patch
@@ -0,0 +1,23 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH] bridge: no EAP forward
+
+When bridging, do not forward EAP frames to other ports, only deliver
+them locally.
+Fixes WPA authentication issues with multiples APs that are connected to
+each other via bridges.
+---
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -169,7 +169,11 @@ int br_handle_frame_finish(struct net *n
+ 	if (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))
+ 		br_do_proxy_arp(skb, br, vid, p);
+ 
+-	if (is_broadcast_ether_addr(dest)) {
++	if (skb->protocol == htons(ETH_P_PAE)) {
++		skb2 = skb;
++		/* Do not forward 802.1x/EAP frames */
++		skb = NULL;
++	} else if (is_broadcast_ether_addr(dest)) {
+ 		skb2 = skb;
+ 		unicast = false;
+ 	} else if (is_multicast_ether_addr(dest)) {
diff --git a/target/linux/generic/pending-4.4/641-bridge_always_accept_eap.patch b/target/linux/generic/pending-4.4/641-bridge_always_accept_eap.patch
new file mode 100644
index 0000000000..a4e2c03cf9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/641-bridge_always_accept_eap.patch
@@ -0,0 +1,17 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH] bridge: always accept EAP
+
+Allow EAP frames to pass through bridges even in learning state. Fixes
+issues with WDS.
+---
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -153,7 +153,7 @@ int br_handle_frame_finish(struct net *n
+ 	    br_multicast_rcv(br, p, skb, vid))
+ 		goto drop;
+ 
+-	if (p->state == BR_STATE_LEARNING)
++	if ((p->state == BR_STATE_LEARNING) && skb->protocol != htons(ETH_P_PAE))
+ 		goto drop;
+ 
+ 	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
diff --git a/target/linux/generic/pending-4.4/642-bridge_port_isolate.patch b/target/linux/generic/pending-4.4/642-bridge_port_isolate.patch
new file mode 100644
index 0000000000..02dfea4659
--- /dev/null
+++ b/target/linux/generic/pending-4.4/642-bridge_port_isolate.patch
@@ -0,0 +1,107 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH] bridge: port isolate
+
+Isolating individual bridge ports
+---
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -45,6 +45,7 @@ struct br_ip_list {
+ #define BR_PROXYARP		BIT(8)
+ #define BR_LEARNING_SYNC	BIT(9)
+ #define BR_PROXYARP_WIFI	BIT(10)
++#define BR_ISOLATE_MODE	BIT(11)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -173,6 +173,22 @@ BRPORT_ATTR_FLAG(unicast_flood, BR_FLOOD
+ BRPORT_ATTR_FLAG(proxyarp, BR_PROXYARP);
+ BRPORT_ATTR_FLAG(proxyarp_wifi, BR_PROXYARP_WIFI);
+ 
++static ssize_t show_isolate_mode(struct net_bridge_port *p, char *buf)
++{
++	int isolate_mode = (p->flags & BR_ISOLATE_MODE) ? 1 : 0;
++	return sprintf(buf, "%d\n", isolate_mode);
++}
++static int store_isolate_mode(struct net_bridge_port *p, unsigned long v)
++{
++	if (v)
++		p->flags |= BR_ISOLATE_MODE;
++	else
++		p->flags &= ~BR_ISOLATE_MODE;
++	return 0;
++}
++static BRPORT_ATTR(isolate_mode, S_IRUGO | S_IWUSR,
++		   show_isolate_mode, store_isolate_mode);
++
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
+ {
+@@ -217,6 +233,7 @@ static const struct brport_attribute *br
+ #endif
+ 	&brport_attr_proxyarp,
+ 	&brport_attr_proxyarp_wifi,
++	&brport_attr_isolate_mode,
+ 	NULL
+ };
+ 
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -192,8 +192,8 @@ int br_handle_frame_finish(struct net *n
+ 
+ 		unicast = false;
+ 		br->dev->stats.multicast++;
+-	} else if ((dst = __br_fdb_get(br, dest, vid)) &&
+-			dst->is_local) {
++	} else if ((p->flags & BR_ISOLATE_MODE) ||
++		   ((dst = __br_fdb_get(br, dest, vid)) && dst->is_local)) {
+ 		skb2 = skb;
+ 		/* Do not forward the packet since it's local. */
+ 		skb = NULL;
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -141,7 +141,7 @@ EXPORT_SYMBOL_GPL(br_deliver);
+ /* called with rcu_read_lock */
+ void br_forward(const struct net_bridge_port *to, struct sk_buff *skb, struct sk_buff *skb0)
+ {
+-	if (to && should_deliver(to, skb)) {
++	if (to && should_deliver(to, skb) && !(to->flags & BR_ISOLATE_MODE)) {
+ 		if (skb0)
+ 			deliver_clone(to, skb, __br_forward);
+ 		else
+@@ -197,7 +197,7 @@ static void br_flood(struct net_bridge *
+ 		     struct sk_buff *skb0,
+ 		     void (*__packet_hook)(const struct net_bridge_port *p,
+ 					   struct sk_buff *skb),
+-		     bool unicast)
++		     				bool unicast, bool forward)
+ {
+ 	struct net_bridge_port *p;
+ 	struct net_bridge_port *prev;
+@@ -205,6 +205,8 @@ static void br_flood(struct net_bridge *
+ 	prev = NULL;
+ 
+ 	list_for_each_entry_rcu(p, &br->port_list, list) {
++		if (forward && (p->flags & BR_ISOLATE_MODE))
++			continue;
+ 		/* Do not flood unicast traffic to ports that turn it off */
+ 		if (unicast && !(p->flags & BR_FLOOD))
+ 			continue;
+@@ -239,14 +241,14 @@ out:
+ /* called with rcu_read_lock */
+ void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast)
+ {
+-	br_flood(br, skb, NULL, __br_deliver, unicast);
++	br_flood(br, skb, NULL, __br_deliver, unicast, false);
+ }
+ 
+ /* called under bridge lock */
+ void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
+ 		      struct sk_buff *skb2, bool unicast)
+ {
+-	br_flood(br, skb, skb2, __br_forward, unicast);
++	br_flood(br, skb, skb2, __br_forward, unicast, true);
+ }
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
diff --git a/target/linux/generic/pending-4.4/645-bridge_multicast_to_unicast.patch b/target/linux/generic/pending-4.4/645-bridge_multicast_to_unicast.patch
new file mode 100644
index 0000000000..f1c7ab1d9c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/645-bridge_multicast_to_unicast.patch
@@ -0,0 +1,420 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH] bridge: multicast to unicast
+
+Implement optinal multicast->unicast conversion for igmp snooping
+---
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -46,6 +46,7 @@ struct br_ip_list {
+ #define BR_LEARNING_SYNC	BIT(9)
+ #define BR_PROXYARP_WIFI	BIT(10)
+ #define BR_ISOLATE_MODE	BIT(11)
++#define BR_MULTICAST_TO_UCAST	BIT(12)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_multicast.c
++++ b/net/bridge/br_multicast.c
+@@ -42,12 +42,13 @@ static void br_multicast_add_router(stru
+ static void br_ip4_multicast_leave_group(struct net_bridge *br,
+ 					 struct net_bridge_port *port,
+ 					 __be32 group,
+-					 __u16 vid);
++					 __u16 vid,
++					 const unsigned char *src);
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void br_ip6_multicast_leave_group(struct net_bridge *br,
+ 					 struct net_bridge_port *port,
+ 					 const struct in6_addr *group,
+-					 __u16 vid);
++					 __u16 vid, const unsigned char *src);
+ #endif
+ unsigned int br_mdb_rehash_seq;
+ 
+@@ -652,7 +653,8 @@ struct net_bridge_port_group *br_multica
+ 			struct net_bridge_port *port,
+ 			struct br_ip *group,
+ 			struct net_bridge_port_group __rcu *next,
+-			unsigned char state)
++			unsigned char state,
++			const unsigned char *src)
+ {
+ 	struct net_bridge_port_group *p;
+ 
+@@ -667,12 +669,33 @@ struct net_bridge_port_group *br_multica
+ 	hlist_add_head(&p->mglist, &port->mglist);
+ 	setup_timer(&p->timer, br_multicast_port_group_expired,
+ 		    (unsigned long)p);
++	if ((port->flags & BR_MULTICAST_TO_UCAST) && src) {
++		memcpy(p->eth_addr, src, ETH_ALEN);
++		p->unicast = true;
++	}
+ 	return p;
+ }
+ 
++static bool br_port_group_equal(struct net_bridge_port_group *p,
++				struct net_bridge_port *port,
++				const unsigned char *src)
++{
++	if (p->port != port)
++		return false;
++
++	if (!p->unicast)
++		return true;
++
++	if (!src)
++		return false;
++
++	return ether_addr_equal(src, p->eth_addr);
++}
++
+ static int br_multicast_add_group(struct net_bridge *br,
+ 				  struct net_bridge_port *port,
+-				  struct br_ip *group)
++				  struct br_ip *group,
++				  const unsigned char *src)
+ {
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct net_bridge_port_group *p;
+@@ -699,13 +722,13 @@ static int br_multicast_add_group(struct
+ 	for (pp = &mp->ports;
+ 	     (p = mlock_dereference(*pp, br)) != NULL;
+ 	     pp = &p->next) {
+-		if (p->port == port)
++		if (br_port_group_equal(p, port, src))
+ 			goto found;
+ 		if ((unsigned long)p->port < (unsigned long)port)
+ 			break;
+ 	}
+ 
+-	p = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY);
++	p = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY, src);
+ 	if (unlikely(!p))
+ 		goto err;
+ 	rcu_assign_pointer(*pp, p);
+@@ -724,7 +747,7 @@ err:
+ static int br_ip4_multicast_add_group(struct net_bridge *br,
+ 				      struct net_bridge_port *port,
+ 				      __be32 group,
+-				      __u16 vid)
++				      __u16 vid, const unsigned char *src)
+ {
+ 	struct br_ip br_group;
+ 
+@@ -735,14 +758,14 @@ static int br_ip4_multicast_add_group(st
+ 	br_group.proto = htons(ETH_P_IP);
+ 	br_group.vid = vid;
+ 
+-	return br_multicast_add_group(br, port, &br_group);
++	return br_multicast_add_group(br, port, &br_group, src);
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int br_ip6_multicast_add_group(struct net_bridge *br,
+ 				      struct net_bridge_port *port,
+ 				      const struct in6_addr *group,
+-				      __u16 vid)
++				      __u16 vid, const unsigned char *src)
+ {
+ 	struct br_ip br_group;
+ 
+@@ -753,7 +776,7 @@ static int br_ip6_multicast_add_group(st
+ 	br_group.proto = htons(ETH_P_IPV6);
+ 	br_group.vid = vid;
+ 
+-	return br_multicast_add_group(br, port, &br_group);
++	return br_multicast_add_group(br, port, &br_group, src);
+ }
+ #endif
+ 
+@@ -1003,6 +1026,7 @@ static int br_ip4_multicast_igmp3_report
+ 					 struct sk_buff *skb,
+ 					 u16 vid)
+ {
++	const unsigned char *src;
+ 	struct igmpv3_report *ih;
+ 	struct igmpv3_grec *grec;
+ 	int i;
+@@ -1043,12 +1067,13 @@ static int br_ip4_multicast_igmp3_report
+ 			continue;
+ 		}
+ 
++		src = eth_hdr(skb)->h_source;
+ 		if ((type == IGMPV3_CHANGE_TO_INCLUDE ||
+ 		     type == IGMPV3_MODE_IS_INCLUDE) &&
+ 		    ntohs(grec->grec_nsrcs) == 0) {
+-			br_ip4_multicast_leave_group(br, port, group, vid);
++			br_ip4_multicast_leave_group(br, port, group, vid, src);
+ 		} else {
+-			err = br_ip4_multicast_add_group(br, port, group, vid);
++			err = br_ip4_multicast_add_group(br, port, group, vid, src);
+ 			if (err)
+ 				break;
+ 		}
+@@ -1063,6 +1088,7 @@ static int br_ip6_multicast_mld2_report(
+ 					struct sk_buff *skb,
+ 					u16 vid)
+ {
++	const unsigned char *src = eth_hdr(skb)->h_source;
+ 	struct icmp6hdr *icmp6h;
+ 	struct mld2_grec *grec;
+ 	int i;
+@@ -1114,10 +1140,10 @@ static int br_ip6_multicast_mld2_report(
+ 		     grec->grec_type == MLD2_MODE_IS_INCLUDE) &&
+ 		    ntohs(*nsrcs) == 0) {
+ 			br_ip6_multicast_leave_group(br, port, &grec->grec_mca,
+-						     vid);
++						     vid, src);
+ 		} else {
+ 			err = br_ip6_multicast_add_group(br, port,
+-							 &grec->grec_mca, vid);
++							 &grec->grec_mca, vid, src);
+ 			if (err)
+ 				break;
+ 		}
+@@ -1432,7 +1458,8 @@ br_multicast_leave_group(struct net_brid
+ 			 struct net_bridge_port *port,
+ 			 struct br_ip *group,
+ 			 struct bridge_mcast_other_query *other_query,
+-			 struct bridge_mcast_own_query *own_query)
++			 struct bridge_mcast_own_query *own_query,
++			 const unsigned char *src)
+ {
+ 	struct net_bridge_mdb_htable *mdb;
+ 	struct net_bridge_mdb_entry *mp;
+@@ -1456,7 +1483,7 @@ br_multicast_leave_group(struct net_brid
+ 		for (pp = &mp->ports;
+ 		     (p = mlock_dereference(*pp, br)) != NULL;
+ 		     pp = &p->next) {
+-			if (p->port != port)
++			if (!br_port_group_equal(p, port, src))
+ 				continue;
+ 
+ 			rcu_assign_pointer(*pp, p->next);
+@@ -1519,7 +1546,7 @@ br_multicast_leave_group(struct net_brid
+ 	for (p = mlock_dereference(mp->ports, br);
+ 	     p != NULL;
+ 	     p = mlock_dereference(p->next, br)) {
+-		if (p->port != port)
++		if (!br_port_group_equal(p, port, src))
+ 			continue;
+ 
+ 		if (!hlist_unhashed(&p->mglist) &&
+@@ -1537,8 +1564,8 @@ out:
+ 
+ static void br_ip4_multicast_leave_group(struct net_bridge *br,
+ 					 struct net_bridge_port *port,
+-					 __be32 group,
+-					 __u16 vid)
++					 __be32 group, __u16 vid,
++					 const unsigned char *src)
+ {
+ 	struct br_ip br_group;
+ 	struct bridge_mcast_own_query *own_query;
+@@ -1553,14 +1580,14 @@ static void br_ip4_multicast_leave_group
+ 	br_group.vid = vid;
+ 
+ 	br_multicast_leave_group(br, port, &br_group, &br->ip4_other_query,
+-				 own_query);
++				 own_query, src);
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void br_ip6_multicast_leave_group(struct net_bridge *br,
+ 					 struct net_bridge_port *port,
+ 					 const struct in6_addr *group,
+-					 __u16 vid)
++					 __u16 vid, const unsigned char *src)
+ {
+ 	struct br_ip br_group;
+ 	struct bridge_mcast_own_query *own_query;
+@@ -1575,7 +1602,7 @@ static void br_ip6_multicast_leave_group
+ 	br_group.vid = vid;
+ 
+ 	br_multicast_leave_group(br, port, &br_group, &br->ip6_other_query,
+-				 own_query);
++				 own_query, src);
+ }
+ #endif
+ 
+@@ -1584,6 +1611,7 @@ static int br_multicast_ipv4_rcv(struct
+ 				 struct sk_buff *skb,
+ 				 u16 vid)
+ {
++	const unsigned char *src;
+ 	struct sk_buff *skb_trimmed = NULL;
+ 	struct igmphdr *ih;
+ 	int err;
+@@ -1600,12 +1628,13 @@ static int br_multicast_ipv4_rcv(struct
+ 
+ 	BR_INPUT_SKB_CB(skb)->igmp = 1;
+ 	ih = igmp_hdr(skb);
++	src = eth_hdr(skb)->h_source;
+ 
+ 	switch (ih->type) {
+ 	case IGMP_HOST_MEMBERSHIP_REPORT:
+ 	case IGMPV2_HOST_MEMBERSHIP_REPORT:
+ 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
+-		err = br_ip4_multicast_add_group(br, port, ih->group, vid);
++		err = br_ip4_multicast_add_group(br, port, ih->group, vid, src);
+ 		break;
+ 	case IGMPV3_HOST_MEMBERSHIP_REPORT:
+ 		err = br_ip4_multicast_igmp3_report(br, port, skb_trimmed, vid);
+@@ -1614,7 +1643,7 @@ static int br_multicast_ipv4_rcv(struct
+ 		err = br_ip4_multicast_query(br, port, skb_trimmed, vid);
+ 		break;
+ 	case IGMP_HOST_LEAVE_MESSAGE:
+-		br_ip4_multicast_leave_group(br, port, ih->group, vid);
++		br_ip4_multicast_leave_group(br, port, ih->group, vid, src);
+ 		break;
+ 	}
+ 
+@@ -1630,6 +1659,7 @@ static int br_multicast_ipv6_rcv(struct
+ 				 struct sk_buff *skb,
+ 				 u16 vid)
+ {
++	const unsigned char *src;
+ 	struct sk_buff *skb_trimmed = NULL;
+ 	struct mld_msg *mld;
+ 	int err;
+@@ -1649,8 +1679,9 @@ static int br_multicast_ipv6_rcv(struct
+ 
+ 	switch (mld->mld_type) {
+ 	case ICMPV6_MGM_REPORT:
++		src = eth_hdr(skb)->h_source;
+ 		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
+-		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);
++		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid, src);
+ 		break;
+ 	case ICMPV6_MLD2_REPORT:
+ 		err = br_ip6_multicast_mld2_report(br, port, skb_trimmed, vid);
+@@ -1659,7 +1690,8 @@ static int br_multicast_ipv6_rcv(struct
+ 		err = br_ip6_multicast_query(br, port, skb_trimmed, vid);
+ 		break;
+ 	case ICMPV6_MGM_REDUCTION:
+-		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);
++		src = eth_hdr(skb)->h_source;
++		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid, src);
+ 		break;
+ 	}
+ 
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -157,7 +157,9 @@ struct net_bridge_port_group {
+ 	struct rcu_head			rcu;
+ 	struct timer_list		timer;
+ 	struct br_ip			addr;
++	unsigned char			eth_addr[ETH_ALEN];
+ 	unsigned char			state;
++	bool				unicast;
+ };
+ 
+ struct net_bridge_mdb_entry
+@@ -555,7 +557,8 @@ void br_multicast_free_pg(struct rcu_hea
+ struct net_bridge_port_group *
+ br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
+ 			    struct net_bridge_port_group __rcu *next,
+-			    unsigned char state);
++			    unsigned char state,
++		       const unsigned char *src);
+ void br_mdb_init(void);
+ void br_mdb_uninit(void);
+ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
+--- a/net/bridge/br_mdb.c
++++ b/net/bridge/br_mdb.c
+@@ -416,7 +416,7 @@ static int br_mdb_add_group(struct net_b
+ 			break;
+ 	}
+ 
+-	p = br_multicast_new_port_group(port, group, *pp, state);
++	p = br_multicast_new_port_group(port, group, *pp, state, NULL);
+ 	if (unlikely(!p))
+ 		return -ENOMEM;
+ 	rcu_assign_pointer(*pp, p);
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -192,6 +192,34 @@ out:
+ 	return p;
+ }
+ 
++static struct net_bridge_port *maybe_deliver_addr(
++	struct net_bridge_port *prev, struct net_bridge_port *p,
++	struct sk_buff *skb, const unsigned char *addr,
++	void (*__packet_hook)(const struct net_bridge_port *p,
++			      struct sk_buff *skb))
++{
++	struct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;
++	const unsigned char *src = eth_hdr(skb)->h_source;
++
++	if (!should_deliver(p, skb))
++		return prev;
++
++	/* Even with hairpin, no soliloquies - prevent breaking IPv6 DAD */
++	if (skb->dev == p->dev && ether_addr_equal(src, addr))
++		return prev;
++
++	skb = skb_copy(skb, GFP_ATOMIC);
++	if (!skb) {
++		dev->stats.tx_dropped++;
++		return prev;
++	}
++
++	memcpy(eth_hdr(skb)->h_dest, addr, ETH_ALEN);
++	__packet_hook(p, skb);
++
++	return prev;
++}
++
+ /* called under bridge lock */
+ static void br_flood(struct net_bridge *br, struct sk_buff *skb,
+ 		     struct sk_buff *skb0,
+@@ -264,6 +292,7 @@ static void br_multicast_flood(struct ne
+ 	struct net_bridge_port *prev = NULL;
+ 	struct net_bridge_port_group *p;
+ 	struct hlist_node *rp;
++	const unsigned char *addr;
+ 
+ 	rp = rcu_dereference(hlist_first_rcu(&br->router_list));
+ 	p = mdst ? rcu_dereference(mdst->ports) : NULL;
+@@ -274,10 +303,19 @@ static void br_multicast_flood(struct ne
+ 		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :
+ 			     NULL;
+ 
+-		port = (unsigned long)lport > (unsigned long)rport ?
+-		       lport : rport;
+-
+-		prev = maybe_deliver(prev, port, skb, __packet_hook);
++		if ((unsigned long)lport > (unsigned long)rport) {
++			port = lport;
++			addr = p->unicast ? p->eth_addr : NULL;
++		} else {
++			port = rport;
++			addr = NULL;
++		}
++
++		if (addr)
++			prev = maybe_deliver_addr(prev, port, skb, addr,
++						  __packet_hook);
++		else
++			prev = maybe_deliver(prev, port, skb, __packet_hook);
+ 		if (IS_ERR(prev))
+ 			goto out;
+ 
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -204,6 +204,7 @@ static BRPORT_ATTR(multicast_router, S_I
+ 		   store_multicast_router);
+ 
+ BRPORT_ATTR_FLAG(multicast_fast_leave, BR_MULTICAST_FAST_LEAVE);
++BRPORT_ATTR_FLAG(multicast_to_unicast, BR_MULTICAST_TO_UCAST);
+ #endif
+ 
+ static const struct brport_attribute *brport_attrs[] = {
+@@ -230,6 +231,7 @@ static const struct brport_attribute *br
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	&brport_attr_multicast_router,
+ 	&brport_attr_multicast_fast_leave,
++	&brport_attr_multicast_to_unicast,
+ #endif
+ 	&brport_attr_proxyarp,
+ 	&brport_attr_proxyarp_wifi,
diff --git a/target/linux/generic/pending-4.4/651-wireless_mesh_header.patch b/target/linux/generic/pending-4.4/651-wireless_mesh_header.patch
new file mode 100644
index 0000000000..17bcb6d24d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/651-wireless_mesh_header.patch
@@ -0,0 +1,11 @@
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -133,7 +133,7 @@ static inline bool dev_xmit_complete(int
+  */
+ 
+ #if defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
+-# if defined(CONFIG_MAC80211_MESH)
++# if 1 || defined(CONFIG_MAC80211_MESH)
+ #  define LL_MAX_HEADER 128
+ # else
+ #  define LL_MAX_HEADER 96
diff --git a/target/linux/generic/pending-4.4/653-disable_netlink_trim.patch b/target/linux/generic/pending-4.4/653-disable_netlink_trim.patch
new file mode 100644
index 0000000000..b11104be9e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/653-disable_netlink_trim.patch
@@ -0,0 +1,27 @@
+--- a/net/netlink/af_netlink.c
++++ b/net/netlink/af_netlink.c
+@@ -1231,24 +1231,7 @@ void netlink_detachskb(struct sock *sk,
+ 
+ static struct sk_buff *netlink_trim(struct sk_buff *skb, gfp_t allocation)
+ {
+-	int delta;
+-
+ 	WARN_ON(skb->sk != NULL);
+-	delta = skb->end - skb->tail;
+-	if (is_vmalloc_addr(skb->head) || delta * 2 < skb->truesize)
+-		return skb;
+-
+-	if (skb_shared(skb)) {
+-		struct sk_buff *nskb = skb_clone(skb, allocation);
+-		if (!nskb)
+-			return skb;
+-		consume_skb(skb);
+-		skb = nskb;
+-	}
+-
+-	if (!pskb_expand_head(skb, 0, -delta, allocation))
+-		skb->truesize -= delta;
+-
+ 	return skb;
+ }
+ 
diff --git a/target/linux/generic/pending-4.4/655-increase_skb_pad.patch b/target/linux/generic/pending-4.4/655-increase_skb_pad.patch
new file mode 100644
index 0000000000..1c8ebacf46
--- /dev/null
+++ b/target/linux/generic/pending-4.4/655-increase_skb_pad.patch
@@ -0,0 +1,11 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -2177,7 +2177,7 @@ static inline int pskb_network_may_pull(
+  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
+  */
+ #ifndef NET_SKB_PAD
+-#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
++#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
+ #endif
+ 
+ int ___pskb_trim(struct sk_buff *skb, unsigned int len);
diff --git a/target/linux/generic/pending-4.4/660-fq_codel_defaults.patch b/target/linux/generic/pending-4.4/660-fq_codel_defaults.patch
new file mode 100644
index 0000000000..fbe900891c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/660-fq_codel_defaults.patch
@@ -0,0 +1,11 @@
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -477,7 +477,7 @@ static int fq_codel_init(struct Qdisc *s
+ 
+ 	sch->limit = 10*1024;
+ 	q->flows_cnt = 1024;
+-	q->memory_limit = 32 << 20; /* 32 MBytes */
++	q->memory_limit = 4 << 20; /* 4 MBytes */
+ 	q->drop_batch_size = 64;
+ 	q->quantum = psched_mtu(qdisc_dev(sch));
+ 	q->perturbation = prandom_u32();
diff --git a/target/linux/generic/pending-4.4/661-fq_codel_keep_dropped_stats.patch b/target/linux/generic/pending-4.4/661-fq_codel_keep_dropped_stats.patch
new file mode 100644
index 0000000000..3cb950c0db
--- /dev/null
+++ b/target/linux/generic/pending-4.4/661-fq_codel_keep_dropped_stats.patch
@@ -0,0 +1,10 @@
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -219,7 +219,6 @@ static int fq_codel_enqueue(struct sk_bu
+ 		list_add_tail(&flow->flowchain, &q->new_flows);
+ 		q->new_flow_count++;
+ 		flow->deficit = q->quantum;
+-		flow->dropped = 0;
+ 	}
+ 	q->memory_usage += skb->truesize;
+ 	memory_limited = q->memory_usage > q->memory_limit;
diff --git a/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch b/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch
new file mode 100644
index 0000000000..8d70b82350
--- /dev/null
+++ b/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch
@@ -0,0 +1,95 @@
+--- a/net/sched/Kconfig
++++ b/net/sched/Kconfig
+@@ -3,8 +3,9 @@
+ # 
+ 
+ menuconfig NET_SCHED
+-	bool "QoS and/or fair queueing"
++	def_bool y
+ 	select NET_SCH_FIFO
++	select NET_SCH_FQ_CODEL
+ 	---help---
+ 	  When the kernel has several packets to send out over a network
+ 	  device, it has to decide which ones to send first, which ones to
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -694,7 +694,7 @@ static const struct Qdisc_class_ops fq_c
+ 	.walk		=	fq_codel_walk,
+ };
+ 
+-static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
++struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
+ 	.cl_ops		=	&fq_codel_class_ops,
+ 	.id		=	"fq_codel",
+ 	.priv_size	=	sizeof(struct fq_codel_sched_data),
+@@ -710,6 +710,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
+ 	.dump_stats =	fq_codel_dump_stats,
+ 	.owner		=	THIS_MODULE,
+ };
++EXPORT_SYMBOL(fq_codel_qdisc_ops);
+ 
+ static int __init fq_codel_module_init(void)
+ {
+--- a/include/net/sch_generic.h
++++ b/include/net/sch_generic.h
+@@ -344,6 +344,7 @@ extern struct Qdisc_ops noop_qdisc_ops;
+ extern struct Qdisc_ops pfifo_fast_ops;
+ extern struct Qdisc_ops mq_qdisc_ops;
+ extern struct Qdisc_ops noqueue_qdisc_ops;
++extern struct Qdisc_ops fq_codel_qdisc_ops;
+ extern const struct Qdisc_ops *default_qdisc_ops;
+ 
+ struct Qdisc_class_common {
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -31,7 +31,7 @@
+ #include <net/dst.h>
+ 
+ /* Qdisc to use by default */
+-const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
++const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
+ EXPORT_SYMBOL(default_qdisc_ops);
+ 
+ /* Main transmission queue. */
+@@ -731,7 +731,7 @@ static void attach_one_default_qdisc(str
+ 				     void *_unused)
+ {
+ 	struct Qdisc *qdisc;
+-	const struct Qdisc_ops *ops = default_qdisc_ops;
++	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
+ 
+ 	if (dev->priv_flags & IFF_NO_QUEUE)
+ 		ops = &noqueue_qdisc_ops;
+--- a/net/sched/sch_mq.c
++++ b/net/sched/sch_mq.c
+@@ -57,7 +57,7 @@ static int mq_init(struct Qdisc *sch, st
+ 
+ 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
+ 		dev_queue = netdev_get_tx_queue(dev, ntx);
+-		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
++		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
+ 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
+ 						    TC_H_MIN(ntx + 1)));
+ 		if (!qdisc)
+--- a/net/sched/sch_mqprio.c
++++ b/net/sched/sch_mqprio.c
+@@ -122,7 +122,7 @@ static int mqprio_init(struct Qdisc *sch
+ 
+ 	for (i = 0; i < dev->num_tx_queues; i++) {
+ 		dev_queue = netdev_get_tx_queue(dev, i);
+-		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
++		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
+ 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
+ 						    TC_H_MIN(i + 1)));
+ 		if (!qdisc)
+--- a/net/sched/sch_api.c
++++ b/net/sched/sch_api.c
+@@ -1951,7 +1951,7 @@ static int __init pktsched_init(void)
+ 		return err;
+ 	}
+ 
+-	register_qdisc(&pfifo_fast_ops);
++	register_qdisc(&fq_codel_qdisc_ops);
+ 	register_qdisc(&pfifo_qdisc_ops);
+ 	register_qdisc(&bfifo_qdisc_ops);
+ 	register_qdisc(&pfifo_head_drop_qdisc_ops);
diff --git a/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch b/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch
new file mode 100644
index 0000000000..6f72b19358
--- /dev/null
+++ b/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch
@@ -0,0 +1,142 @@
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -438,139 +438,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
+ 	.owner		=	THIS_MODULE,
+ };
+ 
+-static const u8 prio2band[TC_PRIO_MAX + 1] = {
+-	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
+-};
+-
+-/* 3-band FIFO queue: old style, but should be a bit faster than
+-   generic prio+fifo combination.
+- */
+-
+-#define PFIFO_FAST_BANDS 3
+-
+-/*
+- * Private data for a pfifo_fast scheduler containing:
+- * 	- queues for the three band
+- * 	- bitmap indicating which of the bands contain skbs
+- */
+-struct pfifo_fast_priv {
+-	u32 bitmap;
+-	struct sk_buff_head q[PFIFO_FAST_BANDS];
+-};
+-
+-/*
+- * Convert a bitmap to the first band number where an skb is queued, where:
+- * 	bitmap=0 means there are no skbs on any band.
+- * 	bitmap=1 means there is an skb on band 0.
+- *	bitmap=7 means there are skbs on all 3 bands, etc.
+- */
+-static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
+-
+-static inline struct sk_buff_head *band2list(struct pfifo_fast_priv *priv,
+-					     int band)
+-{
+-	return priv->q + band;
+-}
+-
+-static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc)
+-{
+-	if (skb_queue_len(&qdisc->q) < qdisc_dev(qdisc)->tx_queue_len) {
+-		int band = prio2band[skb->priority & TC_PRIO_MAX];
+-		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
+-		struct sk_buff_head *list = band2list(priv, band);
+-
+-		priv->bitmap |= (1 << band);
+-		qdisc->q.qlen++;
+-		return __qdisc_enqueue_tail(skb, qdisc, list);
+-	}
+-
+-	return qdisc_drop(skb, qdisc);
+-}
+-
+-static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
+-{
+-	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
+-	int band = bitmap2band[priv->bitmap];
+-
+-	if (likely(band >= 0)) {
+-		struct sk_buff_head *list = band2list(priv, band);
+-		struct sk_buff *skb = __qdisc_dequeue_head(qdisc, list);
+-
+-		qdisc->q.qlen--;
+-		if (skb_queue_empty(list))
+-			priv->bitmap &= ~(1 << band);
+-
+-		return skb;
+-	}
+-
+-	return NULL;
+-}
+-
+-static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
+-{
+-	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
+-	int band = bitmap2band[priv->bitmap];
+-
+-	if (band >= 0) {
+-		struct sk_buff_head *list = band2list(priv, band);
+-
+-		return skb_peek(list);
+-	}
+-
+-	return NULL;
+-}
+-
+-static void pfifo_fast_reset(struct Qdisc *qdisc)
+-{
+-	int prio;
+-	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
+-
+-	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
+-		__qdisc_reset_queue(qdisc, band2list(priv, prio));
+-
+-	priv->bitmap = 0;
+-	qdisc->qstats.backlog = 0;
+-	qdisc->q.qlen = 0;
+-}
+-
+-static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
+-{
+-	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
+-
+-	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
+-	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
+-		goto nla_put_failure;
+-	return skb->len;
+-
+-nla_put_failure:
+-	return -1;
+-}
+-
+-static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
+-{
+-	int prio;
+-	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
+-
+-	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
+-		__skb_queue_head_init(band2list(priv, prio));
+-
+-	/* Can by-pass the queue discipline */
+-	qdisc->flags |= TCQ_F_CAN_BYPASS;
+-	return 0;
+-}
+-
+-struct Qdisc_ops pfifo_fast_ops __read_mostly = {
+-	.id		=	"pfifo_fast",
+-	.priv_size	=	sizeof(struct pfifo_fast_priv),
+-	.enqueue	=	pfifo_fast_enqueue,
+-	.dequeue	=	pfifo_fast_dequeue,
+-	.peek		=	pfifo_fast_peek,
+-	.init		=	pfifo_fast_init,
+-	.reset		=	pfifo_fast_reset,
+-	.dump		=	pfifo_fast_dump,
+-	.owner		=	THIS_MODULE,
+-};
+-
+ static struct lock_class_key qdisc_tx_busylock;
+ 
+ struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
diff --git a/target/linux/generic/pending-4.4/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch b/target/linux/generic/pending-4.4/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
new file mode 100644
index 0000000000..fe599798ce
--- /dev/null
+++ b/target/linux/generic/pending-4.4/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
@@ -0,0 +1,496 @@
+From 775d6fe74d1eaec2ba387535b068dde2dc89de9e Mon Sep 17 00:00:00 2001
+From: Steven Barth <steven@midlink.org>
+Date: Thu, 22 May 2014 09:49:05 +0200
+Subject: [PATCH] Add support for MAP-E FMRs (mesh mode)
+
+MAP-E FMRs (draft-ietf-softwire-map-10) are rules for IPv4-communication
+between MAP CEs (mesh mode) without the need to forward such data to a
+border relay. This is similar to how 6rd works but for IPv4 over IPv6.
+
+Signed-off-by: Steven Barth <cyrus@openwrt.org>
+---
+ include/net/ip6_tunnel.h       |  13 ++
+ include/uapi/linux/if_tunnel.h |  13 ++
+ net/ipv6/ip6_tunnel.c          | 276 +++++++++++++++++++++++++++++++++++++++--
+ 3 files changed, 291 insertions(+), 11 deletions(-)
+
+--- a/include/net/ip6_tunnel.h
++++ b/include/net/ip6_tunnel.h
+@@ -17,6 +17,18 @@
+ /* determine capability on a per-packet basis */
+ #define IP6_TNL_F_CAP_PER_PACKET 0x40000
+ 
++/* IPv6 tunnel FMR */
++struct __ip6_tnl_fmr {
++	struct __ip6_tnl_fmr *next; /* next fmr in list */
++	struct in6_addr ip6_prefix;
++	struct in_addr ip4_prefix;
++
++	__u8 ip6_prefix_len;
++	__u8 ip4_prefix_len;
++	__u8 ea_len;
++	__u8 offset;
++};
++
+ struct __ip6_tnl_parm {
+ 	char name[IFNAMSIZ];	/* name of tunnel device */
+ 	int link;		/* ifindex of underlying L2 interface */
+@@ -27,6 +39,7 @@ struct __ip6_tnl_parm {
+ 	__u32 flags;		/* tunnel flags */
+ 	struct in6_addr laddr;	/* local tunnel end-point address */
+ 	struct in6_addr raddr;	/* remote tunnel end-point address */
++	struct __ip6_tnl_fmr *fmrs;	/* FMRs */
+ 
+ 	__be16			i_flags;
+ 	__be16			o_flags;
+--- a/include/uapi/linux/if_tunnel.h
++++ b/include/uapi/linux/if_tunnel.h
+@@ -57,10 +57,23 @@ enum {
+ 	IFLA_IPTUN_ENCAP_FLAGS,
+ 	IFLA_IPTUN_ENCAP_SPORT,
+ 	IFLA_IPTUN_ENCAP_DPORT,
++	IFLA_IPTUN_FMRS,
+ 	__IFLA_IPTUN_MAX,
+ };
+ #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
+ 
++enum {
++	IFLA_IPTUN_FMR_UNSPEC,
++	IFLA_IPTUN_FMR_IP6_PREFIX,
++	IFLA_IPTUN_FMR_IP4_PREFIX,
++	IFLA_IPTUN_FMR_IP6_PREFIX_LEN,
++	IFLA_IPTUN_FMR_IP4_PREFIX_LEN,
++	IFLA_IPTUN_FMR_EA_LEN,
++	IFLA_IPTUN_FMR_OFFSET,
++	__IFLA_IPTUN_FMR_MAX,
++};
++#define IFLA_IPTUN_FMR_MAX (__IFLA_IPTUN_FMR_MAX - 1)
++
+ enum tunnel_encap_types {
+ 	TUNNEL_ENCAP_NONE,
+ 	TUNNEL_ENCAP_FOU,
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -16,6 +16,8 @@
+  *      as published by the Free Software Foundation; either version
+  *      2 of the License, or (at your option) any later version.
+  *
++ *	Changes:
++ * Steven Barth <cyrus@openwrt.org>:		MAP-E FMR support
+  */
+ 
+ #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+@@ -71,11 +73,9 @@ static bool log_ecn_error = true;
+ module_param(log_ecn_error, bool, 0644);
+ MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
+ 
+-static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)
++static u32 HASH(const struct in6_addr *addr)
+ {
+-	u32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);
+-
+-	return hash_32(hash, HASH_SIZE_SHIFT);
++	return hash_32(ipv6_addr_hash(addr), HASH_SIZE_SHIFT);
+ }
+ 
+ static int ip6_tnl_dev_init(struct net_device *dev);
+@@ -139,20 +139,29 @@ static struct net_device_stats *ip6_get_
+ static struct ip6_tnl *
+ ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_addr *local)
+ {
+-	unsigned int hash = HASH(remote, local);
++	unsigned int hash = HASH(local);
+ 	struct ip6_tnl *t;
+ 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
+ 	struct in6_addr any;
++	struct __ip6_tnl_fmr *fmr;
+ 
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+-		if (ipv6_addr_equal(local, &t->parms.laddr) &&
+-		    ipv6_addr_equal(remote, &t->parms.raddr) &&
+-		    (t->dev->flags & IFF_UP))
++		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
++				!(t->dev->flags & IFF_UP))
++			continue;
++
++		if (ipv6_addr_equal(remote, &t->parms.raddr))
+ 			return t;
++
++		for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
++			if (ipv6_prefix_equal(remote, &fmr->ip6_prefix,
++					fmr->ip6_prefix_len))
++				return t;
++		}
+ 	}
+ 
+ 	memset(&any, 0, sizeof(any));
+-	hash = HASH(&any, local);
++	hash = HASH(local);
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+ 		if (ipv6_addr_equal(local, &t->parms.laddr) &&
+ 		    ipv6_addr_any(&t->parms.raddr) &&
+@@ -160,7 +169,7 @@ ip6_tnl_lookup(struct net *net, const st
+ 			return t;
+ 	}
+ 
+-	hash = HASH(remote, &any);
++	hash = HASH(&any);
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+ 		if (ipv6_addr_equal(remote, &t->parms.raddr) &&
+ 		    ipv6_addr_any(&t->parms.laddr) &&
+@@ -196,7 +205,7 @@ ip6_tnl_bucket(struct ip6_tnl_net *ip6n,
+ 
+ 	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
+ 		prio = 1;
+-		h = HASH(remote, local);
++		h = HASH(local);
+ 	}
+ 	return &ip6n->tnls[prio][h];
+ }
+@@ -369,6 +378,12 @@ ip6_tnl_dev_uninit(struct net_device *de
+ 	struct net *net = t->net;
+ 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
+ 
++	while (t->parms.fmrs) {
++		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
++		kfree(t->parms.fmrs);
++		t->parms.fmrs = next;
++	}
++
+ 	if (dev == ip6n->fb_tnl_dev)
+ 		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
+ 	else
+@@ -765,6 +780,108 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
+ }
+ EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
+ 
++
++/**
++ * ip4ip6_fmr_calc - calculate target / source IPv6-address based on FMR
++ *   @dest: destination IPv6 address buffer
++ *   @skb: received socket buffer
++ *   @fmr: MAP FMR
++ *   @xmit: Calculate for xmit or rcv
++ **/
++static void ip4ip6_fmr_calc(struct in6_addr *dest,
++		const struct iphdr *iph, const uint8_t *end,
++		const struct __ip6_tnl_fmr *fmr, bool xmit)
++{
++	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
++	u8 *portp = NULL;
++	bool use_dest_addr;
++	const struct iphdr *dsth = iph;
++
++	if ((u8*)dsth >= end)
++		return;
++
++	/* find significant IP header */
++	if (iph->protocol == IPPROTO_ICMP) {
++		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
++		if (ih && ((u8*)&ih[1]) <= end && (
++			ih->type == ICMP_DEST_UNREACH ||
++			ih->type == ICMP_SOURCE_QUENCH ||
++			ih->type == ICMP_TIME_EXCEEDED ||
++			ih->type == ICMP_PARAMETERPROB ||
++			ih->type == ICMP_REDIRECT))
++				dsth = (const struct iphdr*)&ih[1];
++	}
++
++	/* in xmit-path use dest port by default and source port only if
++		this is an ICMP reply to something else; vice versa in rcv-path */
++	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
++
++	/* get dst port */
++	if (((u8*)&dsth[1]) <= end && (
++		dsth->protocol == IPPROTO_UDP ||
++		dsth->protocol == IPPROTO_TCP ||
++		dsth->protocol == IPPROTO_SCTP ||
++		dsth->protocol == IPPROTO_DCCP)) {
++			/* for UDP, TCP, SCTP and DCCP source and dest port
++			follow IPv4 header directly */
++			portp = ((u8*)dsth) + dsth->ihl * 4;
++
++			if (use_dest_addr)
++				portp += sizeof(u16);
++	} else if (iph->protocol == IPPROTO_ICMP) {
++		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
++
++		/* use icmp identifier as port */
++		if (((u8*)&ih) <= end && (
++		    (use_dest_addr && (
++		    ih->type == ICMP_ECHOREPLY ||
++			ih->type == ICMP_TIMESTAMPREPLY ||
++			ih->type == ICMP_INFO_REPLY ||
++			ih->type == ICMP_ADDRESSREPLY)) ||
++			(!use_dest_addr && (
++			ih->type == ICMP_ECHO ||
++			ih->type == ICMP_TIMESTAMP ||
++			ih->type == ICMP_INFO_REQUEST ||
++			ih->type == ICMP_ADDRESS)
++			)))
++				portp = (u8*)&ih->un.echo.id;
++	}
++
++	if ((portp && &portp[2] <= end) || psidlen == 0) {
++		int frombyte = fmr->ip6_prefix_len / 8;
++		int fromrem = fmr->ip6_prefix_len % 8;
++		int bytes = sizeof(struct in6_addr) - frombyte;
++		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
++		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
++		u64 t = 0;
++
++		/* extract PSID from port and add it to eabits */
++		u16 psidbits = 0;
++		if (psidlen > 0) {
++			psidbits = ((u16)portp[0]) << 8 | ((u16)portp[1]);
++			psidbits >>= 16 - psidlen - fmr->offset;
++			psidbits = (u16)(psidbits << (16 - psidlen));
++			eabits |= ((u64)psidbits) << (48 - (fmr->ea_len - psidlen));
++		}
++
++		/* rewrite destination address */
++		*dest = fmr->ip6_prefix;
++		memcpy(&dest->s6_addr[10], addr, sizeof(*addr));
++		dest->s6_addr16[7] = htons(psidbits >> (16 - psidlen));
++
++		if (bytes > sizeof(u64))
++			bytes = sizeof(u64);
++
++		/* insert eabits */
++		memcpy(&t, &dest->s6_addr[frombyte], bytes);
++		t = be64_to_cpu(t) & ~(((((u64)1) << fmr->ea_len) - 1)
++			<< (64 - fmr->ea_len - fromrem));
++		t = cpu_to_be64(t | (eabits >> fromrem));
++		memcpy(&dest->s6_addr[frombyte], &t, bytes);
++	}
++}
++
++
+ /**
+  * ip6_tnl_rcv - decapsulate IPv6 packet and retransmit it locally
+  *   @skb: received socket buffer
+@@ -810,6 +927,26 @@ static int ip6_tnl_rcv(struct sk_buff *s
+ 		skb_reset_network_header(skb);
+ 		skb->protocol = htons(protocol);
+ 		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
++		if (protocol == ETH_P_IP &&
++			!ipv6_addr_equal(&ipv6h->saddr, &t->parms.raddr)) {
++				/* Packet didn't come from BR, so lookup FMR */
++				struct __ip6_tnl_fmr *fmr;
++				struct in6_addr expected = t->parms.raddr;
++				for (fmr = t->parms.fmrs; fmr; fmr = fmr->next)
++					if (ipv6_prefix_equal(&ipv6h->saddr,
++						&fmr->ip6_prefix, fmr->ip6_prefix_len))
++							break;
++
++				/* Check that IPv6 matches IPv4 source to prevent spoofing */
++				if (fmr)
++					ip4ip6_fmr_calc(&expected, ip_hdr(skb),
++							skb_tail_pointer(skb), fmr, false);
++
++				if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
++					rcu_read_unlock();
++					goto discard;
++				}
++		}
+ 
+ 		__skb_tunnel_rx(skb, t->dev, t->net);
+ 
+@@ -1145,6 +1282,7 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
+ 	__u32 mtu;
+ 	u8 tproto;
+ 	int err;
++	struct __ip6_tnl_fmr *fmr;
+ 
+ 	tproto = ACCESS_ONCE(t->parms.proto);
+ 	if ((tproto != IPPROTO_IPV6 && tproto != 0) ||
+@@ -1175,6 +1313,18 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
+ 		fl6.flowi6_mark = skb->mark;
+ 
++	/* try to find matching FMR */
++	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
++		unsigned mshift = 32 - fmr->ip4_prefix_len;
++		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
++				ntohl(ip_hdr(skb)->daddr) >> mshift)
++			break;
++	}
++
++	/* change dstaddr according to FMR */
++	if (fmr)
++		ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
++
+ 	err = ip6_tnl_xmit2(skb, dev, dsfield, &fl6, encap_limit, &mtu);
+ 	if (err != 0) {
+ 		if (err == -EMSGSIZE)
+@@ -1289,6 +1439,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
+ 	t->parms.flowinfo = p->flowinfo;
+ 	t->parms.link = p->link;
+ 	t->parms.proto = p->proto;
++
++	while (t->parms.fmrs) {
++		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
++		kfree(t->parms.fmrs);
++		t->parms.fmrs = next;
++	}
++	t->parms.fmrs = p->fmrs;
++
+ 	dst_cache_reset(&t->dst_cache);
+ 	ip6_tnl_link_config(t);
+ 	return 0;
+@@ -1327,6 +1485,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
+ 	p->flowinfo = u->flowinfo;
+ 	p->link = u->link;
+ 	p->proto = u->proto;
++	p->fmrs = NULL;
+ 	memcpy(p->name, u->name, sizeof(u->name));
+ }
+ 
+@@ -1622,6 +1781,15 @@ static int ip6_tnl_validate(struct nlatt
+ 	return 0;
+ }
+ 
++static const struct nla_policy ip6_tnl_fmr_policy[IFLA_IPTUN_FMR_MAX + 1] = {
++	[IFLA_IPTUN_FMR_IP6_PREFIX] = { .len = sizeof(struct in6_addr) },
++	[IFLA_IPTUN_FMR_IP4_PREFIX] = { .len = sizeof(struct in_addr) },
++	[IFLA_IPTUN_FMR_IP6_PREFIX_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_IP4_PREFIX_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_EA_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_OFFSET] = { .type = NLA_U8 }
++};
++
+ static void ip6_tnl_netlink_parms(struct nlattr *data[],
+ 				  struct __ip6_tnl_parm *parms)
+ {
+@@ -1653,6 +1821,46 @@ static void ip6_tnl_netlink_parms(struct
+ 
+ 	if (data[IFLA_IPTUN_PROTO])
+ 		parms->proto = nla_get_u8(data[IFLA_IPTUN_PROTO]);
++
++	if (data[IFLA_IPTUN_FMRS]) {
++		unsigned rem;
++		struct nlattr *fmr;
++		nla_for_each_nested(fmr, data[IFLA_IPTUN_FMRS], rem) {
++			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
++			struct __ip6_tnl_fmr *nfmr;
++
++			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
++				fmr, ip6_tnl_fmr_policy);
++
++			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
++				continue;
++
++			nfmr->offset = 6;
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX]))
++				nla_memcpy(&nfmr->ip6_prefix, fmrd[IFLA_IPTUN_FMR_IP6_PREFIX],
++					sizeof(nfmr->ip6_prefix));
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX]))
++				nla_memcpy(&nfmr->ip4_prefix, fmrd[IFLA_IPTUN_FMR_IP4_PREFIX],
++					sizeof(nfmr->ip4_prefix));
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX_LEN]))
++				nfmr->ip6_prefix_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX_LEN]))
++				nfmr->ip4_prefix_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_EA_LEN]))
++				nfmr->ea_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_OFFSET]))
++				nfmr->offset = nla_get_u8(c);
++
++			nfmr->next = parms->fmrs;
++			parms->fmrs = nfmr;
++		}
++	}
+ }
+ 
+ static int ip6_tnl_newlink(struct net *src_net, struct net_device *dev,
+@@ -1705,6 +1913,12 @@ static void ip6_tnl_dellink(struct net_d
+ 
+ static size_t ip6_tnl_get_size(const struct net_device *dev)
+ {
++	const struct ip6_tnl *t = netdev_priv(dev);
++	struct __ip6_tnl_fmr *c;
++	int fmrs = 0;
++	for (c = t->parms.fmrs; c; c = c->next)
++		++fmrs;
++
+ 	return
+ 		/* IFLA_IPTUN_LINK */
+ 		nla_total_size(4) +
+@@ -1722,6 +1936,24 @@ static size_t ip6_tnl_get_size(const str
+ 		nla_total_size(4) +
+ 		/* IFLA_IPTUN_PROTO */
+ 		nla_total_size(1) +
++		/* IFLA_IPTUN_FMRS */
++		nla_total_size(0) +
++		(
++			/* nest */
++			nla_total_size(0) +
++			/* IFLA_IPTUN_FMR_IP6_PREFIX */
++			nla_total_size(sizeof(struct in6_addr)) +
++			/* IFLA_IPTUN_FMR_IP4_PREFIX */
++			nla_total_size(sizeof(struct in_addr)) +
++			/* IFLA_IPTUN_FMR_EA_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_IP6_PREFIX_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_IP4_PREFIX_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_OFFSET */
++			nla_total_size(1)
++		) * fmrs +
+ 		0;
+ }
+ 
+@@ -1729,6 +1961,9 @@ static int ip6_tnl_fill_info(struct sk_b
+ {
+ 	struct ip6_tnl *tunnel = netdev_priv(dev);
+ 	struct __ip6_tnl_parm *parm = &tunnel->parms;
++	struct __ip6_tnl_fmr *c;
++	int fmrcnt = 0;
++	struct nlattr *fmrs;
+ 
+ 	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
+ 	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
+@@ -1737,8 +1972,27 @@ static int ip6_tnl_fill_info(struct sk_b
+ 	    nla_put_u8(skb, IFLA_IPTUN_ENCAP_LIMIT, parm->encap_limit) ||
+ 	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
+ 	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
+-	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto))
++	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
++	    !(fmrs = nla_nest_start(skb, IFLA_IPTUN_FMRS)))
+ 		goto nla_put_failure;
++
++	for (c = parm->fmrs; c; c = c->next) {
++		struct nlattr *fmr = nla_nest_start(skb, ++fmrcnt);
++		if (!fmr ||
++			nla_put(skb, IFLA_IPTUN_FMR_IP6_PREFIX,
++				sizeof(c->ip6_prefix), &c->ip6_prefix) ||
++			nla_put(skb, IFLA_IPTUN_FMR_IP4_PREFIX,
++				sizeof(c->ip4_prefix), &c->ip4_prefix) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_IP6_PREFIX_LEN, c->ip6_prefix_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_IP4_PREFIX_LEN, c->ip4_prefix_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_EA_LEN, c->ea_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_OFFSET, c->offset))
++				goto nla_put_failure;
++
++		nla_nest_end(skb, fmr);
++	}
++	nla_nest_end(skb, fmrs);
++
+ 	return 0;
+ 
+ nla_put_failure:
+@@ -1762,6 +2016,7 @@ static const struct nla_policy ip6_tnl_p
+ 	[IFLA_IPTUN_FLOWINFO]		= { .type = NLA_U32 },
+ 	[IFLA_IPTUN_FLAGS]		= { .type = NLA_U32 },
+ 	[IFLA_IPTUN_PROTO]		= { .type = NLA_U8 },
++	[IFLA_IPTUN_FMRS]		= { .type = NLA_NESTED },
+ };
+ 
+ static struct rtnl_link_ops ip6_link_ops __read_mostly = {
diff --git a/target/linux/generic/pending-4.4/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch b/target/linux/generic/pending-4.4/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
new file mode 100644
index 0000000000..c921a079ae
--- /dev/null
+++ b/target/linux/generic/pending-4.4/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
@@ -0,0 +1,249 @@
+From 1b5aaa4b16f6e6471ab1c07b38068197a1b4c395 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Fri, 24 May 2013 14:40:54 +0200
+Subject: [PATCH 1/2] ipv6: allow rejecting with "source address failed policy"
+
+RFC6204 L-14 requires rejecting traffic from invalid addresses with
+ICMPv6 Destination Unreachable, Code 5 (Source address failed ingress/
+egress policy) on the LAN side, so add an appropriate rule for that.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ include/net/netns/ipv6.h       |  1 +
+ include/uapi/linux/fib_rules.h |  4 +++
+ include/uapi/linux/rtnetlink.h |  1 +
+ net/ipv4/fib_semantics.c       |  4 +++
+ net/ipv4/fib_trie.c            |  1 +
+ net/ipv4/ipmr.c                |  1 +
+ net/ipv6/fib6_rules.c          |  4 +++
+ net/ipv6/ip6mr.c               |  2 ++
+ net/ipv6/route.c               | 58 +++++++++++++++++++++++++++++++++++++++++-
+ 9 files changed, 75 insertions(+), 1 deletion(-)
+
+--- a/include/net/netns/ipv6.h
++++ b/include/net/netns/ipv6.h
+@@ -63,6 +63,7 @@ struct netns_ipv6 {
+ 	unsigned long		 ip6_rt_last_gc;
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	struct rt6_info         *ip6_prohibit_entry;
++	struct rt6_info		*ip6_policy_failed_entry;
+ 	struct rt6_info         *ip6_blk_hole_entry;
+ 	struct fib6_table       *fib6_local_tbl;
+ 	struct fib_rules_ops    *fib6_rules_ops;
+--- a/include/uapi/linux/fib_rules.h
++++ b/include/uapi/linux/fib_rules.h
+@@ -64,6 +64,10 @@ enum {
+ 	FR_ACT_BLACKHOLE,	/* Drop without notification */
+ 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
+ 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
++	FR_ACT_RES9,
++	FR_ACT_RES10,
++	FR_ACT_RES11,
++	FR_ACT_POLICY_FAILED,	/* Drop with EACCES */
+ 	__FR_ACT_MAX,
+ };
+ 
+--- a/include/uapi/linux/rtnetlink.h
++++ b/include/uapi/linux/rtnetlink.h
+@@ -210,6 +210,7 @@ enum {
+ 	RTN_THROW,		/* Not in this table		*/
+ 	RTN_NAT,		/* Translate this address	*/
+ 	RTN_XRESOLVE,		/* Use external resolver	*/
++	RTN_POLICY_FAILED,	/* Failed ingress/egress policy */
+ 	__RTN_MAX
+ };
+ 
+--- a/net/ipv4/fib_semantics.c
++++ b/net/ipv4/fib_semantics.c
+@@ -138,6 +138,10 @@ const struct fib_prop fib_props[RTN_MAX
+ 		.error	= -EINVAL,
+ 		.scope	= RT_SCOPE_NOWHERE,
+ 	},
++	[RTN_POLICY_FAILED] = {
++		.error	= -EACCES,
++		.scope	= RT_SCOPE_UNIVERSE,
++	},
+ };
+ 
+ static void rt_fibinfo_free(struct rtable __rcu **rtp)
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -2370,6 +2370,7 @@ static const char *const rtn_type_names[
+ 	[RTN_THROW] = "THROW",
+ 	[RTN_NAT] = "NAT",
+ 	[RTN_XRESOLVE] = "XRESOLVE",
++	[RTN_POLICY_FAILED] = "POLICY_FAILED",
+ };
+ 
+ static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -182,6 +182,7 @@ static int ipmr_rule_action(struct fib_r
+ 	case FR_ACT_UNREACHABLE:
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
++	case FR_ACT_POLICY_FAILED:
+ 		return -EACCES;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+--- a/net/ipv6/fib6_rules.c
++++ b/net/ipv6/fib6_rules.c
+@@ -73,6 +73,10 @@ static int fib6_rule_action(struct fib_r
+ 		err = -EACCES;
+ 		rt = net->ipv6.ip6_prohibit_entry;
+ 		goto discard_pkt;
++	case FR_ACT_POLICY_FAILED:
++		err = -EACCES;
++		rt = net->ipv6.ip6_policy_failed_entry;
++		goto discard_pkt;
+ 	}
+ 
+ 	table = fib6_get_table(net, rule->table);
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -167,6 +167,8 @@ static int ip6mr_rule_action(struct fib_
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
+ 		return -EACCES;
++	case FR_ACT_POLICY_FAILED:
++		return -EACCES;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+ 		return -EINVAL;
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -90,6 +90,8 @@ static int		ip6_pkt_discard(struct sk_bu
+ static int		ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);
+ static int		ip6_pkt_prohibit(struct sk_buff *skb);
+ static int		ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);
++static int		ip6_pkt_policy_failed(struct sk_buff *skb);
++static int		ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb);
+ static void		ip6_link_failure(struct sk_buff *skb);
+ static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
+ 					   struct sk_buff *skb, u32 mtu);
+@@ -297,6 +299,21 @@ static const struct rt6_info ip6_prohibi
+ 	.rt6i_ref	= ATOMIC_INIT(1),
+ };
+ 
++static const struct rt6_info ip6_policy_failed_entry_template = {
++	.dst = {
++		.__refcnt	= ATOMIC_INIT(1),
++		.__use		= 1,
++		.obsolete	= DST_OBSOLETE_FORCE_CHK,
++		.error		= -EACCES,
++		.input		= ip6_pkt_policy_failed,
++		.output		= ip6_pkt_policy_failed_out,
++	},
++	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
++	.rt6i_protocol	= RTPROT_KERNEL,
++	.rt6i_metric	= ~(u32) 0,
++	.rt6i_ref	= ATOMIC_INIT(1),
++};
++
+ static const struct rt6_info ip6_blk_hole_entry_template = {
+ 	.dst = {
+ 		.__refcnt	= ATOMIC_INIT(1),
+@@ -1899,6 +1916,11 @@ static struct rt6_info *ip6_route_info_c
+ 			rt->dst.output = ip6_pkt_prohibit_out;
+ 			rt->dst.input = ip6_pkt_prohibit;
+ 			break;
++		case RTN_POLICY_FAILED:
++			rt->dst.error = -EACCES;
++			rt->dst.output = ip6_pkt_policy_failed_out;
++			rt->dst.input = ip6_pkt_policy_failed;
++			break;
+ 		case RTN_THROW:
+ 		case RTN_UNREACHABLE:
+ 		default:
+@@ -2502,6 +2524,17 @@ static int ip6_pkt_prohibit_out(struct n
+ 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
+ }
+ 
++static int ip6_pkt_policy_failed(struct sk_buff *skb)
++{
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
++}
++
++static int ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb)
++{
++	skb->dev = skb_dst(skb)->dev;
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
++}
++
+ /*
+  *	Allocate a dst for local (unicast / anycast) address.
+  */
+@@ -2744,7 +2777,8 @@ static int rtm_to_fib6_config(struct sk_
+ 	if (rtm->rtm_type == RTN_UNREACHABLE ||
+ 	    rtm->rtm_type == RTN_BLACKHOLE ||
+ 	    rtm->rtm_type == RTN_PROHIBIT ||
+-	    rtm->rtm_type == RTN_THROW)
++	    rtm->rtm_type == RTN_THROW ||
++	    rtm->rtm_type == RTN_POLICY_FAILED)
+ 		cfg->fc_flags |= RTF_REJECT;
+ 
+ 	if (rtm->rtm_type == RTN_LOCAL)
+@@ -3097,6 +3131,9 @@ static int rt6_fill_node(struct net *net
+ 		case -EACCES:
+ 			rtm->rtm_type = RTN_PROHIBIT;
+ 			break;
++		case -EPERM:
++			rtm->rtm_type = RTN_POLICY_FAILED;
++			break;
+ 		case -EAGAIN:
+ 			rtm->rtm_type = RTN_THROW;
+ 			break;
+@@ -3376,6 +3413,8 @@ static int ip6_route_dev_notify(struct n
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
+ 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
++		net->ipv6.ip6_policy_failed_entry->dst.dev = dev;
++		net->ipv6.ip6_policy_failed_entry->rt6i_idev = in6_dev_get(dev);
+ 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
+ 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
+ #endif
+@@ -3602,6 +3641,17 @@ static int __net_init ip6_route_net_init
+ 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
+ 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
+ 			 ip6_template_metrics, true);
++
++	net->ipv6.ip6_policy_failed_entry =
++		kmemdup(&ip6_policy_failed_entry_template,
++			sizeof(*net->ipv6.ip6_policy_failed_entry), GFP_KERNEL);
++	if (!net->ipv6.ip6_policy_failed_entry)
++		goto out_ip6_blk_hole_entry;
++	net->ipv6.ip6_policy_failed_entry->dst.path =
++		(struct dst_entry *)net->ipv6.ip6_policy_failed_entry;
++	net->ipv6.ip6_policy_failed_entry->dst.ops = &net->ipv6.ip6_dst_ops;
++	dst_init_metrics(&net->ipv6.ip6_policy_failed_entry->dst,
++			 ip6_template_metrics, true);
+ #endif
+ 
+ 	net->ipv6.sysctl.flush_delay = 0;
+@@ -3620,6 +3670,8 @@ out:
+ 	return ret;
+ 
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
++out_ip6_blk_hole_entry:
++	kfree(net->ipv6.ip6_blk_hole_entry);
+ out_ip6_prohibit_entry:
+ 	kfree(net->ipv6.ip6_prohibit_entry);
+ out_ip6_null_entry:
+@@ -3637,6 +3689,7 @@ static void __net_exit ip6_route_net_exi
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	kfree(net->ipv6.ip6_prohibit_entry);
+ 	kfree(net->ipv6.ip6_blk_hole_entry);
++	kfree(net->ipv6.ip6_policy_failed_entry);
+ #endif
+ 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
+ }
+@@ -3710,6 +3763,9 @@ void __init ip6_route_init_special_entri
+ 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
+ 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
+ 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
++	init_net.ipv6.ip6_policy_failed_entry->dst.dev = init_net.loopback_dev;
++	init_net.ipv6.ip6_policy_failed_entry->rt6i_idev =
++		in6_dev_get(init_net.loopback_dev);
+   #endif
+ }
+ 
diff --git a/target/linux/generic/pending-4.4/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch b/target/linux/generic/pending-4.4/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
new file mode 100644
index 0000000000..dafb56cd8b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
@@ -0,0 +1,53 @@
+From 7749b481ce5d7e232b1f7da5e6b2c44816f51681 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jogo@openwrt.org>
+Date: Sun, 19 Jan 2014 20:45:51 +0100
+Subject: [PATCH 2/2] net: provide defines for _POLICY_FAILED until all code is
+ updated
+
+Upstream introduced ICMPV6_POLICY_FAIL for code 5 of destination
+unreachable, conflicting with our name.
+
+Add appropriate defines to allow our code to build with the new
+name until we have updated our local patches for older kernels
+and userspace packages.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ include/uapi/linux/fib_rules.h | 2 ++
+ include/uapi/linux/icmpv6.h    | 2 ++
+ include/uapi/linux/rtnetlink.h | 2 ++
+ 3 files changed, 6 insertions(+)
+
+--- a/include/uapi/linux/fib_rules.h
++++ b/include/uapi/linux/fib_rules.h
+@@ -71,6 +71,8 @@ enum {
+ 	__FR_ACT_MAX,
+ };
+ 
++#define FR_ACT_FAILED_POLICY FR_ACT_POLICY_FAILED
++
+ #define FR_ACT_MAX (__FR_ACT_MAX - 1)
+ 
+ #endif
+--- a/include/uapi/linux/icmpv6.h
++++ b/include/uapi/linux/icmpv6.h
+@@ -118,6 +118,8 @@ struct icmp6hdr {
+ #define ICMPV6_POLICY_FAIL		5
+ #define ICMPV6_REJECT_ROUTE		6
+ 
++#define ICMPV6_FAILED_POLICY		ICMPV6_POLICY_FAIL
++
+ /*
+  *	Codes for Time Exceeded
+  */
+--- a/include/uapi/linux/rtnetlink.h
++++ b/include/uapi/linux/rtnetlink.h
+@@ -214,6 +214,8 @@ enum {
+ 	__RTN_MAX
+ };
+ 
++#define RTN_FAILED_POLICY RTN_POLICY_FAILED
++
+ #define RTN_MAX (__RTN_MAX - 1)
+ 
+ 
diff --git a/target/linux/generic/pending-4.4/680-NET-skip-GRO-for-foreign-MAC-addresses.patch b/target/linux/generic/pending-4.4/680-NET-skip-GRO-for-foreign-MAC-addresses.patch
new file mode 100644
index 0000000000..bfe76dbc16
--- /dev/null
+++ b/target/linux/generic/pending-4.4/680-NET-skip-GRO-for-foreign-MAC-addresses.patch
@@ -0,0 +1,160 @@
+Subject: NET: skip GRO for foreign MAC addresses
+
+For network drivers using napi_gro_receive, packets are run through GRO,
+even when the destination MAC address does not match, and they're supposed
+to be delivered to another host behind a different bridge port.
+
+This can be very expensive, because for drivers without TSO or scatter-
+gather, this can only be undone by copying the skb and checksumming it
+again.
+
+To be able to track foreign MAC addresses in an inexpensive way, create
+a mask of changed bits in MAC addresses of upper devices. This allows
+handling VLANs and bridge devices with different addresses (as long as
+they are not too different).
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -4278,6 +4278,9 @@ static enum gro_result dev_gro_receive(s
+ 	enum gro_result ret;
+ 	int grow;
+ 
++	if (skb->gro_skip)
++		goto normal;
++
+ 	if (!(skb->dev->features & NETIF_F_GRO))
+ 		goto normal;
+ 
+@@ -5444,6 +5447,48 @@ static void __netdev_adjacent_dev_unlink
+ 					   &upper_dev->adj_list.lower);
+ }
+ 
++static void __netdev_addr_mask(unsigned char *mask, const unsigned char *addr,
++			       struct net_device *dev)
++{
++	int i;
++
++	for (i = 0; i < dev->addr_len; i++)
++		mask[i] |= addr[i] ^ dev->dev_addr[i];
++}
++
++static void __netdev_upper_mask(unsigned char *mask, struct net_device *dev,
++				struct net_device *lower)
++{
++	struct net_device *cur;
++	struct list_head *iter;
++
++	netdev_for_each_upper_dev_rcu(dev, cur, iter) {
++		__netdev_addr_mask(mask, cur->dev_addr, lower);
++		__netdev_upper_mask(mask, cur, lower);
++	}
++}
++
++static void __netdev_update_addr_mask(struct net_device *dev)
++{
++	unsigned char mask[MAX_ADDR_LEN];
++	struct net_device *cur;
++	struct list_head *iter;
++
++	memset(mask, 0, sizeof(mask));
++	__netdev_upper_mask(mask, dev, dev);
++	memcpy(dev->local_addr_mask, mask, dev->addr_len);
++
++	netdev_for_each_lower_dev(dev, cur, iter)
++		__netdev_update_addr_mask(cur);
++}
++
++static void netdev_update_addr_mask(struct net_device *dev)
++{
++	rcu_read_lock();
++	__netdev_update_addr_mask(dev);
++	rcu_read_unlock();
++}
++
+ static int __netdev_upper_dev_link(struct net_device *dev,
+ 				   struct net_device *upper_dev, bool master,
+ 				   void *private)
+@@ -5515,6 +5560,7 @@ static int __netdev_upper_dev_link(struc
+ 			goto rollback_lower_mesh;
+ 	}
+ 
++	netdev_update_addr_mask(dev);
+ 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
+ 				      &changeupper_info.info);
+ 	return 0;
+@@ -5641,6 +5687,7 @@ void netdev_upper_dev_unlink(struct net_
+ 	list_for_each_entry(i, &upper_dev->all_adj_list.upper, list)
+ 		__netdev_adjacent_dev_unlink(dev, i->dev, i->ref_nr);
+ 
++	netdev_update_addr_mask(dev);
+ 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
+ 				      &changeupper_info.info);
+ }
+@@ -6181,6 +6228,7 @@ int dev_set_mac_address(struct net_devic
+ 	if (err)
+ 		return err;
+ 	dev->addr_assign_type = NET_ADDR_SET;
++	netdev_update_addr_mask(dev);
+ 	call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
+ 	add_device_randomness(dev->dev_addr, dev->addr_len);
+ 	return 0;
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1639,6 +1639,8 @@ struct net_device {
+ 	struct netdev_hw_addr_list	mc;
+ 	struct netdev_hw_addr_list	dev_addrs;
+ 
++	unsigned char		local_addr_mask[MAX_ADDR_LEN];
++
+ #ifdef CONFIG_SYSFS
+ 	struct kset		*queues_kset;
+ #endif
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -642,7 +642,8 @@ struct sk_buff {
+ 	__u8			ipvs_property:1;
+ 	__u8			inner_protocol_type:1;
+ 	__u8			remcsum_offload:1;
+-	/* 3 or 5 bit hole */
++	__u8			gro_skip:1;
++	/* 2 or 4 bit hole */
+ 
+ #ifdef CONFIG_NET_SCHED
+ 	__u16			tc_index;	/* traffic control index */
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -140,6 +140,18 @@ u32 eth_get_headlen(void *data, unsigned
+ }
+ EXPORT_SYMBOL(eth_get_headlen);
+ 
++static inline bool
++eth_check_local_mask(const void *addr1, const void *addr2, const void *mask)
++{
++	const u16 *a1 = addr1;
++	const u16 *a2 = addr2;
++	const u16 *m = mask;
++
++	return (((a1[0] ^ a2[0]) & ~m[0]) |
++		((a1[1] ^ a2[1]) & ~m[1]) |
++		((a1[2] ^ a2[2]) & ~m[2]));
++}
++
+ /**
+  * eth_type_trans - determine the packet's protocol ID.
+  * @skb: received socket data
+@@ -168,8 +180,12 @@ __be16 eth_type_trans(struct sk_buff *sk
+ 			skb->pkt_type = PACKET_MULTICAST;
+ 	}
+ 	else if (unlikely(!ether_addr_equal_64bits(eth->h_dest,
+-						   dev->dev_addr)))
++						   dev->dev_addr))) {
+ 		skb->pkt_type = PACKET_OTHERHOST;
++		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
++					 dev->local_addr_mask))
++			skb->gro_skip = 1;
++	}
+ 
+ 	/*
+ 	 * Some variants of DSA tagging don't have an ethertype field
diff --git a/target/linux/generic/pending-4.4/681-NET-add-of_get_mac_address_mtd.patch b/target/linux/generic/pending-4.4/681-NET-add-of_get_mac_address_mtd.patch
new file mode 100644
index 0000000000..2044872973
--- /dev/null
+++ b/target/linux/generic/pending-4.4/681-NET-add-of_get_mac_address_mtd.patch
@@ -0,0 +1,128 @@
+From: John Crispin <blogic@openwrt.org>
+Date: Sun, 27 Jul 2014 09:40:01 +0100
+Subject: NET: add mtd-mac-address support to of_get_mac_address()
+
+Many embedded devices have information such as mac addresses stored inside mtd
+devices. This patch allows us to add a property inside a node describing a
+network interface. The new property points at a mtd partition with an offset
+where the mac address can be found.
+
+Signed-off-by: John Crispin <blogic@openwrt.org>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/of/of_net.c    |   37 +++++++++++++++++++++++++++++++++++++
+ include/linux/of_net.h |    1 +
+ 2 files changed, 38 insertions(+)
+
+--- a/drivers/of/of_net.c
++++ b/drivers/of/of_net.c
+@@ -10,6 +10,7 @@
+ #include <linux/of_net.h>
+ #include <linux/phy.h>
+ #include <linux/export.h>
++#include <linux/mtd/mtd.h>
+ 
+ /**
+  * of_get_phy_mode - Get phy mode for given device_node
+@@ -38,7 +39,7 @@ int of_get_phy_mode(struct device_node *
+ }
+ EXPORT_SYMBOL_GPL(of_get_phy_mode);
+ 
+-static const void *of_get_mac_addr(struct device_node *np, const char *name)
++static void *of_get_mac_addr(struct device_node *np, const char *name)
+ {
+ 	struct property *pp = of_find_property(np, name, NULL);
+ 
+@@ -47,6 +48,73 @@ static const void *of_get_mac_addr(struc
+ 	return NULL;
+ }
+ 
++static const void *of_get_mac_address_mtd(struct device_node *np)
++{
++#ifdef CONFIG_MTD
++	struct device_node *mtd_np = NULL;
++	struct property *prop;
++	size_t retlen;
++	int size, ret;
++	struct mtd_info *mtd;
++	const char *part;
++	const __be32 *list;
++	phandle phandle;
++	u32 mac_inc = 0;
++	u8 mac[ETH_ALEN];
++	void *addr;
++
++	list = of_get_property(np, "mtd-mac-address", &size);
++	if (!list || (size != (2 * sizeof(*list))))
++		return NULL;
++
++	phandle = be32_to_cpup(list++);
++	if (phandle)
++		mtd_np = of_find_node_by_phandle(phandle);
++
++	if (!mtd_np)
++		return NULL;
++
++	part = of_get_property(mtd_np, "label", NULL);
++	if (!part)
++		part = mtd_np->name;
++
++	mtd = get_mtd_device_nm(part);
++	if (IS_ERR(mtd))
++		return NULL;
++
++	ret = mtd_read(mtd, be32_to_cpup(list), 6, &retlen, mac);
++	put_mtd_device(mtd);
++
++	if (!of_property_read_u32(np, "mtd-mac-address-increment", &mac_inc))
++		mac[5] += mac_inc;
++
++	if (!is_valid_ether_addr(mac))
++		return NULL;
++
++	addr = of_get_mac_addr(np, "mac-address");
++	if (addr) {
++		memcpy(addr, mac, ETH_ALEN);
++		return addr;
++	}
++
++	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
++	if (!prop)
++		return NULL;
++
++	prop->name = "mac-address";
++	prop->length = ETH_ALEN;
++	prop->value = kmemdup(mac, ETH_ALEN, GFP_KERNEL);
++	if (!prop->value || of_add_property(np, prop))
++		goto free;
++
++	return prop->value;
++free:
++	kfree(prop->value);
++	kfree(prop);
++#endif
++	return NULL;
++}
++
+ /**
+  * Search the device tree for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+@@ -64,11 +132,18 @@ static const void *of_get_mac_addr(struc
+  * addresses.  Some older U-Boots only initialized 'local-mac-address'.  In
+  * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
+  * but is all zeros.
++ *
++ * If a mtd-mac-address property exists, try to fetch the MAC address from the
++ * specified mtd device, and store it as a 'mac-address' property
+ */
+ const void *of_get_mac_address(struct device_node *np)
+ {
+ 	const void *addr;
+ 
++	addr = of_get_mac_address_mtd(np);
++	if (addr)
++		return addr;
++
+ 	addr = of_get_mac_addr(np, "mac-address");
+ 	if (addr)
+ 		return addr;
diff --git a/target/linux/generic/pending-4.4/700-swconfig.patch b/target/linux/generic/pending-4.4/700-swconfig.patch
new file mode 100644
index 0000000000..122dd446c6
--- /dev/null
+++ b/target/linux/generic/pending-4.4/700-swconfig.patch
@@ -0,0 +1,39 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -12,6 +12,16 @@ menuconfig PHYLIB
+ 
+ if PHYLIB
+ 
++config SWCONFIG
++	tristate "Switch configuration API"
++	---help---
++	  Switch configuration API using netlink. This allows
++	  you to configure the VLAN features of certain switches.
++
++config SWCONFIG_LEDS
++	bool "Switch LED trigger support"
++	depends on (SWCONFIG && LEDS_TRIGGERS)
++
+ comment "MII PHY device drivers"
+ 
+ config AQUANTIA_PHY
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -3,6 +3,7 @@
+ libphy-objs			:= phy.o phy_device.o mdio_bus.o
+ 
+ obj-$(CONFIG_PHYLIB)		+= libphy.o
++obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+ obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia.o
+ obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
+ obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
+--- a/include/uapi/linux/Kbuild
++++ b/include/uapi/linux/Kbuild
+@@ -388,6 +388,7 @@ header-y += stddef.h
+ header-y += string.h
+ header-y += suspend_ioctls.h
+ header-y += swab.h
++header-y += switch.h
+ header-y += synclink.h
+ header-y += sysctl.h
+ header-y += sysinfo.h
diff --git a/target/linux/generic/pending-4.4/701-phy_extension.patch b/target/linux/generic/pending-4.4/701-phy_extension.patch
new file mode 100644
index 0000000000..39b8fd4660
--- /dev/null
+++ b/target/linux/generic/pending-4.4/701-phy_extension.patch
@@ -0,0 +1,63 @@
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -385,6 +385,50 @@ int phy_ethtool_gset(struct phy_device *
+ }
+ EXPORT_SYMBOL(phy_ethtool_gset);
+ 
++int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
++{
++	u32 cmd;
++	int tmp;
++	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
++	struct ethtool_value edata = { ETHTOOL_GLINK };
++
++	if (get_user(cmd, (u32 *) useraddr))
++		return -EFAULT;
++
++	switch (cmd) {
++	case ETHTOOL_GSET:
++		phy_ethtool_gset(phydev, &ecmd);
++		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
++			return -EFAULT;
++		return 0;
++
++	case ETHTOOL_SSET:
++		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
++			return -EFAULT;
++		return phy_ethtool_sset(phydev, &ecmd);
++
++	case ETHTOOL_NWAY_RST:
++		/* if autoneg is off, it's an error */
++		tmp = phy_read(phydev, MII_BMCR);
++		if (tmp & BMCR_ANENABLE) {
++			tmp |= (BMCR_ANRESTART);
++			phy_write(phydev, MII_BMCR, tmp);
++			return 0;
++		}
++		return -EINVAL;
++
++	case ETHTOOL_GLINK:
++		edata.data = (phy_read(phydev,
++				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
++		if (copy_to_user(useraddr, &edata, sizeof(edata)))
++			return -EFAULT;
++		return 0;
++	}
++
++	return -EOPNOTSUPP;
++}
++EXPORT_SYMBOL(phy_ethtool_ioctl);
++
+ /**
+  * phy_mii_ioctl - generic PHY MII ioctl interface
+  * @phydev: the phy_device struct
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -807,6 +807,7 @@ void phy_start_machine(struct phy_device
+ void phy_stop_machine(struct phy_device *phydev);
+ int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+ int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
++int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
+ int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
+ int phy_start_interrupts(struct phy_device *phydev);
+ void phy_print_status(struct phy_device *phydev);
diff --git a/target/linux/generic/pending-4.4/702-phy_add_aneg_done_function.patch b/target/linux/generic/pending-4.4/702-phy_add_aneg_done_function.patch
new file mode 100644
index 0000000000..f20f48f405
--- /dev/null
+++ b/target/linux/generic/pending-4.4/702-phy_add_aneg_done_function.patch
@@ -0,0 +1,27 @@
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -497,6 +497,12 @@ struct phy_driver {
+ 	/* Determines the negotiated speed and duplex */
+ 	int (*read_status)(struct phy_device *phydev);
+ 
++	/* 
++	 * Update the value in phydev->link to reflect the 
++	 * current link value
++	 */
++	int (*update_link)(struct phy_device *phydev);
++
+ 	/* Clears any pending interrupts */
+ 	int (*ack_interrupt)(struct phy_device *phydev);
+ 
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -995,6 +995,9 @@ int genphy_update_link(struct phy_device
+ {
+ 	int status;
+ 
++	if (phydev->drv && phydev->drv->update_link)
++		return phydev->drv->update_link(phydev);
++
+ 	/* Do a fake read */
+ 	status = phy_read(phydev, MII_BMSR);
+ 	if (status < 0)
diff --git a/target/linux/generic/pending-4.4/703-phy-add-detach-callback-to-struct-phy_driver.patch b/target/linux/generic/pending-4.4/703-phy-add-detach-callback-to-struct-phy_driver.patch
new file mode 100644
index 0000000000..4ef3b781fa
--- /dev/null
+++ b/target/linux/generic/pending-4.4/703-phy-add-detach-callback-to-struct-phy_driver.patch
@@ -0,0 +1,27 @@
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -734,6 +734,9 @@ void phy_detach(struct phy_device *phyde
+ 	struct mii_bus *bus;
+ 	int i;
+ 
++	if (phydev->drv && phydev->drv->detach)
++		phydev->drv->detach(phydev);
++
+ 	phydev->attached_dev->phydev = NULL;
+ 	phydev->attached_dev = NULL;
+ 	phy_suspend(phydev);
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -515,6 +515,12 @@ struct phy_driver {
+ 	 */
+ 	int (*did_interrupt)(struct phy_device *phydev);
+ 
++	/*
++	 * Called before an ethernet device is detached
++	 * from the PHY.
++	 */
++	void (*detach)(struct phy_device *phydev);
++
+ 	/* Clears up any memory if needed */
+ 	void (*remove)(struct phy_device *phydev);
+ 
diff --git a/target/linux/generic/pending-4.4/710-phy-add-mdio_register_board_info.patch b/target/linux/generic/pending-4.4/710-phy-add-mdio_register_board_info.patch
new file mode 100644
index 0000000000..d78f3d48a7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/710-phy-add-mdio_register_board_info.patch
@@ -0,0 +1,193 @@
+--- a/drivers/net/phy/mdio_bus.c
++++ b/drivers/net/phy/mdio_bus.c
+@@ -38,6 +38,8 @@
+ 
+ #include <asm/irq.h>
+ 
++#include "mdio-boardinfo.h"
++
+ /**
+  * mdiobus_alloc_size - allocate a mii_bus structure
+  * @size: extra amount of memory to allocate for private storage.
+@@ -346,9 +348,21 @@ void mdiobus_free(struct mii_bus *bus)
+ }
+ EXPORT_SYMBOL(mdiobus_free);
+ 
++static void mdiobus_setup_phydev_from_boardinfo(struct mii_bus *bus,
++						struct phy_device *phydev,
++						struct mdio_board_info *bi)
++{
++	if (strcmp(bus->id, bi->bus_id) ||
++	    bi->phy_addr != phydev->addr)
++	    return;
++
++	phydev->dev.platform_data = (void *) bi->platform_data;
++}
++
+ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
+ {
+ 	struct phy_device *phydev;
++	struct mdio_board_entry *be;
+ 	int err;
+ 
+ 	phydev = get_phy_device(bus, addr, false);
+@@ -361,6 +375,12 @@ struct phy_device *mdiobus_scan(struct m
+ 	 */
+ 	of_mdiobus_link_phydev(bus, phydev);
+ 
++	mutex_lock(&__mdio_board_lock);
++	list_for_each_entry(be, &__mdio_board_list, list)
++		mdiobus_setup_phydev_from_boardinfo(bus, phydev,
++						    &be->board_info);
++	mutex_unlock(&__mdio_board_lock);
++
+ 	err = phy_device_register(phydev);
+ 	if (err) {
+ 		phy_device_free(phydev);
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -846,6 +846,23 @@ void mdio_bus_exit(void);
+ 
+ extern struct bus_type mdio_bus_type;
+ 
++struct mdio_board_info {
++	const char	*bus_id;
++	int		phy_addr;
++
++	const void	*platform_data;
++};
++
++#ifdef CONFIG_MDIO_BOARDINFO
++int mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n);
++#else
++static inline int
++mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n)
++{
++	return 0;
++}
++#endif
++
+ /**
+  * module_phy_driver() - Helper macro for registering PHY drivers
+  * @__phy_drivers: array of PHY drivers to register
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -12,6 +12,10 @@ menuconfig PHYLIB
+ 
+ if PHYLIB
+ 
++config MDIO_BOARDINFO
++	bool
++	default y
++
+ config SWCONFIG
+ 	tristate "Switch configuration API"
+ 	---help---
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -2,6 +2,8 @@
+ 
+ libphy-objs			:= phy.o phy_device.o mdio_bus.o
+ 
++obj-$(CONFIG_MDIO_BOARDINFO)	+= mdio-boardinfo.o
++
+ obj-$(CONFIG_PHYLIB)		+= libphy.o
+ obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+ obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia.o
+--- /dev/null
++++ b/drivers/net/phy/mdio-boardinfo.c
+@@ -0,0 +1,58 @@
++/*
++ * mdio-boardinfo.c - collect pre-declarations of PHY devices
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/phy.h>
++#include <linux/slab.h>
++#include <linux/export.h>
++#include <linux/mutex.h>
++#include <linux/phy.h>
++
++#include "mdio-boardinfo.h"
++
++/*
++ * These symbols are exported ONLY FOR the mdio_bus component.
++ * No other users will be supported.
++ */
++
++LIST_HEAD(__mdio_board_list);
++EXPORT_SYMBOL_GPL(__mdio_board_list);
++
++DEFINE_MUTEX(__mdio_board_lock);
++EXPORT_SYMBOL_GPL(__mdio_board_lock);
++
++/**
++ * mdio_register_board_info - register PHY devices for a given board
++ * @info: array of chip descriptors
++ * @n: how many descriptors are provided
++ * Context: can sleep
++ *
++ * The board info passed can safely be __initdata ... but be careful of
++ * any embedded pointers (platform_data, etc), they're copied as-is.
++ */
++int __init
++mdiobus_register_board_info(struct mdio_board_info const *info, unsigned n)
++{
++	struct mdio_board_entry *be;
++	int i;
++
++	be = kzalloc(n * sizeof(*be), GFP_KERNEL);
++	if (!be)
++		return -ENOMEM;
++
++	for (i = 0; i < n; i++, be++, info++) {
++		memcpy(&be->board_info, info, sizeof(*info));
++		mutex_lock(&__mdio_board_lock);
++		list_add_tail(&be->list, &__mdio_board_list);
++		mutex_unlock(&__mdio_board_lock);
++	}
++
++	return 0;
++}
+--- /dev/null
++++ b/drivers/net/phy/mdio-boardinfo.h
+@@ -0,0 +1,22 @@
++/*
++ * mdio-boardinfo.h - boardinfo interface internal to the mdio_bus component
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ */
++
++#include <linux/mutex.h>
++
++struct mdio_board_entry {
++	struct list_head	list;
++	struct mdio_board_info	board_info;
++};
++
++/* __mdio_board_lock protects __mdio_board_list
++ * only mdio_bus components are allowed to use these symbols.
++ */
++extern struct mutex __mdio_board_lock;
++extern struct list_head __mdio_board_list;
+--- a/drivers/net/Makefile
++++ b/drivers/net/Makefile
+@@ -16,7 +16,7 @@ obj-$(CONFIG_MII) += mii.o
+ obj-$(CONFIG_MDIO) += mdio.o
+ obj-$(CONFIG_NET) += Space.o loopback.o
+ obj-$(CONFIG_NETCONSOLE) += netconsole.o
+-obj-$(CONFIG_PHYLIB) += phy/
++obj-y += phy/
+ obj-$(CONFIG_RIONET) += rionet.o
+ obj-$(CONFIG_NET_TEAM) += team/
+ obj-$(CONFIG_TUN) += tun.o
diff --git a/target/linux/generic/pending-4.4/720-phy_adm6996.patch b/target/linux/generic/pending-4.4/720-phy_adm6996.patch
new file mode 100644
index 0000000000..bf939e893c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/720-phy_adm6996.patch
@@ -0,0 +1,26 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -175,6 +175,13 @@ config LANTIQ_PHY
+ 	---help---
+ 	  Supports the 11G and 22F PHYs.
+ 
++config ADM6996_PHY
++	tristate "Driver for ADM6996 switches"
++	select SWCONFIG
++	---help---
++	  Currently supports the ADM6996FC and ADM6996M switches.
++	  Support for FC is very limited.
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -22,6 +22,7 @@ obj-$(CONFIG_BCM7XXX_PHY)	+= bcm7xxx.o
+ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
+ obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygnus.o
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
++obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
diff --git a/target/linux/generic/pending-4.4/721-phy_packets.patch b/target/linux/generic/pending-4.4/721-phy_packets.patch
new file mode 100644
index 0000000000..39dc5ccbfc
--- /dev/null
+++ b/target/linux/generic/pending-4.4/721-phy_packets.patch
@@ -0,0 +1,161 @@
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1297,6 +1297,7 @@ enum netdev_priv_flags {
+ 	IFF_NO_QUEUE			= 1<<21,
+ 	IFF_OPENVSWITCH			= 1<<22,
+ 	IFF_L3MDEV_SLAVE		= 1<<23,
++	IFF_NO_IP_ALIGN			= 1<<24,
+ };
+ 
+ #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
+@@ -1323,6 +1324,7 @@ enum netdev_priv_flags {
+ #define IFF_NO_QUEUE			IFF_NO_QUEUE
+ #define IFF_OPENVSWITCH			IFF_OPENVSWITCH
+ #define IFF_L3MDEV_SLAVE		IFF_L3MDEV_SLAVE
++#define IFF_NO_IP_ALIGN			IFF_NO_IP_ALIGN
+ 
+ /**
+  *	struct net_device - The DEVICE structure.
+@@ -1603,6 +1605,11 @@ struct net_device {
+ 	const struct l3mdev_ops	*l3mdev_ops;
+ #endif
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
++	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
++#endif
++
+ 	const struct header_ops *header_ops;
+ 
+ 	unsigned int		flags;
+@@ -1670,6 +1677,10 @@ struct net_device {
+ 	struct mpls_dev __rcu	*mpls_ptr;
+ #endif
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void			*phy_ptr; /* PHY device specific data */
++#endif
++
+ /*
+  * Cache lines mostly used on receive path (including eth_type_trans())
+  */
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -2208,6 +2208,10 @@ static inline int pskb_trim(struct sk_bu
+ 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
+ }
+ 
++extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp);
++
++
+ /**
+  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
+  *	@skb: buffer to alter
+@@ -2312,16 +2316,6 @@ static inline struct sk_buff *dev_alloc_
+ }
+ 
+ 
+-static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
+-		unsigned int length, gfp_t gfp)
+-{
+-	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
+-
+-	if (NET_IP_ALIGN && skb)
+-		skb_reserve(skb, NET_IP_ALIGN);
+-	return skb;
+-}
+-
+ static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+ 		unsigned int length)
+ {
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -25,6 +25,12 @@ menuconfig NET
+ 
+ if NET
+ 
++config ETHERNET_PACKET_MANGLE
++	bool
++	help
++	  This option can be selected by phy drivers that need to mangle
++	  packets going in or out of an ethernet device.
++
+ config WANT_COMPAT_NETLINK_MESSAGES
+ 	bool
+ 	help
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -2754,10 +2754,20 @@ static int xmit_one(struct sk_buff *skb,
+ 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
+ 		dev_queue_xmit_nit(skb, dev);
+ 
+-	len = skb->len;
+-	trace_net_dev_start_xmit(skb, dev);
+-	rc = netdev_start_xmit(skb, dev, txq, more);
+-	trace_net_dev_xmit(skb, rc, dev, len);
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (!dev->eth_mangle_tx ||
++	    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
++#else
++	if (1)
++#endif
++	{
++		len = skb->len;
++		trace_net_dev_start_xmit(skb, dev);
++		rc = netdev_start_xmit(skb, dev, txq, more);
++		trace_net_dev_xmit(skb, rc, dev, len);
++	} else {
++		rc = NETDEV_TX_OK;
++	}
+ 
+ 	return rc;
+ }
+--- a/net/core/skbuff.c
++++ b/net/core/skbuff.c
+@@ -63,6 +63,7 @@
+ #include <linux/errqueue.h>
+ #include <linux/prefetch.h>
+ #include <linux/if_vlan.h>
++#include <linux/if.h>
+ 
+ #include <net/protocol.h>
+ #include <net/dst.h>
+@@ -520,6 +521,22 @@ skb_fail:
+ }
+ EXPORT_SYMBOL(__napi_alloc_skb);
+ 
++struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp)
++{
++	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
++		return skb;
++#endif
++
++	if (NET_IP_ALIGN && skb)
++		skb_reserve(skb, NET_IP_ALIGN);
++	return skb;
++}
++EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
++
+ void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
+ 		     int size, unsigned int truesize)
+ {
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -168,6 +168,12 @@ __be16 eth_type_trans(struct sk_buff *sk
+ 	const struct ethhdr *eth;
+ 
+ 	skb->dev = dev;
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev->eth_mangle_rx)
++		dev->eth_mangle_rx(dev, skb);
++#endif
++
+ 	skb_reset_mac_header(skb);
+ 
+ 	eth = (struct ethhdr *)skb->data;
diff --git a/target/linux/generic/pending-4.4/722-phy_mvswitch.patch b/target/linux/generic/pending-4.4/722-phy_mvswitch.patch
new file mode 100644
index 0000000000..37ec7d9e5d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/722-phy_mvswitch.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -182,6 +182,10 @@ config ADM6996_PHY
+ 	  Currently supports the ADM6996FC and ADM6996M switches.
+ 	  Support for FC is very limited.
+ 
++config MVSWITCH_PHY
++	tristate "Driver for Marvell 88E6060 switches"
++	select ETHERNET_PACKET_MANGLE
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -23,6 +23,7 @@ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
+ obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygnus.o
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
++obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
diff --git a/target/linux/generic/pending-4.4/723-phy_ip175c.patch b/target/linux/generic/pending-4.4/723-phy_ip175c.patch
new file mode 100644
index 0000000000..5eb10bb30f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/723-phy_ip175c.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -186,6 +186,10 @@ config MVSWITCH_PHY
+ 	tristate "Driver for Marvell 88E6060 switches"
+ 	select ETHERNET_PACKET_MANGLE
+ 
++config IP17XX_PHY
++	tristate "Driver for IC+ IP17xx switches"
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -24,6 +24,7 @@ obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygn
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
++obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
diff --git a/target/linux/generic/pending-4.4/724-phy_ar8216.patch b/target/linux/generic/pending-4.4/724-phy_ar8216.patch
new file mode 100644
index 0000000000..8cd0034334
--- /dev/null
+++ b/target/linux/generic/pending-4.4/724-phy_ar8216.patch
@@ -0,0 +1,24 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -190,6 +190,11 @@ config IP17XX_PHY
+ 	tristate "Driver for IC+ IP17xx switches"
+ 	select SWCONFIG
+ 
++config AR8216_PHY
++	tristate "Driver for Atheros AR8216 switches"
++	select ETHERNET_PACKET_MANGLE
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
++obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/pending-4.4/725-phy_rtl8306.patch b/target/linux/generic/pending-4.4/725-phy_rtl8306.patch
new file mode 100644
index 0000000000..2bf2760764
--- /dev/null
+++ b/target/linux/generic/pending-4.4/725-phy_rtl8306.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -195,6 +195,10 @@ config AR8216_PHY
+ 	select ETHERNET_PACKET_MANGLE
+ 	select SWCONFIG
+ 
++config RTL8306_PHY
++	tristate "Driver for Realtek RTL8306S switches"
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	tristate "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -27,6 +27,7 @@ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
++obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/pending-4.4/726-phy_rtl8366.patch b/target/linux/generic/pending-4.4/726-phy_rtl8366.patch
new file mode 100644
index 0000000000..53e967b82f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/726-phy_rtl8366.patch
@@ -0,0 +1,45 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -299,6 +299,30 @@ config MDIO_BCM_IPROC
+ 	  This module provides a driver for the MDIO busses found in the
+ 	  Broadcom iProc SoC's.
+ 
++config RTL8366_SMI
++	tristate "Driver for the RTL8366 SMI interface"
++	depends on GPIOLIB
++	---help---
++	  This module implements the SMI interface protocol which is used
++	  by some RTL8366 ethernet switch devices via the generic GPIO API.
++
++if RTL8366_SMI
++
++config RTL8366_SMI_DEBUG_FS
++	bool "RTL8366 SMI interface debugfs support"
++        depends on DEBUG_FS
++        default n
++
++config RTL8366S_PHY
++	tristate "Driver for the Realtek RTL8366S switch"
++	select SWCONFIG
++
++config RTL8366RB_PHY
++	tristate "Driver for the Realtek RTL8366RB switch"
++	select SWCONFIG
++
++endif # RTL8366_SMI
++
+ endif # PHYLIB
+ 
+ config MICREL_KS8995MA
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -28,6 +28,9 @@ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
+ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
++obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
++obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
++obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/pending-4.4/727-phy-rtl8367.patch b/target/linux/generic/pending-4.4/727-phy-rtl8367.patch
new file mode 100644
index 0000000000..9fa8c8fc2a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/727-phy-rtl8367.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -321,6 +321,10 @@ config RTL8366RB_PHY
+ 	tristate "Driver for the Realtek RTL8366RB switch"
+ 	select SWCONFIG
+ 
++config RTL8367_PHY
++	tristate "Driver for the Realtek RTL8367R/M switches"
++	select SWCONFIG
++
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -31,6 +31,7 @@ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
+ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
+ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
++obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/pending-4.4/728-phy-rtl8367b.patch b/target/linux/generic/pending-4.4/728-phy-rtl8367b.patch
new file mode 100644
index 0000000000..12d7fcad90
--- /dev/null
+++ b/target/linux/generic/pending-4.4/728-phy-rtl8367b.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -325,6 +325,10 @@ config RTL8367_PHY
+ 	tristate "Driver for the Realtek RTL8367R/M switches"
+ 	select SWCONFIG
+ 
++config RTL8367B_PHY
++	tristate "Driver fot the Realtek RTL8367R-VB switch"
++	select SWCONFIG
++
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -32,6 +32,7 @@ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi
+ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
++obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/pending-4.4/729-phy-tantos.patch b/target/linux/generic/pending-4.4/729-phy-tantos.patch
new file mode 100644
index 0000000000..3f18c83c42
--- /dev/null
+++ b/target/linux/generic/pending-4.4/729-phy-tantos.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -336,3 +336,8 @@ endif # PHYLIB
+ config MICREL_KS8995MA
+ 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
+ 	depends on SPI
++
++config PSB6970_PHY
++	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
++	select SWCONFIG
++	select ETHERNET_PACKET_MANGLE
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -34,6 +34,7 @@ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
++obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
diff --git a/target/linux/generic/pending-4.4/730-phy_b53.patch b/target/linux/generic/pending-4.4/730-phy_b53.patch
new file mode 100644
index 0000000000..4d5ea7a754
--- /dev/null
+++ b/target/linux/generic/pending-4.4/730-phy_b53.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -331,6 +331,8 @@ config RTL8367B_PHY
+ 
+ endif # RTL8366_SMI
+ 
++source "drivers/net/phy/b53/Kconfig"
++
+ endif # PHYLIB
+ 
+ config MICREL_KS8995MA
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -35,6 +35,7 @@ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
++obj-$(CONFIG_SWCONFIG_B53)	+= b53/
+ obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
diff --git a/target/linux/generic/pending-4.4/732-phy-ar8216-led-support.patch b/target/linux/generic/pending-4.4/732-phy-ar8216-led-support.patch
new file mode 100644
index 0000000000..799ea494a0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/732-phy-ar8216-led-support.patch
@@ -0,0 +1,13 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -195,6 +195,10 @@ config AR8216_PHY
+ 	select ETHERNET_PACKET_MANGLE
+ 	select SWCONFIG
+ 
++config AR8216_PHY_LEDS
++	bool "Atheros AR8216 switch LED support"
++	depends on (AR8216_PHY && LEDS_CLASS)
++
+ config RTL8306_PHY
+ 	tristate "Driver for Realtek RTL8306S switches"
+ 	select SWCONFIG
diff --git a/target/linux/generic/pending-4.4/733-phy_mvsw61xx.patch b/target/linux/generic/pending-4.4/733-phy_mvsw61xx.patch
new file mode 100644
index 0000000000..4daa9e8c87
--- /dev/null
+++ b/target/linux/generic/pending-4.4/733-phy_mvsw61xx.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -186,6 +186,10 @@ config MVSWITCH_PHY
+ 	tristate "Driver for Marvell 88E6060 switches"
+ 	select ETHERNET_PACKET_MANGLE
+ 
++config MVSW61XX_PHY
++	tristate "Driver for Marvell 88E6171/6172 switches"
++	select SWCONFIG
++
+ config IP17XX_PHY
+ 	tristate "Driver for IC+ IP17xx switches"
+ 	select SWCONFIG
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -24,6 +24,7 @@ obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygn
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
++obj-$(CONFIG_MVSW61XX_PHY)	+= mvsw61xx.o
+ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
diff --git a/target/linux/generic/pending-4.4/734-net-phy-at803x-allow-to-configure-via-pdata.patch b/target/linux/generic/pending-4.4/734-net-phy-at803x-allow-to-configure-via-pdata.patch
new file mode 100644
index 0000000000..53abcc33ed
--- /dev/null
+++ b/target/linux/generic/pending-4.4/734-net-phy-at803x-allow-to-configure-via-pdata.patch
@@ -0,0 +1,180 @@
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -12,12 +12,14 @@
+  */
+ 
+ #include <linux/phy.h>
++#include <linux/mdio.h>
+ #include <linux/module.h>
+ #include <linux/string.h>
+ #include <linux/netdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/of_gpio.h>
+ #include <linux/gpio/consumer.h>
++#include <linux/platform_data/phy-at803x.h>
+ 
+ #define AT803X_INTR_ENABLE			0x12
+ #define AT803X_INTR_STATUS			0x13
+@@ -34,8 +36,16 @@
+ #define AT803X_INER				0x0012
+ #define AT803X_INER_INIT			0xec00
+ #define AT803X_INSR				0x0013
++
++#define AT803X_PCS_SMART_EEE_CTRL3			0x805D
++#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
++#define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT	12
++#define AT803X_SMART_EEE_CTRL3_LPI_EN			BIT(8)
++
+ #define AT803X_DEBUG_ADDR			0x1D
+ #define AT803X_DEBUG_DATA			0x1E
++#define AT803X_DBG0_REG				0x00
++#define AT803X_DEBUG_RGMII_RX_CLK_DLY		BIT(8)
+ #define AT803X_DEBUG_SYSTEM_MODE_CTRL		0x05
+ #define AT803X_DEBUG_RGMII_TX_CLK_DLY		BIT(8)
+ 
+@@ -50,6 +60,7 @@ MODULE_LICENSE("GPL");
+ struct at803x_priv {
+ 	bool phy_reset:1;
+ 	struct gpio_desc *gpiod_reset;
++	int prev_speed;
+ };
+ 
+ struct at803x_context {
+@@ -61,6 +72,43 @@ struct at803x_context {
+ 	u16 led_control;
+ };
+ 
++static u16
++at803x_dbg_reg_rmw(struct phy_device *phydev, u16 reg, u16 clear, u16 set)
++{
++	struct mii_bus *bus = phydev->bus;
++	int val;
++
++	mutex_lock(&bus->mdio_lock);
++
++	bus->write(bus, phydev->addr, AT803X_DEBUG_ADDR, reg);
++	val = bus->read(bus, phydev->addr, AT803X_DEBUG_DATA);
++	if (val < 0) {
++		val = 0xffff;
++		goto out;
++	}
++
++	val &= ~clear;
++	val |= set;
++	bus->write(bus, phydev->addr, AT803X_DEBUG_DATA, val);
++
++out:
++	mutex_unlock(&bus->mdio_lock);
++	return val;
++}
++
++static inline void
++at803x_dbg_reg_set(struct phy_device *phydev, u16 reg, u16 set)
++{
++	at803x_dbg_reg_rmw(phydev, reg, 0, set);
++}
++
++static inline void
++at803x_dbg_reg_clr(struct phy_device *phydev, u16 reg, u16 clear)
++{
++	at803x_dbg_reg_rmw(phydev, reg, clear, 0);
++}
++
++
+ /* save relevant PHY registers to private copy */
+ static void at803x_context_save(struct phy_device *phydev,
+ 				struct at803x_context *context)
+@@ -209,8 +257,16 @@ static int at803x_probe(struct phy_devic
+ 	return 0;
+ }
+ 
++static void at803x_disable_smarteee(struct phy_device *phydev)
++{
++	phy_write_mmd(phydev, MDIO_MMD_PCS, AT803X_PCS_SMART_EEE_CTRL3,
++		1 << AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_SHIFT);
++	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
++}
++
+ static int at803x_config_init(struct phy_device *phydev)
+ {
++	struct at803x_platform_data *pdata;
+ 	int ret;
+ 
+ 	ret = genphy_config_init(phydev);
+@@ -228,6 +284,26 @@ static int at803x_config_init(struct phy
+ 			return ret;
+ 	}
+ 
++	pdata = dev_get_platdata(&phydev->dev);
++	if (pdata) {
++		if (pdata->disable_smarteee)
++			at803x_disable_smarteee(phydev);
++
++		if (pdata->enable_rgmii_rx_delay)
++			at803x_dbg_reg_set(phydev, AT803X_DBG0_REG,
++				AT803X_DEBUG_RGMII_RX_CLK_DLY);
++		else
++			at803x_dbg_reg_clr(phydev, AT803X_DBG0_REG,
++				AT803X_DEBUG_RGMII_RX_CLK_DLY);
++
++		if (pdata->enable_rgmii_tx_delay)
++			at803x_dbg_reg_set(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
++				AT803X_DEBUG_RGMII_TX_CLK_DLY);
++		else
++			at803x_dbg_reg_clr(phydev, AT803X_DEBUG_SYSTEM_MODE_CTRL,
++				AT803X_DEBUG_RGMII_TX_CLK_DLY);
++	}
++
+ 	return 0;
+ }
+ 
+@@ -259,6 +335,8 @@ static int at803x_config_intr(struct phy
+ static void at803x_link_change_notify(struct phy_device *phydev)
+ {
+ 	struct at803x_priv *priv = phydev->priv;
++	struct at803x_platform_data *pdata;
++	pdata = dev_get_platdata(&phydev->dev);
+ 
+ 	/*
+ 	 * Conduct a hardware reset for AT8030 every time a link loss is
+@@ -289,6 +367,26 @@ static void at803x_link_change_notify(st
+ 			priv->phy_reset = false;
+ 		}
+ 	}
++	if (pdata && pdata->fixup_rgmii_tx_delay &&
++	    phydev->speed != priv->prev_speed) {
++		switch (phydev->speed) {
++		case SPEED_10:
++		case SPEED_100:
++			at803x_dbg_reg_set(phydev,
++				AT803X_DEBUG_SYSTEM_MODE_CTRL,
++				AT803X_DEBUG_RGMII_TX_CLK_DLY);
++			break;
++		case SPEED_1000:
++			at803x_dbg_reg_clr(phydev,
++				AT803X_DEBUG_SYSTEM_MODE_CTRL,
++				AT803X_DEBUG_RGMII_TX_CLK_DLY);
++			break;
++		default:
++			break;
++		}
++
++		priv->prev_speed = phydev->speed;
++	}
+ }
+ 
+ static struct phy_driver at803x_driver[] = {
+--- /dev/null
++++ b/include/linux/platform_data/phy-at803x.h
+@@ -0,0 +1,11 @@
++#ifndef _PHY_AT803X_PDATA_H
++#define _PHY_AT803X_PDATA_H
++
++struct at803x_platform_data {
++	int disable_smarteee:1;
++	int enable_rgmii_tx_delay:1;
++	int enable_rgmii_rx_delay:1;
++	int fixup_rgmii_tx_delay:1;
++};
++
++#endif /* _PHY_AT803X_PDATA_H */
diff --git a/target/linux/generic/pending-4.4/735-net-phy-at803x-fix-at8033-sgmii-mode.patch b/target/linux/generic/pending-4.4/735-net-phy-at803x-fix-at8033-sgmii-mode.patch
new file mode 100644
index 0000000000..60de6b4f7d
--- /dev/null
+++ b/target/linux/generic/pending-4.4/735-net-phy-at803x-fix-at8033-sgmii-mode.patch
@@ -0,0 +1,96 @@
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -36,6 +36,9 @@
+ #define AT803X_INER				0x0012
+ #define AT803X_INER_INIT			0xec00
+ #define AT803X_INSR				0x0013
++#define AT803X_REG_CHIP_CONFIG			0x1f
++#define AT803X_BT_BX_REG_SEL			0x8000
++#define AT803X_SGMII_ANEG_EN			0x1000
+ 
+ #define AT803X_PCS_SMART_EEE_CTRL3			0x805D
+ #define AT803X_SMART_EEE_CTRL3_LPI_TX_DELAY_SEL_MASK	0x3
+@@ -49,9 +52,10 @@
+ #define AT803X_DEBUG_SYSTEM_MODE_CTRL		0x05
+ #define AT803X_DEBUG_RGMII_TX_CLK_DLY		BIT(8)
+ 
+-#define ATH8030_PHY_ID 0x004dd076
+-#define ATH8031_PHY_ID 0x004dd074
+-#define ATH8035_PHY_ID 0x004dd072
++#define AT803X_PHY_ID_MASK			0xffffffef
++#define ATH8030_PHY_ID				0x004dd076
++#define ATH8031_PHY_ID				0x004dd074
++#define ATH8035_PHY_ID				0x004dd072
+ 
+ MODULE_DESCRIPTION("Atheros 803x PHY driver");
+ MODULE_AUTHOR("Matus Ujhelyi");
+@@ -268,6 +272,27 @@ static int at803x_config_init(struct phy
+ {
+ 	struct at803x_platform_data *pdata;
+ 	int ret;
++	u32 v;
++
++	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
++		phydev->interface == PHY_INTERFACE_MODE_SGMII)
++	{
++		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
++		/* select SGMII/fiber page */
++		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
++						v & ~AT803X_BT_BX_REG_SEL);
++		if (ret)
++			return ret;
++		/* enable SGMII autonegotiation */
++		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
++		if (ret)
++			return ret;
++		/* select copper page */
++		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
++						v | AT803X_BT_BX_REG_SEL);
++		if (ret)
++			return ret;
++	}
+ 
+ 	ret = genphy_config_init(phydev);
+ 	if (ret < 0)
+@@ -394,7 +419,7 @@ static struct phy_driver at803x_driver[]
+ 	/* ATHEROS 8035 */
+ 	.phy_id			= ATH8035_PHY_ID,
+ 	.name			= "Atheros 8035 ethernet",
+-	.phy_id_mask		= 0xffffffef,
++	.phy_id_mask		= AT803X_PHY_ID_MASK,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+ 	.link_change_notify	= at803x_link_change_notify,
+@@ -415,7 +440,7 @@ static struct phy_driver at803x_driver[]
+ 	/* ATHEROS 8030 */
+ 	.phy_id			= ATH8030_PHY_ID,
+ 	.name			= "Atheros 8030 ethernet",
+-	.phy_id_mask		= 0xffffffef,
++	.phy_id_mask		= AT803X_PHY_ID_MASK,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+ 	.link_change_notify	= at803x_link_change_notify,
+@@ -435,8 +460,8 @@ static struct phy_driver at803x_driver[]
+ }, {
+ 	/* ATHEROS 8031 */
+ 	.phy_id			= ATH8031_PHY_ID,
+-	.name			= "Atheros 8031 ethernet",
+-	.phy_id_mask		= 0xffffffef,
++	.name			= "Atheros 8031/8033 ethernet",
++	.phy_id_mask		= AT803X_PHY_ID_MASK,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+ 	.link_change_notify	= at803x_link_change_notify,
+@@ -458,9 +483,9 @@ static struct phy_driver at803x_driver[]
+ module_phy_driver(at803x_driver);
+ 
+ static struct mdio_device_id __maybe_unused atheros_tbl[] = {
+-	{ ATH8030_PHY_ID, 0xffffffef },
+-	{ ATH8031_PHY_ID, 0xffffffef },
+-	{ ATH8035_PHY_ID, 0xffffffef },
++	{ ATH8030_PHY_ID, AT803X_PHY_ID_MASK },
++	{ ATH8031_PHY_ID, AT803X_PHY_ID_MASK },
++	{ ATH8035_PHY_ID, AT803X_PHY_ID_MASK },
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/pending-4.4/736-at803x-fix-reset-handling.patch b/target/linux/generic/pending-4.4/736-at803x-fix-reset-handling.patch
new file mode 100644
index 0000000000..91c2334e55
--- /dev/null
+++ b/target/linux/generic/pending-4.4/736-at803x-fix-reset-handling.patch
@@ -0,0 +1,43 @@
+From: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
+Date: Wed, 23 Mar 2016 00:44:40 +0300
+Subject: [PATCH] at803x: fix reset handling
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The driver of course "knows" that the chip's reset signal is active low,
+so  it drives the GPIO to 0  to reset the PHY and to 1 otherwise; however
+all this will only work iff the GPIO  is  specified as active-high in the
+device tree!  I think both the driver and the device trees (if there are
+any -- I was unable to find them) need to be fixed in this case...
+
+Fixes: 13a56b449325 ("net: phy: at803x: Add support for hardware reset")
+Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
+Acked-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -250,7 +250,7 @@ static int at803x_probe(struct phy_devic
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+-	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
++	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+ 	if (IS_ERR(gpiod_reset))
+ 		return PTR_ERR(gpiod_reset);
+ 
+@@ -377,10 +377,10 @@ static void at803x_link_change_notify(st
+ 
+ 				at803x_context_save(phydev, &context);
+ 
+-				gpiod_set_value(priv->gpiod_reset, 0);
+-				msleep(1);
+ 				gpiod_set_value(priv->gpiod_reset, 1);
+ 				msleep(1);
++				gpiod_set_value(priv->gpiod_reset, 0);
++				msleep(1);
+ 
+ 				at803x_context_restore(phydev, &context);
+ 
diff --git a/target/linux/generic/pending-4.4/737-net-phy-at803x-Request-reset-GPIO-only-for-AT8030-PH.patch b/target/linux/generic/pending-4.4/737-net-phy-at803x-Request-reset-GPIO-only-for-AT8030-PH.patch
new file mode 100644
index 0000000000..b30ba7aaae
--- /dev/null
+++ b/target/linux/generic/pending-4.4/737-net-phy-at803x-Request-reset-GPIO-only-for-AT8030-PH.patch
@@ -0,0 +1,42 @@
+From: Sebastian Frias <sf84@laposte.net>
+Date: Wed, 23 Mar 2016 11:49:09 +0100
+Subject: [PATCH] net: phy: at803x: Request 'reset' GPIO only for AT8030 PHY
+
+This removes the dependency on GPIOLIB for non faulty PHYs.
+
+Indeed, without this patch, if GPIOLIB is not selected
+devm_gpiod_get_optional() will return -ENOSYS and the driver probe
+call will fail, regardless of the actual PHY hardware.
+
+Out of the 3 PHYs supported by this driver (AT8030, AT8031, AT8035),
+only AT8030 presents the issues that commit 13a56b449325 ("net: phy:
+at803x: Add support for hardware reset") attempts to work-around by
+using a 'reset' GPIO line.
+
+Hence, only AT8030 should depend on GPIOLIB operating properly.
+
+Fixes: 13a56b449325 ("net: phy: at803x: Add support for hardware reset")
+
+Signed-off-by: Sebastian Frias <sf84@laposte.net>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -250,12 +250,16 @@ static int at803x_probe(struct phy_devic
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
++	if (phydev->drv->phy_id != ATH8030_PHY_ID)
++		goto does_not_require_reset_workaround;
++
+ 	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+ 	if (IS_ERR(gpiod_reset))
+ 		return PTR_ERR(gpiod_reset);
+ 
+ 	priv->gpiod_reset = gpiod_reset;
+ 
++does_not_require_reset_workaround:
+ 	phydev->priv = priv;
+ 
+ 	return 0;
diff --git a/target/linux/generic/pending-4.4/738-net-phy-at803x-only-the-AT8030-needs-a-hardware-rese.patch b/target/linux/generic/pending-4.4/738-net-phy-at803x-only-the-AT8030-needs-a-hardware-rese.patch
new file mode 100644
index 0000000000..4e6baac0c3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/738-net-phy-at803x-only-the-AT8030-needs-a-hardware-rese.patch
@@ -0,0 +1,81 @@
+From: Timur Tabi <timur@codeaurora.org>
+Date: Tue, 26 Apr 2016 12:44:18 -0500
+Subject: [PATCH] net: phy: at803x: only the AT8030 needs a hardware reset on
+ link change
+
+Commit 13a56b44 ("at803x: Add support for hardware reset") added a
+work-around for a hardware bug on the AT8030.  However, the work-around
+was being called for all 803x PHYs, even those that don't need it.
+Function at803x_link_change_notify() checks to make sure that it only
+resets the PHY on the 8030, but it makes more sense to not call that
+function at all if it isn't needed.
+
+Signed-off-by: Timur Tabi <timur@codeaurora.org>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -374,27 +374,25 @@ static void at803x_link_change_notify(st
+ 	 * in the FIFO. In such cases, the FIFO enters an error mode it
+ 	 * cannot recover from by software.
+ 	 */
+-	if (phydev->drv->phy_id == ATH8030_PHY_ID) {
+-		if (phydev->state == PHY_NOLINK) {
+-			if (priv->gpiod_reset && !priv->phy_reset) {
+-				struct at803x_context context;
+-
+-				at803x_context_save(phydev, &context);
+-
+-				gpiod_set_value(priv->gpiod_reset, 1);
+-				msleep(1);
+-				gpiod_set_value(priv->gpiod_reset, 0);
+-				msleep(1);
+-
+-				at803x_context_restore(phydev, &context);
+-
+-				dev_dbg(&phydev->dev, "%s(): phy was reset\n",
+-					__func__);
+-				priv->phy_reset = true;
+-			}
+-		} else {
+-			priv->phy_reset = false;
++	if (phydev->state == PHY_NOLINK) {
++		if (priv->gpiod_reset && !priv->phy_reset) {
++			struct at803x_context context;
++
++			at803x_context_save(phydev, &context);
++
++			gpiod_set_value(priv->gpiod_reset, 1);
++			msleep(1);
++			gpiod_set_value(priv->gpiod_reset, 0);
++			msleep(1);
++
++			at803x_context_restore(phydev, &context);
++
++			dev_dbg(&phydev->dev, "%s(): phy was reset\n",
++				__func__);
++			priv->phy_reset = true;
+ 		}
++	} else {
++		priv->phy_reset = false;
+ 	}
+ 	if (pdata && pdata->fixup_rgmii_tx_delay &&
+ 	    phydev->speed != priv->prev_speed) {
+@@ -426,7 +424,6 @@ static struct phy_driver at803x_driver[]
+ 	.phy_id_mask		= AT803X_PHY_ID_MASK,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+-	.link_change_notify	= at803x_link_change_notify,
+ 	.set_wol		= at803x_set_wol,
+ 	.get_wol		= at803x_get_wol,
+ 	.suspend		= at803x_suspend,
+@@ -468,7 +465,6 @@ static struct phy_driver at803x_driver[]
+ 	.phy_id_mask		= AT803X_PHY_ID_MASK,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+-	.link_change_notify	= at803x_link_change_notify,
+ 	.set_wol		= at803x_set_wol,
+ 	.get_wol		= at803x_get_wol,
+ 	.suspend		= at803x_suspend,
diff --git a/target/linux/generic/pending-4.4/739-net-phy-at803x-add-support-for-AT8032.patch b/target/linux/generic/pending-4.4/739-net-phy-at803x-add-support-for-AT8032.patch
new file mode 100644
index 0000000000..4455ec49e1
--- /dev/null
+++ b/target/linux/generic/pending-4.4/739-net-phy-at803x-add-support-for-AT8032.patch
@@ -0,0 +1,65 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 30 Nov 2016 11:31:03 +0100
+Subject: [PATCH] net: phy: at803x: add support for AT8032
+
+Like AT8030, this PHY needs the GPIO reset workaround
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -55,6 +55,7 @@
+ #define AT803X_PHY_ID_MASK			0xffffffef
+ #define ATH8030_PHY_ID				0x004dd076
+ #define ATH8031_PHY_ID				0x004dd074
++#define ATH8032_PHY_ID				0x004dd023
+ #define ATH8035_PHY_ID				0x004dd072
+ 
+ MODULE_DESCRIPTION("Atheros 803x PHY driver");
+@@ -250,7 +251,8 @@ static int at803x_probe(struct phy_devic
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+-	if (phydev->drv->phy_id != ATH8030_PHY_ID)
++	if (phydev->drv->phy_id != ATH8030_PHY_ID &&
++	    phydev->drv->phy_id != ATH8032_PHY_ID)
+ 		goto does_not_require_reset_workaround;
+ 
+ 	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+@@ -478,6 +480,27 @@ static struct phy_driver at803x_driver[]
+ 	.driver			= {
+ 		.owner = THIS_MODULE,
+ 	},
++}, {
++	/* ATHEROS 8032 */
++	.phy_id			= ATH8032_PHY_ID,
++	.name			= "Atheros 8032 ethernet",
++	.phy_id_mask		= AT803X_PHY_ID_MASK,
++	.probe			= at803x_probe,
++	.config_init		= at803x_config_init,
++	.link_change_notify	= at803x_link_change_notify,
++	.set_wol		= at803x_set_wol,
++	.get_wol		= at803x_get_wol,
++	.suspend		= at803x_suspend,
++	.resume			= at803x_resume,
++	.features		= PHY_GBIT_FEATURES,
++	.flags			= PHY_HAS_INTERRUPT,
++	.config_aneg		= genphy_config_aneg,
++	.read_status		= genphy_read_status,
++	.ack_interrupt		= &at803x_ack_interrupt,
++	.config_intr		= &at803x_config_intr,
++	.driver			= {
++		.owner = THIS_MODULE,
++	},
+ } };
+ 
+ module_phy_driver(at803x_driver);
+@@ -485,6 +508,7 @@ module_phy_driver(at803x_driver);
+ static struct mdio_device_id __maybe_unused atheros_tbl[] = {
+ 	{ ATH8030_PHY_ID, AT803X_PHY_ID_MASK },
+ 	{ ATH8031_PHY_ID, AT803X_PHY_ID_MASK },
++	{ ATH8032_PHY_ID, AT803X_PHY_ID_MASK },
+ 	{ ATH8035_PHY_ID, AT803X_PHY_ID_MASK },
+ 	{ }
+ };
diff --git a/target/linux/generic/pending-4.4/773-bgmac-add-srab-switch.patch b/target/linux/generic/pending-4.4/773-bgmac-add-srab-switch.patch
new file mode 100644
index 0000000000..b3cb087235
--- /dev/null
+++ b/target/linux/generic/pending-4.4/773-bgmac-add-srab-switch.patch
@@ -0,0 +1,88 @@
+Register switch connected to srab
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -11,6 +11,7 @@
+ 
+ #include <linux/bcma/bcma.h>
+ #include <linux/etherdevice.h>
++#include <linux/platform_data/b53.h>
+ #include <linux/bcm47xx_nvram.h>
+ #include "bgmac.h"
+ 
+@@ -1403,6 +1404,17 @@ static const struct ethtool_ops bgmac_et
+ 	.get_drvinfo		= bgmac_get_drvinfo,
+ };
+ 
++static struct b53_platform_data bgmac_b53_pdata = {
++};
++
++static struct platform_device bgmac_b53_dev = {
++	.name		= "b53-srab-switch",
++	.id		= -1,
++	.dev		= {
++		.platform_data = &bgmac_b53_pdata,
++	},
++};
++
+ /**************************************************
+  * MII
+  **************************************************/
+@@ -1549,6 +1561,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
+ 	net_dev->hw_features = net_dev->features;
+ 	net_dev->vlan_features = net_dev->features;
+ 
++	if ((bgmac->feature_flags & BGMAC_FEAT_SRAB) && !bgmac_b53_pdata.regs) {
++		bgmac_b53_pdata.regs = ioremap_nocache(0x18007000, 0x1000);
++
++		err = platform_device_register(&bgmac_b53_dev);
++		if (!err)
++			bgmac->b53_device = &bgmac_b53_dev;
++	}
++
+ 	err = register_netdev(bgmac->net_dev);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Cannot register net device\n");
+@@ -1571,6 +1591,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
+ 
+ void bgmac_enet_remove(struct bgmac *bgmac)
+ {
++	if (bgmac->b53_device)
++		platform_device_unregister(&bgmac_b53_dev);
++	bgmac->b53_device = NULL;
++
+ 	unregister_netdev(bgmac->net_dev);
+ 	phy_disconnect(bgmac->net_dev->phydev);
+ 	netif_napi_del(&bgmac->napi);
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -409,6 +409,7 @@
+ #define BGMAC_FEAT_CC4_IF_SW_TYPE	BIT(17)
+ #define BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII	BIT(18)
+ #define BGMAC_FEAT_CC7_IF_TYPE_RGMII	BIT(19)
++#define BGMAC_FEAT_SRAB			BIT(20)
+ 
+ struct bgmac_slot_info {
+ 	union {
+@@ -513,6 +514,9 @@ struct bgmac {
+ 	u32 (*get_bus_clock)(struct bgmac *bgmac);
+ 	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
+ 			      u32 set);
++
++	/* platform device for associated switch */
++	struct platform_device *b53_device;
+ };
+ 
+ struct bgmac *bgmac_alloc(struct device *dev);
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -236,6 +236,7 @@ static int bgmac_probe(struct bcma_devic
+ 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+ 		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
+ 		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
++		bgmac->feature_flags |= BGMAC_FEAT_SRAB;
+ 		break;
+ 	case BCMA_CHIP_ID_BCM53573:
+ 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
diff --git a/target/linux/generic/pending-4.4/810-pci_disable_common_quirks.patch b/target/linux/generic/pending-4.4/810-pci_disable_common_quirks.patch
new file mode 100644
index 0000000000..e5c9043065
--- /dev/null
+++ b/target/linux/generic/pending-4.4/810-pci_disable_common_quirks.patch
@@ -0,0 +1,51 @@
+--- a/drivers/pci/Kconfig
++++ b/drivers/pci/Kconfig
+@@ -68,6 +68,12 @@ config XEN_PCIDEV_FRONTEND
+           The PCI device frontend driver allows the kernel to import arbitrary
+           PCI devices from a PCI backend to support PCI driver domains.
+ 
++config PCI_DISABLE_COMMON_QUIRKS
++	bool "PCI disable common quirks"
++	depends on PCI
++	help
++	  If you don't know what to do here, say N.
++
+ config HT_IRQ
+ 	bool "Interrupts on hypertransport devices"
+ 	default y
+--- a/drivers/pci/quirks.c
++++ b/drivers/pci/quirks.c
+@@ -41,6 +41,7 @@ static void quirk_mmio_always_on(struct
+ DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
+ 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+ /* The Mellanox Tavor device gives false positive parity errors
+  * Mark this device with a broken_parity_status, to allow
+  * PCI scanning code to "skip" this now blacklisted device.
+@@ -2975,6 +2976,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
+ 
+ /*
+  * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.  To
+@@ -3031,6 +3033,8 @@ static void fixup_debug_report(struct pc
+ 	}
+ }
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ /*
+  * Some BIOS implementations leave the Intel GPU interrupts enabled,
+  * even though no one is handling them (f.e. i915 driver is never loaded).
+@@ -3065,6 +3069,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
+ /*
+  * PCI devices which are on Intel chips can skip the 10ms delay
+  * before entering D3 mode.
diff --git a/target/linux/generic/pending-4.4/811-pci_disable_usb_common_quirks.patch b/target/linux/generic/pending-4.4/811-pci_disable_usb_common_quirks.patch
new file mode 100644
index 0000000000..702c9fa2b5
--- /dev/null
+++ b/target/linux/generic/pending-4.4/811-pci_disable_usb_common_quirks.patch
@@ -0,0 +1,101 @@
+
+--- a/drivers/usb/host/pci-quirks.c
++++ b/drivers/usb/host/pci-quirks.c
+@@ -98,6 +98,8 @@ struct amd_chipset_type {
+ 	u8 rev;
+ };
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ static struct amd_chipset_info {
+ 	struct pci_dev	*nb_dev;
+ 	struct pci_dev	*smbus_dev;
+@@ -458,6 +460,10 @@ void usb_amd_dev_put(void)
+ }
+ EXPORT_SYMBOL_GPL(usb_amd_dev_put);
+ 
++#endif /* CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
++#if IS_ENABLED(CONFIG_USB_UHCI_HCD)
++
+ /*
+  * Make sure the controller is completely inactive, unable to
+  * generate interrupts or do DMA.
+@@ -537,8 +543,17 @@ reset_needed:
+ 	uhci_reset_hc(pdev, base);
+ 	return 1;
+ }
++#else
++int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
++{
++	return 0;
++}
++
++#endif
+ EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
+ {
+ 	u16 cmd;
+@@ -1103,3 +1118,4 @@ static void quirk_usb_early_handoff(stru
+ }
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
+ 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
++#endif
+--- a/drivers/usb/host/pci-quirks.h
++++ b/drivers/usb/host/pci-quirks.h
+@@ -4,6 +4,9 @@
+ #ifdef CONFIG_PCI
+ void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
+ int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
++#endif  /* CONFIG_PCI */
++
++#if defined(CONFIG_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
+ int usb_amd_find_chipset_info(void);
+ int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev);
+ bool usb_amd_hang_symptom_quirk(void);
+@@ -16,11 +19,24 @@ void usb_disable_xhci_ports(struct pci_d
+ void sb800_prefetch(struct device *dev, int on);
+ #else
+ struct pci_dev;
++static inline int usb_amd_find_chipset_info(void)
++{
++	return 0;
++}
++static inline bool usb_amd_hang_symptom_quirk(void)
++{
++	return false;
++}
++static inline bool usb_amd_prefetch_quirk(void)
++{
++	return false;
++}
+ static inline void usb_amd_quirk_pll_disable(void) {}
+ static inline void usb_amd_quirk_pll_enable(void) {}
+ static inline void usb_amd_dev_put(void) {}
+ static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
+ static inline void sb800_prefetch(struct device *dev, int on) {}
+-#endif  /* CONFIG_PCI */
++static inline void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev) {}
++#endif
+ 
+ #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
+--- a/include/linux/usb/hcd.h
++++ b/include/linux/usb/hcd.h
+@@ -460,7 +460,14 @@ extern int usb_hcd_pci_probe(struct pci_
+ extern void usb_hcd_pci_remove(struct pci_dev *dev);
+ extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+ extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
++#else
++static inline int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev)
++{
++	return 0;
++}
++#endif
+ 
+ #ifdef CONFIG_PM
+ extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
diff --git a/target/linux/generic/pending-4.4/821-usb-Remove-annoying-warning-about-bogus-URB.patch b/target/linux/generic/pending-4.4/821-usb-Remove-annoying-warning-about-bogus-URB.patch
new file mode 100644
index 0000000000..eb7cc809c7
--- /dev/null
+++ b/target/linux/generic/pending-4.4/821-usb-Remove-annoying-warning-about-bogus-URB.patch
@@ -0,0 +1,78 @@
+From f13ad28ba4280d2283ca2b49f0bd384bc51e6a68 Mon Sep 17 00:00:00 2001
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Date: Tue, 5 Jul 2016 14:28:31 +0300
+Subject: [PATCH] usb: Remove annoying warning about bogus URB
+
+When ath9k-htc Wi-Fi dongle is used with generic OHCI controller
+infinite stream of warnings appears in debug console like this:
+-------------------------->8----------------------
+usb 1-1: new full-speed USB device number 2 using ohci-platform
+usb 1-1: ath9k_htc: Firmware ath9k_htc/htc_9271-1.4.0.fw requested
+usb 1-1: ath9k_htc: Transferred FW: ath9k_htc/htc_9271-1.4.0.fw, size:
+51008
+------------[ cut here ]------------
+WARNING: CPU: 0 PID: 19 at drivers/usb/core/urb.c:449
+usb_submit_urb+0x1b4/0x498()
+usb 1-1: BOGUS urb xfer, pipe 1 != type 3
+Modules linked in:
+CPU: 0 PID: 19 Comm: kworker/0:1 Not tainted
+4.4.0-rc4-00017-g00e2d79-dirty #3
+Workqueue: events request_firmware_work_func
+
+Stack Trace:
+  arc_unwind_core.constprop.1+0xa4/0x110
+---[ end trace 649ef8c342817fc2 ]---
+------------[ cut here ]------------
+WARNING: CPU: 0 PID: 19 at drivers/usb/core/urb.c:449
+usb_submit_urb+0x1b4/0x498()
+usb 1-1: BOGUS urb xfer, pipe 1 != type 3
+Modules linked in:
+CPU: 0 PID: 19 Comm: kworker/0:1 Tainted: G        W
+4.4.0-rc4-00017-g00e2d79-dirty #3
+Workqueue: events request_firmware_work_func
+
+Stack Trace:
+  arc_unwind_core.constprop.1+0xa4/0x110
+---[ end trace 649ef8c342817fc3 ]---
+------------[ cut here ]------------
+-------------------------->8----------------------
+
+There're some discussions in mailing lists proposing to disable
+that particular check alltogether and magically all seem to work
+fine with muted warning.
+
+Anyways new thread on that regard could be found here:
+http://lists.infradead.org/pipermail/linux-snps-arc/2016-July/001310.html
+
+Let's see what comes out of that new discussion, hopefully patching
+of generic USB stuff won't be required then.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+---
+ drivers/usb/core/urb.c | 5 -----
+ 1 file changed, 5 deletions(-)
+
+--- a/drivers/usb/core/urb.c
++++ b/drivers/usb/core/urb.c
+@@ -323,9 +323,6 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
+  */
+ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
+ {
+-	static int			pipetypes[4] = {
+-		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+-	};
+ 	int				xfertype, max;
+ 	struct usb_device		*dev;
+ 	struct usb_host_endpoint	*ep;
+@@ -443,11 +440,6 @@ int usb_submit_urb(struct urb *urb, gfp_
+ 	 * cause problems in HCDs if they get it wrong.
+ 	 */
+ 
+-	/* Check that the pipe's type matches the endpoint's type */
+-	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
+-		dev_WARN(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
+-			usb_pipetype(urb->pipe), pipetypes[xfertype]);
+-
+ 	/* Check against a simple/standard policy */
+ 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
+ 			URB_FREE_BUFFER);
diff --git a/target/linux/generic/pending-4.4/831-ledtrig_netdev.patch b/target/linux/generic/pending-4.4/831-ledtrig_netdev.patch
new file mode 100644
index 0000000000..a28de899ac
--- /dev/null
+++ b/target/linux/generic/pending-4.4/831-ledtrig_netdev.patch
@@ -0,0 +1,21 @@
+--- a/drivers/leds/trigger/Kconfig
++++ b/drivers/leds/trigger/Kconfig
+@@ -108,4 +108,11 @@ config LEDS_TRIGGER_CAMERA
+ 	  This enables direct flash/torch on/off by the driver, kernel space.
+ 	  If unsure, say Y.
+ 
++config LEDS_TRIGGER_NETDEV
++	tristate "LED Netdev Trigger"
++	depends on NET && LEDS_TRIGGERS
++	help
++	  This allows LEDs to be controlled by network device activity.
++	  If unsure, say Y.
++
+ endif # LEDS_TRIGGERS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -72,3 +72,4 @@ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-d
+ 
+ # LED Triggers
+ obj-$(CONFIG_LEDS_TRIGGERS)		+= trigger/
++obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
diff --git a/target/linux/generic/pending-4.4/834-ledtrig-libata.patch b/target/linux/generic/pending-4.4/834-ledtrig-libata.patch
new file mode 100644
index 0000000000..ad63634479
--- /dev/null
+++ b/target/linux/generic/pending-4.4/834-ledtrig-libata.patch
@@ -0,0 +1,153 @@
+From 52cfd51cdf6a6e14d4fb270c6343abac3bac00f4 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 12 Dec 2014 13:38:33 +0100
+Subject: [PATCH] libata: add ledtrig support
+To: linux-ide@vger.kernel.org,
+    Tejun Heo <tj@kernel.org>
+
+This adds a LED trigger for each ATA port indicating disk activity.
+
+As this is needed only on specific platforms (NAS SoCs and such),
+these platforms should define ARCH_WANTS_LIBATA_LEDS if there
+are boards with LED(s) intended to indicate ATA disk activity and
+need the OS to take care of that.
+In that way, if not selected, LED trigger support not will be
+included in libata-core and both, codepaths and structures remain
+untouched.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/ata/Kconfig       | 16 ++++++++++++++++
+ drivers/ata/libata-core.c | 41 +++++++++++++++++++++++++++++++++++++++++
+ include/linux/libata.h    |  9 +++++++++
+ 3 files changed, 66 insertions(+)
+
+--- a/drivers/ata/Kconfig
++++ b/drivers/ata/Kconfig
+@@ -46,6 +46,22 @@ config ATA_VERBOSE_ERROR
+ 
+ 	  If unsure, say Y.
+ 
++config ARCH_WANT_LIBATA_LEDS
++	bool
++
++config ATA_LEDS
++	bool "support ATA port LED triggers"
++	depends on ARCH_WANT_LIBATA_LEDS
++	select NEW_LEDS
++	select LEDS_CLASS
++	select LEDS_TRIGGERS
++	default y
++	help
++	  This option adds a LED trigger for each registered ATA port.
++	  It is used to drive disk activity leds connected via GPIO.
++
++	  If unsure, say N.
++
+ config ATA_ACPI
+ 	bool "ATA ACPI Support"
+ 	depends on ACPI
+--- a/drivers/ata/libata-core.c
++++ b/drivers/ata/libata-core.c
+@@ -728,6 +728,19 @@ u64 ata_tf_read_block(struct ata_taskfil
+ 	return block;
+ }
+ 
++#ifdef CONFIG_ATA_LEDS
++#define LIBATA_BLINK_DELAY 20 /* ms */
++static inline void ata_led_act(struct ata_port *ap)
++{
++	unsigned long led_delay = LIBATA_BLINK_DELAY;
++
++	if (unlikely(!ap->ledtrig))
++		return;
++
++	led_trigger_blink_oneshot(ap->ledtrig, &led_delay, &led_delay, 0);
++}
++#endif
++
+ /**
+  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
+  *	@tf: Target ATA taskfile
+@@ -4781,6 +4794,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
+ 		if (tag < 0)
+ 			return NULL;
+ 	}
++#ifdef CONFIG_ATA_LEDS
++	ata_led_act(ap);
++#endif
+ 
+ 	qc = __ata_qc_from_tag(ap, tag);
+ 	qc->tag = tag;
+@@ -5678,6 +5694,9 @@ struct ata_port *ata_port_alloc(struct a
+ 	ap->stats.unhandled_irq = 1;
+ 	ap->stats.idle_irq = 1;
+ #endif
++#ifdef CONFIG_ATA_LEDS
++	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
++#endif
+ 	ata_sff_port_init(ap);
+ 
+ 	return ap;
+@@ -5699,6 +5718,12 @@ static void ata_host_release(struct devi
+ 
+ 		kfree(ap->pmp_link);
+ 		kfree(ap->slave_link);
++#ifdef CONFIG_ATA_LEDS
++		if (ap->ledtrig) {
++			led_trigger_unregister(ap->ledtrig);
++			kfree(ap->ledtrig);
++		};
++#endif
+ 		kfree(ap);
+ 		host->ports[i] = NULL;
+ 	}
+@@ -6145,7 +6170,23 @@ int ata_host_register(struct ata_host *h
+ 		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
+ 		host->ports[i]->local_port_no = i + 1;
+ 	}
++#ifdef CONFIG_ATA_LEDS
++	for (i = 0; i < host->n_ports; i++) {
++		if (unlikely(!host->ports[i]->ledtrig))
++			continue;
+ 
++		snprintf(host->ports[i]->ledtrig_name,
++			sizeof(host->ports[i]->ledtrig_name), "ata%u",
++			host->ports[i]->print_id);
++
++		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
++
++		if (led_trigger_register(host->ports[i]->ledtrig)) {
++			kfree(host->ports[i]->ledtrig);
++			host->ports[i]->ledtrig = NULL;
++		}
++	}
++#endif
+ 	/* Create associated sysfs transport objects  */
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		rc = ata_tport_add(host->dev,host->ports[i]);
+--- a/include/linux/libata.h
++++ b/include/linux/libata.h
+@@ -38,6 +38,9 @@
+ #include <linux/acpi.h>
+ #include <linux/cdrom.h>
+ #include <linux/sched.h>
++#ifdef CONFIG_ATA_LEDS
++#include <linux/leds.h>
++#endif
+ 
+ /*
+  * Define if arch has non-standard setup.  This is a _PCI_ standard
+@@ -877,6 +880,12 @@ struct ata_port {
+ #ifdef CONFIG_ATA_ACPI
+ 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
+ #endif
++
++#ifdef CONFIG_ATA_LEDS
++	struct led_trigger	*ledtrig;
++	char			ledtrig_name[8];
++#endif
++
+ 	/* owned by EH */
+ 	u8			sector_buf[ATA_SECT_SIZE] ____cacheline_aligned;
+ };
diff --git a/target/linux/generic/pending-4.4/835-misc-owl_loader.patch b/target/linux/generic/pending-4.4/835-misc-owl_loader.patch
new file mode 100644
index 0000000000..c179020680
--- /dev/null
+++ b/target/linux/generic/pending-4.4/835-misc-owl_loader.patch
@@ -0,0 +1,31 @@
+--- a/drivers/misc/Kconfig
++++ b/drivers/misc/Kconfig
+@@ -150,6 +150,18 @@ config SGI_IOC4
+ 	  If you have an SGI Altix with an IOC4-based card say Y.
+ 	  Otherwise say N.
+ 
++config OWL_LOADER
++	tristate "Owl loader for initializing Atheros PCI(e) Wifi chips"
++	depends on PCI
++	---help---
++	This kernel module helps to initialize certain Qualcomm
++	Atheros' PCI(e) Wifi chips, which have the init data
++	(which contains the PCI device ID for example) stored
++	together with the calibration data in the file system.
++
++	This is necessary for devices like the Cisco Meraki Z1, say M.
++	Otherwise say N.
++
+ config TIFM_CORE
+ 	tristate "TI Flash Media interface support"
+ 	depends on PCI
+--- a/drivers/misc/Makefile
++++ b/drivers/misc/Makefile
+@@ -15,6 +15,7 @@ obj-$(CONFIG_BMP085_SPI)	+= bmp085-spi.o
+ obj-$(CONFIG_DUMMY_IRQ)		+= dummy-irq.o
+ obj-$(CONFIG_ICS932S401)	+= ics932s401.o
+ obj-$(CONFIG_LKDTM)		+= lkdtm.o
++obj-$(CONFIG_OWL_LOADER)	+= owl-loader.o
+ obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
+ obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
+ obj-$(CONFIG_PHANTOM)		+= phantom.o
diff --git a/target/linux/generic/pending-4.4/840-rtc7301.patch b/target/linux/generic/pending-4.4/840-rtc7301.patch
new file mode 100644
index 0000000000..fafeb830e9
--- /dev/null
+++ b/target/linux/generic/pending-4.4/840-rtc7301.patch
@@ -0,0 +1,250 @@
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -1132,6 +1132,15 @@ config RTC_DRV_ZYNQMP
+ 	  If you say yes here you get support for the RTC controller found on
+ 	  Xilinx Zynq Ultrascale+ MPSoC.
+ 
++config RTC_DRV_RTC7301
++	tristate "Epson RTC-7301 SF/DG"
++	help
++	  If you say Y here you will get support for the
++	  Epson RTC-7301 SF/DG RTC chips.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-7301.
++
+ comment "on-CPU RTC drivers"
+ 
+ config RTC_DRV_DAVINCI
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -125,6 +125,7 @@ obj-$(CONFIG_RTC_DRV_RP5C01)	+= rtc-rp5c
+ obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
+ obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
+ obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
++obj-$(CONFIG_RTC_DRV_RTC7301)	+= rtc-rtc7301.o
+ obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
+ obj-$(CONFIG_RTC_DRV_RV8803)	+= rtc-rv8803.o
+ obj-$(CONFIG_RTC_DRV_RX4581)	+= rtc-rx4581.o
+--- /dev/null
++++ b/drivers/rtc/rtc-rtc7301.c
+@@ -0,0 +1,219 @@
++/*
++ * Driver for Epson RTC-7301SF/DG
++ *
++ * Copyright (C) 2009 Jose Vasconcellos
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/rtc.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/delay.h>
++#include <linux/bcd.h>
++
++#define RTC_NAME "rtc7301"
++#define RTC_VERSION "0.1"
++
++/* Epson RTC-7301 register addresses */
++#define RTC7301_SEC		0x00
++#define RTC7301_SEC10		0x01
++#define RTC7301_MIN		0x02
++#define RTC7301_MIN10		0x03
++#define RTC7301_HOUR		0x04
++#define RTC7301_HOUR10		0x05
++#define RTC7301_WEEKDAY		0x06
++#define RTC7301_DAY		0x07
++#define RTC7301_DAY10		0x08
++#define RTC7301_MON		0x09
++#define RTC7301_MON10		0x0A
++#define RTC7301_YEAR		0x0B
++#define RTC7301_YEAR10		0x0C
++#define RTC7301_YEAR100		0x0D
++#define RTC7301_YEAR1000	0x0E
++#define RTC7301_CTRLREG		0x0F
++
++static uint8_t __iomem *rtc7301_base;
++
++#define read_reg(offset) (readb(rtc7301_base + offset) & 0xf)
++#define write_reg(offset, data) writeb(data, rtc7301_base + (offset))
++
++#define rtc7301_isbusy() (read_reg(RTC7301_CTRLREG) & 1)
++
++static void rtc7301_init_settings(void)
++{
++	int i;
++
++	write_reg(RTC7301_CTRLREG, 2);
++	write_reg(RTC7301_YEAR1000, 2);
++	udelay(122);
++
++	/* bank 1 */
++	write_reg(RTC7301_CTRLREG, 6);
++	for (i=0; i<15; i++)
++		write_reg(i, 0);
++
++	/* bank 2 */
++	write_reg(RTC7301_CTRLREG, 14);
++	for (i=0; i<15; i++)
++		write_reg(i, 0);
++	write_reg(RTC7301_CTRLREG, 0);
++}
++
++static int rtc7301_get_datetime(struct device *dev, struct rtc_time *dt)
++{
++	int cnt;
++	uint8_t buf[16];
++
++	cnt = 0;
++	while (rtc7301_isbusy()) {
++		udelay(244);
++		if (cnt++ > 100) {
++			dev_err(dev, "%s: timeout error %x\n", __func__, rtc7301_base[RTC7301_CTRLREG]);
++			return -EIO;
++		}
++	}
++
++	for (cnt=0; cnt<16; cnt++)
++		buf[cnt] = read_reg(cnt);
++
++	if (buf[RTC7301_SEC10] & 8) {
++		dev_err(dev, "%s: RTC not set\n", __func__);
++		return -EINVAL;
++	}
++
++	memset(dt, 0, sizeof(*dt));
++
++	dt->tm_sec =  buf[RTC7301_SEC] + buf[RTC7301_SEC10]*10;
++	dt->tm_min =  buf[RTC7301_MIN] + buf[RTC7301_MIN10]*10;
++	dt->tm_hour = buf[RTC7301_HOUR] + buf[RTC7301_HOUR10]*10;
++
++	dt->tm_mday = buf[RTC7301_DAY] + buf[RTC7301_DAY10]*10;
++	dt->tm_mon =  buf[RTC7301_MON] + buf[RTC7301_MON10]*10 - 1;
++	dt->tm_year = buf[RTC7301_YEAR] + buf[RTC7301_YEAR10]*10 +
++		      buf[RTC7301_YEAR100]*100 +
++		      ((buf[RTC7301_YEAR1000] & 3)*1000) - 1900;
++
++	/* the rtc device may contain illegal values on power up
++	 * according to the data sheet. make sure they are valid.
++	 */
++
++	return rtc_valid_tm(dt);
++}
++
++static int rtc7301_set_datetime(struct device *dev, struct rtc_time *dt)
++{
++	int data;
++
++	data = dt->tm_year + 1900;
++	if (data >= 2100 || data < 1900)
++		return -EINVAL;
++
++	write_reg(RTC7301_CTRLREG, 2);
++       	udelay(122);
++
++	data = bin2bcd(dt->tm_sec);
++	write_reg(RTC7301_SEC, data);
++	write_reg(RTC7301_SEC10, (data >> 4));
++
++	data = bin2bcd(dt->tm_min);
++	write_reg(RTC7301_MIN, data );
++	write_reg(RTC7301_MIN10, (data >> 4));
++
++	data = bin2bcd(dt->tm_hour);
++	write_reg(RTC7301_HOUR, data);
++	write_reg(RTC7301_HOUR10, (data >> 4));
++
++	data = bin2bcd(dt->tm_mday);
++	write_reg(RTC7301_DAY, data);
++	write_reg(RTC7301_DAY10, (data>> 4));
++
++	data = bin2bcd(dt->tm_mon + 1);
++	write_reg(RTC7301_MON, data);
++	write_reg(RTC7301_MON10, (data >> 4));
++
++	data = bin2bcd(dt->tm_year % 100);
++	write_reg(RTC7301_YEAR, data);
++	write_reg(RTC7301_YEAR10, (data >> 4));
++	data = bin2bcd((1900 + dt->tm_year) / 100);
++	write_reg(RTC7301_YEAR100, data);
++
++	data = bin2bcd(dt->tm_wday);
++	write_reg(RTC7301_WEEKDAY, data);
++
++	write_reg(RTC7301_CTRLREG, 0);
++
++	return 0;
++}
++
++static const struct rtc_class_ops rtc7301_rtc_ops = {
++	.read_time	= rtc7301_get_datetime,
++	.set_time	= rtc7301_set_datetime,
++};
++
++static int rtc7301_probe(struct platform_device *pdev)
++{
++	struct rtc_device *rtc;
++	struct resource *res;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENOENT;
++
++	rtc7301_base = ioremap_nocache(res->start, 0x1000 /*res->end - res->start + 1*/);
++	if (!rtc7301_base)
++		return -EINVAL;
++
++	rtc = rtc_device_register(RTC_NAME, &pdev->dev,
++				&rtc7301_rtc_ops, THIS_MODULE);
++	if (IS_ERR(rtc)) {
++		iounmap(rtc7301_base);
++		return PTR_ERR(rtc);
++	}
++
++	platform_set_drvdata(pdev, rtc);
++
++	rtc7301_init_settings();
++	return 0;
++}
++
++static int rtc7301_remove(struct platform_device *pdev)
++{
++	struct rtc_device *rtc = platform_get_drvdata(pdev);
++
++	if (rtc)
++		rtc_device_unregister(rtc);
++	if (rtc7301_base)
++		iounmap(rtc7301_base);
++	return 0;
++}
++
++static struct platform_driver rtc7301_driver = {
++	.driver = {
++		.name	= RTC_NAME,
++		.owner	= THIS_MODULE,
++	},
++	.probe	= rtc7301_probe,
++	.remove = rtc7301_remove,
++};
++
++static __init int rtc7301_init(void)
++{
++	return platform_driver_register(&rtc7301_driver);
++}
++module_init(rtc7301_init);
++
++static __exit void rtc7301_exit(void)
++{
++	platform_driver_unregister(&rtc7301_driver);
++}
++module_exit(rtc7301_exit);
++
++MODULE_DESCRIPTION("Epson 7301 RTC driver");
++MODULE_AUTHOR("Jose Vasconcellos <jvasco@verizon.net>");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:" RTC_NAME);
++MODULE_VERSION(RTC_VERSION);
diff --git a/target/linux/generic/pending-4.4/841-rtc_pt7c4338.patch b/target/linux/generic/pending-4.4/841-rtc_pt7c4338.patch
new file mode 100644
index 0000000000..4235efa38a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/841-rtc_pt7c4338.patch
@@ -0,0 +1,247 @@
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -612,6 +612,15 @@ config RTC_DRV_S5M
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called rtc-s5m.
+ 
++config RTC_DRV_PT7C4338
++	tristate "Pericom Technology Inc. PT7C4338 RTC"
++	help
++	  If you say yes here you get support for the Pericom Technology
++	  Inc. PT7C4338 RTC chip.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-pt7c4338.
++
+ endif # I2C
+ 
+ comment "SPI RTC drivers"
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -116,6 +116,7 @@ obj-$(CONFIG_RTC_DRV_PL030)	+= rtc-pl030
+ obj-$(CONFIG_RTC_DRV_PL031)	+= rtc-pl031.o
+ obj-$(CONFIG_RTC_DRV_PM8XXX)	+= rtc-pm8xxx.o
+ obj-$(CONFIG_RTC_DRV_PS3)	+= rtc-ps3.o
++obj-$(CONFIG_RTC_DRV_PT7C4338)	+= rtc-pt7c4338.o
+ obj-$(CONFIG_RTC_DRV_PUV3)	+= rtc-puv3.o
+ obj-$(CONFIG_RTC_DRV_PXA)	+= rtc-pxa.o
+ obj-$(CONFIG_RTC_DRV_R9701)	+= rtc-r9701.o
+--- /dev/null
++++ b/drivers/rtc/rtc-pt7c4338.c
+@@ -0,0 +1,216 @@
++/*
++ * Copyright 2010 Freescale Semiconductor, Inc.
++ *
++ * Author:	Priyanka Jain <Priyanka.Jain@freescale.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++/*
++ * This file provides Date & Time support (no alarms) for PT7C4338 chip.
++ *
++ * This file is based on drivers/rtc/rtc-ds1307.c
++ *
++ * PT7C4338 chip is manufactured by Pericom Technology Inc.
++ * It is a serial real-time clock which provides
++ * 1)Low-power clock/calendar.
++ * 2)Programmable square-wave output.
++ * It has 56 bytes of nonvolatile RAM.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/i2c.h>
++#include <linux/rtc.h>
++#include <linux/bcd.h>
++
++/* RTC register addresses */
++#define PT7C4338_REG_SECONDS          0x00
++#define PT7C4338_REG_MINUTES          0x01
++#define PT7C4338_REG_HOURS            0x02
++#define PT7C4338_REG_AMPM             0x02
++#define PT7C4338_REG_DAY              0x03
++#define PT7C4338_REG_DATE             0x04
++#define PT7C4338_REG_MONTH            0x05
++#define PT7C4338_REG_YEAR             0x06
++#define PT7C4338_REG_CTRL_STAT        0x07
++
++/* RTC second register address bit */
++#define PT7C4338_SEC_BIT_CH           0x80	/*Clock Halt (in Register 0)*/
++
++/* RTC control and status register bits */
++#define PT7C4338_CTRL_STAT_BIT_RS0    0x1	/*Rate select 0*/
++#define PT7C4338_CTRL_STAT_BIT_RS1    0x2	/*Rate select 1*/
++#define PT7C4338_CTRL_STAT_BIT_SQWE   0x10	/*Square Wave Enable*/
++#define PT7C4338_CTRL_STAT_BIT_OSF    0x20	/*Oscillator Stop Flag*/
++#define PT7C4338_CTRL_STAT_BIT_OUT    0x80	/*Output Level Control*/
++
++static const struct i2c_device_id pt7c4338_id[] = {
++	{ "pt7c4338", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, pt7c4338_id);
++
++struct pt7c4338{
++	struct i2c_client *client;
++	struct rtc_device *rtc;
++};
++
++static int pt7c4338_read_time(struct device *dev, struct rtc_time *time)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	int ret;
++	u8 buf[7];
++	u8 year, month, day, hour, minute, second;
++	u8 week, twelve_hr, am_pm;
++
++	ret = i2c_smbus_read_i2c_block_data(client,
++			PT7C4338_REG_SECONDS, 7, buf);
++	if (ret < 0)
++		return ret;
++	if (ret < 7)
++		return -EIO;
++
++	second = buf[0];
++	minute = buf[1];
++	hour = buf[2];
++	week = buf[3];
++	day = buf[4];
++	month = buf[5];
++	year = buf[6];
++
++	/* Extract additional information for AM/PM */
++	twelve_hr = hour & 0x40;
++	am_pm = hour & 0x20;
++
++	/* Write to rtc_time structure */
++	time->tm_sec = bcd2bin(second & 0x7f);
++	time->tm_min = bcd2bin(minute & 0x7f);
++	if (twelve_hr) {
++		/* Convert to 24 hr */
++		if (am_pm)
++			time->tm_hour = bcd2bin(hour & 0x10) + 12;
++		else
++			time->tm_hour = bcd2bin(hour & 0xBF);
++	} else {
++		time->tm_hour = bcd2bin(hour);
++	}
++
++	time->tm_wday = bcd2bin(week & 0x07) - 1;
++	time->tm_mday = bcd2bin(day & 0x3f);
++	time->tm_mon = bcd2bin(month & 0x1F) - 1;
++	/* assume 20YY not 19YY */
++	time->tm_year = bcd2bin(year) + 100;
++
++	return 0;
++}
++
++static int pt7c4338_set_time(struct device *dev, struct rtc_time *time)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	u8 buf[7];
++
++	/* Extract time from rtc_time and load into pt7c4338*/
++	buf[0] = bin2bcd(time->tm_sec);
++	buf[1] = bin2bcd(time->tm_min);
++	buf[2] = bin2bcd(time->tm_hour);
++	buf[3] = bin2bcd(time->tm_wday + 1); /* Day of the week */
++	buf[4] = bin2bcd(time->tm_mday); /* Date */
++	buf[5] = bin2bcd(time->tm_mon + 1);
++
++	/* assume 20YY not 19YY */
++	if (time->tm_year >= 100)
++		buf[6] = bin2bcd(time->tm_year - 100);
++	else
++		buf[6] = bin2bcd(time->tm_year);
++
++	return i2c_smbus_write_i2c_block_data(client,
++					PT7C4338_REG_SECONDS, 7, buf);
++}
++
++static const struct rtc_class_ops pt7c4338_rtc_ops = {
++	.read_time = pt7c4338_read_time,
++	.set_time = pt7c4338_set_time,
++};
++
++static int pt7c4338_probe(struct i2c_client *client,
++		const struct i2c_device_id *id)
++{
++	struct pt7c4338 *pt7c4338;
++	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
++	int ret;
++
++	pt7c4338 = kzalloc(sizeof(struct pt7c4338), GFP_KERNEL);
++	if (!pt7c4338)
++		return -ENOMEM;
++
++	pt7c4338->client = client;
++	i2c_set_clientdata(client, pt7c4338);
++	pt7c4338->rtc = rtc_device_register(client->name, &client->dev,
++					&pt7c4338_rtc_ops, THIS_MODULE);
++	if (IS_ERR(pt7c4338->rtc)) {
++		ret = PTR_ERR(pt7c4338->rtc);
++		dev_err(&client->dev, "unable to register the class device\n");
++		goto out_free;
++	}
++
++	return 0;
++out_free:
++	i2c_set_clientdata(client, NULL);
++	kfree(pt7c4338);
++	return ret;
++}
++
++static int pt7c4338_remove(struct i2c_client *client)
++{
++	struct pt7c4338 *pt7c4338 = i2c_get_clientdata(client);
++
++	rtc_device_unregister(pt7c4338->rtc);
++	i2c_set_clientdata(client, NULL);
++	kfree(pt7c4338);
++	return 0;
++}
++
++static struct i2c_driver pt7c4338_driver = {
++	.driver = {
++		.name = "rtc-pt7c4338",
++		.owner = THIS_MODULE,
++	},
++	.probe = pt7c4338_probe,
++	.remove = pt7c4338_remove,
++	.id_table = pt7c4338_id,
++};
++
++static int __init pt7c4338_init(void)
++{
++	return i2c_add_driver(&pt7c4338_driver);
++}
++
++static void __exit pt7c4338_exit(void)
++{
++	i2c_del_driver(&pt7c4338_driver);
++}
++
++module_init(pt7c4338_init);
++module_exit(pt7c4338_exit);
++
++MODULE_AUTHOR("Priyanka Jain <Priyanka.Jain@freescale.com>");
++MODULE_DESCRIPTION("pericom Technology Inc. PT7C4338 RTC Driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-4.4/861-04_spi_gpio_implement_spi_delay.patch b/target/linux/generic/pending-4.4/861-04_spi_gpio_implement_spi_delay.patch
new file mode 100644
index 0000000000..fc1b40c035
--- /dev/null
+++ b/target/linux/generic/pending-4.4/861-04_spi_gpio_implement_spi_delay.patch
@@ -0,0 +1,58 @@
+Implement the SPI-GPIO delay function for busses that need speed limitation.
+
+--mb
+
+
+
+--- a/drivers/spi/spi-gpio.c
++++ b/drivers/spi/spi-gpio.c
+@@ -17,6 +17,7 @@
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/gpio.h>
++#include <linux/delay.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/of_gpio.h>
+@@ -69,6 +70,7 @@ struct spi_gpio {
+  *		#define	SPI_MOSI_GPIO	120
+  *		#define	SPI_SCK_GPIO	121
+  *		#define	SPI_N_CHIPSEL	4
++ *		#undef NEED_SPIDELAY
+  *		#include "spi-gpio.c"
+  */
+ 
+@@ -76,6 +78,7 @@ struct spi_gpio {
+ #define DRIVER_NAME	"spi_gpio"
+ 
+ #define GENERIC_BITBANG	/* vs tight inlines */
++#define NEED_SPIDELAY	1
+ 
+ /* all functions referencing these symbols must define pdata */
+ #define SPI_MISO_GPIO	((pdata)->miso)
+@@ -126,12 +129,20 @@ static inline int getmiso(const struct s
+ #undef pdata
+ 
+ /*
+- * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
+- * requested device clock.  Software overhead means we usually have trouble
+- * reaching even one Mbit/sec (except when we can inline bitops), so for now
+- * we'll just assume we never need additional per-bit slowdowns.
++ * NOTE:  to clock "as fast as we can", set spi_device.max_speed_hz
++ * and spi_transfer.speed_hz to 0.
++ * Otherwise this is a function of the requested device clock.
++ * Software overhead means we usually have trouble
++ * reaching even one Mbit/sec (except when we can inline bitops). So on small
++ * embedded devices with fast SPI slaves you usually don't need a delay.
+  */
+-#define spidelay(nsecs)	do {} while (0)
++static inline void spidelay(unsigned nsecs)
++{
++#ifdef NEED_SPIDELAY
++	if (unlikely(nsecs))
++		ndelay(nsecs);
++#endif /* NEED_SPIDELAY */
++}
+ 
+ #include "spi-bitbang-txrx.h"
+ 
diff --git a/target/linux/generic/pending-4.4/862-gpio_spi_driver.patch b/target/linux/generic/pending-4.4/862-gpio_spi_driver.patch
new file mode 100644
index 0000000000..8f334ec396
--- /dev/null
+++ b/target/linux/generic/pending-4.4/862-gpio_spi_driver.patch
@@ -0,0 +1,373 @@
+THIS CODE IS DEPRECATED.
+
+Please use the new mainline SPI-GPIO driver, as of 2.6.29.
+
+--mb
+
+
+
+---
+ drivers/spi/Kconfig              |    9 +
+ drivers/spi/Makefile             |    1 
+ drivers/spi/spi_gpio_old.c       |  251 +++++++++++++++++++++++++++++++++++++++
+ include/linux/spi/spi_gpio_old.h |   73 +++++++++++
+ 4 files changed, 334 insertions(+)
+
+--- /dev/null
++++ b/include/linux/spi/spi_gpio_old.h
+@@ -0,0 +1,73 @@
++/*
++ * spi_gpio interface to platform code
++ *
++ * Copyright (c) 2008 Piotr Skamruk
++ * Copyright (c) 2008 Michael Buesch
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++#ifndef _LINUX_SPI_SPI_GPIO
++#define _LINUX_SPI_SPI_GPIO
++
++#include <linux/types.h>
++#include <linux/spi/spi.h>
++
++
++/**
++ * struct spi_gpio_platform_data - Data definitions for a SPI-GPIO device.
++ *
++ * This structure holds information about a GPIO-based SPI device.
++ *
++ * @pin_clk: The GPIO pin number of the CLOCK pin.
++ *
++ * @pin_miso: The GPIO pin number of the MISO pin.
++ *
++ * @pin_mosi: The GPIO pin number of the MOSI pin.
++ *
++ * @pin_cs: The GPIO pin number of the CHIPSELECT pin.
++ *
++ * @cs_activelow: If true, the chip is selected when the CS line is low.
++ *
++ * @no_spi_delay: If true, no delay is done in the lowlevel bitbanging.
++ *                Note that doing no delay is not standards compliant,
++ *                but it might be needed to speed up transfers on some
++ *                slow embedded machines.
++ *
++ * @boardinfo_setup: This callback is called after the
++ *                   SPI master device was registered, but before the
++ *                   device is registered.
++ * @boardinfo_setup_data: Data argument passed to boardinfo_setup().
++ */
++struct spi_gpio_platform_data {
++	unsigned int pin_clk;
++	unsigned int pin_miso;
++	unsigned int pin_mosi;
++	unsigned int pin_cs;
++	bool cs_activelow;
++	bool no_spi_delay;
++	int (*boardinfo_setup)(struct spi_board_info *bi,
++			       struct spi_master *master,
++			       void *data);
++	void *boardinfo_setup_data;
++};
++
++/**
++ * SPI_GPIO_PLATDEV_NAME - The platform device name string.
++ *
++ * The name string that has to be used for platform_device_alloc
++ * when allocating a spi-gpio device.
++ */
++#define SPI_GPIO_PLATDEV_NAME	"spi-gpio"
++
++/**
++ * spi_gpio_next_id - Get another platform device ID number.
++ *
++ * This returns the next platform device ID number that has to be used
++ * for platform_device_alloc. The ID is opaque and should not be used for
++ * anything else.
++ */
++int spi_gpio_next_id(void);
++
++#endif /* _LINUX_SPI_SPI_GPIO */
+--- /dev/null
++++ b/drivers/spi/spi_gpio_old.c
+@@ -0,0 +1,251 @@
++/*
++ * Bitbanging SPI bus driver using GPIO API
++ *
++ * Copyright (c) 2008 Piotr Skamruk
++ * Copyright (c) 2008 Michael Buesch
++ *
++ * based on spi_s3c2410_gpio.c
++ *   Copyright (c) 2006 Ben Dooks
++ *   Copyright (c) 2006 Simtec Electronics
++ * and on i2c-gpio.c
++ *   Copyright (C) 2007 Atmel Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/spinlock.h>
++#include <linux/workqueue.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/spi_bitbang.h>
++#include <linux/spi/spi_gpio_old.h>
++#include <linux/gpio.h>
++#include <asm/atomic.h>
++
++
++struct spi_gpio {
++	struct spi_bitbang bitbang;
++	struct spi_gpio_platform_data *info;
++	struct platform_device *pdev;
++	struct spi_board_info bi;
++};
++
++
++static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
++{
++	return dev->controller_data;
++}
++
++static inline void setsck(struct spi_device *dev, int val)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
++}
++
++static inline void setmosi(struct spi_device *dev, int val)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
++}
++
++static inline u32 getmiso(struct spi_device *dev)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
++}
++
++static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++
++	if (!sp->info->no_spi_delay)
++		ndelay(nsecs);
++}
++
++#define spidelay(nsecs) do {					\
++	/* Steal the spi_device pointer from our caller.	\
++	 * The bitbang-API should probably get fixed here... */	\
++	do_spidelay(spi, nsecs);				\
++  } while (0)
++
++#define EXPAND_BITBANG_TXRX
++#include "spi-bitbang-txrx.h"
++
++static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
++}
++
++static void spi_gpio_chipselect(struct spi_device *dev, int on)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++
++	if (sp->info->cs_activelow)
++		on = !on;
++	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
++}
++
++static int spi_gpio_probe(struct platform_device *pdev)
++{
++	struct spi_master *master;
++	struct spi_gpio_platform_data *pdata;
++	struct spi_gpio *sp;
++	struct spi_device *spidev;
++	int err;
++
++	pdata = pdev->dev.platform_data;
++	if (!pdata)
++		return -ENXIO;
++
++	err = -ENOMEM;
++	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
++	if (!master)
++		goto err_alloc_master;
++
++	sp = spi_master_get_devdata(master);
++	platform_set_drvdata(pdev, sp);
++	sp->info = pdata;
++
++	err = gpio_request(pdata->pin_clk, "spi_clock");
++	if (err)
++		goto err_request_clk;
++	err = gpio_request(pdata->pin_mosi, "spi_mosi");
++	if (err)
++		goto err_request_mosi;
++	err = gpio_request(pdata->pin_miso, "spi_miso");
++	if (err)
++		goto err_request_miso;
++	err = gpio_request(pdata->pin_cs, "spi_cs");
++	if (err)
++		goto err_request_cs;
++
++	sp->bitbang.master = spi_master_get(master);
++	sp->bitbang.master->bus_num = -1;
++	sp->bitbang.master->num_chipselect = 1;
++	sp->bitbang.chipselect = spi_gpio_chipselect;
++	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
++	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
++	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
++	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
++
++	gpio_direction_output(pdata->pin_clk, 0);
++	gpio_direction_output(pdata->pin_mosi, 0);
++	gpio_direction_output(pdata->pin_cs,
++			      pdata->cs_activelow ? 1 : 0);
++	gpio_direction_input(pdata->pin_miso);
++
++	err = spi_bitbang_start(&sp->bitbang);
++	if (err)
++		goto err_no_bitbang;
++	err = pdata->boardinfo_setup(&sp->bi, master,
++				     pdata->boardinfo_setup_data);
++	if (err)
++		goto err_bi_setup;
++	sp->bi.controller_data = sp;
++	spidev = spi_new_device(master, &sp->bi);
++	if (!spidev)
++		goto err_new_dev;
++
++	return 0;
++
++err_new_dev:
++err_bi_setup:
++	spi_bitbang_stop(&sp->bitbang);
++err_no_bitbang:
++	spi_master_put(sp->bitbang.master);
++	gpio_free(pdata->pin_cs);
++err_request_cs:
++	gpio_free(pdata->pin_miso);
++err_request_miso:
++	gpio_free(pdata->pin_mosi);
++err_request_mosi:
++	gpio_free(pdata->pin_clk);
++err_request_clk:
++	kfree(master);
++
++err_alloc_master:
++	return err;
++}
++
++static int spi_gpio_remove(struct platform_device *pdev)
++{
++	struct spi_gpio *sp;
++	struct spi_gpio_platform_data *pdata;
++
++	pdata = pdev->dev.platform_data;
++	sp = platform_get_drvdata(pdev);
++
++	gpio_free(pdata->pin_clk);
++	gpio_free(pdata->pin_mosi);
++	gpio_free(pdata->pin_miso);
++	gpio_free(pdata->pin_cs);
++	spi_bitbang_stop(&sp->bitbang);
++	spi_master_put(sp->bitbang.master);
++
++	return 0;
++}
++
++static struct platform_driver spi_gpio_driver = {
++	.driver		= {
++		.name	= SPI_GPIO_PLATDEV_NAME,
++		.owner	= THIS_MODULE,
++	},
++	.probe		= spi_gpio_probe,
++	.remove		= spi_gpio_remove,
++};
++
++int spi_gpio_next_id(void)
++{
++	static atomic_t counter = ATOMIC_INIT(-1);
++
++	return atomic_inc_return(&counter);
++}
++EXPORT_SYMBOL(spi_gpio_next_id);
++
++static int __init spi_gpio_init(void)
++{
++	int err;
++
++	err = platform_driver_register(&spi_gpio_driver);
++	if (err)
++		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
++
++	return err;
++}
++module_init(spi_gpio_init);
++
++static void __exit spi_gpio_exit(void)
++{
++	platform_driver_unregister(&spi_gpio_driver);
++}
++module_exit(spi_gpio_exit);
++
++MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
++MODULE_AUTHOR("Michael Buesch");
++MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
++MODULE_LICENSE("GPL v2");
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -254,6 +254,15 @@ config SPI_IMG_SPFI
+ 	  This enables support for the SPFI master controller found on
+ 	  IMG SoCs.
+ 
++config SPI_GPIO_OLD
++	tristate "Old GPIO API based bitbanging SPI controller (DEPRECATED)"
++	depends on SPI_MASTER && GPIOLIB
++	select SPI_BITBANG
++	help
++	  This code is deprecated. Please use the new mainline SPI-GPIO driver.
++
++	  If unsure, say N.
++
+ config SPI_IMX
+ 	tristate "Freescale i.MX SPI controllers"
+ 	depends on ARCH_MXC || COMPILE_TEST
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -42,6 +42,7 @@ obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-li
+ obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
+ obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
+ obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
++obj-$(CONFIG_SPI_GPIO_OLD)		+= spi_gpio_old.o
+ obj-$(CONFIG_SPI_IMG_SPFI)		+= spi-img-spfi.o
+ obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
+ obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
diff --git a/target/linux/generic/pending-4.4/890-uart_optional_sysrq.patch b/target/linux/generic/pending-4.4/890-uart_optional_sysrq.patch
new file mode 100644
index 0000000000..0e37f9456c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/890-uart_optional_sysrq.patch
@@ -0,0 +1,25 @@
+--- a/lib/Kconfig.debug
++++ b/lib/Kconfig.debug
+@@ -382,6 +382,11 @@ config MAGIC_SYSRQ_DEFAULT_ENABLE
+ 	  This may be set to 1 or 0 to enable or disable them all, or
+ 	  to a bitmask as described in Documentation/sysrq.txt.
+ 
++config MAGIC_SYSRQ_SERIAL
++	bool "Enable magic SysRq key over serial"
++	depends on MAGIC_SYSRQ
++	default y
++
+ config DEBUG_KERNEL
+ 	bool "Kernel debugging"
+ 	help
+--- a/include/linux/serial_core.h
++++ b/include/linux/serial_core.h
+@@ -426,7 +426,7 @@ extern void uart_handle_cts_change(struc
+ extern void uart_insert_char(struct uart_port *port, unsigned int status,
+ 		 unsigned int overrun, unsigned int ch, unsigned int flag);
+ 
+-#ifdef SUPPORT_SYSRQ
++#if defined(SUPPORT_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ_SERIAL)
+ static inline int
+ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
+ {
diff --git a/target/linux/generic/pending-4.4/901-debloat_sock_diag.patch b/target/linux/generic/pending-4.4/901-debloat_sock_diag.patch
new file mode 100644
index 0000000000..4733d1b79c
--- /dev/null
+++ b/target/linux/generic/pending-4.4/901-debloat_sock_diag.patch
@@ -0,0 +1,79 @@
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -92,6 +92,9 @@ source "net/netlabel/Kconfig"
+ 
+ endif # if INET
+ 
++config SOCK_DIAG
++	bool
++
+ config NETWORK_SECMARK
+ 	bool "Security Marking"
+ 	help
+--- a/net/core/Makefile
++++ b/net/core/Makefile
+@@ -9,8 +9,9 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
+ 
+ obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
+ 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
+-			sock_diag.o dev_ioctl.o tso.o
++			dev_ioctl.o tso.o
+ 
++obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
+ obj-$(CONFIG_XFRM) += flow.o
+ obj-y += net-sysfs.o
+ obj-$(CONFIG_PROC_FS) += net-procfs.o
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -1474,9 +1474,11 @@ void sk_destruct(struct sock *sk)
+ 
+ static void __sk_free(struct sock *sk)
+ {
++#ifdef CONFIG_SOCK_DIAG
+ 	if (unlikely(sock_diag_has_destroy_listeners(sk) && sk->sk_net_refcnt))
+ 		sock_diag_broadcast_destroy(sk);
+ 	else
++#endif
+ 		sk_destruct(sk);
+ }
+ 
+--- a/net/ipv4/Kconfig
++++ b/net/ipv4/Kconfig
+@@ -415,6 +415,7 @@ config INET_LRO
+ 
+ config INET_DIAG
+ 	tristate "INET: socket monitoring interface"
++	select SOCK_DIAG
+ 	default y
+ 	---help---
+ 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
+--- a/net/unix/Kconfig
++++ b/net/unix/Kconfig
+@@ -22,6 +22,7 @@ config UNIX
+ config UNIX_DIAG
+ 	tristate "UNIX: socket monitoring interface"
+ 	depends on UNIX
++	select SOCK_DIAG
+ 	default n
+ 	---help---
+ 	  Support for UNIX socket monitoring interface used by the ss tool.
+--- a/net/netlink/Kconfig
++++ b/net/netlink/Kconfig
+@@ -4,6 +4,7 @@
+ 
+ config NETLINK_DIAG
+ 	tristate "NETLINK: socket monitoring interface"
++	select SOCK_DIAG
+ 	default n
+ 	---help---
+ 	  Support for NETLINK socket monitoring interface used by the ss tool.
+--- a/net/packet/Kconfig
++++ b/net/packet/Kconfig
+@@ -18,6 +18,7 @@ config PACKET
+ config PACKET_DIAG
+ 	tristate "Packet: sockets monitoring interface"
+ 	depends on PACKET
++	select SOCK_DIAG
+ 	default n
+ 	---help---
+ 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
diff --git a/target/linux/generic/pending-4.4/902-debloat_proc.patch b/target/linux/generic/pending-4.4/902-debloat_proc.patch
new file mode 100644
index 0000000000..2fe048944f
--- /dev/null
+++ b/target/linux/generic/pending-4.4/902-debloat_proc.patch
@@ -0,0 +1,385 @@
+--- a/fs/locks.c
++++ b/fs/locks.c
+@@ -2716,6 +2716,8 @@ static const struct file_operations proc
+ 
+ static int __init proc_locks_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	proc_create("locks", 0, NULL, &proc_locks_operations);
+ 	return 0;
+ }
+--- a/fs/proc/Kconfig
++++ b/fs/proc/Kconfig
+@@ -81,3 +81,8 @@ config PROC_CHILDREN
+ 
+ 	  Say Y if you are running any user-space software which takes benefit from
+ 	  this interface. For example, rkt is such a piece of software.
++
++config PROC_STRIPPED
++	default n
++	depends on EXPERT
++	bool "Strip non-essential /proc functionality to reduce code size"
+--- a/fs/proc/consoles.c
++++ b/fs/proc/consoles.c
+@@ -106,6 +106,9 @@ static const struct file_operations proc
+ 
+ static int __init proc_consoles_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	proc_create("consoles", 0, NULL, &proc_consoles_operations);
+ 	return 0;
+ }
+--- a/fs/proc/proc_tty.c
++++ b/fs/proc/proc_tty.c
+@@ -144,7 +144,10 @@ static const struct file_operations proc
+ void proc_tty_register_driver(struct tty_driver *driver)
+ {
+ 	struct proc_dir_entry *ent;
+-		
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (!driver->driver_name || driver->proc_entry ||
+ 	    !driver->ops->proc_fops)
+ 		return;
+@@ -161,6 +164,9 @@ void proc_tty_unregister_driver(struct t
+ {
+ 	struct proc_dir_entry *ent;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	ent = driver->proc_entry;
+ 	if (!ent)
+ 		return;
+@@ -175,6 +181,9 @@ void proc_tty_unregister_driver(struct t
+  */
+ void __init proc_tty_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (!proc_mkdir("tty", NULL))
+ 		return;
+ 	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
+--- a/kernel/exec_domain.c
++++ b/kernel/exec_domain.c
+@@ -41,6 +41,8 @@ static const struct file_operations exec
+ 
+ static int __init proc_execdomains_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	proc_create("execdomains", 0, NULL, &execdomains_proc_fops);
+ 	return 0;
+ }
+--- a/kernel/irq/proc.c
++++ b/kernel/irq/proc.c
+@@ -327,6 +327,9 @@ void register_irq_proc(unsigned int irq,
+ 	static DEFINE_MUTEX(register_lock);
+ 	char name [MAX_NAMELEN];
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
+ 		return;
+ 
+@@ -376,6 +379,9 @@ void unregister_irq_proc(unsigned int ir
+ {
+ 	char name [MAX_NAMELEN];
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	if (!root_irq_dir || !desc->dir)
+ 		return;
+ #ifdef CONFIG_SMP
+@@ -411,6 +417,9 @@ void init_irq_proc(void)
+ 	unsigned int irq;
+ 	struct irq_desc *desc;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	/* create /proc/irq */
+ 	root_irq_dir = proc_mkdir("irq", NULL);
+ 	if (!root_irq_dir)
+--- a/kernel/time/timer_list.c
++++ b/kernel/time/timer_list.c
+@@ -393,6 +393,8 @@ static int __init init_timer_list_procfs
+ {
+ 	struct proc_dir_entry *pe;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	pe = proc_create("timer_list", 0444, NULL, &timer_list_fops);
+ 	if (!pe)
+ 		return -ENOMEM;
+--- a/mm/vmalloc.c
++++ b/mm/vmalloc.c
+@@ -2684,6 +2684,8 @@ static const struct file_operations proc
+ 
+ static int __init proc_vmalloc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	proc_create("vmallocinfo", S_IRUSR, NULL, &proc_vmalloc_operations);
+ 	return 0;
+ }
+--- a/mm/vmstat.c
++++ b/mm/vmstat.c
+@@ -1558,10 +1558,12 @@ static int __init setup_vmstat(void)
+ 	cpu_notifier_register_done();
+ #endif
+ #ifdef CONFIG_PROC_FS
+-	proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
+-	proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
++		proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
++		proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
++	}
+ 	proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
+-	proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
+ #endif
+ 	return 0;
+ }
+--- a/net/8021q/vlanproc.c
++++ b/net/8021q/vlanproc.c
+@@ -127,6 +127,9 @@ void vlan_proc_cleanup(struct net *net)
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (vn->proc_vlan_conf)
+ 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
+ 
+@@ -146,6 +149,9 @@ int __net_init vlan_proc_init(struct net
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
+ 	if (!vn->proc_vlan_dir)
+ 		goto err;
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -3044,6 +3044,8 @@ static __net_initdata struct pernet_oper
+ 
+ static int __init proto_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	return register_pernet_subsys(&proto_net_ops);
+ }
+ 
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -2641,10 +2641,12 @@ static const struct file_operations fib_
+ 
+ int __net_init fib_proc_init(struct net *net)
+ {
+-	if (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
+ 		goto out1;
+ 
+-	if (!proc_create("fib_triestat", S_IRUGO, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("fib_triestat", S_IRUGO, net->proc_net,
+ 			 &fib_triestat_fops))
+ 		goto out2;
+ 
+@@ -2654,17 +2656,21 @@ int __net_init fib_proc_init(struct net
+ 	return 0;
+ 
+ out3:
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_triestat", net->proc_net);
+ out2:
+-	remove_proc_entry("fib_trie", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_trie", net->proc_net);
+ out1:
+ 	return -ENOMEM;
+ }
+ 
+ void __net_exit fib_proc_exit(struct net *net)
+ {
+-	remove_proc_entry("fib_trie", net->proc_net);
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("fib_trie", net->proc_net);
++		remove_proc_entry("fib_triestat", net->proc_net);
++	}
+ 	remove_proc_entry("route", net->proc_net);
+ }
+ 
+--- a/net/ipv4/proc.c
++++ b/net/ipv4/proc.c
+@@ -539,6 +539,9 @@ static __net_initdata struct pernet_oper
+ 
+ int __init ip_misc_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_proc_ops);
+ }
+ 
+--- a/net/ipv4/route.c
++++ b/net/ipv4/route.c
+@@ -423,6 +423,9 @@ static struct pernet_operations ip_rt_pr
+ 
+ static int __init ip_rt_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_rt_proc_ops);
+ }
+ 
+--- a/ipc/msg.c
++++ b/ipc/msg.c
+@@ -1071,6 +1071,9 @@ void __init msg_init(void)
+ {
+ 	msg_init_ns(&init_ipc_ns);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	ipc_init_proc_interface("sysvipc/msg",
+ 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
+ 				IPC_MSG_IDS, sysvipc_msg_proc_show);
+--- a/ipc/sem.c
++++ b/ipc/sem.c
+@@ -198,6 +198,8 @@ void sem_exit_ns(struct ipc_namespace *n
+ void __init sem_init(void)
+ {
+ 	sem_init_ns(&init_ipc_ns);
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/sem",
+ 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
+ 				IPC_SEM_IDS, sysvipc_sem_proc_show);
+--- a/ipc/shm.c
++++ b/ipc/shm.c
+@@ -118,6 +118,8 @@ pure_initcall(ipc_ns_init);
+ 
+ void __init shm_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/shm",
+ #if BITS_PER_LONG <= 32
+ 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
+--- a/ipc/util.c
++++ b/ipc/util.c
+@@ -121,6 +121,9 @@ void __init ipc_init_proc_interface(cons
+ 	struct proc_dir_entry *pde;
+ 	struct ipc_proc_iface *iface;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
+ 	if (!iface)
+ 		return;
+--- a/net/core/net-procfs.c
++++ b/net/core/net-procfs.c
+@@ -318,10 +318,12 @@ static int __net_init dev_proc_net_init(
+ 
+ 	if (!proc_create("dev", S_IRUGO, net->proc_net, &dev_seq_fops))
+ 		goto out;
+-	if (!proc_create("softnet_stat", S_IRUGO, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("softnet_stat", S_IRUGO, net->proc_net,
+ 			 &softnet_seq_fops))
+ 		goto out_dev;
+-	if (!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
+ 		goto out_softnet;
+ 
+ 	if (wext_proc_init(net))
+@@ -330,9 +332,11 @@ static int __net_init dev_proc_net_init(
+ out:
+ 	return rc;
+ out_ptype:
+-	remove_proc_entry("ptype", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("ptype", net->proc_net);
+ out_softnet:
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("softnet_stat", net->proc_net);
+ out_dev:
+ 	remove_proc_entry("dev", net->proc_net);
+ 	goto out;
+@@ -342,8 +346,10 @@ static void __net_exit dev_proc_net_exit
+ {
+ 	wext_proc_exit(net);
+ 
+-	remove_proc_entry("ptype", net->proc_net);
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("ptype", net->proc_net);
++		remove_proc_entry("softnet_stat", net->proc_net);
++	}
+ 	remove_proc_entry("dev", net->proc_net);
+ }
+ 
+--- a/include/net/snmp.h
++++ b/include/net/snmp.h
+@@ -123,6 +123,30 @@ struct linux_xfrm_mib {
+ #define DECLARE_SNMP_STAT(type, name)	\
+ 	extern __typeof__(type) __percpu *name
+ 
++#ifdef CONFIG_PROC_STRIPPED
++#define SNMP_INC_STATS_BH(mib, field)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_INC_STATS_USER(mib, field)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_INC_STATS_ATOMIC_LONG(mib, field)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_INC_STATS(mib, field)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_DEC_STATS(mib, field)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_ADD_STATS_BH(mib, field, addend)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_ADD_STATS_USER(mib, field, addend)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_ADD_STATS(mib, field, addend)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_UPD_PO_STATS(mib, basefield, addend)	\
++	do { (void) mib->mibs[0]; } while(0)
++#define SNMP_UPD_PO_STATS_BH(mib, basefield, addend)	\
++	do { (void) mib->mibs[0]; } while(0)
++
++#else
++
+ #define SNMP_INC_STATS_BH(mib, field)	\
+ 			__this_cpu_inc(mib->mibs[field])
+ 
+@@ -159,8 +183,9 @@ struct linux_xfrm_mib {
+ 		__this_cpu_add(ptr[basefield##OCTETS], addend);	\
+ 	} while (0)
+ 
++#endif
+ 
+-#if BITS_PER_LONG==32
++#if (BITS_PER_LONG==32) && !defined(CONFIG_PROC_STRIPPED)
+ 
+ #define SNMP_ADD_STATS64_BH(mib, field, addend) 			\
+ 	do {								\
diff --git a/target/linux/generic/pending-4.4/904-debloat_dma_buf.patch b/target/linux/generic/pending-4.4/904-debloat_dma_buf.patch
new file mode 100644
index 0000000000..b9fdad9c1b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/904-debloat_dma_buf.patch
@@ -0,0 +1,44 @@
+--- a/drivers/base/Kconfig
++++ b/drivers/base/Kconfig
+@@ -232,7 +232,7 @@ config SOC_BUS
+ source "drivers/base/regmap/Kconfig"
+ 
+ config DMA_SHARED_BUFFER
+-	bool
++	tristate
+ 	default n
+ 	select ANON_INODES
+ 	help
+--- a/drivers/dma-buf/Makefile
++++ b/drivers/dma-buf/Makefile
+@@ -1 +1,2 @@
+-obj-y := dma-buf.o fence.o reservation.o seqno-fence.o
++obj-$(CONFIG_DMA_SHARED_BUFFER) := dma-shared-buffer.o
++dma-shared-buffer-objs := dma-buf.o fence.o reservation.o seqno-fence.o
+--- a/drivers/dma-buf/dma-buf.c
++++ b/drivers/dma-buf/dma-buf.c
+@@ -33,6 +33,7 @@
+ #include <linux/seq_file.h>
+ #include <linux/poll.h>
+ #include <linux/reservation.h>
++#include <linux/module.h>
+ 
+ static inline int is_dma_buf_file(struct file *);
+ 
+@@ -914,4 +915,5 @@ static void __exit dma_buf_deinit(void)
+ {
+ 	dma_buf_uninit_debugfs();
+ }
+-__exitcall(dma_buf_deinit);
++module_exit(dma_buf_deinit);
++MODULE_LICENSE("GPL");
+--- a/kernel/sched/core.c
++++ b/kernel/sched/core.c
+@@ -2096,6 +2096,7 @@ int wake_up_state(struct task_struct *p,
+ {
+ 	return try_to_wake_up(p, state, 0);
+ }
++EXPORT_SYMBOL_GPL(wake_up_state);
+ 
+ /*
+  * This function clears the sched_dl_entity static params.
diff --git a/target/linux/generic/pending-4.4/910-kobject_uevent.patch b/target/linux/generic/pending-4.4/910-kobject_uevent.patch
new file mode 100644
index 0000000000..a2c935f26b
--- /dev/null
+++ b/target/linux/generic/pending-4.4/910-kobject_uevent.patch
@@ -0,0 +1,21 @@
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -52,6 +52,18 @@ static const char *kobject_actions[] = {
+ 	[KOBJ_OFFLINE] =	"offline",
+ };
+ 
++u64 uevent_next_seqnum(void)
++{
++	u64 seq;
++
++	mutex_lock(&uevent_sock_mutex);
++	seq = ++uevent_seqnum;
++	mutex_unlock(&uevent_sock_mutex);
++
++	return seq;
++}
++EXPORT_SYMBOL_GPL(uevent_next_seqnum);
++
+ /**
+  * kobject_action_type - translate action string to numeric type
+  *
diff --git a/target/linux/generic/pending-4.4/911-kobject_add_broadcast_uevent.patch b/target/linux/generic/pending-4.4/911-kobject_add_broadcast_uevent.patch
new file mode 100644
index 0000000000..a3401ff4b3
--- /dev/null
+++ b/target/linux/generic/pending-4.4/911-kobject_add_broadcast_uevent.patch
@@ -0,0 +1,65 @@
+--- a/include/linux/kobject.h
++++ b/include/linux/kobject.h
+@@ -32,6 +32,8 @@
+ #define UEVENT_NUM_ENVP			32	/* number of env pointers */
+ #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
+ 
++struct sk_buff;
++
+ #ifdef CONFIG_UEVENT_HELPER
+ /* path to the userspace helper executed on an event */
+ extern char uevent_helper[];
+@@ -222,4 +224,7 @@ int add_uevent_var(struct kobj_uevent_en
+ int kobject_action_type(const char *buf, size_t count,
+ 			enum kobject_action *type);
+ 
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation);
++
+ #endif /* _KOBJECT_H_ */
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -423,6 +423,43 @@ int add_uevent_var(struct kobj_uevent_en
+ EXPORT_SYMBOL_GPL(add_uevent_var);
+ 
+ #if defined(CONFIG_NET)
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	struct uevent_sock *ue_sk;
++	int err = 0;
++
++	/* send netlink message */
++	mutex_lock(&uevent_sock_mutex);
++	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
++		struct sock *uevent_sock = ue_sk->sk;
++		struct sk_buff *skb2;
++
++		skb2 = skb_clone(skb, allocation);
++		if (!skb2)
++			break;
++
++		err = netlink_broadcast(uevent_sock, skb2, pid, group,
++					allocation);
++		if (err)
++			break;
++	}
++	mutex_unlock(&uevent_sock_mutex);
++
++	kfree_skb(skb);
++	return err;
++}
++#else
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	kfree_skb(skb);
++	return 0;
++}
++#endif
++EXPORT_SYMBOL_GPL(broadcast_uevent);
++
++#if defined(CONFIG_NET)
+ static int uevent_net_init(struct net *net)
+ {
+ 	struct uevent_sock *ue_sk;
diff --git a/target/linux/generic/pending-4.4/921-use_preinit_as_init.patch b/target/linux/generic/pending-4.4/921-use_preinit_as_init.patch
new file mode 100644
index 0000000000..3aba9d63ba
--- /dev/null
+++ b/target/linux/generic/pending-4.4/921-use_preinit_as_init.patch
@@ -0,0 +1,12 @@
+--- a/init/main.c
++++ b/init/main.c
+@@ -966,7 +966,8 @@ static int __ref kernel_init(void *unuse
+ 		panic("Requested init %s failed (error %d).",
+ 		      execute_command, ret);
+ 	}
+-	if (!try_to_run_init_process("/sbin/init") ||
++	if (!try_to_run_init_process("/etc/preinit") ||
++	    !try_to_run_init_process("/sbin/init") ||
+ 	    !try_to_run_init_process("/etc/init") ||
+ 	    !try_to_run_init_process("/bin/init") ||
+ 	    !try_to_run_init_process("/bin/sh"))
diff --git a/target/linux/generic/pending-4.4/922-always-create-console-node-in-initramfs.patch b/target/linux/generic/pending-4.4/922-always-create-console-node-in-initramfs.patch
new file mode 100644
index 0000000000..988de35ce0
--- /dev/null
+++ b/target/linux/generic/pending-4.4/922-always-create-console-node-in-initramfs.patch
@@ -0,0 +1,30 @@
+--- a/scripts/gen_initramfs_list.sh
++++ b/scripts/gen_initramfs_list.sh
+@@ -59,6 +59,18 @@ default_initramfs() {
+ 	EOF
+ }
+ 
++list_openwrt_initramfs() {
++	:
++}
++
++openwrt_initramfs() {
++	# make sure that /dev/console exists
++	cat <<-EOF >> ${output}
++		dir /dev 0755 0 0
++		nod /dev/console 0600 0 0 c 5 1
++	EOF
++}
++
+ filetype() {
+ 	local argv1="$1"
+ 
+@@ -177,6 +189,8 @@ dir_filelist() {
+ 	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
+ 		${dep_list}print_mtime "$1"
+ 
++		${dep_list}openwrt_initramfs
++
+ 		echo "${dirlist}" | \
+ 		while read x; do
+ 			${dep_list}parse ${x}
diff --git a/target/linux/generic/pending-4.4/930-crashlog.patch b/target/linux/generic/pending-4.4/930-crashlog.patch
new file mode 100644
index 0000000000..fdc80d750a
--- /dev/null
+++ b/target/linux/generic/pending-4.4/930-crashlog.patch
@@ -0,0 +1,317 @@
+--- /dev/null
++++ b/include/linux/crashlog.h
+@@ -0,0 +1,17 @@
++#ifndef __CRASHLOG_H
++#define __CRASHLOG_H
++
++#ifdef CONFIG_CRASHLOG
++void crashlog_init_bootmem(struct bootmem_data *bdata);
++void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
++#else
++static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
++{
++}
++
++static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++}
++#endif
++
++#endif
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1296,6 +1296,10 @@ config RELAY
+ 
+ 	  If unsure, say N.
+ 
++config CRASHLOG
++	bool "Crash logging"
++	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK)
++
+ config BLK_DEV_INITRD
+ 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
+ 	depends on BROKEN || !FRV
+--- a/kernel/Makefile
++++ b/kernel/Makefile
+@@ -103,6 +103,7 @@ obj-$(CONFIG_TORTURE_TEST) += torture.o
+ obj-$(CONFIG_MEMBARRIER) += membarrier.o
+ 
+ obj-$(CONFIG_HAS_IOMEM) += memremap.o
++obj-$(CONFIG_CRASHLOG) += crashlog.o
+ 
+ $(obj)/configs.o: $(obj)/config_data.h
+ 
+--- /dev/null
++++ b/kernel/crashlog.c
+@@ -0,0 +1,213 @@
++/*
++ * Crash information logger
++ * Copyright (C) 2010 Felix Fietkau <nbd@nbd.name>
++ *
++ * Based on ramoops.c
++ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ *
++ */
++
++#include <linux/module.h>
++#include <linux/bootmem.h>
++#include <linux/memblock.h>
++#include <linux/debugfs.h>
++#include <linux/crashlog.h>
++#include <linux/kmsg_dump.h>
++#include <linux/module.h>
++#include <linux/pfn.h>
++#include <linux/vmalloc.h>
++#include <asm/io.h>
++
++#define CRASHLOG_PAGES	4
++#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
++#define CRASHLOG_MAGIC	0xa1eedead
++
++/*
++ * Start the log at 1M before the end of RAM, as some boot loaders like
++ * to use the end of the RAM for stack usage and other things
++ * If this fails, fall back to using the last part.
++ */
++#define CRASHLOG_OFFSET	(1024 * 1024)
++
++struct crashlog_data {
++	u32 magic;
++	u32 len;
++	u8 data[];
++};
++
++static struct debugfs_blob_wrapper crashlog_blob;
++static unsigned long crashlog_addr = 0;
++static struct crashlog_data *crashlog_buf;
++static struct kmsg_dumper dump;
++static bool first = true;
++
++extern struct list_head *crashlog_modules;
++
++static bool crashlog_set_addr(phys_addr_t addr, phys_addr_t size)
++{
++	/* Limit to lower 64 MB to avoid highmem */
++	phys_addr_t limit = 64 * 1024 * 1024;
++
++	if (crashlog_addr)
++		return false;
++
++	if (addr > limit)
++		return false;
++
++	if (addr + size > limit)
++		size = limit - addr;
++
++	crashlog_addr = addr;
++
++	if (addr + size > CRASHLOG_OFFSET)
++		crashlog_addr += size - CRASHLOG_OFFSET;
++
++	return true;
++}
++
++#ifndef CONFIG_NO_BOOTMEM
++void __init crashlog_init_bootmem(bootmem_data_t *bdata)
++{
++	phys_addr_t start, end;
++
++	start = PFN_PHYS(bdata->node_low_pfn);
++	end = PFN_PHYS(bdata->node_min_pfn);
++	if (!crashlog_set_addr(start, end - start))
++		return;
++
++	if (reserve_bootmem(crashlog_addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
++		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
++		       crashlog_addr);
++		crashlog_addr = 0;
++	}
++}
++#endif
++
++#ifdef CONFIG_HAVE_MEMBLOCK
++void __init_memblock crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++	if (!crashlog_set_addr(addr, size))
++		return;
++
++	if (memblock_reserve(crashlog_addr, CRASHLOG_SIZE)) {
++		printk("Crashlog failed to allocate RAM at address 0x%lx\n",
++		       crashlog_addr);
++		crashlog_addr = 0;
++	}
++}
++#endif
++
++static void __init crashlog_copy(void)
++{
++	if (crashlog_buf->magic != CRASHLOG_MAGIC)
++		return;
++
++	if (!crashlog_buf->len || crashlog_buf->len >
++	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
++		return;
++
++	crashlog_blob.size = crashlog_buf->len;
++	crashlog_blob.data = kmemdup(crashlog_buf->data,
++		crashlog_buf->len, GFP_KERNEL);
++
++	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
++}
++
++static int get_maxlen(void)
++{
++	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
++}
++
++static void crashlog_printf(const char *fmt, ...)
++{
++	va_list args;
++	int len = get_maxlen();
++
++	if (!len)
++		return;
++
++	va_start(args, fmt);
++	crashlog_buf->len += vscnprintf(
++		&crashlog_buf->data[crashlog_buf->len],
++		len, fmt, args);
++	va_end(args);
++}
++
++static void crashlog_do_dump(struct kmsg_dumper *dumper,
++		enum kmsg_dump_reason reason)
++{
++	struct timeval tv;
++	struct module *m;
++	char *buf;
++	size_t len;
++
++	if (!first)
++		crashlog_printf("\n===================================\n");
++
++	do_gettimeofday(&tv);
++	crashlog_printf("Time: %lu.%lu\n",
++		(long)tv.tv_sec, (long)tv.tv_usec);
++
++	if (first) {
++		crashlog_printf("Modules:");
++		list_for_each_entry(m, crashlog_modules, list) {
++			crashlog_printf("\t%s@%p+%x", m->name,
++			m->module_core, m->core_size,
++			m->module_init, m->init_size);
++		}
++		crashlog_printf("\n");
++		first = false;
++	}
++
++	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
++
++	kmsg_dump_get_buffer(dumper, true, buf, get_maxlen(), &len);
++
++	crashlog_buf->len += len;
++}
++
++
++int __init crashlog_init_fs(void)
++{
++	struct page *pages[CRASHLOG_PAGES];
++	pgprot_t prot;
++	int i;
++
++	if (!crashlog_addr) {
++		printk("No memory allocated for crashlog\n");
++		return -ENOMEM;
++	}
++
++	printk("Crashlog allocated RAM at address 0x%lx\n", (unsigned long) crashlog_addr);
++	for (i = 0; i < CRASHLOG_PAGES; i++)
++		pages[i] = pfn_to_page((crashlog_addr >> PAGE_SHIFT) + i);
++
++	prot = pgprot_writecombine(PAGE_KERNEL);
++	crashlog_buf = vmap(pages, CRASHLOG_PAGES, VM_MAP, prot);
++
++	crashlog_copy();
++
++	crashlog_buf->magic = CRASHLOG_MAGIC;
++	crashlog_buf->len = 0;
++
++	dump.max_reason = KMSG_DUMP_OOPS;
++	dump.dump = crashlog_do_dump;
++	kmsg_dump_register(&dump);
++
++	return 0;
++}
++module_init(crashlog_init_fs);
+--- a/kernel/module.c
++++ b/kernel/module.c
+@@ -275,6 +275,9 @@ static void mod_update_bounds(struct mod
+ #ifdef CONFIG_KGDB_KDB
+ struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
+ #endif /* CONFIG_KGDB_KDB */
++#ifdef CONFIG_CRASHLOG
++struct list_head *crashlog_modules = &modules;
++#endif
+ 
+ static void module_assert_mutex(void)
+ {
+--- a/mm/memblock.c
++++ b/mm/memblock.c
+@@ -19,6 +19,7 @@
+ #include <linux/debugfs.h>
+ #include <linux/seq_file.h>
+ #include <linux/memblock.h>
++#include <linux/crashlog.h>
+ 
+ #include <asm-generic/sections.h>
+ #include <linux/io.h>
+@@ -503,6 +504,8 @@ static void __init_memblock memblock_ins
+ 	memblock_set_region_node(rgn, nid);
+ 	type->cnt++;
+ 	type->total_size += size;
++	if (type == &memblock.memory)
++		crashlog_init_memblock(base, size);
+ }
+ 
+ /**
+@@ -541,6 +544,8 @@ int __init_memblock memblock_add_range(s
+ 		type->regions[0].flags = flags;
+ 		memblock_set_region_node(&type->regions[0], nid);
+ 		type->total_size = size;
++		if (type == &memblock.memory)
++			crashlog_init_memblock(base, size);
+ 		return 0;
+ 	}
+ repeat:
+--- a/mm/bootmem.c
++++ b/mm/bootmem.c
+@@ -15,6 +15,7 @@
+ #include <linux/export.h>
+ #include <linux/kmemleak.h>
+ #include <linux/range.h>
++#include <linux/crashlog.h>
+ #include <linux/memblock.h>
+ #include <linux/bug.h>
+ #include <linux/io.h>
+@@ -177,6 +178,7 @@ static unsigned long __init free_all_boo
+ 	if (!bdata->node_bootmem_map)
+ 		return 0;
+ 
++	crashlog_init_bootmem(bdata);
+ 	map = bdata->node_bootmem_map;
+ 	start = bdata->node_min_pfn;
+ 	end = bdata->node_low_pfn;
diff --git a/target/linux/generic/pending-4.4/970-remove-unsane-filenames-from-deps_initramfs-list.patch b/target/linux/generic/pending-4.4/970-remove-unsane-filenames-from-deps_initramfs-list.patch
new file mode 100644
index 0000000000..ac13c9e673
--- /dev/null
+++ b/target/linux/generic/pending-4.4/970-remove-unsane-filenames-from-deps_initramfs-list.patch
@@ -0,0 +1,29 @@
+--- a/usr/Makefile
++++ b/usr/Makefile
+@@ -53,6 +53,8 @@ ifneq ($(wildcard $(obj)/.initramfs_data
+ 	include $(obj)/.initramfs_data.cpio.d
+ endif
+ 
++deps_initramfs_sane := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
++
+ quiet_cmd_initfs = GEN     $@
+       cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
+ 
+@@ -61,14 +63,14 @@ targets := initramfs_data.cpio.gz initra
+ 	initramfs_data.cpio.lzo initramfs_data.cpio.lz4 \
+ 	initramfs_data.cpio
+ # do not try to update files included in initramfs
+-$(deps_initramfs): ;
++$(deps_initramfs_sane): ;
+ 
+-$(deps_initramfs): klibcdirs
++$(deps_initramfs_sane): klibcdirs
+ # We rebuild initramfs_data.cpio if:
+ # 1) Any included file is newer then initramfs_data.cpio
+ # 2) There are changes in which files are included (added or deleted)
+ # 3) If gen_init_cpio are newer than initramfs_data.cpio
+ # 4) arguments to gen_initramfs.sh changes
+-$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs) klibcdirs
++$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs_sane) klibcdirs
+ 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/.initramfs_data.cpio.d
+ 	$(call if_changed,initfs)
diff --git a/target/linux/generic/pending-4.4/995-mangle_bootargs.patch b/target/linux/generic/pending-4.4/995-mangle_bootargs.patch
new file mode 100644
index 0000000000..821370350e
--- /dev/null
+++ b/target/linux/generic/pending-4.4/995-mangle_bootargs.patch
@@ -0,0 +1,58 @@
+--- a/init/main.c
++++ b/init/main.c
+@@ -356,6 +356,29 @@ static inline void setup_nr_cpu_ids(void
+ static inline void smp_prepare_cpus(unsigned int maxcpus) { }
+ #endif
+ 
++#ifdef CONFIG_MANGLE_BOOTARGS
++static void __init mangle_bootargs(char *command_line)
++{
++	char *rootdev;
++	char *rootfs;
++
++	rootdev = strstr(command_line, "root=/dev/mtdblock");
++
++	if (rootdev)
++		strncpy(rootdev, "mangled_rootblock=", 18);
++
++	rootfs = strstr(command_line, "rootfstype");
++
++	if (rootfs)
++		strncpy(rootfs, "mangled_fs", 10);
++
++}
++#else
++static void __init mangle_bootargs(char *command_line)
++{
++}
++#endif
++
+ /*
+  * We need to store the untouched command line for future reference.
+  * We also need to store the touched command line since the parameter
+@@ -529,6 +552,7 @@ asmlinkage __visible void __init start_k
+ 	pr_notice("%s", linux_banner);
+ 	setup_arch(&command_line);
+ 	mm_init_cpumask(&init_mm);
++	mangle_bootargs(command_line);
+ 	setup_command_line(command_line);
+ 	setup_nr_cpu_ids();
+ 	setup_per_cpu_areas();
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1655,6 +1655,15 @@ config EMBEDDED
+ 	  an embedded system so certain expert options are available
+ 	  for configuration.
+ 
++config MANGLE_BOOTARGS
++	bool "Rename offending bootargs"
++	depends on EXPERT
++	help
++	  Sometimes the bootloader passed bogus root= and rootfstype=
++	  parameters to the kernel, and while you want to ignore them,
++	  you need to know the values f.e. to support dual firmware
++	  layouts on the flash.
++
+ config HAVE_PERF_EVENTS
+ 	bool
+ 	help
diff --git a/target/linux/generic/pending-4.4/998-enable_wilink_platform_without_drivers.patch b/target/linux/generic/pending-4.4/998-enable_wilink_platform_without_drivers.patch
new file mode 100644
index 0000000000..d317de1102
--- /dev/null
+++ b/target/linux/generic/pending-4.4/998-enable_wilink_platform_without_drivers.patch
@@ -0,0 +1,15 @@
+We use backports for driver updates - make sure we can compile in the glue code regardless
+
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+
+--- a/drivers/net/wireless/ti/Kconfig
++++ b/drivers/net/wireless/ti/Kconfig
+@@ -15,7 +15,7 @@ source "drivers/net/wireless/ti/wlcore/K
+ 
+ config WILINK_PLATFORM_DATA
+ 	bool "TI WiLink platform data"
+-	depends on WLCORE_SDIO || WL1251_SDIO
++	depends on WLCORE_SDIO || WL1251_SDIO || ARCH_OMAP2PLUS
+ 	default y
+ 	---help---
+ 	Small platform data bit needed to pass data to the sdio modules.
-- 
2.11.0

